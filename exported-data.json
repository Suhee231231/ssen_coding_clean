{
  "subjects": [
    {
      "id": 1,
      "name": "JavaScript",
      "description": "웹의 동적 기능 구현",
      "category": "Frontend",
      "total_problems": 797,
      "sort_order": 3,
      "is_public": 1
    },
    {
      "id": 2,
      "name": "Python",
      "description": "쉽고 강력한 범용 프로그래밍 언어",
      "category": "Backend",
      "total_problems": 0,
      "sort_order": 5,
      "is_public": 0
    },
    {
      "id": 3,
      "name": "Java",
      "description": "안정적이고 확장 가능한 프로그래밍 언어",
      "category": "Backend",
      "total_problems": 0,
      "sort_order": 6,
      "is_public": 0
    },
    {
      "id": 5,
      "name": "SQL",
      "description": "데이터베이스 관리 언어",
      "category": "Backend",
      "total_problems": 0,
      "sort_order": 4,
      "is_public": 0
    },
    {
      "id": 8,
      "name": "HTML",
      "description": "웹 페이지의 뼈대와 구조",
      "category": "Frontend",
      "total_problems": 210,
      "sort_order": 1,
      "is_public": 1
    },
    {
      "id": 9,
      "name": "CSS",
      "description": "웹 디자인과 레이아웃",
      "category": "Frontend",
      "total_problems": 494,
      "sort_order": 2,
      "is_public": 1
    }
  ],
  "problems": [
    {
      "id": 1,
      "subject_id": 1,
      "question": "다음 중 JavaScript의 기본적인 역할이 아닌 것은 무엇인가?",
      "option_a": "HTML의 내용을 동적으로 변경",
      "option_b": "CSS의 스타일을 조정",
      "option_c": "데이터를 계산하고 검증",
      "option_d": "서버의 운영체제를 변경",
      "correct_answer": "D",
      "explanation": "JavaScript는 웹 클라이언트 측에서 동작하며, HTML과 CSS를 제어하고 데이터를 처리할 수 있습니다. 하지만 서버 운영체제를 직접 변경할 수는 없습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T04:56:16.000Z"
    },
    {
      "id": 2,
      "subject_id": 1,
      "question": "다음 JavaScript 코드에서 `innerHTML` 속성이 하는 일은?\n\n```javascript\ndocument.getElementById(\"demo\").innerHTML = \"Hello JavaScript!\";\n```",
      "option_a": "HTML 요소를 삭제한다",
      "option_b": "HTML 요소의 스타일을 변경한다",
      "option_c": "HTML 요소의 ID를 변경한다",
      "option_d": "HTML 요소의 콘텐츠를 변경한다",
      "correct_answer": "D",
      "explanation": "`innerHTML`은 해당 HTML 요소 내부의 내용을 변경할 때 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T06:04:39.000Z"
    },
    {
      "id": 3,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 적절한 표현은?\n\n```javascript\ndocument.getElementById(\"demo\")._________ = \"none\";\n```\n이 코드는 HTML 요소를 숨기기 위한 코드이다.",
      "option_a": "display",
      "option_b": "innerHTML",
      "option_c": "style.display",
      "option_d": "value",
      "correct_answer": "C",
      "explanation": "요소를 숨기기 위해서는 `style.display = \"none\"`을 사용합니다. `display`만 쓰면 오류가 발생합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T06:45:06.000Z"
    },
    {
      "id": 4,
      "subject_id": 1,
      "question": "다음 중 JavaScript 문법으로 옳은 문장은?",
      "option_a": "document.getElementById(\"demo\").innerHtml = \"Hi!\";",
      "option_b": "document.getElementById('demo').innerHTML = 'Hi!';",
      "option_c": "getElementById.document(\"demo\") = \"Hi!\";",
      "option_d": "document.getElement('demo').innerHTML: \"Hi!\";",
      "correct_answer": "B",
      "explanation": "`innerHTML`에서 대소문자 구분이 중요하며, `document.getElementById()`는 함수입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T06:46:56.000Z"
    },
    {
      "id": 5,
      "subject_id": 1,
      "question": "다음 코드를 실행하면 브라우저에서 어떤 변화가 생기는가?\n\n```javascript\ndocument.getElementById(\"demo\").style.fontSize = \"35px\";\n```",
      "option_a": "요소의 폰트 크기가 35px로 커진다",
      "option_b": "요소가 사라진다",
      "option_c": "요소의 텍스트가 바뀐다",
      "option_d": "요소가 클릭되었는지 확인한다",
      "correct_answer": "A",
      "explanation": "`style.fontSize`를 사용하면 글자의 크기를 변경할 수 있습니다. 시각적인 변화입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T06:48:24.000Z"
    },
    {
      "id": 6,
      "subject_id": 1,
      "question": "다음 HTML + JavaScript 코드를 실행하면 버튼을 클릭할 때 어떤 일이 발생하는가?\n\n```html\n<p id=\"demo\">JavaScript can change HTML content.</p>\n<button onclick=\"document.getElementById('demo').innerHTML = 'Hello JavaScript!'\">Click Me!</button>\n```",
      "option_a": "버튼이 사라진다",
      "option_b": "id가 \"demo\"인 요소의 텍스트가 \"Hello JavaScript!\"로 바뀐다",
      "option_c": "아무 변화 없음",
      "option_d": "새로운 버튼이 생성된다",
      "correct_answer": "B",
      "explanation": "`onclick` 이벤트가 발생하면 JavaScript 코드가 실행되어 콘텐츠가 변경됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T06:50:08.000Z"
    },
    {
      "id": 7,
      "subject_id": 1,
      "question": "다음 중 JavaScript로 HTML 요소를 숨기기 위해 사용하는 올바른 코드는?",
      "option_a": "document.getElementById(\"demo\").style.display = \"none\";",
      "option_b": "document.getElementById(\"demo\").style.visibility = \"none\";",
      "option_c": "document.getElementById(\"demo\").hide();",
      "option_d": "document.getElement(\"demo\").style.display = \"none\";",
      "correct_answer": "A",
      "explanation": "`display = \"none\"`은 요소를 화면에서 완전히 숨깁니다. `visibility = \"hidden\"`도 숨기지만 공간은 차지하며, `\"none\"`은 유효한 값이 아닙니다. `hide()`는 표준 JavaScript 메서드가 아닙니다.\n\n",
      "difficulty": "medium",
      "created_at": "2025-08-04T07:14:07.000Z"
    },
    {
      "id": 8,
      "subject_id": 1,
      "question": "다음 JavaScript 문장에서 `'demo'`는 무엇을 의미하는가?\n\n```javascript\ndocument.getElementById('demo')\n```",
      "option_a": "클래스 이름",
      "option_b": "태그 이름",
      "option_c": "요소의 name 속성",
      "option_d": "요소의 id 속성",
      "correct_answer": "D",
      "explanation": "`getElementById()`는 id 속성값을 기준으로 특정 요소를 선택합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T07:15:11.000Z"
    },
    {
      "id": 9,
      "subject_id": 1,
      "question": "다음 중 JavaScript로 이미지 태그의 `src` 속성을 변경할 수 있는 문장은?",
      "option_a": "document.getElementById(\"myImg\").src = \"pic_bulboff.gif\";",
      "option_b": "getElementById.document(\"myImg\").src = \"pic_bulboff.gif\";",
      "option_c": "document.getElement(\"myImg\").src = \"pic_bulboff.gif\";",
      "option_d": "document.setAttribute(\"myImg\", \"src\", \"pic_bulboff.gif\");",
      "correct_answer": "A",
      "explanation": "`src`는 이미지 태그의 속성이며, JavaScript로 접근할 때는 `getElementById()`로 요소를 찾고 `.src`로 값을 설정합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T07:16:08.000Z"
    },
    {
      "id": 10,
      "subject_id": 1,
      "question": "다음은 JavaScript의 특징에 대한 설명이다. 옳지 않은 것은?",
      "option_a": "JavaScript는 HTML과 CSS와 함께 웹 개발에 필수적인 언어이다",
      "option_b": "JavaScript는 서버의 운영체제와 밀접하게 연동된다",
      "option_c": "JavaScript는 HTML 요소의 스타일을 변경할 수 있다",
      "option_d": "JavaScript는 HTML 속성 값을 변경할 수 있다",
      "correct_answer": "B",
      "explanation": "JavaScript는 클라이언트 측에서 작동하며, 서버의 운영체제와는 직접적으로 연동되지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T07:16:44.000Z"
    },
    {
      "id": 11,
      "subject_id": 1,
      "question": "JavaScript 코드를 HTML 문서에 작성할 때 사용하는 태그는 무엇인가요?\n\n```html\n<______>\ndocument.getElementById(\"demo\").innerHTML = \"Hello!\";\n</______>\n```",
      "option_a": "`<js>`",
      "option_b": "`<script>`",
      "option_c": "`<javascript>`",
      "option_d": "`<code>`",
      "correct_answer": "B",
      "explanation": "JavaScript 코드는 `<script>`와 `</script>` 사이에 작성됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T07:29:04.000Z"
    },
    {
      "id": 12,
      "subject_id": 1,
      "question": "아래 코드에서 버튼을 클릭하면 문장의 내용이 바뀝니다. 그 이유는?\n\n```html\n<button onclick=\"myFunction()\">Click me</button>\n\n<script>\nfunction myFunction() {\n  document.getElementById(\"demo\").innerHTML = \"Changed!\";\n}\n</script>\n```",
      "option_a": "버튼이 자동으로 스크립트를 읽기 때문이다",
      "option_b": "HTML에서 버튼은 기본적으로 텍스트를 바꾸기 때문이다",
      "option_c": "`onclick` 이벤트가 함수 실행을 트리거하기 때문이다",
      "option_d": "`<script>`는 항상 버튼 아래 있어야 하기 때문이다",
      "correct_answer": "C",
      "explanation": "`onclick`은 클릭 시 특정 함수를 실행하는 이벤트입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T07:30:33.000Z"
    },
    {
      "id": 13,
      "subject_id": 1,
      "question": "`<script>` 태그를 `<head>`에 넣을 경우 유의해야 할 점은?",
      "option_a": "반드시 `<body>` 끝에 다시 동일한 코드가 있어야 한다",
      "option_b": "HTML 요소가 로딩되기 전 실행될 수 있다",
      "option_c": "HTML은 `<head>` 내부의 스크립트를 무시한다",
      "option_d": "`<script`>는 `<head>`에서만 사용할 수 있다",
      "correct_answer": "B",
      "explanation": "`<head>`에 스크립트를 넣으면 HTML 요소가 아직 생성되기 전에 실행되어 `getElementById` 등이 작동하지 않을 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T07:31:46.000Z"
    },
    {
      "id": 14,
      "subject_id": 1,
      "question": "외부 JavaScript 파일을 사용하려면 `<script>` 태그의 어떤 속성을 사용해야 하나요?",
      "option_a": "`href`",
      "option_b": "`type`",
      "option_c": "`src`",
      "option_d": "`link`",
      "correct_answer": "C",
      "explanation": "외부 파일을 불러올 때는 `<script src=\"파일.js\"></script>` 형식을 사용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T07:33:55.000Z"
    },
    {
      "id": 15,
      "subject_id": 1,
      "question": "외부 스크립트 파일의 확장자는 무엇이어야 하는가?",
      "option_a": "`.html`",
      "option_b": "`.txt`",
      "option_c": "`.jsx`",
      "option_d": "`.js`",
      "correct_answer": "D",
      "explanation": "자바스크립트 외부 파일은 `.js` 확장자를 사용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T07:35:05.000Z"
    },
    {
      "id": 16,
      "subject_id": 1,
      "question": "다음 중 외부 스크립트를 참조하는 방법이 아닌 것은?",
      "option_a": "`<script src=\"https://example.com/script.js\"></script>`",
      "option_b": "`<script src=\"/js/script.js\"></script>`",
      "option_c": "`<script src=\"script.js\"></script>`",
      "option_d": "`<script href=\"script.js\"></script>`",
      "correct_answer": "D",
      "explanation": "`href`는 `<link>`에 사용하는 속성이며, 외부 스크립트에는 `src`를 사용해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T07:36:04.000Z"
    },
    {
      "id": 17,
      "subject_id": 1,
      "question": "아래 코드를 실행하면 발생할 수 있는 문제는?\n\n```html\n<head>\n<script>\ndocument.getElementById(\"demo\").innerHTML = \"Text changed\";\n</script>\n</head>\n<body>\n<p id=\"demo\">Original Text</p>\n</body>\n```",
      "option_a": "브라우저가 스크립트를 무시함",
      "option_b": "\"Original Text\"가 유지됨",
      "option_c": "\"Text changed\"로 잘 변경됨",
      "option_d": "문법 오류 발생",
      "correct_answer": "B",
      "explanation": "`<head>`에 있는 스크립트가 실행될 때, 아직 `<body>`의 `<p>` 요소가 존재하지 않기 때문에 `getElementById`가 실패합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T07:37:41.000Z"
    },
    {
      "id": 18,
      "subject_id": 1,
      "question": "JavaScript로 데이터를 HTML에 표시하는 가장 일반적인 방법은?\n\n```javascript\ndocument.getElementById(\"demo\").________ = \"<h2>Hello</h2>\";\n```",
      "option_a": "innerText",
      "option_b": "innerContent",
      "option_c": "innerHTML",
      "option_d": "textValue",
      "correct_answer": "C",
      "explanation": "`innerHTML`은 HTML 요소의 내용을 변경하는 데 가장 널리 쓰입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T08:14:26.000Z"
    },
    {
      "id": 19,
      "subject_id": 1,
      "question": "`document.write()`를 사용하는 가장 적절한 용도는?",
      "option_a": "HTML 요소에 스타일을 적용할 때",
      "option_b": "테스트 용으로 출력 결과를 확인할 때",
      "option_c": "사용자 입력값을 검증할 때",
      "option_d": "이벤트 리스너를 등록할 때",
      "correct_answer": "B",
      "explanation": "`document.write()`는 주로 테스트 또는 빠른 출력 확인 용도로만 사용하며, 실제 웹페이지에서는 거의 쓰이지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T08:15:11.000Z"
    },
    {
      "id": 20,
      "subject_id": 1,
      "question": "다음 중 **경고창(alert box)**을 띄우는 코드로 알맞은 것은?",
      "option_a": "`console.alert(\"Hello\")`",
      "option_b": "`window.popUp(\"Hello\")`",
      "option_c": "`alert(\"Hello\")`",
      "option_d": "`document.alert(\"Hello\")`",
      "correct_answer": "C",
      "explanation": "`alert()`은 브라우저에서 경고창을 띄우는 표준 함수이며, `window`는 생략 가능합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T08:16:05.000Z"
    },
    {
      "id": 21,
      "subject_id": 1,
      "question": "아래 코드 실행 결과로 알맞은 설명은?\n\n```html\n<script>\ndocument.getElementById(\"demo\").innerText = \"<b>Hello</b>\";\n</script>\n```",
      "option_a": "`<b>Hello</b>`가 굵은 글씨로 출력된다",
      "option_b": "`Hello`만 출력된다",
      "option_c": "`<b>Hello</b>` 그대로 텍스트로 출력된다",
      "option_d": "에러가 발생한다",
      "correct_answer": "C",
      "explanation": "`innerText`는 HTML 태그를 해석하지 않고 문자 그대로 출력합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T08:17:19.000Z"
    },
    {
      "id": 22,
      "subject_id": 1,
      "question": "아래 코드의 실행 결과로 출력되는 값은?\n\n```javascript\n<script>\nconsole.log(5 + 6);\n</script>\n```",
      "option_a": "HTML 화면에 \"11\" 표시",
      "option_b": "경고창에 \"11\" 표시",
      "option_c": "아무 것도 표시되지 않음",
      "option_d": "개발자 콘솔에 \"11\" 표시",
      "correct_answer": "D",
      "explanation": "`console.log()`는 브라우저의 개발자 도구 콘솔에 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T08:18:09.000Z"
    },
    {
      "id": 23,
      "subject_id": 1,
      "question": "다음 중 HTML 문서가 모두 로드된 후 `document.write()`를 실행하면 발생하는 일은?",
      "option_a": "아무 것도 출력되지 않는다",
      "option_b": "새 창이 열린다",
      "option_c": "기존 문서가 모두 지워진다",
      "option_d": "입력 오류가 발생한다",
      "correct_answer": "C",
      "explanation": "문서가 로드된 이후에 `document.write()`를 호출하면 페이지 전체가 지워집니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T08:18:48.000Z"
    },
    {
      "id": 24,
      "subject_id": 1,
      "question": "아래 코드에서 출력된 결과가 HTML 화면에서 굵은 제목으로 나타나도록 하는 요소는?\n\n```javascript\ndocument.getElementById(\"demo\").innerHTML = \"<h2>Hello</h2>\";\n```",
      "option_a": "`innerText`",
      "option_b": "`h2`",
      "option_c": "`console.log()`",
      "option_d": "`alert()`",
      "correct_answer": "B",
      "explanation": "`<h2>`는 HTML 태그로, 굵고 큰 제목을 만들어줍니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T08:24:15.000Z"
    },
    {
      "id": 25,
      "subject_id": 1,
      "question": "다음 중 콘솔 디버깅 용도로 가장 적절한 함수는?",
      "option_a": "`document.write()`",
      "option_b": "`alert()`",
      "option_c": "`innerText`",
      "option_d": "`console.log()`",
      "correct_answer": "D",
      "explanation": "`console.log()`는 디버깅 정보를 출력할 때 가장 많이 쓰입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T08:25:33.000Z"
    },
    {
      "id": 26,
      "subject_id": 1,
      "question": "다음 중 `window.alert()`과 `alert()`의 관계로 올바른 설명은?",
      "option_a": "`alert()`는 `window.alert()`의 축약형이다",
      "option_b": "`window.alert()`는 `alert()`보다 더 최신이다",
      "option_c": "`window.alert()`는 콘솔 전용 함수이다",
      "option_d": "`alert()`는 오직 모바일 브라우저에서만 동작한다",
      "correct_answer": "A",
      "explanation": "`alert()`는 전역 객체 `window`의 메서드로, `window.alert()`와 동일합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T08:27:10.000Z"
    },
    {
      "id": 27,
      "subject_id": 1,
      "question": "다음 중 JavaScript에서 출력 장치를 직접 제어하는 print 함수를 지원하는 유일한 방법은?\n\n```html\n<button onclick=\"__________\">Print this page</button>\n```",
      "option_a": "`document.print()`",
      "option_b": "`window.alert()`",
      "option_c": "`window.print()`",
      "option_d": "`console.print()`",
      "correct_answer": "C",
      "explanation": "`window.print()`는 현재 브라우저 창을 프린트하는 유일한 방법입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T08:28:02.000Z"
    },
    {
      "id": 28,
      "subject_id": 1,
      "question": "JavaScript에서 여러 변수 선언을 한 문장으로 작성할 수 있다. 다음 코드에서 빈칸에 들어갈 키워드는?\n\n```javascript\n___ x, y, z;\n```",
      "option_a": "`define`",
      "option_b": "`var`",
      "option_c": "`let`",
      "option_d": "`const`",
      "correct_answer": "C",
      "explanation": "`let`은 블록 범위 변수를 선언할 때 사용되며, 여러 개를 콤마로 구분해 한 줄에 선언할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T08:33:15.000Z"
    },
    {
      "id": 29,
      "subject_id": 1,
      "question": "다음 중 JavaScript 문장(statement)을 올바르게 구성한 것은?",
      "option_a": "`x = 10;`",
      "option_b": "`10 = x;`",
      "option_c": "`x == 10;`",
      "option_d": "`value 10 to x;`",
      "correct_answer": "A",
      "explanation": "`x = 10;`은 변수 x에 10을 할당하는 올바른 할당문입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T08:34:05.000Z"
    },
    {
      "id": 30,
      "subject_id": 1,
      "question": "JavaScript 문장은 일반적으로 무엇으로 구분하나요?\n\n```javascript\nlet x = 5 ___ y = 6;\n```",
      "option_a": "콤마(,)",
      "option_b": "세미콜론(;)",
      "option_c": "마침표(.)",
      "option_d": "슬래시(/)",
      "correct_answer": "B",
      "explanation": "세미콜론(;)은 JavaScript 문장의 끝을 구분하는 데 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T08:35:05.000Z"
    },
    {
      "id": 31,
      "subject_id": 1,
      "question": "다음 코드 실행 결과로 올바른 것은?\n\n```javascript\nlet a = 5; b = 6; c = a + b;\n```",
      "option_a": "문법 오류가 발생한다",
      "option_b": "`c`는 11을 저장한다",
      "option_c": "변수는 한 줄에 하나만 선언 가능하다",
      "option_d": "`c`에는 NaN이 저장된다",
      "correct_answer": "B",
      "explanation": "세미콜론으로 구분된 여러 문장을 한 줄에 작성해도 JavaScript는 이를 올바르게 해석합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T08:36:11.000Z"
    },
    {
      "id": 32,
      "subject_id": 1,
      "question": "다음 코드에서 `z`의 값으로 올바른 것은?\n\n```javascript\nlet x = 3;\nlet y = 7;\nlet z = x + y;\n```",
      "option_a": "10",
      "option_b": "\"3 + 7\"",
      "option_c": "37",
      "option_d": "undefined",
      "correct_answer": "A",
      "explanation": "숫자 덧셈이므로 `3 + 7 = 10`입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T08:37:05.000Z"
    },
    {
      "id": 33,
      "subject_id": 1,
      "question": "다음 중 JavaScript 코드에서 들여쓰기와 공백에 대한 설명으로 올바른 것은?",
      "option_a": "들여쓰기는 문법적으로 반드시 필요하다",
      "option_b": "여러 공백은 에러를 유발한다",
      "option_c": "공백과 들여쓰기는 가독성을 높이기 위한 것이다",
      "option_d": "변수 선언에는 공백을 사용할 수 없다",
      "correct_answer": "C",
      "explanation": "JavaScript는 공백을 무시하므로 들여쓰기는 선택사항이지만, 가독성을 위해 권장됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T08:37:47.000Z"
    },
    {
      "id": 34,
      "subject_id": 1,
      "question": "다음 코드에서 innerHTML 속성을 줄 바꿈하여 사용할 경우 가장 적절한 위치는?\n\n```javascript\ndocument.getElementById(\"demo\").innerHTML = \"Hello Dolly!\";\n```",
      "option_a": "`\"Hello Dolly!\"` 앞",
      "option_b": "`=` 뒤",
      "option_c": "`document` 앞",
      "option_d": "`;` 앞",
      "correct_answer": "B",
      "explanation": "줄바꿈은 연산자 뒤에 하면 가독성이 좋고 에러를 방지할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T08:39:46.000Z"
    },
    {
      "id": 35,
      "subject_id": 1,
      "question": "아래 코드에서 한 함수 안에 여러 문장을 묶기 위해 사용하는 기호는?\n\n```javascript\nfunction myFunction() {\n  document.getElementById(\"demo1\").innerHTML = \"Hello!\";\n  document.getElementById(\"demo2\").innerHTML = \"Bye!\";\n}\n```",
      "option_a": "()",
      "option_b": "[]",
      "option_c": "{}",
      "option_d": "\"\"",
      "correct_answer": "C",
      "explanation": "중괄호 `{}`는 여러 문장을 하나의 코드 블록으로 묶을 때 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T08:40:39.000Z"
    },
    {
      "id": 36,
      "subject_id": 1,
      "question": "JavaScript에서 예약어(Reserved Words)는 무엇을 의미하나요?",
      "option_a": "항상 변수로 사용하는 단어",
      "option_b": "JavaScript 문법에 필요한 키워드로 변수명으로 사용할 수 없음",
      "option_c": "HTML 태그로 지정된 단어",
      "option_d": "콘솔에서만 사용하는 명령어",
      "correct_answer": "B",
      "explanation": "예약어는 JavaScript 문법에서 이미 사용되는 키워드로 변수명으로 사용할 수 없습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T08:41:25.000Z"
    },
    {
      "id": 37,
      "subject_id": 1,
      "question": "다음 중 JavaScript 문장을 구성하는 **요소(components)**가 아닌 것은?",
      "option_a": "연산자(operators)",
      "option_b": "값(values)",
      "option_c": "HTML 태그",
      "option_d": "키워드(keywords)",
      "correct_answer": "C",
      "explanation": "JavaScript 문장은 값, 연산자, 키워드, 표현식, 주석 등으로 구성되며 HTML 태그는 포함되지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T08:42:01.000Z"
    },
    {
      "id": 38,
      "subject_id": 1,
      "question": "JavaScript에서 값을 저장하기 위한 공간을 만들기 위해 사용하는 키워드는?\n\n```javascript\n___ x;\nx = 5;\n```",
      "option_a": "define",
      "option_b": "let",
      "option_c": "input",
      "option_d": "const",
      "correct_answer": "B",
      "explanation": "`let`은 JavaScript에서 변수를 선언하는 데 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T08:58:40.000Z"
    },
    {
      "id": 39,
      "subject_id": 1,
      "question": "다음 중 문자열(string) 값을 올바르게 표현한 것은?",
      "option_a": "`John Doe`",
      "option_b": "`'John Doe'`",
      "option_c": "`John \"Doe\"`",
      "option_d": "`\\\"John Doe\\\"`",
      "correct_answer": "B",
      "explanation": "문자열은 작은 따옴표 또는 큰 따옴표로 감싸야 합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T08:59:22.000Z"
    },
    {
      "id": 40,
      "subject_id": 1,
      "question": "다음 중 유효한 변수명으로 사용할 수 없는 것은?",
      "option_a": "`_name`",
      "option_b": "`$value`",
      "option_c": "`1stPlace`",
      "option_d": "`camelCase`",
      "correct_answer": "C",
      "explanation": "변수명은 숫자로 시작할 수 없습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:00:13.000Z"
    },
    {
      "id": 41,
      "subject_id": 1,
      "question": "아래 JavaScript 표현식의 결과는?\n\n```javascript\n\"John\" + \" \" + \"Doe\"\n```",
      "option_a": "JohnDoe",
      "option_b": "John",
      "option_c": "\"John Doe\"",
      "option_d": "undefined",
      "correct_answer": "C",
      "explanation": "문자열 연결 연산자 `+`를 통해 `\"John Doe\"`가 생성됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:01:07.000Z"
    },
    {
      "id": 42,
      "subject_id": 1,
      "question": "JavaScript에서 let, var, const는 공통적으로 어떤 역할을 하나요?",
      "option_a": "연산자",
      "option_b": "변수 선언",
      "option_c": "함수 호출",
      "option_d": "객체 생성",
      "correct_answer": "B",
      "explanation": "이들 키워드는 모두 변수를 선언하는 데 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:01:50.000Z"
    },
    {
      "id": 43,
      "subject_id": 1,
      "question": "다음 중 JavaScript에서 **식별자(identifier)**에 대한 설명으로 옳은 것은?",
      "option_a": "JavaScript에서 식별자는 숫자로만 구성된다",
      "option_b": "식별자는 예약어로도 사용할 수 있다",
      "option_c": "식별자는 변수, 함수, 키워드에 이름을 붙일 때 사용된다",
      "option_d": "대소문자를 구분하지 않는다",
      "correct_answer": "C",
      "explanation": "식별자는 이름을 붙일 때 사용되며, JavaScript는 대소문자를 구분합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T09:02:55.000Z"
    },
    {
      "id": 44,
      "subject_id": 1,
      "question": "JavaScript에서 **한 줄 주석(Single Line Comment)**을 작성할 때 사용하는 기호는?\n\n```javascript\n_____ 이 코드는 실행되지 않습니다.\nlet x = 5;\n```",
      "option_a": "`/*`",
      "option_b": "`-->`",
      "option_c": "`//`",
      "option_d": "`<!--`",
      "correct_answer": "C",
      "explanation": "`//`는 JavaScript에서 한 줄 주석을 작성할 때 사용하는 표준 기호입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T09:05:46.000Z"
    },
    {
      "id": 45,
      "subject_id": 1,
      "question": "아래 코드에서 변수 y의 값은 얼마입니까?\n\n```javascript\nlet x = 5;      // x는 5입니다\nlet y = x + 2;  // y는 x + 2입니다\n```",
      "option_a": "5",
      "option_b": "6",
      "option_c": "7",
      "option_d": "주석 때문에 코드가 실행되지 않는다",
      "correct_answer": "C",
      "explanation": "주석은 코드 실행에 영향을 주지 않으므로 y = 5 + 2 = 7입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T09:06:31.000Z"
    },
    {
      "id": 46,
      "subject_id": 1,
      "question": "다음 중 **여러 줄 주석(Multi-line Comment)**을 올바르게 작성한 것은?",
      "option_a": "// 이건 첫 줄 주석 // 이건 두 번째 줄",
      "option_b": "/* 이건 주석 시작 * 이건 끝 */",
      "option_c": "/* 이건 첫 줄 주석\\n 이건 두 번째 줄 */",
      "option_d": "`<!-- 이건 HTML 주석 -->`",
      "correct_answer": "C",
      "explanation": "JavaScript에서 여러 줄 주석은 `/* ... */` 형식을 사용하며, 줄바꿈이 포함될 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:07:24.000Z"
    },
    {
      "id": 47,
      "subject_id": 1,
      "question": "다음 코드에서 실제로 실행되는 줄은 몇 번째 줄인가요?\n\n```javascript\n//document.getElementById(\"myH\").innerHTML = \"Hello!\";\ndocument.getElementById(\"myP\").innerHTML = \"World!\";\n```",
      "option_a": "첫번째 줄",
      "option_b": "두번째 줄",
      "option_c": "모두 실행됨",
      "option_d": "모두 실행되지 않음",
      "correct_answer": "B",
      "explanation": "첫 번째 줄은 `//`로 주석 처리되어 실행되지 않고, 두 번째 줄만 실행됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:08:20.000Z"
    },
    {
      "id": 48,
      "subject_id": 1,
      "question": "다음 중 주석을 활용하는 주된 목적으로 적절하지 않은 것은?",
      "option_a": "코드의 가독성을 높이기 위해",
      "option_b": "코드 실행을 일시적으로 막기 위해",
      "option_c": "프로그램 속도를 빠르게 하기 위해",
      "option_d": "코드의 기능을 설명하기 위해",
      "correct_answer": "C",
      "explanation": "주석은 실행되지 않으므로 성능에 영향을 주지 않으며, 속도를 빠르게 하지도 않습니다.\n\n",
      "difficulty": "hard",
      "created_at": "2025-08-04T09:08:52.000Z"
    },
    {
      "id": 49,
      "subject_id": 1,
      "question": "JavaScript에서 값을 저장하기 위해 사용하는 기본 단위는?\n\n```javascript\nlet x = 5;\n```",
      "option_a": "함수 (function)",
      "option_b": "상수 (constant)",
      "option_c": "변수 (variable)",
      "option_d": "객체 (object)",
      "correct_answer": "C",
      "explanation": "변수는 데이터를 저장하기 위한 컨테이너입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T09:20:05.000Z"
    },
    {
      "id": 50,
      "subject_id": 1,
      "question": "아래 코드에서 변수 `z`의 결과값은?\n\n```javascript\nlet x = 5;\nlet y = 6;\nlet z = x + y;\n```",
      "option_a": "56",
      "option_b": "11",
      "option_c": "\"11\"",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "숫자 덧셈이므로 5 + 6 = 11입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T09:21:00.000Z"
    },
    {
      "id": 51,
      "subject_id": 1,
      "question": "다음 중 JavaScript에서 변수를 선언할 수 있는 키워드가 아닌 것은?",
      "option_a": "var",
      "option_b": "let",
      "option_c": "const",
      "option_d": "make",
      "correct_answer": "D",
      "explanation": "JavaScript는 `var`, `let`, `const`를 사용해 변수를 선언합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T09:21:50.000Z"
    },
    {
      "id": 52,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = \"5\" + 2 + 3;\n```",
      "option_a": "\"10\"",
      "option_b": "10",
      "option_c": "\"523\"",
      "option_d": "\"55\"",
      "correct_answer": "C",
      "explanation": "문자열 \"5\" 이후의 숫자도 문자열처럼 연결(concatenate)됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:23:21.000Z"
    },
    {
      "id": 53,
      "subject_id": 1,
      "question": "다음 코드에서 총 몇 개의 변수를 선언하고 있나요?\n\n```javascript\nlet a = 1, b = 2, c = 3;\n```",
      "option_a": "1개",
      "option_b": "2개",
      "option_c": "3개",
      "option_d": "4개",
      "correct_answer": "C",
      "explanation": "`let` 키워드 한 번으로도 여러 개의 변수를 콤마(,)로 구분하여 선언할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:24:52.000Z"
    },
    {
      "id": 54,
      "subject_id": 1,
      "question": "`let` 키워드는 JavaScript의 어떤 버전에서 도입되었나요?",
      "option_a": "ES3",
      "option_b": "ES5",
      "option_c": "ES6",
      "option_d": "ES7",
      "correct_answer": "C",
      "explanation": "`let`은 ES6(2015)부터 도입된 변수 선언 키워드입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T09:28:23.000Z"
    },
    {
      "id": 55,
      "subject_id": 1,
      "question": "다음 코드에서 변수 x의 유효 범위(Scope)는 어디인가요?\n\n```javascript\n{\n  let x = 2;\n}\n```",
      "option_a": "전역(Global)",
      "option_b": "함수(Function)",
      "option_c": "블록(Block)",
      "option_d": "스크립트 전체",
      "correct_answer": "C",
      "explanation": "`let`은 블록 스코프를 가지므로, `{}` 내부에서만 유효합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T09:29:12.000Z"
    },
    {
      "id": 56,
      "subject_id": 1,
      "question": "다음 중 let 변수의 특징으로 옳지 않은 것은?",
      "option_a": "재할당 가능",
      "option_b": "재선언 가능",
      "option_c": "선언 전에 사용할 수 없음",
      "option_d": "블록 스코프를 가짐",
      "correct_answer": "B",
      "explanation": "`let` 변수는 같은 스코프 내에서 재선언할 수 없습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:29:55.000Z"
    },
    {
      "id": 57,
      "subject_id": 1,
      "question": "다음 코드에서 실행 결과는?\n\n```javascript\nlet x = 10;\n{\n  let x = 5;\n  console.log(x);\n}\nconsole.log(x);\n```",
      "option_a": "5, 5",
      "option_b": "5, 10",
      "option_c": "10, 5",
      "option_d": "10, 10",
      "correct_answer": "B",
      "explanation": "블록 내 `x`는 블록 스코프에 해당되므로 각각 5, 10이 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:30:57.000Z"
    },
    {
      "id": 58,
      "subject_id": 1,
      "question": "아래 코드의 실행 결과는?\n\n```javascript\ncarName = \"Volvo\";\nlet carName;\n```",
      "option_a": "\"Volvo\" 출력",
      "option_b": "ReferenceError 발생",
      "option_c": "undefined 출력",
      "option_d": "null 출력",
      "correct_answer": "B",
      "explanation": "`let` 변수는 호이스팅은 되지만 초기화되지 않으므로, 선언 전 접근 시 오류 발생합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:32:22.000Z"
    },
    {
      "id": 59,
      "subject_id": 1,
      "question": "다음 코드 실행 결과로 올바른 것은?\n\n```javascript\nlet x = 2;\n{\n  var x = 3;\n}\n```",
      "option_a": "정상 실행됨",
      "option_b": "var는 블록 외부에서만 사용 가능하므로 에러 발생함",
      "option_c": "let과 var는 같은 이름으로 선언 가능하므로 x는 3임",
      "option_d": "SyntaxError 발생함",
      "correct_answer": "D",
      "explanation": "`let x`는 전역 블록 스코프에 선언됩니다. `var x`는 블록을 무시하고, 함수 바깥이므로 전역에 선언됩니다. 따라서 두 변수는 같은 전역 스코프에 x라는 이름으로 중복 선언됩니다.\n\n",
      "difficulty": "hard",
      "created_at": "2025-08-04T09:36:24.000Z"
    },
    {
      "id": 60,
      "subject_id": 1,
      "question": "다음 중 `let`을 사용하는 목적에 가장 부합하는 설명은?",
      "option_a": "전역 변수 선언",
      "option_b": "같은 변수 이름으로 여러 번 선언",
      "option_c": "블록 안에서만 유효한 변수 선언",
      "option_d": "상수 선언",
      "correct_answer": "C",
      "explanation": "`let`은 블록 스코프를 가지며, 함수나 조건문 안에서 제한적으로 쓰기 좋습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T09:37:21.000Z"
    },
    {
      "id": 61,
      "subject_id": 1,
      "question": "다음 중 `let`과 `var`의 차이로 옳지 않은 것은?",
      "option_a": "`let`은 재선언이 불가능하다",
      "option_b": "`let`은 블록 스코프를 가진다",
      "option_c": "`let`은 함수 바깥에서 선언해도 전역 스코프를 가진다",
      "option_d": "`var`는 호이스팅되어 선언 전에 접근 가능하다",
      "correct_answer": "C",
      "explanation": "`let`은 블록 스코프이며, 전역 스코프는 자동으로 가지지 않습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T09:38:33.000Z"
    },
    {
      "id": 62,
      "subject_id": 1,
      "question": "다음 코드에서 오류가 발생하는 이유는?\n\n```javascript\nconst name;\nname = \"Alice\";\n```",
      "option_a": "`const`는 문자열을 저장할 수 없다.",
      "option_b": "`const`는 변수명을 미리 지정할 수 없다.",
      "option_c": "`const` 변수는 선언만 할 수 있고 할당은 나중에 해야 한다.",
      "option_d": "`const` 변수는 선언과 동시에 값을 할당해야 한다.",
      "correct_answer": "D",
      "explanation": "`const` 변수는 선언 시점에서 바로 값을 할당해야 한다. 나중에 값을 넣으려고 하면 문법 오류가 발생한다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T09:43:34.000Z"
    },
    {
      "id": 63,
      "subject_id": 1,
      "question": "다음 코드에서 오류가 발생하는 이유는?\n\n```javascript\nconst PI = 3.14;\nPI = 3.14159;\n```",
      "option_a": "const로 숫자형을 저장할 수 없다.",
      "option_b": "const 변수는 재선언만 불가능하다.",
      "option_c": "const 변수는 재할당이 불가능하다.",
      "option_d": "const 변수는 블록 외부에서만 선언 가능하다.",
      "correct_answer": "C",
      "explanation": "`const`로 선언된 변수는 값을 재할당할 수 없다. 위 코드는 PI에 새로운 값을 넣으려 하므로 오류가 발생한다.",
      "difficulty": "easy",
      "created_at": "2025-08-04T09:44:35.000Z"
    },
    {
      "id": 64,
      "subject_id": 1,
      "question": "다음 중 `const`로 선언한 배열의 가능한 조작은 무엇인가?\n\n```javascript\nconst cars = [\"Saab\", \"Volvo\", \"BMW\"];\n```",
      "option_a": "`cars = [\"Toyota\", \"Volvo\", \"Audi\"];`",
      "option_b": "`cars[0] = \"Toyota\";`",
      "option_c": "`const cars = [\"Hyundai\"];`",
      "option_d": "`delete cars;`",
      "correct_answer": "B",
      "explanation": "`const`는 변수 자체를 재할당하는 것은 막지만, 참조값이 배열이나 객체일 경우 내부 요소 변경은 가능하다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:45:34.000Z"
    },
    {
      "id": 65,
      "subject_id": 1,
      "question": "다음 코드에서 출력되는 결과는?\n\n```javascript\nconst x = 10;\n{\n  const x = 2;\n  console.log(x);\n}\n```",
      "option_a": "10",
      "option_b": "2",
      "option_c": "undefined",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "`const`는 블록 스코프를 가지므로, 중괄호 내부에서 새롭게 `x`가 선언되어 값이 2가 된다. 따라서 출력 결과는 2이다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:46:37.000Z"
    },
    {
      "id": 66,
      "subject_id": 1,
      "question": "다음 코드에서 어떤 결과가 출력되는가?\n\n```javascript\nconst cars = [\"Volvo\", \"BMW\"];\ncars.push(\"Audi\");\nconsole.log(cars);\n```",
      "option_a": "[\"Volvo\", \"BMW\"]",
      "option_b": "[\"Volvo\", \"BMW\", \"Audi\"]",
      "option_c": "오류 발생",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "배열 내부 요소를 변경하거나 추가하는 것은 `const` 변수라도 허용된다. 다만, 배열 자체를 다른 값으로 바꾸는 건 불가하다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:47:51.000Z"
    },
    {
      "id": 67,
      "subject_id": 1,
      "question": "다음 중 올바른 `const` 사용 예는?",
      "option_a": "`const user; user = \"Kim\";`",
      "option_b": "`const user = \"Lee\"; user = \"Kim\";`",
      "option_c": "`const user = \"Lee\";`",
      "option_d": "`const = \"Lee\";`",
      "correct_answer": "C",
      "explanation": "`const`는 선언과 동시에 값을 할당해야 하며, 그 이후 재할당은 불가능하다. 변수명을 생략해서도 안 된다.",
      "difficulty": "medium",
      "created_at": "2025-08-04T09:48:40.000Z"
    },
    {
      "id": 68,
      "subject_id": 1,
      "question": "다음 코드 중 오류가 발생하지 않는 문장은?\n\n```javascript\nconst car = {type: \"Fiat\", color: \"white\"};\n```",
      "option_a": "`car = {type: \"BMW\", color: \"black\"};`",
      "option_b": "`car.color = \"red\";`",
      "option_c": "`const car = \"Toyota\";`",
      "option_d": "`car = \"Volvo\";`",
      "correct_answer": "B",
      "explanation": "`const`로 선언된 객체는 객체 자체를 새로 할당할 수는 없지만, 내부 프로퍼티의 변경은 허용된다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T09:49:50.000Z"
    },
    {
      "id": 69,
      "subject_id": 1,
      "question": "다음 코드에서 오류가 발생하는 이유는?\n\n```javascript\nconsole.log(x);\nconst x = 5;\n```",
      "option_a": "const 변수는 선언 전에도 사용할 수 있다.",
      "option_b": "const 변수는 호이스팅되지 않는다.",
      "option_c": "const 변수는 선언되기 전에는 접근할 수 없다.",
      "option_d": "const는 선언만 하면 자동으로 초기화된다.",
      "correct_answer": "C",
      "explanation": "`const x`는 호이스팅되어 선언은 되었지만, `const x = 5;` 줄에 도달하기 전까지는 초기화되지 않았기 때문에 `console.log(x)`에서 ReferenceError가 발생합니다. 즉, 선언 전에 사용하려고 해서 에러가 난 것입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-04T09:52:31.000Z"
    },
    {
      "id": 70,
      "subject_id": 1,
      "question": "다음 코드에서 사용된 `=` 연산자의 역할은 무엇인가요?\n\n```javascript\nlet a = 10;\n```",
      "option_a": "덧셈",
      "option_b": "비교",
      "option_c": "값 할당",
      "option_d": "곱셈",
      "correct_answer": "C",
      "explanation": "`=`는 **대입 연산자(Assignment Operator)**입니다. 변수 `a`에 값 10을 할당합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T05:13:07.000Z"
    },
    {
      "id": 71,
      "subject_id": 1,
      "question": "아래 코드의 출력값은 무엇인가요?\n\n```javascript\nlet text = \"Hello\";\ntext += \" World\";\nconsole.log(text);\n```",
      "option_a": "Hello",
      "option_b": "World",
      "option_c": "Hello World",
      "option_d": "undefined",
      "correct_answer": "C",
      "explanation": "`+=`는 문자열에서도 사용할 수 있으며, 기존 문자열에 다른 문자열을 이어 붙입니다. 결과는 `\"Hello World\"`입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T05:13:59.000Z"
    },
    {
      "id": 72,
      "subject_id": 1,
      "question": "다음 코드의 결과로 알맞은 것은?\n\n```javascript\nlet x = \"5\";\nlet y = 5;\nlet result = x + y;\n```",
      "option_a": "10",
      "option_b": "\"55\"",
      "option_c": "0",
      "option_d": "Error",
      "correct_answer": "B",
      "explanation": "`x`는 문자열 `\"5\"`이고, `y`는 숫자 5입니다. 이 경우 자바스크립트는 숫자를 문자열로 변환해서 `\"5\" + \"5\"`로 처리하므로 `\"55\"`가 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:15:18.000Z"
    },
    {
      "id": 73,
      "subject_id": 1,
      "question": "다음 중 두 피연산자의 값과 타입이 모두 같아야 true를 반환하는 비교 연산자는?",
      "option_a": "`==`",
      "option_b": "`===`",
      "option_c": "`!=`",
      "option_d": "`!==`",
      "correct_answer": "B",
      "explanation": "`===`는 엄격한 비교(strict equality) 연산자로 값과 자료형이 모두 같을 때에만 `true`를 반환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:16:40.000Z"
    },
    {
      "id": 74,
      "subject_id": 1,
      "question": "아래 코드에서 `z`의 값은 무엇인가요?\n\n```javascript\nlet x = 10;\nx *= 2;\nlet z = x;\n```\n",
      "option_a": "5",
      "option_b": "12",
      "option_c": "20",
      "option_d": "100",
      "correct_answer": "C",
      "explanation": "`*=`는 곱하기 후 대입하는 연산자입니다. `x *= 2`는 `x = x * 2`와 같으므로 `x = 10 * 2 = 20`입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:18:05.000Z"
    },
    {
      "id": 75,
      "subject_id": 1,
      "question": "다음 코드 중 `true`를 반환하는 비교는 무엇인가요?\n\n```javascript\nlet a = \"10\";\nlet b = 10;\n```",
      "option_a": "a === b",
      "option_b": "a == b",
      "option_c": "a !== b",
      "option_d": "typeof a == typeof b",
      "correct_answer": "B",
      "explanation": "`==`는 **느슨한 비교(loose equality)**로 값만 비교합니다. `\"10\"`과 `10`은 자료형은 다르지만 값은 같기 때문에 `true`를 반환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:29:41.000Z"
    },
    {
      "id": 76,
      "subject_id": 1,
      "question": "아래 코드 실행 결과는?\n\n```javascript\nlet a = \"20\";\nlet b = \"5\";\nconsole.log(a < b);\n```",
      "option_a": "true",
      "option_b": "false",
      "option_c": "Error",
      "option_d": "NaN",
      "correct_answer": "A",
      "explanation": "문자열 간 `<` 비교는 알파벳 순서 또는 문자열 순서로 비교합니다. `\"20\"`이 `\"5\"`보다 앞이기 때문에 `true`입니다. 숫자 비교가 아닌 문자열 비교라는 점이 포인트입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T05:30:48.000Z"
    },
    {
      "id": 77,
      "subject_id": 1,
      "question": "다음 코드에서 `typeof` 연산 결과로 올바른 것은?\n\n```javascript\nlet x = 42;\nlet y = \"42\";\nconsole.log(typeof x, typeof y);\n```",
      "option_a": "number, number",
      "option_b": "string, string",
      "option_c": "number, string",
      "option_d": "object, string",
      "correct_answer": "C",
      "explanation": "`typeof`는 변수의 자료형을 문자열로 반환합니다. `x`는 숫자 → `number`, `y`는 문자열 → `string`이므로 `number, string`입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:32:57.000Z"
    },
    {
      "id": 78,
      "subject_id": 1,
      "question": "다음 중 결과가 문자열이 아닌 숫자가 되는 연산은?",
      "option_a": "`\"5\" + 2`",
      "option_b": "`2 + \"5\"`",
      "option_c": "`5 + 2`",
      "option_d": "`\"5\" + \"2\"`",
      "correct_answer": "C",
      "explanation": "나머지는 모두 문자열이 포함된 연산이기 때문에 문자열 결합이 발생합니다. `5 + 2`는 숫자끼리의 연산이라 덧셈이 수행되어 숫자 `7`이 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:34:24.000Z"
    },
    {
      "id": 79,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 10;\nlet y = 3;\nlet z = x % y;\n```",
      "option_a": "1",
      "option_b": "3",
      "option_c": "0",
      "option_d": "10",
      "correct_answer": "A",
      "explanation": "`%`는 나머지 연산자입니다. 10을 3으로 나눈 나머지는 1입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:38:45.000Z"
    },
    {
      "id": 80,
      "subject_id": 1,
      "question": "다음 코드에서 `z`의 값은?\n\n```javascript\nlet x = 4;\nx++;\nlet z = x;\n```",
      "option_a": "3",
      "option_b": "4",
      "option_c": "5",
      "option_d": "undefined",
      "correct_answer": "C",
      "explanation": "`x++`는 1 증가시키는 후위 증가 연산자입니다. x는 5가 되어 z도 5입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:39:44.000Z"
    },
    {
      "id": 81,
      "subject_id": 1,
      "question": "다음 코드의 출력값은?\n\n```javascript\nlet x = 8;\nx--;\nlet z = x;\n```",
      "option_a": "7",
      "option_b": "8",
      "option_c": "9",
      "option_d": "NaN",
      "correct_answer": "A",
      "explanation": "`x--`는 1 감소시키는 연산자입니다. x가 8 → 7이 되므로 z도 7입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:40:38.000Z"
    },
    {
      "id": 82,
      "subject_id": 1,
      "question": "다음 중 거듭제곱(Exponentiation) 연산에 해당하는 코드는?",
      "option_a": "`let z = x + y;`",
      "option_b": "`let z = x ** y;`",
      "option_c": "`let z = x % y;`",
      "option_d": "`let z = x / y;`",
      "correct_answer": "B",
      "explanation": "`**`는 거듭제곱 연산자입니다. `x ** y`는 `x`를 `y`번 곱한 값입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:41:35.000Z"
    },
    {
      "id": 83,
      "subject_id": 1,
      "question": "다음 코드에서 `z`의 결과값은?\n\n```javascript\nlet x = 2;\nlet y = 3;\nlet z = x ** y;\n```",
      "option_a": "5",
      "option_b": "6",
      "option_c": "8",
      "option_d": "9",
      "correct_answer": "C",
      "explanation": "`2 ** 3`은 2를 세 번 곱한 것 = 2 × 2 × 2 = 8입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:44:16.000Z"
    },
    {
      "id": 84,
      "subject_id": 1,
      "question": "아래 코드에서 `x`의 값은?\n\n```javascript\nlet x = 100 + 50 * 3;\n```",
      "option_a": "450",
      "option_b": "300",
      "option_c": "150",
      "option_d": "250",
      "correct_answer": "D",
      "explanation": "연산자 우선순위에 따라 곱셈이 먼저 실행됩니다. 50 * 3 = 150 → 100 + 150 = 250",
      "difficulty": "medium",
      "created_at": "2025-08-05T05:47:27.000Z"
    },
    {
      "id": 85,
      "subject_id": 1,
      "question": "다음 코드에서 `x`의 값은 얼마인가요?\n\n```javascript\nlet x = 10;\nx += 5;\n```",
      "option_a": "5",
      "option_b": "10",
      "option_c": "15",
      "option_d": "\"105\"",
      "correct_answer": "C",
      "explanation": "`+=`는 기존 값에 더한 값을 다시 할당합니다. `x += 5`는 `x = x + 5`, 즉 `10 + 5 = 15`가 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T05:55:16.000Z"
    },
    {
      "id": 86,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 올바른 것은?\n\n```javascript\nlet text = \"Hello\";\ntext += \" World\";\n```",
      "option_a": "`\"Hello\"`",
      "option_b": "`\" World\"`",
      "option_c": "`\"HelloWorld\"`",
      "option_d": "`\"Hello World\"`",
      "correct_answer": "D",
      "explanation": "문자열에도 `+=`를 사용할 수 있습니다. `\"Hello\" + \" World\"` = `\"Hello World\"`",
      "difficulty": "easy",
      "created_at": "2025-08-05T05:56:15.000Z"
    },
    {
      "id": 87,
      "subject_id": 1,
      "question": "다음 중 `x = x * y` 와 같은 의미의 할당 연산자는?",
      "option_a": "`x *= y`",
      "option_b": "`x **= y`",
      "option_c": "`x += y`",
      "option_d": "`x /= y`",
      "correct_answer": "A",
      "explanation": "`*=`는 곱하기 후 대입 연산자입니다. 즉 `x *= y`는 `x = x * y`와 동일합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T05:59:02.000Z"
    },
    {
      "id": 88,
      "subject_id": 1,
      "question": "아래 코드에서 빈칸에 알맞은 연산자는?\n\n```javascript\nlet x = 10;\nx ___ 3;\nconsole.log(x); // 결과: 1\n```",
      "option_a": "`+=`",
      "option_b": "`%=`",
      "option_c": "`-=`",
      "option_d": "`/=`",
      "correct_answer": "B",
      "explanation": "`x %= 3`은 `x = x % 3`, 즉 나머지 연산입니다. `10 % 3 = 1`",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:00:17.000Z"
    },
    {
      "id": 89,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 2;\nx **= 3;\n```",
      "option_a": "5",
      "option_b": "6",
      "option_c": "8",
      "option_d": "9",
      "correct_answer": "C",
      "explanation": "`**=`는 거듭제곱 연산입니다. `x = x ** 3` → `2 ** 3 = 8`",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:01:12.000Z"
    },
    {
      "id": 90,
      "subject_id": 1,
      "question": "다음 중 `x = x / y` 와 동일한 의미를 가지는 코드는?",
      "option_a": "`x **= y`",
      "option_b": "`x /= y`",
      "option_c": "`x %= y`",
      "option_d": "`x += y`",
      "correct_answer": "B",
      "explanation": "`/=`는 나누기 후 대입 연산자입니다. `x = x / y`와 동일합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:02:19.000Z"
    },
    {
      "id": 91,
      "subject_id": 1,
      "question": "다음 코드에서 `x`의 최종 값은 얼마인가요?\n\n```javascript\nlet x = 10;\nx &= 7;\n```",
      "option_a": "7",
      "option_b": "2",
      "option_c": "0",
      "option_d": "3",
      "correct_answer": "B",
      "explanation": "`&=`는 비트 AND 연산자입니다. 10 → `1010`, 7 → `0111`, `1010 & 0111` = `0010` → 2",
      "difficulty": "hard",
      "created_at": "2025-08-05T06:04:04.000Z"
    },
    {
      "id": 92,
      "subject_id": 1,
      "question": "다음 코드에서 `x`의 값은?\n\n```javascript\nlet x = -100;\nx <<= 2;\n```",
      "option_a": "-25",
      "option_b": "-400",
      "option_c": "-200",
      "option_d": "-50",
      "correct_answer": "B",
      "explanation": "`<<=`는 왼쪽 비트 시프트 후 대입 연산자입니다. -100 << 2 = -100 × 2² = -400",
      "difficulty": "hard",
      "created_at": "2025-08-05T06:05:09.000Z"
    },
    {
      "id": 93,
      "subject_id": 1,
      "question": "다음 중 ES2020에서 도입된 할당 연산자는?",
      "option_a": "`+=`",
      "option_b": "`*=`",
      "option_c": "`||=`",
      "option_d": "`%=`",
      "correct_answer": "C",
      "explanation": "`||=`, `&&=`, `??=` 는 모두 ES2020에 도입된 논리 연산 할당자입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T06:05:56.000Z"
    },
    {
      "id": 94,
      "subject_id": 1,
      "question": "다음 코드의 결과는?\n\n```javascript\nlet x;\nx ??= 5;\n```",
      "option_a": "`undefined`",
      "option_b": "`null`",
      "option_c": "`0`",
      "option_d": "`5`",
      "correct_answer": "D",
      "explanation": "`??=`는 값이 `null` 또는 `undefined`일 경우에만 값을 할당합니다. `x`가 선언만 되었기 때문에 `undefined` → 따라서 `x = 5`가 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T06:07:02.000Z"
    },
    {
      "id": 95,
      "subject_id": 1,
      "question": "다음 코드에서 변수 `x`의 자료형은?\n\n```javascript\nlet x = \"Hello, world!\";\nconsole.log(typeof x);\n```",
      "option_a": "number",
      "option_b": "string",
      "option_c": "boolean",
      "option_d": "object",
      "correct_answer": "B",
      "explanation": "문자열 `\"Hello, world!\"`는 JavaScript에서 `string` 타입입니다. `typeof`로 확인하면 `\"string\"`이 출력됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T06:15:25.000Z"
    },
    {
      "id": 96,
      "subject_id": 1,
      "question": "아래 중 자바스크립트의 원시 데이터 타입이 아닌 것은?",
      "option_a": "String",
      "option_b": "Boolean",
      "option_c": "Object",
      "option_d": "Number",
      "correct_answer": "C",
      "explanation": "`Object`는 **참조 타입(reference type)**입니다. 나머지는 모두 **원시 타입(primitive type)**입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T06:16:03.000Z"
    },
    {
      "id": 97,
      "subject_id": 1,
      "question": "아래 코드에서 `typeof y`의 결과는?\n\n```javascript\nlet y;\n```",
      "option_a": "\"null\"",
      "option_b": "\"undefined\"",
      "option_c": "\"object\"",
      "option_d": "\"string\"",
      "correct_answer": "B",
      "explanation": "선언만 하고 값을 할당하지 않은 변수의 값은 `undefined`이며, `typeof y`도 `\"undefined\"`가 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T06:17:35.000Z"
    },
    {
      "id": 98,
      "subject_id": 1,
      "question": "다음 코드에서 변수 `x`의 최종 자료형은?\n\n```javascript\nlet x;\nx = 5;\nx = \"John\";\n```",
      "option_a": "undefined",
      "option_b": "number",
      "option_c": "string",
      "option_d": "boolean",
      "correct_answer": "C",
      "explanation": "이 문제에서 핵심은 JavaScript가 동적 타이핑(Dynamic Typing) 언어라는 점입니다. 동적 타이핑이란, 변수를 선언할 때 자료형을 명시하지 않아도 되고, 하나의 변수에 서로 다른 자료형의 값을 자유롭게 할당할 수 있는 특성입니다. 변수 x는 undefined → number → string으로 자료형이 바뀝니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:22:08.000Z"
    },
    {
      "id": 99,
      "subject_id": 1,
      "question": "다음 중 올바른 배열 선언 코드는?",
      "option_a": "`let cars = { \"Saab\", \"Volvo\", \"BMW\" };`",
      "option_b": "`let cars = [ \"Saab\", \"Volvo\", \"BMW\" ];`",
      "option_c": "`let cars = \"Saab\", \"Volvo\", \"BMW\";`",
      "option_d": "`let cars = <\"Saab\", \"Volvo\", \"BMW\">;`",
      "correct_answer": "B",
      "explanation": "배열은 대괄호 [ ]로 선언하며, 요소는 쉼표로 구분합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:22:44.000Z"
    },
    {
      "id": 100,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 16 + \"Volvo\";\nconsole.log(x);\n```",
      "option_a": "\"16Volvo\"",
      "option_b": "16",
      "option_c": "\"Volvo16\"",
      "option_d": "NaN",
      "correct_answer": "A",
      "explanation": "숫자와 문자열을 더하면 JavaScript는 문자열 결합을 수행합니다. → `\"16\" + \"Volvo\"` = `\"16Volvo\"`",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:23:35.000Z"
    },
    {
      "id": 101,
      "subject_id": 1,
      "question": "아래 코드에서 `typeof person`의 결과는?\n\n```javascript\nconst person = {firstName: \"John\", lastName: \"Doe\"};\nconsole.log(typeof person);\n```",
      "option_a": "\"object\"",
      "option_b": "\"array\"",
      "option_c": "\"string\"",
      "option_d": "\"function\"",
      "correct_answer": "A",
      "explanation": "객체 리터럴 `{}`로 생성된 변수는 `typeof`로 검사 시 `\"object\"`가 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:24:36.000Z"
    },
    {
      "id": 102,
      "subject_id": 1,
      "question": "다음 중 `typeof` 연산 결과가 `\"number\"`인 것은?",
      "option_a": "`typeof \"123\"`",
      "option_b": "`typeof true`",
      "option_c": "`typeof 3.14`",
      "option_d": "`typeof {a:1}`",
      "correct_answer": "C",
      "explanation": "JavaScript에서 모든 숫자형(정수, 실수)은 `\"number\"`로 간주됩니다. `3.14`는 실수지만 여전히 number입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:26:41.000Z"
    },
    {
      "id": 103,
      "subject_id": 1,
      "question": "다음 코드에서 변수 `x`의 값은?\n\n```javascript\nlet x = \"Volvo\" + 16 + 4;\n```",
      "option_a": "\"Volvo164\"",
      "option_b": "\"Volvo20\"",
      "option_c": "\"20Volvo\"",
      "option_d": "Error",
      "correct_answer": "A",
      "explanation": "JavaScript는 왼쪽에서 오른쪽으로 평가합니다. `\"Volvo\" + 16` → `\"Volvo16\"`, 그 후 `\"Volvo16\" + 4` → `\"Volvo164\"`",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:28:05.000Z"
    },
    {
      "id": 104,
      "subject_id": 1,
      "question": "다음 중 BigInt에 대한 설명으로 올바른 것은?",
      "option_a": "BigInt는 실수(decimal)를 저장할 수 있다.",
      "option_b": "BigInt는 기존 Number 타입보다 더 작은 정수를 저장한다.",
      "option_c": "BigInt는 `BigInt()` 생성자를 사용하거나 `n` 접미사를 붙여 생성할 수 있다.",
      "option_d": "BigInt는 Boolean과 자동 변환이 가능하다.",
      "correct_answer": "C",
      "explanation": "BigInt는 매우 큰 정수를 저장하기 위한 타입이며, `BigInt(\"123456...\")` 또는 `123456789n` 형식으로 선언합니다. 소수는 허용되지 않습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T06:29:20.000Z"
    },
    {
      "id": 105,
      "subject_id": 1,
      "question": "함수 정의를 위해 사용하는 키워드는 무엇인가요?\n\n```javascript\n______ myFunction(p1, p2) {\n  return p1 * p2;\n}\n```",
      "option_a": "define",
      "option_b": "function",
      "option_c": "method",
      "option_d": "return",
      "correct_answer": "B",
      "explanation": "자바스크립트에서 함수를 정의할 때는 항상 `function` 키워드를 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T06:34:24.000Z"
    },
    {
      "id": 106,
      "subject_id": 1,
      "question": "다음 코드에서 `result`에 저장되는 값은?\n\n```javascript\nfunction multiply(a, b) {\n  return a * b;\n}\nlet result = multiply(4, 3);\n```",
      "option_a": "7",
      "option_b": "12",
      "option_c": "1",
      "option_d": "\"4 * 3\"",
      "correct_answer": "B",
      "explanation": "`multiply(4, 3)`은 4 * 3 = 12를 계산한 결과를 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T06:35:20.000Z"
    },
    {
      "id": 107,
      "subject_id": 1,
      "question": "함수가 실행되도록 만드는 동작은 무엇이라 부르나요?",
      "option_a": "함수 선언 (Declaration)",
      "option_b": "함수 리턴 (Return)",
      "option_c": "함수 호출 (Invocation)",
      "option_d": "함수 반복 (Looping)",
      "correct_answer": "C",
      "explanation": "선언된 함수는 `myFunction()`처럼 호출(invocation) 해야 실행됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T06:36:40.000Z"
    },
    {
      "id": 108,
      "subject_id": 1,
      "question": "다음 중 올바른 함수 선언 형식은?",
      "option_a": "`let x = function() { return; }`",
      "option_b": "`let = function(x, y) return x + y;`",
      "option_c": "`function = myFunction(x, y) { return x + y; }`",
      "option_d": "`myFunction function(x, y) { return x + y; }`",
      "correct_answer": "A",
      "explanation": "함수 표현식은 `let 변수명 = function(...) { ... }` 형식이 맞습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:37:28.000Z"
    },
    {
      "id": 109,
      "subject_id": 1,
      "question": "다음 코드에서 `value`의 결과는?\n\n```javascript\nfunction toCelsius(fahrenheit) {\n  return (5/9) * (fahrenheit - 32);\n}\nlet value = toCelsius(); // 인자 없음\n```",
      "option_a": "0",
      "option_b": "NaN",
      "option_c": "undefined",
      "option_d": "\"Fahrenheit\"",
      "correct_answer": "B",
      "explanation": "인자 없이 호출된 함수는 `fahrenheit`가 `undefined`가 되고, `undefined - 32`는 **숫자와 정의되지 않은 값(undefined)**의 연산이므로, 자바스크립트는 계산할 수 없고 그 결과는 **NaN (Not a Number)**입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T06:40:27.000Z"
    },
    {
      "id": 110,
      "subject_id": 1,
      "question": "아래 코드의 결과는?\n\n```javascript\nfunction toCelsius(f) {\n  return (5/9) * (f - 32);\n}\nlet value = toCelsius;\nconsole.log(value);\n```",
      "option_a": "함수 반환값",
      "option_b": "NaN",
      "option_c": "함수 그 자체",
      "option_d": "에러",
      "correct_answer": "C",
      "explanation": "`toCelsius`는 괄호 없이 접근하면 함수 객체 그 자체를 참조하게 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:41:17.000Z"
    },
    {
      "id": 111,
      "subject_id": 1,
      "question": "아래 코드에서 `greet` 함수 호출의 출력 결과는?\n\n```javascript\nfunction greet(name, age) {\n  return `Hello ${name}! You are ${age} years old.`;\n}\nconsole.log(greet(\"John\", 21));\n```",
      "option_a": "Hello name! You are age years old.",
      "option_b": "Hello ${name}! You are ${age} years old.",
      "option_c": "Hello John! You are 21 years old.",
      "option_d": "SyntaxError",
      "correct_answer": "C",
      "explanation": "백틱(&#96;)과 `${}`를 이용하면 변수 값이 문자열에 삽입됩니다. 이를 템플릿 리터럴이라 부릅니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:43:16.000Z"
    },
    {
      "id": 112,
      "subject_id": 1,
      "question": "아래에서 `carName`을 사용할 수 있는 위치는?\n\n```javascript\nfunction myFunction() {\n  let carName = \"Volvo\";\n  // 이 위치에서 carName 사용 가능\n}\n// 이 위치에서 carName 사용 가능?\n```",
      "option_a": "함수 안에서만",
      "option_b": "함수 밖에서도 가능",
      "option_c": "어디서나 가능",
      "option_d": "전혀 사용할 수 없음",
      "correct_answer": "A",
      "explanation": "`let`으로 선언된 변수는 블록 스코프를 가지므로 함수 내부에서만 유효합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T06:45:16.000Z"
    },
    {
      "id": 113,
      "subject_id": 1,
      "question": "화살표 함수(Arrow Function)의 문법으로 올바른 것은?",
      "option_a": "`let x = => (a, b) a * b;`",
      "option_b": "`let x = (a, b) => { a * b };`",
      "option_c": "`let x = (a, b) => a * b;`",
      "option_d": "`let x = function => (a, b) * a b;`",
      "correct_answer": "C",
      "explanation": "간단한 로직일 경우 중괄호 없이 `let x = (a, b) => a * b;` 형식으로 작성할 수 있습니다. 중괄호를 쓸 경우, return을 명시해야 합니다. `let x = (a, b) => { return a + b; };`",
      "difficulty": "medium",
      "created_at": "2025-08-05T06:48:33.000Z"
    },
    {
      "id": 114,
      "subject_id": 1,
      "question": "함수에서 `parameter`와 `argument`의 차이를 올바르게 설명한 것은?",
      "option_a": "둘 다 같은 의미이다.",
      "option_b": "parameter는 실행 시 전달되는 값이다.",
      "option_c": "argument는 함수 내부에서 사용하는 이름이다.",
      "option_d": "parameter는 정의할 때 사용하는 이름, argument는 호출 시 전달하는 값이다.",
      "correct_answer": "D",
      "explanation": "parameter는 함수 선언 시 괄호 안의 변수들 (function add(x, y))이며, argument는 실제 함수 호출 시 넣는 값 (add(3, 5)에서 3, 5) 입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T06:50:06.000Z"
    },
    {
      "id": 115,
      "subject_id": 1,
      "question": "다음 중 JavaScript에서 객체를 정의하는 올바른 방법은?",
      "option_a": "`let car = \"Fiat\";`",
      "option_b": "`let car = {type: \"Fiat\", model: \"500\", color: \"white\"};`",
      "option_c": "`let car = [ \"Fiat\", \"500\", \"white\" ];`",
      "option_d": "`let car = new Array(\"Fiat\", \"500\", \"white\");`",
      "correct_answer": "B",
      "explanation": "`{}`안에 `key: value` 쌍을 나열하여 정의하는 것을 객체 리터럴이라고 합니다. 배열이나 문자열은 객체가 아닙니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T06:59:41.000Z"
    },
    {
      "id": 116,
      "subject_id": 1,
      "question": "객체의 속성에 접근하는 올바른 방법은?\n\n```javascript\nconst person = {firstName: \"John\", lastName: \"Doe\"};\n```",
      "option_a": "`person.firstName`",
      "option_b": "`person[\"firstName\"]`",
      "option_c": "`person(firstName)`",
      "option_d": "a, b 모두 맞다",
      "correct_answer": "D",
      "explanation": "객체 속성은 `.` 또는 `[]` 표기법으로 접근할 수 있습니다. 두 방식 모두 자주 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T07:00:50.000Z"
    },
    {
      "id": 117,
      "subject_id": 1,
      "question": "다음 중 객체의 메서드(method) 정의 방식으로 올바른 것은?",
      "option_a": "`drive: () => \"Driving\"`",
      "option_b": "`drive: \"Driving\"`",
      "option_c": "`drive = function() \"Driving\"`",
      "option_d": "`drive() => { return \"Driving\" }`",
      "correct_answer": "A",
      "explanation": "객체의 메서드는 속성 값으로 함수를 넣는 방식입니다. `drive: function() { ... }` 또는 `drive: () => ...` 모두 가능합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T07:02:29.000Z"
    },
    {
      "id": 118,
      "subject_id": 1,
      "question": "빈칸에 들어갈 알맞은 코드는?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  fullName: function() {\n    return _____ + \" \" + _____;\n  }\n};\n```",
      "option_a": "`this.firstName`, `this.lastName`",
      "option_b": "`person.firstName`, `person.lastName`",
      "option_c": "`firstName`, `lastName`",
      "option_d": "`fullName`, `fullName`",
      "correct_answer": "A",
      "explanation": "객체 내부에서 자신의 속성에 접근할 때는 `this` 키워드를 사용합니다. `this.firstName`은 해당 객체의 `firstName` 속성을 참조합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:06:19.000Z"
    },
    {
      "id": 119,
      "subject_id": 1,
      "question": "다음 중 객체를 빈 객체로 먼저 생성한 후, 속성을 추가하는 코드는?",
      "option_a": "`const person = {firstName: \"John\"};`",
      "option_b": "`const person = new Object(); person.firstName = \"John\";`",
      "option_c": "`const person = Object(); firstName = \"John\";`",
      "option_d": "`let person = [firstName = \"John\"];`",
      "correct_answer": "B",
      "explanation": "`new Object()`로 빈 객체를 생성하고, 이후 속성을 `person.속성명 = 값`으로 추가할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:07:10.000Z"
    },
    {
      "id": 120,
      "subject_id": 1,
      "question": "다음 코드의 출력 결과는?\n\n```javascript\nconst person = {firstName: \"John\", age: 50};\nconst x = person;\nx.age = 10;\nconsole.log(person.age);\n```",
      "option_a": "`10`",
      "option_b": "`50`",
      "option_c": "`undefined`",
      "option_d": "`Error`",
      "correct_answer": "A",
      "explanation": "객체는 **참조 타입(reference type)**이므로, `x = person`은 복사된 것이 아니라 같은 객체를 가리킴.\n따라서 `x.age = 10`은 `person.age`에도 영향을 줍니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:08:28.000Z"
    },
    {
      "id": 121,
      "subject_id": 1,
      "question": "아래 코드에서 `person[\"eyeColor\"]`와 동일한 결과를 내는 접근 방식은?\n\n```javascript\nconst person = {eyeColor: \"blue\"};\n```",
      "option_a": "`person.eyeColor`",
      "option_b": "`person->eyeColor`",
      "option_c": "`person(eyeColor)`",
      "option_d": "`eyeColor.person`",
      "correct_answer": "A",
      "explanation": "객체 속성 접근은 `객체명.속성명` 또는 `객체명[\"속성명\"]`을 사용합니다. C언어처럼 `->`는 사용하지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:09:48.000Z"
    },
    {
      "id": 122,
      "subject_id": 1,
      "question": "다음 중 JavaScript에서 객체 리터럴 방식으로 객체를 만드는 코드는?",
      "option_a": "`const car = new Object(\"Fiat\");`",
      "option_b": "`const car = {type: \"Fiat\", model: \"500\"};`",
      "option_c": "`const car = Object.create(\"Fiat\");`",
      "option_d": "`const car = Object.type(\"Fiat\", \"500\");`",
      "correct_answer": "B",
      "explanation": "`{ ... }` 형태로 key-value 쌍을 나열하는 것이 object literal 방식입니다. 가장 많이 쓰이는 방식입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:10:30.000Z"
    },
    {
      "id": 123,
      "subject_id": 1,
      "question": "다음 코드에서 `fullName()` 함수가 반환하는 값은?\n\n```javascript\nconst person = {\n  firstName: \"Jane\",\n  lastName: \"Smith\",\n  fullName: function() {\n    return this.firstName + \" \" + this.lastName;\n  }\n};\nconsole.log(person.fullName());\n```",
      "option_a": "`JaneSmith`",
      "option_b": "`this.firstName this.lastName`",
      "option_c": "`Jane Smith`",
      "option_d": "`undefined undefined`",
      "correct_answer": "C",
      "explanation": "`this.firstName`은 `\"Jane\"`, `this.lastName`은 `\"Smith\"` → 문자열 결합 결과 `\"Jane Smith\"`",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:12:03.000Z"
    },
    {
      "id": 124,
      "subject_id": 1,
      "question": "다음 중 JavaScript 객체에 대한 설명으로 틀린 것은?",
      "option_a": "객체의 속성은 키-값 쌍으로 구성된다.",
      "option_b": "객체는 배열이나 문자열과 달리 메서드를 가질 수 없다.",
      "option_c": "객체는 참조에 의해 전달된다.",
      "option_d": "객체의 속성 값으로 함수도 포함될 수 있다.",
      "correct_answer": "B",
      "explanation": "객체는 **메서드(함수 속성)**를 가질 수 있습니다. 실제로 자바스크립트 객체는 속성뿐만 아니라 동작(메서드)도 정의할 수 있어 매우 유연합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T07:12:48.000Z"
    },
    {
      "id": 125,
      "subject_id": 1,
      "question": "객체의 속성에 접근하는 올바른 방법은?\n\n```javascript\nconst person = { name: \"Alice\", age: 30 };\nconsole.log(_________);\n```",
      "option_a": "`person.age()`",
      "option_b": "`person[age]`",
      "option_c": "`person[\"age\"]`",
      "option_d": "`person->age`",
      "correct_answer": "C",
      "explanation": "속성 접근은 `person[\"age\"]` 또는 `person.age` 형태로 할 수 있습니다. 단, `\" \"` 없이 `person[age]`라고 하면 변수 `age`를 찾게 되므로 오류가 납니다. ",
      "difficulty": "easy",
      "created_at": "2025-08-05T07:22:14.000Z"
    },
    {
      "id": 126,
      "subject_id": 1,
      "question": "다음 코드의 결과는?\n\n```javascript\nconst person = { name: \"Tom\", age: 25 };\nlet prop = \"name\";\nconsole.log(person[prop]);\n```",
      "option_a": "`\"prop\"`",
      "option_b": "`\"name\"`",
      "option_c": "`\"Tom\"`",
      "option_d": "`undefined`",
      "correct_answer": "C",
      "explanation": "대괄호 `[]` 안에 변수명을 넣으면 해당 변수의 값이 속성 이름으로 사용됩니다. 여기서는 `person[\"name\"]`과 동일하므로 결과는 `\"Tom\"`입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T07:23:36.000Z"
    },
    {
      "id": 127,
      "subject_id": 1,
      "question": "다음 중 객체에 새로운 속성을 추가하는 코드로 올바른 것은?\n\n```javascript\nconst person = { name: \"Lisa\" };\n```",
      "option_a": "`addProperty(person, \"age\", 20);`",
      "option_b": "`person.age = 20;`",
      "option_c": "`append(person, \"age\", 20);`",
      "option_d": "`person(\"age\") = 20;`",
      "correct_answer": "B",
      "explanation": "객체에 새 속성을 추가하려면 `객체.속성 = 값` 방식으로 간단히 추가할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T07:24:20.000Z"
    },
    {
      "id": 128,
      "subject_id": 1,
      "question": "다음 코드 실행 후 `person.age`의 값은?\n\n```javascript\nconst person = { name: \"Anna\", age: 40 };\ndelete person.age;\n```",
      "option_a": "`null`",
      "option_b": "`\"\"`",
      "option_c": "`undefined`",
      "option_d": "`40`",
      "correct_answer": "C",
      "explanation": "`delete` 키워드를 사용하면 해당 속성 자체가 삭제됩니다. 따라서 이후 `person.age`는 존재하지 않아 `undefined`가 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:25:22.000Z"
    },
    {
      "id": 129,
      "subject_id": 1,
      "question": "다음 중 `delete` 키워드에 대한 설명으로 올바른 것은?",
      "option_a": "속성의 값을 null로 만든다.",
      "option_b": "속성의 이름만 삭제하고 값은 남긴다.",
      "option_c": "속성과 값을 모두 제거한다.",
      "option_d": "변수 전체를 삭제한다.",
      "correct_answer": "C",
      "explanation": "`delete 객체.속성`은 속성과 값 모두를 완전히 제거합니다. 변수 자체를 삭제하지는 않으며, 이후 접근하면 `undefined`가 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:27:36.000Z"
    },
    {
      "id": 130,
      "subject_id": 1,
      "question": "다음 중 객체의 중첩 속성(nested property)을 접근하는 올바른 방식은?\n\n```javascript\nconst obj = {\n  profile: {\n    name: \"Sara\",\n    age: 22\n  }\n};\n```",
      "option_a": "`obj[\"name\"]`",
      "option_b": "`obj.profile.name`",
      "option_c": "`obj.name.profile`",
      "option_d": "`obj->profile->name`",
      "correct_answer": "B",
      "explanation": "중첩된 객체 접근은 점(.) 또는 대괄호([]) 표기법을 반복하여 사용합니다. 여기선 `profile` 속성 안의 `name`이므로 `obj.profile.name`이 맞습니다.\n\n",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:28:36.000Z"
    },
    {
      "id": 131,
      "subject_id": 1,
      "question": "다음 코드의 결과는?\n\n```javascript\nconst person = { name: \"Leo\", age: 33 };\nlet x = \"name\";\nlet y = \"age\";\nconsole.log(person[x] + \" is \" + person[y] + \" years old.\");\n```",
      "option_a": "`name is age years old.`",
      "option_b": "`Leo is 33 years old.`",
      "option_c": "`undefined is undefined years old.`",
      "option_d": "`\"name\" is \"age\" years old.`",
      "correct_answer": "B",
      "explanation": "person[x] → person[\"name\"] = \"Leo\", person[y] → person[\"age\"] = 33, 결과는 \"Leo is 33 years old.\"입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T07:29:35.000Z"
    },
    {
      "id": 132,
      "subject_id": 1,
      "question": "다음 중 **객체 생성자(Constructor)**를 사용하는 예는?\n\n```javascript\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n```",
      "option_a": "`let p = Person(\"Tom\", 30);`",
      "option_b": "`let p = new Person(\"Tom\", 30);`",
      "option_c": "`let p = make Person(\"Tom\", 30);`",
      "option_d": "`let p = Person.new(\"Tom\", 30);`",
      "correct_answer": "B",
      "explanation": "생성자 함수는 `new` 키워드를 통해 호출해야 새 객체가 생성됩니다. `new Person(...)`이 정확한 사용법입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:30:42.000Z"
    },
    {
      "id": 133,
      "subject_id": 1,
      "question": "다음 코드 실행 후 출력 결과는?\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n  this.nationality = \"Korean\";\n}\nconst user = new Person(\"Yuna\");\nconsole.log(user.nationality);\n```",
      "option_a": "`undefined`",
      "option_b": "`Korean`",
      "option_c": "`Yuna`",
      "option_d": "`null`",
      "correct_answer": "B",
      "explanation": "생성자 함수 내부에서 `this.nationality = \"Korean\"`으로 설정되어 있으므로 `user` 객체의 `nationality`는 `\"Korean\"`입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:32:04.000Z"
    },
    {
      "id": 134,
      "subject_id": 1,
      "question": "다음 코드의 출력 결과는?\n\n```javascript\nconst obj = {\n  info: {\n    email: \"test@example.com\"\n  }\n};\nlet a = \"info\";\nlet b = \"email\";\nconsole.log(obj[a][b]);\n```",
      "option_a": "`undefined`",
      "option_b": "`\"email\"`",
      "option_c": "`\"info.email\"`",
      "option_d": "`\"test@example.com\"`",
      "correct_answer": "D",
      "explanation": "`obj[a]`는 `obj[\"info\"]`, 그 안의 `[b]`는 `[\"email\"]` → `\"test@example.com\"`을 정확히 참조합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:33:07.000Z"
    },
    {
      "id": 135,
      "subject_id": 1,
      "question": "다음 중 **자바스크립트에서 메서드(method)**에 대한 설명으로 올바른 것은?",
      "option_a": "객체 외부에서만 정의할 수 있는 함수",
      "option_b": "객체의 속성으로 저장된 함수",
      "option_c": "객체 안의 문자열 속성\n",
      "option_d": "DOM 요소에만 적용되는 특수 함수",
      "correct_answer": "B",
      "explanation": "메서드는 객체의 속성으로 저장된 함수입니다.\n\n```javascript\nconst person = {\n  fullName: function() { return \"John Doe\"; }\n};\n```",
      "difficulty": "easy",
      "created_at": "2025-08-05T07:36:52.000Z"
    },
    {
      "id": 136,
      "subject_id": 1,
      "question": "다음 코드에서 메서드 호출로 올바른 것은?\n\n```javascript\nconst person = {\n  name: function() {\n    return \"Alice\";\n  }\n};\nconsole.log(__________);\n```",
      "option_a": "`person.name`",
      "option_b": "`person.name[]`",
      "option_c": "`person.name()`",
      "option_d": "`name.person()`",
      "correct_answer": "C",
      "explanation": "메서드를 실행하려면 반드시 **괄호 `()`**를 붙여야 합니다. `person.name()` → 함수 호출, `person.name` → 함수 정의만 가져옵니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T07:38:58.000Z"
    },
    {
      "id": 137,
      "subject_id": 1,
      "question": "아래 코드에서 `this.firstName`의 의미는?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  fullName: function() {\n    return this.firstName;\n  }\n};\n```",
      "option_a": "전역 변수 `firstName`",
      "option_b": "메서드의 지역 변수",
      "option_c": "`person` 객체의 `firstName` 속성",
      "option_d": "함수 이름",
      "correct_answer": "C",
      "explanation": "객체 내부에서 `this`는 해당 객체를 가리킵니다. 따라서 `this.firstName`은 `person.firstName`과 동일합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T07:40:19.000Z"
    },
    {
      "id": 138,
      "subject_id": 1,
      "question": "다음 중 메서드의 반환값이 대문자 문자열이 되는 코드는?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  name: function() {\n    return (this.firstName + \" \" + this.lastName).__________;\n  }\n};\n```",
      "option_a": "`join()`",
      "option_b": "`capitalize()`",
      "option_c": "`toUpperCase()`",
      "option_d": "`makeUpper()`",
      "correct_answer": "C",
      "explanation": "`toUpperCase()`는 문자열을 전부 대문자로 변환하는 문자열 메서드입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:41:09.000Z"
    },
    {
      "id": 139,
      "subject_id": 1,
      "question": "다음 코드 실행 결과는?\n\n```javascript\nconst person = {\n  firstName: \"Jane\",\n  lastName: \"Lee\",\n  fullName: function() {\n    return this.firstName + \" \" + this.lastName;\n  }\n};\nconst result = person.fullName;\nconsole.log(typeof result);\n```",
      "option_a": "`\"object\"`",
      "option_b": "`\"string\"`",
      "option_c": "`\"function\"`",
      "option_d": "`\"undefined\"`",
      "correct_answer": "C",
      "explanation": "`person.fullName`은 괄호 없이 접근했기 때문에 함수 그 자체를 가져온 것이고, `typeof`로 확인하면 `\"function\"`이 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:42:13.000Z"
    },
    {
      "id": 140,
      "subject_id": 1,
      "question": "다음 중 객체에 새로운 메서드를 추가하는 올바른 방식은?\n\n```javascript\nconst user = {\n  name: \"Alex\"\n};\n___________\n```",
      "option_a": "`user.age = function() { return 30; };`",
      "option_b": "`addMethod(user, \"age\", 30);`",
      "option_c": "`user.method(\"age\", function() { return 30; });`",
      "option_d": "`user = function age() { return 30; };`",
      "correct_answer": "A",
      "explanation": "메서드는 객체에 속성으로 함수를 할당하는 방식으로 추가할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:43:01.000Z"
    },
    {
      "id": 141,
      "subject_id": 1,
      "question": "다음 코드의 출력 결과는?\n\n```javascript\nconst person = {\n  firstName: \"Tom\",\n  lastName: \"Kim\",\n  fullName: function() {\n    return this.firstName + \" \" + this.lastName;\n  }\n};\nconst name = person.fullName();\nconsole.log(name);\n```",
      "option_a": "`Tom Kim`",
      "option_b": "`firstName lastName`",
      "option_c": "`undefined undefined`",
      "option_d": "`function() { return this.firstName + \" \" + this.lastName; }`",
      "correct_answer": "A",
      "explanation": "메서드가 호출되며 `this`는 `person` 객체를 가리킴 → `\"Tom Kim\"` 반환",
      "difficulty": "medium",
      "created_at": "2025-08-05T07:43:58.000Z"
    },
    {
      "id": 142,
      "subject_id": 1,
      "question": "다음 중 메서드를 호출하지 않고 접근만 했을 때 반환되는 것은?\n\n```javascript\nconst user = {\n  greet: function() {\n    return \"Hello!\";\n  }\n};\nconsole.log(user.greet);\n```",
      "option_a": "`\"Hello!\"`",
      "option_b": "`undefined`",
      "option_c": "`function definition`",
      "option_d": "`true`",
      "correct_answer": "C",
      "explanation": "괄호 없이 `user.greet`라고만 하면 함수는 실행되지 않고 **함수 자체(정의)**가 반환됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T07:44:57.000Z"
    },
    {
      "id": 143,
      "subject_id": 1,
      "question": "다음 코드에서 `\"My father is JOHN DOE\"`가 출력되도록 하는 코드는?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\"\n};\nperson.name = function() {\n  return ___________________;\n};\nconsole.log(\"My father is \" + person.name());\n```",
      "option_a": "`this.firstName.toUpperCase + \" \" + this.lastName.toUpperCase`",
      "option_b": "`this.firstName + \" \" + this.lastName`",
      "option_c": "`(this.firstName + \" \" + this.lastName).toUpperCase()`",
      "option_d": "`toUpperCase(this.firstName + \" \" + this.lastName)`",
      "correct_answer": "C",
      "explanation": "전체 문자열을 합친 후에 `toUpperCase()`를 적용해야 `\"JOHN DOE\"`로 변환됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T07:46:03.000Z"
    },
    {
      "id": 144,
      "subject_id": 1,
      "question": "다음 중 this 키워드에 대한 설명으로 옳지 않은 것은?",
      "option_a": "객체 메서드 내에서 `this`는 해당 객체를 가리킨다.",
      "option_b": "전역 범위에서 `this`는 `window`를 참조한다 (브라우저 기준).",
      "option_c": "메서드가 아닌 일반 함수에서 `this`는 항상 정의되지 않는다.",
      "option_d": "`this`는 컨텍스트에 따라 가리키는 대상이 달라진다.",
      "correct_answer": "C",
      "explanation": "일반 함수에서 `this`는 엄격 모드 여부와 호출 방식에 따라 달라지며, “항상 정의되지 않는다”는 설명은 잘못된 일반화입니다.\n\n",
      "difficulty": "hard",
      "created_at": "2025-08-05T07:47:25.000Z"
    },
    {
      "id": 145,
      "subject_id": 1,
      "question": "다음 코드의 출력 결과는?\n\n```javascript\nconst person = { name: \"John\", age: 30, city: \"New York\" };\ndocument.getElementById(\"demo\").innerHTML = person;\n```",
      "option_a": "`\"John 30 New York\"`",
      "option_b": "`\"person\"`",
      "option_c": "`\"[object Object]\"`",
      "option_d": "`undefined`",
      "correct_answer": "C",
      "explanation": "객체 전체를 직접 출력하면 `\"[object Object]\"`라는 문자열이 표시됩니다. 객체를 문자열로 자동 변환하려고 시도한 결과입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T08:49:51.000Z"
    },
    {
      "id": 146,
      "subject_id": 1,
      "question": "객체의 속성을 직접 출력하려면 어떻게 해야 하나요?\n\n```javascript\nconst person = { name: \"John\", age: 30, city: \"New York\" };\ndocument.getElementById(\"demo\").innerHTML = ____________;\n```",
      "option_a": "`person`",
      "option_b": "`person[\"John\"]`",
      "option_c": "`person.name + \", \" + person.age + \", \" + person.city`",
      "option_d": "`JSON.stringify(\"person\")`",
      "correct_answer": "C",
      "explanation": "객체의 각 속성을 직접 접근하여 연결하면 `\"John, 30, New York\"` 같은 형식으로 출력됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T08:51:07.000Z"
    },
    {
      "id": 147,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 알맞은 것은?\n\n```javascript\nlet text = \"\";\nfor (let x in person) {\n  text += __________ + \" \";\n}\n```",
      "option_a": "`person.x`",
      "option_b": "`x.person`",
      "option_c": "`person[x]`",
      "option_d": "`person[\"x\"]`",
      "correct_answer": "C",
      "explanation": "`for...in` 루프에서 `x`는 속성 이름이고, `person[x]`으로 그 값을 참조할 수 있습니다. `person.x`는 실제 속성명이 `\"x\"`일 때만 동작하므로 틀립니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T08:53:26.000Z"
    },
    {
      "id": 148,
      "subject_id": 1,
      "question": "다음 코드 실행 결과는?\n\n```javascript\nconst person = { name: \"John\", age: 30, city: \"New York\" };\nconst arr = Object.values(person);\nconsole.log(arr);\n```",
      "option_a": "`[\"name\", \"age\", \"city\"]`",
      "option_b": "`\"John,30,New York\"`",
      "option_c": "`[\"John\", 30, \"New York\"]`",
      "option_d": "`undefined`",
      "correct_answer": "C",
      "explanation": "`Object.values()`는 객체의 값들만을 배열로 추출합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T09:22:31.000Z"
    },
    {
      "id": 149,
      "subject_id": 1,
      "question": "다음 중 `Object.entries()`의 결과는?\n\n```javascript\nconst car = { brand: \"Toyota\", year: 2020 };\nconsole.log(Object.entries(car));\n```",
      "option_a": "`[[\"brand\", \"Toyota\"], [\"year\", 2020]]`",
      "option_b": "`[\"Toyota\", 2020]`",
      "option_c": "`[\"brand: Toyota\", \"year: 2020\"]`",
      "option_d": "`undefined`",
      "correct_answer": "A",
      "explanation": "`Object.entries()`는 `[key, value]` 형태의 쌍들을 이차원 배열로 반환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T09:23:37.000Z"
    },
    {
      "id": 150,
      "subject_id": 1,
      "question": "다음 중 객체를 문자열로 바꾸는 메서드는?",
      "option_a": "`object.toText()`",
      "option_b": "`JSON.stringify()`",
      "option_c": "`Object.print()`",
      "option_d": "`String.object()`",
      "correct_answer": "B",
      "explanation": "`JSON.stringify()`는 객체를 JSON 형식의 문자열로 변환합니다. 예: `{ name: \"John\" }` → `\"{\"name\":\"John\"}\"`\n\n",
      "difficulty": "medium",
      "created_at": "2025-08-05T09:25:00.000Z"
    },
    {
      "id": 151,
      "subject_id": 1,
      "question": "`JSON.stringify()`의 출력 결과는?\n\n```javascript\nconst person = { name: \"John\", age: 30, city: \"New York\" };\nconsole.log(JSON.stringify(person));\n```",
      "option_a": "`\"[object Object]\"`",
      "option_b": "`[\"John\", 30, \"New York\"]`",
      "option_c": "`\"{name: 'John', age: 30, city: 'New York'}\"`",
      "option_d": "`{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}`",
      "correct_answer": "D",
      "explanation": "`JSON.stringify()`는 객체를 JSON 표기법에 맞게 문자열로 변환합니다. 속성명과 문자열 값 모두 **큰따옴표(\")**로 감싸는 것이 특징입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T09:26:03.000Z"
    },
    {
      "id": 152,
      "subject_id": 1,
      "question": "`Object.entries()`를 사용해 다음 결과를 얻기 위한 코드는?\n\n출력:\n```makefile\nBananas: 300  \nOranges: 200  \nApples: 500\n```",
      "option_a": "```javascript\nObject.entries(fruits).map((k, v) => console.log(k + \": \" + v));\n```",
      "option_b": "```javascript\nfor (let fruit in fruits) {\n  console.log(fruit + \": \" + fruits[fruit]);\n}\n```",
      "option_c": "```javascript\nfor (let [fruit, value] of Object.entries(fruits)) {\n  console.log(fruit + \": \" + value);\n}\n```",
      "option_d": "```javascript\nObject.keys(fruits).forEach(fruit => console.log(fruit));\n```",
      "correct_answer": "C",
      "explanation": "`for...of` 루프에서 `Object.entries()`를 구조분해 `[key, value]`로 받아 사용하면 키-값 쌍을 출력하기 편리합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T09:29:09.000Z"
    },
    {
      "id": 153,
      "subject_id": 1,
      "question": "다음 코드의 최종 출력값은?\n\n```javascript\nconst person = { name: \"Jane\", age: 28, city: \"Seoul\" };\nlet text = \"\";\nfor (let x in person) {\n  text += person[x] + \" \";\n}\nconsole.log(text.trim());\n```",
      "option_a": "`Jane 28 Seoul`",
      "option_b": "`[\"Jane\", 28, \"Seoul\"]`",
      "option_c": "`{ name: \"Jane\", age: 28, city: \"Seoul\" }`",
      "option_d": "`undefined`",
      "correct_answer": "A",
      "explanation": "`for...in` 루프로 각 속성 값을 이어 붙인 후, 끝의 공백을 제거하기 위해 `trim()` 사용하며, 결과는 문자열 `\"Jane 28 Seoul\"`입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T09:30:46.000Z"
    },
    {
      "id": 154,
      "subject_id": 1,
      "question": "다음 중 객체 전체를 HTML에 출력했을 때 `[object Object]`가 나오는 이유는?",
      "option_a": "객체는 기본적으로 문자열로 변환되지 않기 때문",
      "option_b": "객체가 배열로 출력되기 때문",
      "option_c": "객체의 기본 출력 형식이 `[object Object]`이기 때문",
      "option_d": "HTML에서는 객체를 지원하지 않기 때문",
      "correct_answer": "C",
      "explanation": "자바스크립트에서 객체를 HTML에 그대로 출력하면 `[object Object]`가 나오는 이유는, 객체가 문자열로 변환될 때 기본적으로 `toString()` 메서드가 호출되며 그 결과가 바로 `[object Object]`이기 때문입니다. 해결책은 `JSON.stringify()` 또는 속성값을 직접 꺼내서 출력하는 것입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T09:35:40.000Z"
    },
    {
      "id": 155,
      "subject_id": 1,
      "question": "HTML 이벤트란 무엇인가요?",
      "option_a": "HTML 태그의 스타일을 변경하는 것",
      "option_b": "HTML 요소에 발생하는 \"일\"들",
      "option_c": "JavaScript 함수를 정의하는 것",
      "option_d": "CSS를 HTML에 연결하는 것",
      "correct_answer": "B",
      "explanation": "HTML 이벤트는 HTML 요소에 발생하는 \"일\"들을 의미합니다. 예를 들어 웹페이지가 로딩 완료되거나, 사용자가 버튼을 클릭하거나, 입력 필드의 값이 변경되는 것 등이 모두 HTML 이벤트입니다. 이런 이벤트가 발생했을 때 JavaScript로 특정 동작을 수행할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T09:41:05.000Z"
    },
    {
      "id": 156,
      "subject_id": 1,
      "question": "다음 중 HTML 이벤트의 예시가 아닌 것은?",
      "option_a": "HTML 웹페이지 로딩 완료",
      "option_b": "HTML 입력 필드 값 변경",
      "option_c": "HTML 태그 작성",
      "option_d": "HTML 버튼 클릭",
      "correct_answer": "C",
      "explanation": "HTML 태그 작성은 개발자가 코드를 작성하는 행위로, 브라우저나 사용자에 의해 발생하는 이벤트가 아닙니다. 나머지는 모두 브라우저나 사용자의 동작으로 인해 발생하는 실제 HTML 이벤트들입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T09:42:01.000Z"
    },
    {
      "id": 157,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 이벤트 속성명은?\n\n```html\n<button _____=\"alert('Hello!')\">클릭하세요</button>\n```",
      "option_a": "onpress",
      "option_b": "onclick",
      "option_c": "ontouch",
      "option_d": "onhit",
      "correct_answer": "B",
      "explanation": "버튼이 클릭되었을 때 발생하는 이벤트는 `onclick`입니다. 사용자가 HTML 요소를 클릭했을 때 JavaScript 코드를 실행하려면 onclick 속성을 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T09:43:21.000Z"
    },
    {
      "id": 158,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```html\n<button onclick=\"this.innerHTML = '완료!'\">시작</button>\n```",
      "option_a": "버튼을 클릭하면 페이지에 '완료!'가 새로 표시됨",
      "option_b": "버튼을 클릭하면 버튼의 텍스트가 '완료!'로 변경됨",
      "option_c": "버튼을 클릭해도 아무 변화 없음",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "`this.innerHTML`에서 `this`는 이벤트가 발생한 요소(여기서는 버튼) 자신을 가리킵니다. 따라서 버튼을 클릭하면 버튼의 내용(innerHTML)이 '완료!'로 변경되어 버튼에 표시되는 텍스트가 '시작'에서 '완료!'로 바뀝니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T09:44:45.000Z"
    },
    {
      "id": 159,
      "subject_id": 1,
      "question": "다음 중 마우스 관련 이벤트가 아닌 것은?",
      "option_a": "onmouseover",
      "option_b": "onmouseout",
      "option_c": "onkeydown",
      "option_d": "onclick",
      "correct_answer": "C",
      "explanation": "`onkeydown`은 키보드 관련 이벤트로, 사용자가 키보드의 키를 눌렀을 때 발생합니다. 나머지는 모두 마우스 관련 이벤트들입니다. `onmouseover`는 마우스가 요소 위로 올라갔을 때, `onmouseout`은 마우스가 요소에서 벗어났을 때, `onclick`은 마우스로 클릭했을 때 발생합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T09:45:41.000Z"
    },
    {
      "id": 160,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 코드는?\n\n```html\n<button onclick=\"document.getElementById('demo')._____ = Date()\">\n시간 표시\n</button>\n<p id=\"demo\"></p>\n```",
      "option_a": "value",
      "option_b": "innerHTML",
      "option_c": "text",
      "option_d": "content",
      "correct_answer": "B",
      "explanation": "HTML 요소의 내용을 변경하려면 `innerHTML` 속성을 사용합니다. `Date()` 함수의 결과를 id가 'demo'인 요소의 내용으로 설정하여 현재 날짜와 시간을 표시하게 됩니다. `value`는 주로 input 요소에서 사용되고, `text`와 `content`는 유효한 DOM 속성이 아닙니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T09:48:16.000Z"
    },
    {
      "id": 161,
      "subject_id": 1,
      "question": "이벤트 속성에서 JavaScript 코드를 작성할 때 사용할 수 있는 따옴표는?",
      "option_a": "작은따옴표만 가능",
      "option_b": "큰따옴표만 가능",
      "option_c": "작은따옴표와 큰따옴표 모두 가능",
      "option_d": "따옴표 없이만 가능",
      "correct_answer": "C",
      "explanation": "HTML 이벤트 속성에서는 작은따옴표(')와 큰따옴표(\") 모두 사용할 수 있습니다. 예: `<element onclick='some JavaScript'>` 또는 `<element onclick=\"some JavaScript\">`. 다만 HTML 속성 값을 감싸는 따옴표와 JavaScript 코드 내부의 따옴표가 겹치지 않도록 주의해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T09:49:55.000Z"
    },
    {
      "id": 162,
      "subject_id": 1,
      "question": "다음 코드에서 버튼을 클릭했을 때의 동작을 설명한 것으로 올바른 것은?\n\n```html\n<button onclick=\"displayDate()\">날짜 표시</button>\n<script>\nfunction displayDate() {\n    document.getElementById(\"result\").innerHTML = Date();\n}\n</script>\n<p id=\"result\"></p>\n```",
      "option_a": "버튼 텍스트가 현재 날짜로 변경됨",
      "option_b": "id가 \"result\"인 요소에 현재 날짜가 표시됨",
      "option_c": "새 창에 현재 날짜가 표시됨",
      "option_d": "에러가 발생함",
      "correct_answer": "B",
      "explanation": "버튼을 클릭하면 `displayDate()` 함수가 호출되고, 이 함수는 `document.getElementById(\"result\")`로 id가 \"result\"인 요소(여기서는 `<p>` 태그)를 찾아 그 요소의 innerHTML을 `Date()` 함수의 결과로 설정합니다. 따라서 `<p id=\"result\"></p>` 요소에 현재 날짜와 시간이 표시됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T09:51:34.000Z"
    },
    {
      "id": 163,
      "subject_id": 1,
      "question": "다음 중 페이지 로딩과 관련된 이벤트는?",
      "option_a": "onchange",
      "option_b": "onclick",
      "option_c": "onload",
      "option_d": "onkeydown",
      "correct_answer": "C",
      "explanation": "`onload` 이벤트는 브라우저가 페이지 로딩을 완료했을 때 발생하는 이벤트입니다. 주로 `<body>` 태그나 `window` 객체에서 사용되며, 페이지의 모든 내용이 로드된 후 실행되어야 하는 JavaScript 코드를 작성할 때 활용됩니다. 나머지는 모두 사용자의 직접적인 행동에 의해 발생하는 이벤트들입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T09:52:43.000Z"
    },
    {
      "id": 164,
      "subject_id": 1,
      "question": "JavaScript 이벤트 핸들러의 활용 방법이 아닌 것은?",
      "option_a": "HTML 이벤트 속성으로 JavaScript 코드를 직접 실행",
      "option_b": "HTML 이벤트 속성으로 JavaScript 함수 호출\n",
      "option_c": "HTML 요소에 이벤트 핸들러 함수 할당",
      "option_d": "CSS 스타일시트에서 이벤트 정의",
      "correct_answer": "D",
      "explanation": "CSS는 스타일링을 담당하는 언어로, 이벤트 처리 기능을 제공하지 않습니다. JavaScript 이벤트 핸들러는 1) HTML 속성에서 직접 코드 실행 (`onclick=\"alert('hi')\"`), 2) HTML 속성에서 함수 호출 (`onclick=\"myFunction()\"`), 3) JavaScript에서 요소에 이벤트 핸들러 할당 (`element.onclick = function(){}`) 등의 방법으로 사용할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T09:54:17.000Z"
    },
    {
      "id": 165,
      "subject_id": 1,
      "question": "JavaScript에서 문자열을 만들 때 사용할 수 있는 기호는?",
      "option_a": "소괄호 ()",
      "option_b": "대괄호 []",
      "option_c": "따옴표 \" \"",
      "option_d": "중괄호 {}",
      "correct_answer": "C",
      "explanation": "JavaScript에서 문자열(String)은 따옴표로 감싸서 만듭니다. 작은따옴표(')나 큰따옴표(\") 모두 사용할 수 있습니다. 예를 들어 `let text = \"Hello World\";` 또는 `let text = 'Hello World';`와 같이 작성합니다. 다른 기호들은 배열, 객체 등을 만들 때 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T10:19:35.000Z"
    },
    {
      "id": 166,
      "subject_id": 1,
      "question": "다음 코드 중 올바른 문자열 선언은?",
      "option_a": "let name = John;",
      "option_b": "let name = \"John\";",
      "option_c": "let name = [John];",
      "option_d": "let name = {John};",
      "correct_answer": "B",
      "explanation": "문자열을 선언할 때는 텍스트를 따옴표로 감싸야 합니다. `\"John\"`처럼 큰따옴표나 `'John'`처럼 작은따옴표를 사용해야 합니다. 1번처럼 따옴표 없이 작성하면 JavaScript는 John을 변수명으로 인식하게 되어 오류가 발생할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T10:21:31.000Z"
    },
    {
      "id": 167,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 속성은?\n\n```javascript\nlet text = \"Hello World\";\nlet size = text._____;\n```",
      "option_a": "size",
      "option_b": "count",
      "option_c": "length",
      "option_d": "number",
      "correct_answer": "C",
      "explanation": "문자열의 길이를 구하려면 `length` 속성을 사용합니다. `text.length`는 문자열 \"Hello World\"의 문자 개수인 11을 반환합니다 (공백도 포함). length는 JavaScript 문자열의 내장 속성으로, 문자열에 포함된 문자의 총 개수를 알려줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T10:23:21.000Z"
    },
    {
      "id": 168,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet answer1 = \"It's alright\";\nlet answer2 = 'He said \"Hello\"';\n```",
      "option_a": "두 문장 모두 오류 발생",
      "option_b": "answer1만 오류 발생",
      "option_c": "answer2만 오류 발생",
      "option_d": "두 문장 모두 정상 작동",
      "correct_answer": "D",
      "explanation": "문자열 내부에 따옴표를 사용할 때는 외부 따옴표와 다른 종류를 사용하면 됩니다. answer1에서는 큰따옴표로 감싸고 내부에 작은따옴표(')를 사용했고, answer2에서는 작은따옴표로 감싸고 내부에 큰따옴표(\")를 사용했습니다. 이렇게 하면 JavaScript가 어디서 문자열이 시작하고 끝나는지 정확히 구분할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T10:24:37.000Z"
    },
    {
      "id": 169,
      "subject_id": 1,
      "question": "ES6에서 도입된 템플릿 문자열을 만들 때 사용하는 기호는?",
      "option_a": "작은따옴표 ' '",
      "option_b": "큰따옴표 \" \"",
      "option_c": "백틱 &#96;&#96",
      "option_d": "슬래시 / /",
      "correct_answer": "C",
      "explanation": "템플릿 문자열(Template String)은 ES6(2016)에서 도입된 기능으로, 백틱(&#96;&#96)을 사용해서 만듭니다. 예: let text = &#96;Hello World&#96;;. 템플릿 문자열의 장점은 문자열 내부에 작은따옴표와 큰따옴표를 모두 자유롭게 사용할 수 있고, 여러 줄 문자열을 쉽게 만들 수 있다는 것입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T10:30:37.000Z"
    },
    {
      "id": 170,
      "subject_id": 1,
      "question": "긴 문자열을 여러 줄로 나누는 안전한 방법은?",
      "option_a": "아무 곳에서나 줄바꿈",
      "option_b": "문자열 중간에서 줄바꿈",
      "option_c": "문자열 더하기(+) 사용",
      "option_d": "세미콜론 사용",
      "correct_answer": "C",
      "explanation": "긴 문자열을 읽기 쉽게 나누려면 문자열 더하기 연산자(+)를 사용하는 것이 안전합니다. 예: `\"Hello \" + \"World!\"`. 이렇게 하면 코드의 가독성을 높이면서도 문법 오류를 방지할 수 있습니다. 문자열 중간에서 임의로 줄바꿈을 하면 오류가 발생합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T10:33:39.000Z"
    },
    {
      "id": 171,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = \"John\";\nlet y = new String(\"John\");\nconsole.log(x == y);  // 결과1\nconsole.log(x === y); // 결과2\n```",
      "option_a": "결과1: true, 결과2: true",
      "option_b": "결과1: true, 결과2: false",
      "option_c": "결과1: false, 결과2: true",
      "option_d": "결과1: false, 결과2: false",
      "correct_answer": "B",
      "explanation": "`x`는 문자열 리터럴(primitive value)이고, `y`는 String 객체입니다. `==` 연산자는 값만 비교하므로 \"John\"과 \"John\"이 같아서 true를 반환합니다. 하지만 `===`연산자는 값과 타입을 모두 비교하는데, x는 string 타입이고 y는 object 타입이므로 false를 반환합니다. 이것이 String 객체를 사용하지 않는 이유 중 하나입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T10:37:01.000Z"
    },
    {
      "id": 172,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = new String(\"John\");\nlet y = new String(\"John\");\nconsole.log(x == y);  // 결과1\nconsole.log(x === y); // 결과2\n```",
      "option_a": "결과1: true, 결과2: true",
      "option_b": "결과1: true, 결과2: false",
      "option_c": "결과1: false, 결과2: true",
      "option_d": "결과1: false, 결과2: false",
      "correct_answer": "D",
      "explanation": "두 변수 모두 String 객체입니다. JavaScript에서 객체는 참조로 비교되는데, `x`와 `y`는 내용이 같더라도 서로 다른 객체입니다. 즉, 메모리상 다른 위치에 저장된 별개의 객체이므로 `==`와 `===` 모두 false를 반환합니다. 이는 JavaScript 객체의 기본적인 비교 방식으로, 두 객체가 정확히 같은 참조를 가질 때만 true가 됩니다. 이것이 문자열을 객체로 만들지 말아야 하는 또 다른 이유입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T10:40:00.000Z"
    },
    {
      "id": 173,
      "subject_id": 1,
      "question": "템플릿 문자열(Template String)을 만들 때 사용하는 기호는?",
      "option_a": "작은따옴표 ' '",
      "option_b": "큰따옴표 \" \"",
      "option_c": "백틱 &#96;&#96;",
      "option_d": "슬래시 / /",
      "correct_answer": "C",
      "explanation": "템플릿 문자열은 백틱(&#96;&#96;)을 사용해서 만듭니다. 백틱은 키보드에서 보통 1번 키 왼쪽에 위치하며, 일반 따옴표와는 다른 특별한 기능을 제공합니다. 템플릿 문자열은 ES6(2015)에서 도입된 새로운 문자열 표현 방식입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T10:49:10.000Z"
    },
    {
      "id": 174,
      "subject_id": 1,
      "question": "템플릿 문자열의 다른 이름이 아닌 것은?",
      "option_a": "Template Literals",
      "option_b": "String Templates",
      "option_c": "Template Variables",
      "option_d": "Template Strings",
      "correct_answer": "C",
      "explanation": "템플릿 문자열은 여러 이름으로 불립니다. Template Strings, Template Literals, String Templates 모두 같은 개념을 가리키는 용어입니다. 이 기능은 다양한 이름으로 불리지만 Template Variables는 공식적인 명칭이 아닙니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T10:50:10.000Z"
    },
    {
      "id": 175,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 기호는?\n\n```javascript\nlet text = ___He's often called \"Johnny\"___;\n```",
      "option_a": "\"",
      "option_b": "'",
      "option_c": "`",
      "option_d": "/",
      "correct_answer": "C",
      "explanation": "템플릿 문자열을 사용하면 하나의 문자열 안에 작은따옴표(')와 큰따옴표(\")를 모두 자유롭게 사용할 수 있습니다. 따라서 백틱(&#96;)으로 문자열을 감싸면 됩니다. 일반 따옴표를 사용하면 내부의 같은 종류 따옴표와 충돌이 발생합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T10:52:22.000Z"
    },
    {
      "id": 176,
      "subject_id": 1,
      "question": "템플릿 문자열에서 변수를 삽입할 때 사용하는 문법은?",
      "option_a": "#{variable}",
      "option_b": "${variable}",
      "option_c": "%{variable}",
      "option_d": "&{variable}",
      "correct_answer": "B",
      "explanation": "템플릿 문자열에서 변수나 표현식을 삽입할 때는 `${}`(달러 기호와 중괄호) 문법을 사용합니다. 이를 인터폴레이션(Interpolation) 또는 변수 치환(Variable Substitution)이라고 합니다. 다른 기호들은 JavaScript에서 변수 삽입에 사용되지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T10:54:59.000Z"
    },
    {
      "id": 177,
      "subject_id": 1,
      "question": "템플릿 문자열의 장점이 아닌 것은?",
      "option_a": "여러 줄 문자열 작성 가능",
      "option_b": "변수 삽입 가능",
      "option_c": "작은따옴표와 큰따옴표 동시 사용 가능",
      "option_d": "일반 문자열보다 메모리 사용량이 적음",
      "correct_answer": "D",
      "explanation": "템플릿 문자열이 일반 문자열보다 메모리 사용량이 적다는 것은 사실이 아닙니다. 템플릿 문자열의 실제 장점은 1) 백틱 내에서 실제 줄바꿈으로 여러 줄 문자열을 만들 수 있고, 2) `${}` 문법으로 변수나 표현식을 쉽게 삽입할 수 있으며, 3) 내부에 작은따옴표와 큰따옴표를 자유롭게 사용할 수 있다는 것입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T10:58:26.000Z"
    },
    {
      "id": 178,
      "subject_id": 1,
      "question": "템플릿 문자열이 지원되는 브라우저에 대한 설명으로 올바른 것은?",
      "option_a": "모든 브라우저에서 처음부터 지원됨",
      "option_b": "Internet Explorer에서만 지원됨",
      "option_c": "ES6 기능으로 2017년 이후 모든 모던 브라우저에서 지원됨",
      "option_d": "Node.js에서만 사용 가능함",
      "correct_answer": "C",
      "explanation": "템플릿 문자열은 ES6(ECMAScript 2015) 기능입니다. 자료에 따르면 2017년 6월부터 모든 모던 브라우저에서 완전히 지원되기 시작했습니다. Chrome 51(2016년 5월), Edge 15(2017년 4월), Firefox 54(2017년 6월), Safari 10(2016년 9월), Opera 38(2016년 6월)부터 지원되었습니다. 따라서 현재는 모든 모던 브라우저에서 안전하게 사용할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T11:04:01.000Z"
    },
    {
      "id": 179,
      "subject_id": 1,
      "question": "JavaScript에서 숫자 타입의 개수는?",
      "option_a": "정수, 실수, 소수 등 여러 타입",
      "option_b": "정수와 실수 2가지 타입",
      "option_c": "단 하나의 숫자 타입",
      "option_d": "타입이 없음",
      "correct_answer": "C",
      "explanation": "JavaScript는 다른 프로그래밍 언어와 달리 숫자 타입이 단 하나뿐입니다. 정수, 실수, long, short 등의 구분이 없고, 모든 숫자는 64비트 부동소수점(double precision floating point) 형태로 저장됩니다. 이는 IEEE 754 국제 표준을 따르는 방식입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T11:13:55.000Z"
    },
    {
      "id": 180,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 표현은?\n\n```javascript\nlet x = 123_____; // 12300000\nlet y = 123_____; // 0.00123\n```",
      "option_a": "e5, e-5",
      "option_b": "*5, /-5",
      "option_c": "^5, ^-5",
      "option_d": "+5, -5",
      "correct_answer": "A",
      "explanation": "JavaScript에서는 과학적 표기법(scientific notation)을 사용하여 매우 큰 수나 작은 수를 표현할 수 있습니다. `e5`는 10의 5제곱을 의미하므로 123 × 100000 = 12300000이 되고, `e-5`는 10의 -5제곱을 의미하므로 123 × 0.00001 = 0.00123이 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T11:14:58.000Z"
    },
    {
      "id": 181,
      "subject_id": 1,
      "question": "JavaScript에서 정수의 정확도는 몇 자리까지인가요?",
      "option_a": "10자리",
      "option_b": "15자리",
      "option_c": "17자리",
      "option_d": "20자리",
      "correct_answer": "B",
      "explanation": "JavaScript에서 정수(소수점이나 지수 표기법이 없는 숫자)는 15자리까지 정확합니다. 예를 들어 `999999999999999`(15자리)는 그대로 표현되지만, `9999999999999999`(16자리)는 `10000000000000000`으로 반올림됩니다. 이는 64비트 부동소수점 형식의 한계 때문입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T11:15:48.000Z"
    },
    {
      "id": 182,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 0.2 + 0.1;\nconsole.log(x);\n```",
      "option_a": "0.3",
      "option_b": "0.30000000000000004",
      "option_c": "0.03",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "부동소수점 연산은 항상 100% 정확하지 않습니다. 0.2 + 0.1의 결과는 0.3이 아니라 0.30000000000000004가 됩니다. 이는 컴퓨터가 소수를 이진법으로 표현할 때 발생하는 정밀도 문제입니다. 이 문제를 해결하려면 `(0.2 * 10 + 0.1 * 10) / 10`처럼 곱셈과 나눗셈을 활용할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T11:16:55.000Z"
    },
    {
      "id": 183,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 10;\nlet y = \"20\";\nlet z = x + y;\n```",
      "option_a": "30 (숫자)",
      "option_b": "\"30\" (문자열)",
      "option_c": "\"1020\" (문자열)",
      "option_d": "오류 발생",
      "correct_answer": "C",
      "explanation": "JavaScript에서 `+` 연산자는 덧셈과 문자열 연결 두 가지 용도로 사용됩니다. 숫자와 문자열을 더하면 숫자가 문자열로 변환되어 문자열 연결이 됩니다. 따라서 10 + \"20\"은 \"10\" + \"20\" = \"1020\"이 됩니다. 이는 JavaScript의 중요한 특징 중 하나입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T11:17:51.000Z"
    },
    {
      "id": 184,
      "subject_id": 1,
      "question": "다음 중 문자열을 숫자로 자동 변환하지 않는 연산자는?",
      "option_a": "/  (나눗셈)",
      "option_b": "* (곱셈)",
      "option_c": "- (뺄셈)",
      "option_d": "+ (덧셈)",
      "correct_answer": "D",
      "explanation": "JavaScript는 나눗셈(/), 곱셈(*), 뺄셈(-) 연산에서는 문자열을 자동으로 숫자로 변환합니다. 예를 들어 \"100\" / \"10\" = 10이 됩니다. 하지만 덧셈(+)에서는 문자열 연결 기능 때문에 자동 변환이 일어나지 않습니다. \"100\" + \"10\" = \"10010\"이 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T11:19:03.000Z"
    },
    {
      "id": 185,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 함수는?\n\n```javascript\nlet x = 100 / \"Apple\";\nconsole.log(_____(x)); // true\n```",
      "option_a": "isNumber",
      "option_b": "isNaN",
      "option_c": "isValid",
      "option_d": "isValid",
      "correct_answer": "B",
      "explanation": "숫자가 아닌 문자열로 나눗셈을 하면 `NaN`(Not a Number)이 됩니다. `isNaN()` 함수는 값이 NaN인지 확인하는 전역 함수입니다. 100 / \"Apple\"은 NaN이므로 `isNaN(x)`는 true를 반환합니다. NaN은 \"숫자가 아님\"을 나타내는 JavaScript의 특별한 값입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T11:20:46.000Z"
    },
    {
      "id": 186,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 10;\nlet y = 20;\nlet z = \"30\";\nlet result = x + y + z;\n```",
      "option_a": "\"102030\"",
      "option_b": "\"3030\"",
      "option_c": "60",
      "option_d": "\"60\"",
      "correct_answer": "B",
      "explanation": "JavaScript는 왼쪽에서 오른쪽으로 연산을 수행합니다. 먼저 `x + y`(10 + 20)는 둘 다 숫자이므로 30이 됩니다. 그 다음 `30 + z`(30 + \"30\")는 숫자와 문자열의 덧셈이므로 문자열 연결이 되어 \"3030\"이 됩니다. 연산 순서를 이해하는 것이 중요합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T11:22:10.000Z"
    },
    {
      "id": 187,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 내용은?\n\n```javascript\nlet x = _____; // 16진수 255를 표현\n```",
      "option_a": "255x0",
      "option_b": "0xFF",
      "option_c": "255h",
      "option_d": "#FF",
      "correct_answer": "B",
      "explanation": "JavaScript에서 16진수(헥사데시멀)는 `0x` 접두사를 사용하여 표현합니다. `0xFF`는 16진수 FF를 의미하며, 이는 10진수 255와 같습니다. F는 16진수에서 15를 의미하므로, FF = 15×16 + 15 = 255입니다. `0x` 접두사는 JavaScript가 해당 값을 16진수로 해석하도록 합니다",
      "difficulty": "hard",
      "created_at": "2025-08-05T11:23:18.000Z"
    },
    {
      "id": 188,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 500;\nlet y = new Number(500);\nconsole.log(x == y);   // 결과1\nconsole.log(x === y);  // 결과2\n```",
      "option_a": "결과1: true, 결과2: true",
      "option_b": "결과1: true, 결과2: false",
      "option_c": "결과1: false, 결과2: true",
      "option_d": "결과1: false, 결과2: false",
      "correct_answer": "B",
      "explanation": "`x`는 원시값(primitive value)이고, `y`는 Number 객체입니다. `==` 연산자는 값만 비교하므로 500과 500이 같아서 true를 반환합니다. 하지만 `===` 연산자는 값과 타입을 모두 비교하는데, x는 number 타입이고 y는 object 타입이므로 false를 반환합니다. 이것이 Number 객체를 만들지 않는 이유 중 하나입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T11:24:36.000Z"
    },
    {
      "id": 189,
      "subject_id": 1,
      "question": "JavaScript에서 일반 Number 타입이 정확하게 표현할 수 있는 정수의 최대 자릿수는?",
      "option_a": "10자리",
      "option_b": "15자리",
      "option_c": "20자리",
      "option_d": "무제한",
      "correct_answer": "B",
      "explanation": "JavaScript 정수는 최대 15자리까지만 정확하게 표현할 수 있습니다. 이는 JavaScript가 모든 숫자를 64비트 부동소수점 형식(IEEE 754 표준)으로 저장하기 때문입니다. 15자리를 초과하는 정수는 반올림되어 정확도를 잃게 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T14:20:21.000Z"
    },
    {
      "id": 190,
      "subject_id": 1,
      "question": "다음 코드의 출력 결과는?\n\n```javascript\nlet x = BigInt(999999999999999);\nlet type = typeof x;\nconsole.log(type);\n```",
      "option_a": "\"number\"",
      "option_b": "\"bigint\"",
      "option_c": "\"string\"",
      "option_d": "\"object\"",
      "correct_answer": "B",
      "explanation": "BigInt의 typeof 연산 결과는 \"bigint\"입니다. BigInt는 JavaScript의 두 번째 숫자 데이터 타입으로, Number와는 구별되는 별도의 타입입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T15:39:13.000Z"
    },
    {
      "id": 191,
      "subject_id": 1,
      "question": "JavaScript에서 안전하게 표현할 수 있는 최대 정수는?",
      "option_a": "9007199254740990",
      "option_b": "9007199254740991",
      "option_c": "9007199254740992",
      "option_d": "9007199254740993",
      "correct_answer": "B",
      "explanation": "JavaScript에서 안전하게 표현할 수 있는 최대 정수는 2^53 - 1 = 9007199254740991입니다. 이 값은 Number.MAX_SAFE_INTEGER로 확인할 수 있습니다. 이 범위를 벗어나는 정수는 정확도를 잃게 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T15:40:08.000Z"
    },
    {
      "id": 192,
      "subject_id": 1,
      "question": "다음 코드의 결과는?\n\n```javascript\nlet result = 9007199254740992 === 9007199254740993;\nconsole.log(result);\n```",
      "option_a": "false",
      "option_b": "true",
      "option_c": "undefined",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "이는 JavaScript의 정수 정확도 문제를 보여주는 예입니다. 9007199254740992와 9007199254740993 모두 안전한 정수 범위를 벗어나므로, JavaScript는 이들을 동일한 값으로 반올림합니다. 따라서 비교 결과가 true가 됩니다. 이런 문제 때문에 BigInt가 필요합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T15:41:08.000Z"
    },
    {
      "id": 193,
      "subject_id": 1,
      "question": "다음 빈칸에 들어갈 올바른 코드는?\n\n```javascript\nlet x = 9007199254740995n;\nlet y = 9007199254740995n;\nlet z = x _____ y;  // 곱셈 연산\n```",
      "option_a": "+",
      "option_b": "*",
      "option_c": "**",
      "option_d": "multiply",
      "correct_answer": "B",
      "explanation": "BigInt에서도 일반 Number와 동일한 산술 연산자를 사용할 수 있습니다. 곱셈은 `*` 연산자를 사용합니다. BigInt는 매우 큰 수의 정확한 계산을 가능하게 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T15:42:18.000Z"
    },
    {
      "id": 194,
      "subject_id": 1,
      "question": "다음 코드에서 에러가 발생하는 이유는?\n\n```javascript\nlet x = 5n;\nlet y = x / 2;  // 에러 발생\n```",
      "option_a": "BigInt는 나눗셈을 지원하지 않음",
      "option_b": "BigInt와 Number를 직접 연산할 수 없음",
      "option_c": "2가 너무 작은 수임",
      "option_d": "나눗셈 결과가 소수점을 가지기 때문",
      "correct_answer": "B",
      "explanation": "BigInt와 일반 Number 타입 간의 직접적인 산술 연산은 허용되지 않습니다. 이는 타입 변환 과정에서 정보 손실이 발생할 수 있기 때문입니다. 올바른 방법은 `Number(x) / 2` 또는 `x / 2n`과 같이 명시적 변환을 사용하는 것입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T15:43:35.000Z"
    },
    {
      "id": 195,
      "subject_id": 1,
      "question": "다음 중 BigInt로 표현할 수 없는 것은?",
      "option_a": "16진수: `0x20000000000003n`",
      "option_b": "8진수: `0o400000000000000003n`",
      "option_c": "2진수: `0b100000000000000000000000000000000000000000000000000011n`",
      "option_d": "소수: `5.5n`",
      "correct_answer": "D",
      "explanation": "BigInt는 정수만 표현할 수 있으며, 소수점을 가질 수 없습니다. 하지만 16진수, 8진수, 2진수 표기법은 모두 지원합니다. 소수를 다루려면 Number 타입을 사용하거나 BigInt를 Number로 변환해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T15:44:49.000Z"
    },
    {
      "id": 196,
      "subject_id": 1,
      "question": "다음 코드의 출력 결과는?\n\n```javascript\nconsole.log(Number.isSafeInteger(10));\nconsole.log(Number.isSafeInteger(12345678901234567890));\n```",
      "option_a": "true, true",
      "option_b": "false, false",
      "option_c": "true, falsetrue, false",
      "option_d": "false, true",
      "correct_answer": "C",
      "explanation": "`Number.isSafeInteger()` 메서드는 인수가 안전한 정수인지 확인합니다. 안전한 정수는 -(2^53 - 1)부터 +(2^53 - 1) 범위의 정수입니다. 10은 이 범위 내에 있으므로 true이고, 12345678901234567890은 이 범위를 벗어나므로 false입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T15:45:59.000Z"
    },
    {
      "id": 197,
      "subject_id": 1,
      "question": "JavaScript에서 지원하는 총 데이터 타입의 개수와 BigInt가 추가된 후의 순서는?",
      "option_a": "7개, BigInt는 6번째",
      "option_b": "8개, BigInt는 3번째",
      "option_c": "8개, BigInt는 2번째",
      "option_d": "9개, BigInt는 3번째",
      "correct_answer": "B",
      "explanation": "JavaScript는 총 8개의 데이터 타입을 지원합니다: 1) String, 2) Number, 3) Bigint, 4) Boolean, 5) Undefined, 6) Null, 7) Symbol, 8) Object. BigInt는 Number 다음인 3번째 위치에 있으며, Number에 이어 두 번째 숫자 데이터 타입입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T15:47:17.000Z"
    },
    {
      "id": 198,
      "subject_id": 1,
      "question": "JavaScript 배열의 첫 번째 요소의 인덱스는?",
      "option_a": "1",
      "option_b": "0",
      "option_c": "-1",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "JavaScript 배열은 0부터 시작하는 인덱스를 사용합니다. 즉, 첫 번째 요소는 인덱스 0, 두 번째 요소는 인덱스 1이 됩니다. 이를 \"zero-indexed\"라고 합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T16:02:11.000Z"
    },
    {
      "id": 199,
      "subject_id": 1,
      "question": "다음 중 배열을 생성하는 올바른 방법은?",
      "option_a": "const cars = [\"Saab\", \"Volvo\", \"BMW\"];",
      "option_b": "const cars = new Array(\"Saab\", \"Volvo\", \"BMW\");",
      "option_c": "const cars = []; cars[0] = \"Saab\";",
      "option_d": "모두 올바름",
      "correct_answer": "D",
      "explanation": "JavaScript에서 배열을 생성하는 방법은 여러 가지입니다. 배열 리터럴 `[]`, `new Array()` 생성자, 빈 배열을 만든 후 요소를 추가하는 방법 모두 유효합니다. 하지만 가독성과 실행 속도를 위해 배열 리터럴 방법이 권장됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T16:03:04.000Z"
    },
    {
      "id": 200,
      "subject_id": 1,
      "question": "다음 코드의 출력 결과는?\n\n```javascript\nconst fruits = [\"Banana\", \"Orange\", \"Apple\"];\nconsole.log(fruits[0]);\n```",
      "option_a": "Banana",
      "option_b": "Orange",
      "option_c": "Apple",
      "option_d": "undefined",
      "correct_answer": "A",
      "explanation": "배열의 첫 번째 요소는 인덱스 0에 위치합니다. `fruits[0]`은 배열의 첫 번째 요소인 \"Banana\"를 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T16:04:09.000Z"
    },
    {
      "id": 201,
      "subject_id": 1,
      "question": "다음 빈칸에 들어갈 올바른 코드는?\n\n```javascript\nconst cars = [\"Saab\", \"Volvo\", \"BMW\"];\ncars[0] = ______;  // 첫 번째 요소를 \"Opel\"로 변경\n```",
      "option_a": "\"Opel\"",
      "option_b": "Opel",
      "option_c": "'Opel'",
      "option_d": "1번과 3번 모두 올바름",
      "correct_answer": "D",
      "explanation": "JavaScript에서 문자열은 큰따옴표(\"\")나 작은따옴표('')로 감쌀 수 있습니다. 따라서 `\"Opel\"`과 `'Opel'` 모두 올바른 문자열 표현입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-05T16:06:22.000Z"
    },
    {
      "id": 202,
      "subject_id": 1,
      "question": "배열을 쉼표로 구분된 문자열로 변환하는 메서드는?",
      "option_a": "toArray()",
      "option_b": "toString()",
      "option_c": "stringify()",
      "option_d": "join()",
      "correct_answer": "B",
      "explanation": "`toString()` 메서드는 배열의 모든 요소를 쉼표로 구분된 하나의 문자열로 변환합니다. 예: `[\"Banana\", \"Orange\", \"Apple\"]` → `\"Banana,Orange,Apple\"`",
      "difficulty": "easy",
      "created_at": "2025-08-05T16:07:22.000Z"
    },
    {
      "id": 203,
      "subject_id": 1,
      "question": "다음 코드의 출력 결과는?\n\n```javascript\nconst fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];\nconsole.log(fruits.length);\n```",
      "option_a": "3",
      "option_b": "4",
      "option_c": "5",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "`length` 속성은 배열의 요소 개수를 반환합니다. fruits 배열에는 \"Banana\", \"Orange\", \"Apple\", \"Mango\" 총 4개의 요소가 있으므로 4를 반환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T16:08:16.000Z"
    },
    {
      "id": 204,
      "subject_id": 1,
      "question": "배열의 마지막 요소에 접근하는 올바른 방법은?\n\n```javascript\nconst fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];\n```",
      "option_a": "fruits[4]",
      "option_b": "fruits[fruits.length]",
      "option_c": "fruits[fruits.length - 1]",
      "option_d": "fruits.last()",
      "correct_answer": "C",
      "explanation": "배열의 길이는 4이지만, 인덱스는 0부터 시작하므로 마지막 요소의 인덱스는 3입니다. `fruits.length - 1`은 3이 되어 마지막 요소 \"Mango\"에 접근할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T16:09:21.000Z"
    },
    {
      "id": 205,
      "subject_id": 1,
      "question": "다음 빈칸에 들어갈 올바른 코드는?\n\n```javascript\nconst fruits = [\"Banana\", \"Orange\", \"Apple\"];\nfruits.______(\"Lemon\");  // 배열 끝에 새 요소 추가\n```",
      "option_a": "add",
      "option_b": "push",
      "option_c": "append",
      "option_d": "insert",
      "correct_answer": "B",
      "explanation": "`push()` 메서드는 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환합니다. 이는 배열에 요소를 추가하는 가장 간단한 방법입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T16:10:15.000Z"
    },
    {
      "id": 206,
      "subject_id": 1,
      "question": "다음 코드의 문제점은?\n\n```javascript\nconst fruits = [\"Banana\", \"Orange\", \"Apple\"];\nfruits[6] = \"Lemon\";\n```",
      "option_a": "문법 오류",
      "option_b": "undefined \"holes\" 생성",
      "option_c": "배열이 삭제됨",
      "option_d": "문제없음",
      "correct_answer": "B",
      "explanation": "인덱스 3, 4, 5를 건너뛰고 인덱스 6에 값을 할당하면, 건너뛴 인덱스들은 `undefined`가 됩니다. 이를 \"holes\"라고 하며, 예상치 못한 동작을 일으킬 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T16:11:06.000Z"
    },
    {
      "id": 207,
      "subject_id": 1,
      "question": "JavaScript에서 배열의 `typeof` 연산 결과는?",
      "option_a": "\"array\"",
      "option_b": "\"object\"",
      "option_c": "\"list\"",
      "option_d": "\"string\"",
      "correct_answer": "B",
      "explanation": "JavaScript에서 배열은 특별한 종류의 객체입니다. 따라서 `typeof` 연산자는 \"object\"를 반환합니다. 배열인지 확인하려면 `Array.isArray()` 메서드를 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T16:12:08.000Z"
    },
    {
      "id": 208,
      "subject_id": 1,
      "question": "다음 코드의 출력 결과는?\n\n```javascript\nconst person = [];\nperson[\"firstName\"] = \"John\";\nperson[\"lastName\"] = \"Doe\";\nconsole.log(person.length);\n```",
      "option_a": "0",
      "option_b": "1",
      "option_c": "2",
      "option_d": "undefined",
      "correct_answer": "A",
      "explanation": "배열에 named index(문자열 키)를 사용하면 JavaScript는 해당 배열을 일반 객체로 재정의합니다. 이때 `length` 속성은 0을 반환하고, 일부 배열 메서드와 속성이 올바르게 작동하지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T16:15:16.000Z"
    },
    {
      "id": 209,
      "subject_id": 1,
      "question": "다음 두 코드의 차이점은?\n\n```javascript\n// 코드 A\nconst points = [40];\n\n// 코드 B  \nconst points = new Array(40);\n```",
      "option_a": "동일한 결과",
      "option_b": "A는 1개 요소, B는 40개의 undefined 요소",
      "option_c": "A는 40개 요소, B는 1개 요소",
      "option_d": "둘 다 오류 발생",
      "correct_answer": "B",
      "explanation": "`[40]`은 값이 40인 요소 1개를 가진 배열을 생성합니다. 하지만 `new Array(40)`은 40개의 빈 슬롯(undefined)을 가진 배열을 생성합니다. 이는 `new Array()` 생성자의 예상치 못한 동작 중 하나입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T16:16:44.000Z"
    },
    {
      "id": 210,
      "subject_id": 1,
      "question": "배열인지 확인하는 올바른 방법은?\n\n```javascript\nconst fruits = [\"Banana\", \"Orange\", \"Apple\"];\n```",
      "option_a": "typeof fruits === \"array\"",
      "option_b": "Array.isArray(fruits)",
      "option_c": "fruits instanceof Array",
      "option_d": "2번과 3번 모두 올바름",
      "correct_answer": "D",
      "explanation": "`Array.isArray()`는 ES5에서 도입된 표준 방법이고, `instanceof Array`도 올바른 방법입니다. `typeof`는 \"object\"를 반환하므로 배열 구별에 사용할 수 없습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T16:18:07.000Z"
    },
    {
      "id": 211,
      "subject_id": 1,
      "question": "다음 코드의 출력 결과는?\n\n```javascript\nconst fruits = [\"Banana\", \"Orange\", \"Apple\"];\nlet text = \"\";\nfruits.forEach(function(value) {\n    text += value + \" \";\n});\nconsole.log(text);\n```",
      "option_a": "\"Banana Orange Apple\"",
      "option_b": "\"Banana Orange Apple \"",
      "option_c": "\"BananaOrangeApple\"",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "`forEach()` 메서드는 배열의 각 요소에 대해 제공한 함수를 실행합니다. 각 값 뒤에 공백을 추가하므로 마지막에도 공백이 포함됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T16:19:13.000Z"
    },
    {
      "id": 212,
      "subject_id": 1,
      "question": "다음 빈칸에 들어갈 올바른 코드는?\n\n```javascript\nconst fruits = [\"Banana\", \"Orange\", \"Apple\"];\nfruits[fruits.______] = \"Lemon\";  // push() 없이 끝에 요소 추가\n```",
      "option_a": "size",
      "option_b": "length",
      "option_c": "count",
      "option_d": "index",
      "correct_answer": "B",
      "explanation": "`fruits.length`는 배열의 길이(3)를 반환하므로, `fruits[3] = \"Lemon\"`이 됩니다. 이는 배열의 끝에 새 요소를 추가하는 다른 방법입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T16:20:27.000Z"
    },
    {
      "id": 213,
      "subject_id": 1,
      "question": "JavaScript에서 연관 배열(associative arrays)에 대한 올바른 설명은?",
      "option_a": "JavaScript는 연관 배열을 지원함",
      "option_b": "JavaScript는 연관 배열을 지원하지 않음",
      "option_c": "배열에 문자열 인덱스를 사용하면 연관 배열이 됨",
      "option_d": "`new Array()`로만 생성 가능",
      "correct_answer": "B",
      "explanation": "JavaScript는 연관 배열을 지원하지 않습니다. 배열에는 항상 숫자 인덱스를 사용해야 합니다. 문자열 키가 필요하다면 객체를 사용해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T16:21:17.000Z"
    },
    {
      "id": 214,
      "subject_id": 1,
      "question": "다음 코드에서 배열과 객체의 차이점을 설명한 것은?\n\n```javascript\n// 배열\nconst person = [\"John\", \"Doe\", 46];\n\n// 객체\nconst person = {firstName:\"John\", lastName:\"Doe\", age:46};\n```",
      "option_a": "배열은 숫자 인덱스, 객체는 이름 인덱스 사용",
      "option_b": "배열은 순서가 있고, 객체는 순서가 없음",
      "option_c": "배열은 동적 크기, 객체는 고정 크기",
      "option_d": "1번과 2번 모두 올바름",
      "correct_answer": "D",
      "explanation": "배열은 숫자 인덱스를 사용하여 순서대로 데이터를 저장하고, 객체는 이름(키)을 사용하여 데이터에 접근합니다. 배열은 순서가 중요하지만 객체는 순서가 보장되지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-05T16:22:21.000Z"
    },
    {
      "id": 215,
      "subject_id": 1,
      "question": "다음 중 배열에 저장할 수 있는 데이터 타입은?",
      "option_a": "숫자와 문자열만",
      "option_b": "동일한 타입만",
      "option_c": "숫자, 문자열, 객체, 함수, 다른 배열 등 모든 타입",
      "option_d": "원시 타입만",
      "correct_answer": "C",
      "explanation": "JavaScript 배열은 heterogeneous(이질적)하므로 서로 다른 데이터 타입의 요소들을 함께 저장할 수 있습니다. 숫자, 문자열, 객체, 함수, 심지어 다른 배열도 같은 배열에 저장 가능합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T16:23:02.000Z"
    },
    {
      "id": 216,
      "subject_id": 1,
      "question": "다음 중첩 객체와 배열 코드에서 \"Focus\"에 접근하는 올바른 방법은?\n\n```javascript\nconst myObj = {\n    name: \"John\",\n    cars: [\n        {name:\"Ford\", models:[\"Fiesta\", \"Focus\", \"Mustang\"]},\n        {name:\"BMW\", models:[\"320\", \"X3\", \"X5\"]}\n    ]\n}\n```",
      "option_a": "myObj.cars[0].models[1]",
      "option_b": "myObj.cars.Ford.models[1]",
      "option_c": "myObj[0].cars.models[1]",
      "option_d": "myObj.cars[\"Ford\"][1]",
      "correct_answer": "A",
      "explanation": "중첩된 구조에서는 단계별로 접근해야 합니다. `myObj.cars`로 배열에 접근하고, `[0]`으로 첫 번째 객체에 접근한 후, `.models[1]`로 models 배열의 두 번째 요소(\"Focus\")에 접근합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T16:24:30.000Z"
    },
    {
      "id": 217,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst arr = [1, 2, 3];\narr.length = 5;\nconsole.log(arr);\nconsole.log(arr[4]);\n```",
      "option_a": "`[1, 2, 3, undefined, undefined]`, `undefined`",
      "option_b": "`[1, 2, 3]`, `undefined`",
      "option_c": "오류 발생",
      "option_d": "`[1, 2, 3, null, null]`, `null`",
      "correct_answer": "A",
      "explanation": "배열의 `length` 속성을 직접 수정할 수 있습니다. 길이를 늘리면 새로운 슬롯들은 `undefined`로 채워집니다. 따라서 `arr[4]`는 `undefined`를 반환합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-05T16:26:36.000Z"
    },
    {
      "id": 218,
      "subject_id": 1,
      "question": "JavaScript에서 현재 날짜와 시간으로 Date 객체를 생성하는 방법은?",
      "option_a": "const d = Date();",
      "option_b": "const d = new Date();",
      "option_c": "const d = Date.now();",
      "option_d": "const d = current Date();",
      "correct_answer": "B",
      "explanation": "JavaScript에서 Date 객체를 생성할 때는 `new` 키워드를 사용해야 합니다. `new Date()`는 현재 날짜와 시간을 가진 Date 객체를 생성합니다. `Date()`만 사용하면 문자열을 반환하고, `Date.now()`는 밀리초 값을 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T00:13:02.000Z"
    },
    {
      "id": 219,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 내용은?\n\n```javascript\nconst d = new Date(\"________\");\n```\n\n특정 날짜 \"2022년 3월 25일\"을 설정하려고 할 때:",
      "option_a": "2022/03/25",
      "option_b": "2022-03-25",
      "option_c": "March 25, 2022",
      "option_d": "2번과 3번 모두 가능",
      "correct_answer": "D",
      "explanation": "JavaScript Date 생성자는 다양한 문자열 형식을 받아들입니다. ISO 형식인 \"2022-03-25\"와 자연어 형식인 \"March 25, 2022\" 모두 유효한 날짜 문자열입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T00:14:24.000Z"
    },
    {
      "id": 220,
      "subject_id": 1,
      "question": "JavaScript에서 날짜를 저장하는 내부 방식은?",
      "option_a": "년-월-일 형태의 문자열",
      "option_b": "1970년 1월 1일 00:00:00 UTC부터의 밀리초 수",
      "option_c": "각 날짜 구성요소를 별도 속성으로 저장",
      "option_d": "브라우저마다 다름",
      "correct_answer": "B",
      "explanation": "JavaScript는 날짜를 1970년 1월 1일 00:00:00 UTC(협정세계시)부터 경과한 밀리초 수로 저장합니다. 이를 \"Unix 타임스탬프\"라고도 합니다. 하루는 86,400,000 밀리초(24시간 × 60분 × 60초 × 1000밀리초)입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T00:15:06.000Z"
    },
    {
      "id": 221,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst d = new Date(2018, 11, 24);\n```",
      "option_a": "2018년 11월 24일",
      "option_b": "2018년 12월 24일",
      "option_c": "2019년 1월 24일",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "JavaScript에서 월(month)은 0부터 시작합니다. 즉, 1월=0, 2월=1, ..., 12월=11입니다. 따라서 `new Date(2018, 11, 24)`는 2018년 12월 24일을 의미합니다. 이는 많은 초보자들이 헷갈려하는 부분입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T00:16:13.000Z"
    },
    {
      "id": 222,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 숫자는?\n\n```javascript\nconst d = new Date(2018, __, 24, 10, 33, 30, 0);\n// 2018년 12월 24일 10시 33분 30초 0밀리초\n```",
      "option_a": "11",
      "option_b": "12",
      "option_c": "13",
      "option_d": "24",
      "correct_answer": "A",
      "explanation": "JavaScript의 월은 0부터 시작하므로 12월은 11로 표현됩니다. 7개의 매개변수를 사용할 때 순서는 (년, 월, 일, 시, 분, 초, 밀리초)이며, 월만 0부터 시작한다는 점을 기억해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T00:17:04.000Z"
    },
    {
      "id": 223,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst d = new Date(2018, 15, 24);\n```",
      "option_a": "2018년 15월 24일 (오류)",
      "option_b": "2019년 3월 24일",
      "option_c": "2019년 4월 24일",
      "option_d": "2018년 12월 24일",
      "correct_answer": "C",
      "explanation": "JavaScript는 월이 11을 초과하면 오류를 발생시키지 않고 다음 연도로 넘어갑니다. 15월은 12개월을 초과하므로 15-12=3이 되어 다음 해(2019년)의 4월(월 인덱스 3)이 됩니다. 마찬가지로 일수도 해당 월의 최대 일수를 초과하면 다음 달로 넘어갑니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T00:17:55.000Z"
    },
    {
      "id": 224,
      "subject_id": 1,
      "question": "다음 중 올바른 Date 생성자 사용법이 아닌 것은?",
      "option_a": "new Date(2018, 11, 24, 10, 33, 30)",
      "option_b": "new Date(2018, 11, 24, 10, 33)",
      "option_c": "new Date(2018, 11, 24, 10)",
      "option_d": "new Date(2018)",
      "correct_answer": "D",
      "explanation": "매개변수를 하나만 제공하면 JavaScript는 이를 밀리초로 해석합니다. 따라서 `new Date(2018)`은 1970년 1월 1일부터 2018밀리초 후(약 2초 후)를 의미하며, 2018년을 의미하지 않습니다. 연도만 지정하려면 최소한 월도 함께 제공해야 합니다: `new Date(2018, 0)`.",
      "difficulty": "medium",
      "created_at": "2025-08-06T00:18:51.000Z"
    },
    {
      "id": 225,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 메서드는?\n\n```javascript\nconst d = new Date();\nconst result = d.________();\n// 결과: \"Wed Aug 06 2025\"\n```",
      "option_a": "toString",
      "option_b": "toDateString",
      "option_c": "toUTCString",
      "option_d": "toISOString",
      "correct_answer": "B",
      "explanation": "각 메서드의 출력 형식이 다릅니다:\n\n`toString()`: 전체 날짜와 시간 + 시간대 정보\n`toDateString()`: 요일과 날짜만 (시간 제외)\n`toUTCString()`: UTC 표준 형식 (\"Wed, 06 Aug 2025 00:09:16 GMT\")\n`toISOString()`: ISO 표준 형식 (\"2025-08-06T00:09:31.896Z\")",
      "difficulty": "hard",
      "created_at": "2025-08-06T00:20:36.000Z"
    },
    {
      "id": 226,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst d1 = new Date(99, 11, 24);\nconst d2 = new Date(9, 11, 24);\n```\n각각 어떤 연도를 나타내는가?",
      "option_a": "d1: 99년, d2: 9년",
      "option_b": "d1: 1999년, d2: 1909년",
      "option_c": "d1: 2099년, d2: 2009년",
      "option_d": "d1: 1999년, d2: 9년",
      "correct_answer": "B",
      "explanation": "JavaScript는 1~2자리 연도를 19xx년으로 해석합니다. 따라서 99는 1999년, 9는 1909년으로 변환됩니다. 이는 Y2K 문제와 관련된 레거시 동작입니다. 현재 연도를 명확히 지정하려면 4자리 연도를 사용해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T00:21:34.000Z"
    },
    {
      "id": 227,
      "subject_id": 1,
      "question": "다음 코드에서 `d1`과 `d2`는 같은 날짜를 나타내는가?\n\n```javascript\nconst d1 = new Date(86400000);\nconst d2 = new Date(24 * 60 * 60 * 1000);\n```",
      "option_a": "예, 둘 다 1970년 1월 2일",
      "option_b": "아니오, d1은 1970년 1월 1일, d2는 1970년 1월 2일",
      "option_c": "아니오, d1은 1970년 1월 2일, d2는 1970년 1월 1일",
      "option_d": "오류가 발생함",
      "correct_answer": "A",
      "explanation": "두 코드 모두 같은 값을 계산합니다:\n\n`86400000`은 직접적인 밀리초 \n`24 * 60 * 60 * 1000`은 (24시간 × 60분 × 60초 × 1000밀리초) = 86,400,000 밀리초\n\n둘 다 1970년 1월 1일 00:00:00 UTC부터 하루(24시간) 후인 1970년 1월 2일을 나타냅니다. 하루는 정확히 86,400,000 밀리초입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T00:25:58.000Z"
    },
    {
      "id": 228,
      "subject_id": 1,
      "question": "JavaScript에서 Math 객체를 사용하는 올바른 방법은?",
      "option_a": "const math = new Math(); math.PI;",
      "option_b": "Math.PI;",
      "option_c": "var math = Math(); math.PI;",
      "option_d": "Math math = new Math(); math.PI;",
      "correct_answer": "B",
      "explanation": "JavaScript의 Math 객체는 정적(static) 객체입니다. 즉, `new` 키워드로 인스턴스를 생성할 필요가 없으며, 직접 `Math.속성` 또는 `Math.메서드()`의 형태로 사용합니다. Math 객체의 모든 속성과 메서드는 정적이므로 객체 생성 없이 바로 접근할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T00:39:13.000Z"
    },
    {
      "id": 229,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconsole.log(Math.PI);\n```",
      "option_a": "3.14",
      "option_b": "3.141592653589793",
      "option_c": "PI",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "`Math.PI`는 원주율(π)을 나타내는 JavaScript의 수학 상수입니다. 정확한 값은 3.141592653589793으로, 원의 둘레와 지름의 비율을 의미합니다. Math 객체에는 이런 수학 상수들이 8개 제공되며, 모두 높은 정밀도로 저장되어 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T00:42:17.000Z"
    },
    {
      "id": 230,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\nconst result = Math.______(4.7);\n// 결과: 5 (가장 가까운 정수로 반올림)\n```",
      "option_a": "ceil",
      "option_b": "floor",
      "option_c": "round",
      "option_d": "trunc",
      "correct_answer": "C",
      "explanation": "4.7을 가장 가까운 정수로 반올림하면 5가 됩니다. 각 메서드의 차이점은:\n\n`Math.round()`: 가장 가까운 정수로 반올림 (0.5 이상이면 올림)\n`Math.ceil()`: 항상 올림 (천장값)\n`Math.floor()`: 항상 내림 (바닥값)\n`Math.trunc()`: 소수점 이하 제거 (절단)",
      "difficulty": "easy",
      "created_at": "2025-08-06T00:43:30.000Z"
    },
    {
      "id": 231,
      "subject_id": 1,
      "question": "다음 각 메서드의 실행 결과를 올바르게 짝지은 것은?\n\n```javascript\nMath.ceil(-4.2);   // A\nMath.floor(-4.2);  // B\nMath.round(-4.2);  // C\nMath.trunc(-4.2);  // D\n```",
      "option_a": "A: -4, B: -5, C: -4, D: -4",
      "option_b": "A: -4, B: -4, C: -4, D: -4",
      "option_c": "A: -5, B: -4, C: -4, D: -4",
      "option_d": "A: -4, B: -5, C: -5, D: -4",
      "correct_answer": "A",
      "explanation": "음수에서의 동작을 이해하는 것이 중요합니다:\n\n`Math.ceil(-4.2)`: -4 (음수에서 ceil은 0에 가까운 방향)\n`Math.floor(-4.2)`: -5 (음수에서 floor는 0에서 먼 방향)\n`Math.round(-4.2)`: -4 (가장 가까운 정수)\n`Math.trunc(-4.2)`: -4 (소수점만 제거)\n\n음수에서 ceil과 floor의 방향이 양수와 반대라는 점을 기억해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T00:44:43.000Z"
    },
    {
      "id": 232,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 적절한 값들은?\n\n```javascript\nMath.pow(__, __); // 결과: 64\n```",
      "option_a": "(8, 2)",
      "option_b": "(4, 3)",
      "option_c": "(2, 6)",
      "option_d": "1번과 3번 모두",
      "correct_answer": "D",
      "explanation": "`Math.pow(x, y)`는 x의 y제곱을 계산합니다. 64가 되는 경우들을 살펴보면:\n\n`Math.pow(8, 2)`: 8<sup>2</sup> = 64\n`Math.pow(4, 3)`: 4<sup>3</sup> = 64 \n`Math.pow(2, 6)`: 2<sup>6</sup> = 64\n\n수학적으로 64 = 8<sup>2</sup> = 4<sup>3</sup> = 2<sup>6</sup> 이므로 1번과 3번 모두 올바른 답입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T00:48:43.000Z"
    },
    {
      "id": 233,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nMath.sign(-10) + Math.sign(0) + Math.sign(15);\n```",
      "option_a": "0",
      "option_b": "-1",
      "option_c": "1",
      "option_d": "undefined",
      "correct_answer": "A",
      "explanation": "Math.sign(x) 함수는 숫자의 부호를 반환합니다:\n\n양수이면 1 반환\n음수이면 -1 반환\n0이면 0 반환\n\n따라서:\n\n`Math.sign(-10)`: -1 (음수)\n`Math.sign(0)`: 0 (영)\n`Math.sign(15)`: 1 (양수)\n\n결과: -1 + 0 + 1 = 0",
      "difficulty": "medium",
      "created_at": "2025-08-06T00:54:44.000Z"
    },
    {
      "id": 234,
      "subject_id": 1,
      "question": "삼각함수를 사용하여 90도의 사인값을 구하려고 합니다. 다음 코드의 빈칸은?\n\n```javascript\nconst result = Math.sin(90 * _______ / 180);\n// 결과: 1\n```",
      "option_a": "Math.E",
      "option_b": "Math.PI",
      "option_c": "Math.SQRT2",
      "option_d": "Math.LN2",
      "correct_answer": "B",
      "explanation": "JavaScript의 삼각함수는 라디안(radian) 단위를 사용합니다. 도(degree)를 라디안으로 변환하는 공식은:\n\n라디안 = 도 × π / 180\n\n따라서 90도를 라디안으로 변환하려면 `90 * Math.PI / 180`이 필요합니다. 90도의 사인값은 1이므로 결과가 맞습니다. `Math.PI`는 원주율(π) 상수입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T00:57:58.000Z"
    },
    {
      "id": 235,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst values = [0, 150, 30, 20, -8, -200];\nconst minVal = Math.min(...values);\nconst maxVal = Math.max(...values);\nconsole.log(maxVal - minVal);\n```",
      "option_a": "350",
      "option_b": "358",
      "option_c": "200",
      "option_d": "150",
      "correct_answer": "A",
      "explanation": "`Math.min(0, 150, 30, 20, -8, -200)`: -200 (최솟값)\n`Math.max(0, 150, 30, 20, -8, -200)`: 150 (최댓값)\n차이: 150 - (-200) = 150 + 200 = 350\n\n스프레드 연산자(`...`)를 사용하여 배열의 요소들을 개별 인수로 전달했습니다. Math.min과 Math.max는 배열을 직접 받지 않으므로 이런 방법을 사용합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T00:59:22.000Z"
    },
    {
      "id": 236,
      "subject_id": 1,
      "question": "다음 로그 함수들의 의미를 올바르게 설명한 것은?\n\n\n```javascript\nMath.log2(8);    // A\nMath.log10(1000); // B\nMath.log(Math.E); // C\n```",
      "option_a": "A: 2를 몇 번 곱해야 8?, B: 10을 몇 번 곱해야 1000?, C: e를 몇 번 곱해야 e?",
      "option_b": "A: 8을 2로 나눈 값, B: 1000을 10으로 나눈 값, C: e를 e로 나눈 값",
      "option_c": "A: 2의 8제곱, B: 10의 1000제곱, C: e의 e제곱",
      "option_d": "A: 8 + 2, B: 1000 + 10, C: e + e",
      "correct_answer": "A",
      "explanation": "로그함수는 \"밑을 몇 번 곱해야 주어진 수가 되는가?\"를 구하는 함수입니다:\n\n`Math.log2(8)`: 2<sup>3</sup> = 8이므로 답은 3 (2를 3번 곱하면 8)\n`Math.log10(1000)`: 10<sup>3</sup> = 1000이므로 답은 3 (10을 3번 곱하면 1000)\n`Math.log(Math.E)`: e<sup>1</sup> = e이므로 답은 1 (e를 1번 곱하면 e)\n\nMath.log()는 자연로그(밑이 e)입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T01:02:38.000Z"
    },
    {
      "id": 237,
      "subject_id": 1,
      "question": "빈칸에 들어갈 메서드와 출력 가능한 값의 범위는?\n\n```javascript\nfunction getRandomInteger(min, max) {\n    return Math.______(Math.random() * (max - min + 1)) + min;\n}\n\nconsole.log(getRandomInteger(5, 10));\n```",
      "option_a": "`round`, 5~10 (포함)",
      "option_b": "`floor`, 5~10 (포함)",
      "option_c": "`ceil`, 6~11 (포함)",
      "option_d": "`trunc`, 5~9 (포함)",
      "correct_answer": "B",
      "explanation": "이는 특정 범위의 랜덤 정수를 생성하는 일반적인 패턴입니다:\n\n`Math.random()`: 0 이상 1 미만의 랜덤 실수\n`Math.random() * (10 - 5 + 1)`: 0 이상 6 미만\n`Math.floor()` 적용 후: 0, 1, 2, 3, 4, 5 중 하나\n`+ 5` 후: 5, 6, 7, 8, 9, 10 중 하나\n\n`Math.floor()`를 사용해야 최솟값과 최댓값이 모두 포함된 정수 범위를 만들 수 있습니다. `Math.ceil()`을 사용하면 최솟값이 제외되고, `Math.round()`는 확률분포가 균등하지 않습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T01:05:01.000Z"
    },
    {
      "id": 238,
      "subject_id": 1,
      "question": "`Math.random()`이 반환하는 값의 범위는?",
      "option_a": "0 이상 1 이하 (0과 1 포함)",
      "option_b": "0 이상 1 미만 (0 포함, 1 제외)",
      "option_c": "0 초과 1 미만 (0과 1 모두 제외)",
      "option_d": "0 초과 1 이하 (0 제외, 1 포함)",
      "correct_answer": "B",
      "explanation": "`Math.random()`은 0 이상 1 미만의 실수를 반환합니다. 즉, 0은 포함되지만 1은 절대 포함되지 않습니다. 예를 들어 0.0, 0.5, 0.9999... 등은 가능하지만 정확히 1.0은 나올 수 없습니다. 이는 \"0 (inclusive), 1 (exclusive)\"로 표현되며, 수학적으로는 [0, 1) 구간을 의미합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T01:11:17.000Z"
    },
    {
      "id": 239,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 나올 수 없는 값은?\n\n```javascript\nMath.random();\n```",
      "option_a": "0",
      "option_b": "0.5",
      "option_c": "0.999",
      "option_d": "1",
      "correct_answer": "D",
      "explanation": "`Math.random()`은 항상 1보다 작은 수를 반환합니다. 따라서 정확히 1은 절대 나올 수 없습니다. 0은 가능하고(매우 드물지만), 0.5나 0.999 같은 값들도 모두 가능합니다. 가장 큰 값은 0.9999999...에 가까운 값이지만 1은 아닙니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T01:14:03.000Z"
    },
    {
      "id": 240,
      "subject_id": 1,
      "question": "0부터 9까지의 랜덤한 정수를 얻으려면 다음 코드의 빈칸에 무엇이 들어가야 하는가?\n```javascript\nMath._______(Math.random() * 10);\n```",
      "option_a": "round",
      "option_b": "ceil",
      "option_c": "floor",
      "option_d": "trunc",
      "correct_answer": "C",
      "explanation": "`Math.floor()`를 사용해야 합니다. `Math.random() * 10`은 0 이상 10 미만의 값을 만들어내고, `Math.floor()`는 이를 내림하여 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 중 하나의 정수로 만듭니다. `Math.round()`를 사용하면 10이 나올 수 있고, `Math.ceil()`을 사용하면 0이 나오지 않을 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T01:22:02.000Z"
    },
    {
      "id": 241,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 나올 수 있는 값의 범위는?\n\n```javascript\nMath.floor(Math.random() * 11);\n```",
      "option_a": "0~10 (0과 10 포함)",
      "option_b": "1~11 (1과 11 포함)",
      "option_c": "0~11 (0과 11 포함)",
      "option_d": "1~10 (1과 10 포함)",
      "correct_answer": "A",
      "explanation": "단계별로 분석해보겠습니다:\n\n1) `Math.random()`: 0 이상 1 미만\n2) `Math.random() * 11`: 0 이상 11 미만\n3) `Math.floor()` 적용: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\n`Math.random()`이 최대 0.9999...이므로, 11을 곱하면 최대 10.9999...가 되고, 이를 `Math.floor()`로 내림하면 최대 10이 됩니다. 최소값은 0입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T01:23:49.000Z"
    },
    {
      "id": 242,
      "subject_id": 1,
      "question": "1부터 100까지의 랜덤한 정수를 얻는 올바른 코드는?",
      "option_a": "Math.floor(Math.random() * 100);",
      "option_b": "Math.floor(Math.random() * 100) + 1;",
      "option_c": "Math.floor(Math.random() * 101);",
      "option_d": "Math.ceil(Math.random() * 100);",
      "correct_answer": "B",
      "explanation": "1부터 100까지를 얻으려면:\n\n`Math.random() * 100`: 0 이상 100 미만\n`Math.floor()` 적용: 0~99의 정수\n`+ 1` 추가: 1~100의 정수\n\n다른 선택지들의 문제점:\n\n1번: 0~99 범위 (1이 빠짐)\n3번: 0~100 범위 (1이 빠지고 0이 포함됨)\n4번: 1~100 범위이지만 확률분포가 균등하지 않음 (1과 100이 나올 확률이 절반)",
      "difficulty": "medium",
      "created_at": "2025-08-06T01:25:19.000Z"
    },
    {
      "id": 243,
      "subject_id": 1,
      "question": "다음 코드에서 나올 수 없는 값은?다음 코드에서 나올 수 없는 값은?\n\n```javascript\nMath.floor(Math.random() * 100) + 1;\n```\n",
      "option_a": "1",
      "option_b": "50",
      "option_c": "100",
      "option_d": "101101",
      "correct_answer": "D",
      "explanation": "이 코드의 동작을 분석하면:\n\n`Math.random()`: 0 이상 1 미만\n`* 100`: 0 이상 100 미만\n`Math.floor()`: 0~99의 정수\n`+ 1`: 1~100의 정수\n\n따라서 최소값은 1, 최대값은 100입니다. 101은 절대 나올 수 없습니다. 이는 1부터 100까지의 랜덤 정수를 생성하는 표준적인 방법입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T01:27:04.000Z"
    },
    {
      "id": 244,
      "subject_id": 1,
      "question": "다음 함수에서 min=5, max=15로 호출했을 때의 결과 범위는?\n\n```javascript\nfunction getRndInteger(min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n}\n```",
      "option_a": "5~15 (5와 15 포함)",
      "option_b": "5~15 (5와 15 포함)",
      "option_c": "6~15 (6과 15 포함)",
      "option_d": "6~14 (6과 14 포함)",
      "correct_answer": "B",
      "explanation": "`getRndInteger(5, 15)` 호출 시:\n\n`max - min = 15 - 5 = 10`\n`Math.random() * 10`: 0 이상 10 미만\n`Math.floor()`: 0~9의 정수\n`+ min(5)`: 5~14의 정수\n\n이 함수는 min은 포함하지만 max는 제외하는 범위를 만듭니다. max를 포함하려면 `(max - min + 1)`을 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T01:29:10.000Z"
    },
    {
      "id": 245,
      "subject_id": 1,
      "question": "다음 두 함수의 차이점을 올바르게 설명한 것은?\n\n```javascript\n// 함수 A\nfunction getRndA(min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n}\n\n// 함수 B  \nfunction getRndB(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n```",
      "option_a": "A와 B는 동일한 결과를 반환한다",
      "option_b": "A는 max 포함, B는 max 제외",
      "option_c": "A는 max 제외, B는 max 포함",
      "option_d": "A는 min 제외, B는 min 포함",
      "correct_answer": "C",
      "explanation": "두 함수의 핵심 차이는 +1 여부입니다:\n\n함수 A: `getRndA(1, 5)` 호출 시\n\n`Math.random() * (5-1) = Math.random() * 4`\n결과: 1, 2, 3, 4 (max인 5 제외)\n\n함수 B: `getRndB(1, 5)` 호출 시\n\n`Math.random() * (5-1+1) = Math.random() * 5`\n결과: 1, 2, 3, 4, 5 (max인 5 포함)\n\n함수 A는 min 이상 max 미만의 범위이고, 함수 B는 min 이상 max 이하의 범위입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T01:31:26.000Z"
    },
    {
      "id": 246,
      "subject_id": 1,
      "question": "JavaScript에서 Boolean 데이터 타입이 가질 수 있는 값은?",
      "option_a": "`true`, `false`, `null`",
      "option_b": "`true`, `false`",
      "option_c": "`True`, `False`",
      "option_d": "`\"true\"`, `\"false\"`",
      "correct_answer": "B",
      "explanation": "JavaScript의 Boolean 데이터 타입은 원시(primitive) 데이터 타입으로, 오직 두 개의 값만 가질 수 있습니다: `true`와 `false`. 이 값들은 반드시 소문자로 작성해야 하며, 따옴표 없이 사용해야 합니다. `True`나 `False`(대문자)는 Boolean 값이 아니라 변수명이 될 수 있고, `\"true\"`나 `\"false\"`는 문자열입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T01:43:04.000Z"
    },
    {
      "id": 247,
      "subject_id": 1,
      "question": "다음 중 올바른 Boolean 값 작성법은?",
      "option_a": "True",
      "option_b": "\"true\"",
      "option_c": "true",
      "option_d": "TRUE",
      "correct_answer": "C",
      "explanation": "Boolean 값은 반드시 소문자로 작성해야 하며, 따옴표 없이 사용해야 합니다. `true`와 `false`는 JavaScript의 예약어(reserved word)로 정의되어 있습니다. `True`나 `TRUE`는 변수명으로 사용될 수 있지만 Boolean 값이 아니고, `\"true\"`는 문자열입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T02:15:18.000Z"
    },
    {
      "id": 248,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 5;\nconsole.log(x > 3);\n```",
      "option_a": "5",
      "option_b": "true",
      "option_c": "false",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "비교 연산자 `>`는 두 값을 비교하여 Boolean 값을 반환합니다. `x`가 5이고 `5 > 3`이므로 이 표현식은 `true`를 반환합니다. JavaScript의 모든 비교 연산자(`==`, `!=`, `<`, `>`, `<=`, `>=`)는 항상 `true` 또는 `false`를 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T02:17:02.000Z"
    },
    {
      "id": 249,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 조건은?\n\n```javascript\nlet age = 16;\nif (age __ 18) {\n    console.log(\"미성년자입니다\");\n}\n```",
      "option_a": "==",
      "option_b": ">",
      "option_c": "<",
      "option_d": "!=",
      "correct_answer": "C",
      "explanation": "\"미성년자입니다\"라는 메시지가 출력되려면 age가 18보다 작아야 합니다. 16 < 18이므로 `<` 연산자가 올바릅니다. Boolean 값은 if문에서 조건을 판단하는 데 핵심적으로 사용되며, 조건이 `true`일 때 if 블록이 실행됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T02:19:09.000Z"
    },
    {
      "id": 250,
      "subject_id": 1,
      "question": "다음 중 `Boolean()` 함수를 사용했을 때 `true`를 반환하는 것은?",
      "option_a": "Boolean(0)",
      "option_b": "Boolean(\"\")",
      "option_c": "Boolean(\"false\")",
      "option_d": "Boolean(null)",
      "correct_answer": "C",
      "explanation": "JavaScript에서 \"값이 있는\" 모든 것은 `true`로 평가됩니다. `\"false\"`는 문자열이므로 길이가 5인 값이 있는 문자열입니다. 따라서 `Boolean(\"false\")`는 `true`를 반환합니다. 반면:\n\n`Boolean(0)`: `false` (0은 falsy 값)\n`Boolean(\"\")`: `false` (빈 문자열은 falsy 값)\n`Boolean(null)`: `false` (null은 falsy 값)",
      "difficulty": "medium",
      "created_at": "2025-08-06T02:21:15.000Z"
    },
    {
      "id": 251,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 `<`가 들어갔을 때 결과는?\n\n```javascript\nlet i = 1;\nlet result = \"\";\nwhile (i __ 3) {\n    result += i;\n    i++;\n}\nconsole.log(result);\n```",
      "option_a": "\"1\"",
      "option_b": "\"12\"",
      "option_c": "\"123\"",
      "option_d": "\"1234\"",
      "correct_answer": "B",
      "explanation": " while 루프는 조건이 `true`인 동안 반복 실행됩니다:\n\n1) i=1: 1<3 → true → result=\"1\", i=2\n2) i=2: 2<3 → true → result=\"12\", i=3\n3) i=3: 3<3 → false → 루프 종료\n\n따라서 최종 결과는 \"12\"입니다. Boolean 값은 루프의 조건부에서 언제 반복을 계속하거나 중단할지 결정하는 데 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T02:23:47.000Z"
    },
    {
      "id": 252,
      "subject_id": 1,
      "question": "다음 중 `Boolean()` 함수에 의해 `false`로 평가되는 것들을 모두 고른 것은?\n\nA. `0`\nB. `\"0\"`\nC. `undefined`\nD. `[]` (빈 배열)",
      "option_a": "A, C만",
      "option_b": "A, B, C만",
      "option_c": "A, C, D만",
      "option_d": "A, B, C, D 모두",
      "correct_answer": "A",
      "explanation": "JavaScript에서 falsy 값은 정확히 7개입니다: `false`, `0`, `-0`, `\"\"` (빈 문자열), `null`, `undefined`, `NaN`.\n\nA. `0`: falsy 값\nB. `\"0\"`: 문자열이므로 truthy 값 (길이가 1)\nC. `undefined`: falsy 값\nD. `[]`: 빈 배열이지만 객체이므로 truthy 값\n\n따라서 A와 C만이 `false`로 평가됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T02:26:58.000Z"
    },
    {
      "id": 253,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = Boolean(false);\nlet y = new Boolean(false);\n\nconsole.log(typeof x);\nconsole.log(typeof y);\nconsole.log(x == y);\nconsole.log(x === y);\n```",
      "option_a": "boolean, object, true, true",
      "option_b": "boolean, object, true, false",
      "option_c": "boolean, boolean, true, true",
      "option_d": "object, object, false, false",
      "correct_answer": "B",
      "explanation": "이는 원시값과 객체의 차이를 보여주는 중요한 예제입니다:\n\n1) `Boolean(false)`: Boolean 함수를 사용한 원시값 → `typeof`는 \"boolean\"\n2) `new Boolean(false)`: new 키워드로 생성한 Boolean 객체 → `typeof`는 \"object\"\n3) `x == y`: 동등 비교(`==`)는 타입 변환 후 비교하므로 `true`\n4) `x === y`: 엄격한 비교(`===`)는 타입과 값이 모두 같아야 하므로 `false` (원시값 ≠ 객체)",
      "difficulty": "hard",
      "created_at": "2025-08-06T02:29:24.000Z"
    },
    {
      "id": 254,
      "subject_id": 1,
      "question": "다음 코드에서 예상치 못한 결과가 나오는 이유는?\n\n```javascript\nlet a = new Boolean(false);\nlet b = new Boolean(false);\n\nif (a) {\n    console.log(\"a는 truthy입니다\");\n}\n\nconsole.log(a == b);\nconsole.log(a === b);\n```",
      "option_a": "Boolean 객체는 항상 truthy이고, 두 객체는 항상 다르다",
      "option_b": "new Boolean은 잘못된 문법이다",
      "option_c": "false 값이 잘못 설정되었다",
      "option_d": "비교 연산자가 잘못 사용되었다",
      "correct_answer": "A",
      "explanation": "이 문제는 Boolean 객체 사용 시 주의점을 보여줍니다:\n\n1) Boolean 객체는 항상 truthy: `new Boolean(false)`로 생성된 객체는 내부 값이 `false`여도 객체 자체는 truthy입니다. 따라서 `if (a)`는 `true`가 됩니다.\n2) 객체 비교는 항상 false: JavaScript에서 두 객체를 비교하면 같은 참조를 가리키지 않는 한 항상 `false`입니다. `a`와 `b`는 서로 다른 객체입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T02:31:10.000Z"
    },
    {
      "id": 255,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과를 예측하세요:\n\n```javascript\nconsole.log(Boolean(10 / \"Hello\"));\nconsole.log(Boolean(-0));\nconsole.log(Boolean(\"\"));\nconsole.log(Boolean(\" \"));\nconsole.log(Boolean([]));\n```",
      "option_a": "false, false, false, false, false",
      "option_b": "false, false, false, true, true",
      "option_c": "true, false, false, true, false",
      "option_d": "false, true, false, true, true",
      "correct_answer": "B",
      "explanation": "각 값을 분석해보겠습니다:\n\n1. `Boolean(10 / \"Hello\")`\n  • `10 / \"Hello\"`는 `NaN` (Not a Number)\n  • `NaN`은 falsy 값 → `false`\n\n2. `Boolean(-0)`: `-0`은 falsy 값 → `false`\n\n3. `Boolean(\"\")`: 빈 문자열은 falsy 값 → `false`\n\n4. `Boolean(\" \")`: 공백 문자가 있는 문자열은 truthy 값 → `true`\n\n5. `Boolean([])`: 빈 배열이지만 객체이므로 truthy 값 → `true`\n\n중요한 점은 빈 문자열 `\"\"`와 공백이 있는 문자열 `\" \"`의 차이, 그리고 빈 배열 `[]`도 객체이므로 truthy라는 것입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T02:35:25.000Z"
    },
    {
      "id": 256,
      "subject_id": 1,
      "question": "다음 중 JavaScript에서 값과 타입이 모두 같은 지를 확인하는 비교 연산자는?",
      "option_a": "==",
      "option_b": "===",
      "option_c": "!=",
      "option_d": "!==",
      "correct_answer": "B",
      "explanation": "`===`는 strict equality 연산자로, 값 뿐만 아니라 데이터 타입도 함께 비교합니다. `==`는 타입 변환을 통해 값만 비교하므로 `5 == \"5\"`가 true가 되지만, `===`에서는 `5 === \"5\"`가 false가 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T02:40:47.000Z"
    },
    {
      "id": 257,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 5;\nconsole.log(x == \"5\");\n```",
      "option_a": "true",
      "option_b": "false",
      "option_c": "undefined",
      "option_d": "오류 발생",
      "correct_answer": "A",
      "explanation": "`==` 연산자는 타입이 다를 때 자동으로 타입 변환을 수행합니다. 숫자 5와 문자열 \"5\"를 비교할 때, 문자열 \"5\"가 숫자 5로 변환되어 `5 == 5`가 되므로 결과는 `true`입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T02:41:49.000Z"
    },
    {
      "id": 258,
      "subject_id": 1,
      "question": "다음 빈칸에 들어갈 논리 연산자는?\n\n```javascript\nlet age = 25;\nlet hasLicense = true;\n\nif (age >= 18 ___ hasLicense) {\n    console.log(\"운전 가능\");\n}\n```",
      "option_a": "||",
      "option_b": "&&",
      "option_c": "!",
      "option_d": "??",
      "correct_answer": "B",
      "explanation": "운전을 하려면 나이가 18세 이상이면서 동시에 면허가 있어야 합니다. 두 조건이 모두 참이어야 하므로 AND 연산자인 `&&`를 사용해야 합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T02:42:43.000Z"
    },
    {
      "id": 259,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 6;\nlet y = 3;\nconsole.log(x < 10 && y > 1);\n```",
      "option_a": "true",
      "option_b": "false",
      "option_c": "6",
      "option_d": "3",
      "correct_answer": "A",
      "explanation": "`&&` 연산자는 양쪽 조건이 모두 참일 때만 `true`를 반환합니다. `x < 10`은 `6 < 10`이므로 `true`이고, `y > 1`은 `3 > 1`이므로 `true`입니다. 따라서 `true && true`의 결과는 `true`입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T02:44:18.000Z"
    },
    {
      "id": 260,
      "subject_id": 1,
      "question": "삼항 연산자(Ternary Operator)를 사용한 다음 코드에서 빈칸에 들어갈 구문은?\n\n```javascript\nlet score = 85;\nlet grade = (score >= 90) ? \"A\" ___ \"B\";\n```",
      "option_a": "&&",
      "option_b": "||",
      "option_c": ":",
      "option_d": "??",
      "correct_answer": "C",
      "explanation": "삼항 연산자의 구문은 `조건 ? 참일때값 : 거짓일때값` 입니다. 조건이 참이면 첫 번째 값을, 거짓이면 콜론(`:`) 뒤의 두 번째 값을 반환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T02:45:39.000Z"
    },
    {
      "id": 261,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconsole.log(\"2\" < \"12\");\n```",
      "option_a": "true",
      "option_b": "false",
      "option_c": "2",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "두 문자열을 비교할 때는 알파벳 순서(사전식 순서)로 비교합니다. 문자 \"2\"와 \"1\"을 비교하면 \"1\"이 \"2\"보다 앞서므로 \"12\"가 \"2\"보다 작다고 판단됩니다. 따라서 `\"2\" < \"12\"`는 `false`입니다. 숫자로 비교하려면 `Number()` 함수로 변환해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T02:46:43.000Z"
    },
    {
      "id": 262,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 5;\nconsole.log(x === 5 && x !== \"5\");\n```",
      "option_a": "true",
      "option_b": "false",
      "option_c": "undefined",
      "option_d": "null",
      "correct_answer": "A",
      "explanation": "첫 번째 조건 `x === 5`는 값과 타입이 모두 일치하므로 `true`입니다. 두 번째 조건 `x !== \"5\"`는 숫자 5와 문자열 \"5\"가 타입이 다르므로 `true`입니다. `true && true`의 결과는 `true`입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T02:53:35.000Z"
    },
    {
      "id": 263,
      "subject_id": 1,
      "question": "Nullish Coalescing 연산자(`??`)에 대한 다음 코드의 실행 결과는?\n\n```javascript\nlet name = undefined;\nlet defaultName = \"Anonymous\";\nlet result = name ?? defaultName;\nconsole.log(result);\n```",
      "option_a": "undefined",
      "option_b": "\"Anonymous\"",
      "option_c": "null",
      "option_d": "\"\"",
      "correct_answer": "B",
      "explanation": "`??` 연산자는 왼쪽 값이 `null` 또는 `undefined`일 때만 오른쪽 값을 반환합니다. `name`이 `undefined`이므로 nullish하며, 따라서 `defaultName`인 \"Anonymous\"가 반환됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T02:55:05.000Z"
    },
    {
      "id": 264,
      "subject_id": 1,
      "question": "Optional Chaining 연산자(`?.`)를 사용한 다음 코드의 실행 결과는?\n\n```javascript\nconst user = {\n    name: \"John\",\n    address: null\n};\nconsole.log(user.address?.street);\n```",
      "option_a": "오류 발생",
      "option_b": "null",
      "option_c": "undefined",
      "option_d": "\"street\"",
      "correct_answer": "C",
      "explanation": "`?.` 연산자는 객체가 `null` 또는 `undefined`일 때 오류를 발생시키지 않고 `undefined`를 반환합니다. `user.address`가 `null`이므로, `user.address?.street`는 오류 없이 `undefined`를 반환합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T02:56:53.000Z"
    },
    {
      "id": 265,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 조건식은?\n\n```javascript\nfunction checkVotingEligibility(age) {\n    age = Number(age);\n    if (______) {\n        return \"유효하지 않은 나이입니다\";\n    } else {\n        return (age >= 18) ? \"투표 가능\" : \"투표 불가능\";\n    }\n}\n```",
      "option_a": "age == NaN",
      "option_b": "isNaN(age)",
      "option_c": "age === undefined",
      "option_d": "age ?? false",
      "correct_answer": "B",
      "explanation": "`Number()` 함수로 변환할 수 없는 값은 `NaN`(Not a Number)이 됩니다. `NaN`을 확인하려면 `isNaN()` 함수를 사용해야 합니다. `age == NaN`이나 `age === NaN`은 항상 `false`를 반환하므로 올바르지 않습니다. `NaN`은 자기 자신과도 같지 않다는 특별한 성질을 가지고 있기 때문입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T02:58:20.000Z"
    },
    {
      "id": 266,
      "subject_id": 1,
      "question": "JavaScript에서 조건이 참일 때 코드를 실행하기 위해 사용하는 키워드는?",
      "option_a": "when",
      "option_b": "if",
      "option_c": "condition",
      "option_d": "check",
      "correct_answer": "B",
      "explanation": "JavaScript에서는 `if` 키워드를 사용하여 조건문을 작성합니다. 조건이 참(true)일 때 중괄호 `{}` 안의 코드가 실행됩니다. `if`는 반드시 소문자로 작성해야 하며, 대문자(`If`, `IF`)를 사용하면 오류가 발생합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:02:17.000Z"
    },
    {
      "id": 267,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 키워드는?\n\n```javascript\nlet hour = 15;\nlet greeting;\n\nif (hour < 18) {\n    greeting = \"Good day\";\n} ____ {\n    greeting = \"Good evening\";\n}\n```",
      "option_a": "otherwise",
      "option_b": "then",
      "option_c": "else",
      "option_d": "if not",
      "correct_answer": "C",
      "explanation": "`else` 키워드는 if 조건이 거짓(false)일 때 실행할 코드 블록을 지정합니다. 위 코드에서 hour가 18보다 작지 않을 때(18 이상일 때) \"Good evening\"을 실행하도록 합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:03:09.000Z"
    },
    {
      "id": 268,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet hour = 20;\nif (hour < 18) {\n    console.log(\"Good day\");\n}\n```",
      "option_a": "\"Good day\"가 출력됨",
      "option_b": "\"Good evening\"이 출력됨",
      "option_c": "아무것도 출력되지 않음",
      "option_d": "오류 발생",
      "correct_answer": "C",
      "explanation": "hour 값이 20이므로 조건 `hour < 18`은 거짓입니다. if문의 조건이 거짓일 때는 중괄호 안의 코드가 실행되지 않으므로 아무것도 출력되지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:04:10.000Z"
    },
    {
      "id": 269,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 구문은?\n\n```javascript\nlet time = 15;\nlet greeting;\n\nif (time < 10) {\n    greeting = \"Good morning\";\n} _____ (time < 20) {\n    greeting = \"Good day\";\n} else {\n    greeting = \"Good evening\";\n}\n```",
      "option_a": "if",
      "option_b": "else if",
      "option_c": "or if",
      "option_d": "then if",
      "correct_answer": "B",
      "explanation": "`else if`는 첫 번째 조건이 거짓일 때 추가적인 조건을 검사하는 데 사용됩니다. 이 코드에서는 시간에 따라 세 가지 다른 인사말을 설정하는 다중 조건문입니다. time이 15이므로 첫 번째 조건(time < 10)은 거짓이고, 두 번째 조건(time < 20)이 참이므로 \"Good day\"가 설정됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:05:36.000Z"
    },
    {
      "id": 270,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 greeting 변수에 저장되는 값은?\n\n```javascript\nlet time = 25;\nif (time < 10) {\n    greeting = \"Good morning\";\n} else if (time < 20) {\n    greeting = \"Good day\";\n} else {\n    greeting = \"Good evening\";\n}\n```",
      "option_a": "\"Good morning\"",
      "option_b": "\"Good day\"",
      "option_c": "\"Good evening\"",
      "option_d": "undefined",
      "correct_answer": "C",
      "explanation": "time이 25이므로 첫 번째 조건 `time < 10` (25 < 10)은 거짓이고, 두 번째 조건 `time < 20` (25 < 20)도 거짓입니다. 따라서 마지막 else 블록이 실행되어 \"Good evening\"이 greeting에 저장됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:09:05.000Z"
    },
    {
      "id": 271,
      "subject_id": 1,
      "question": "다음 코드에서 실행될 가능성이 있는 결과는? (Math.random()은 0 이상 1 미만의 랜덤한 수를 반환)\n\n```javascript\nlet text;\nif (Math.random() < 0.5) {\n    text = \"첫 번째\";\n} else {\n    text = \"두 번째\";\n}\n```",
      "option_a": "항상 \"첫 번째\"",
      "option_b": "항상 \"두 번째\"",
      "option_c": "\"첫 번째\" 또는 \"두 번째\" 중 하나",
      "option_d": "아무것도 설정되지 않음",
      "correct_answer": "C",
      "explanation": "`Math.random()`은 0 이상 1 미만의 랜덤한 숫자를 반환합니다. 이 값이 0.5보다 작으면(약 50% 확률) \"첫 번째\"가, 0.5 이상이면(약 50% 확률) \"두 번째\"가 text에 저장됩니다. 따라서 실행할 때마다 둘 중 하나의 값이 설정됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:10:15.000Z"
    },
    {
      "id": 272,
      "subject_id": 1,
      "question": "다음 조건문의 논리적 흐름에서 잘못된 부분은?\n\n```javascript\nlet score = 85;\nif (score >= 90) {\n    grade = \"A\";\n} else if (score >= 80) {\n    grade = \"B\";\n} else if (score >= 90) {\n    grade = \"C\";\n} else {\n    grade = \"F\";\n}\n```",
      "option_a": "문법적으로 완전히 올바름",
      "option_b": "세 번째 조건 `score >= 90`이 절대 실행될 수 없음",
      "option_c": "else 블록이 불필요함",
      "option_d": "조건의 순서가 잘못됨",
      "correct_answer": "B",
      "explanation": "세 번째 조건 `score >= 90`은 절대 실행될 수 없습니다. 왜냐하면 score가 90 이상이면 이미 첫 번째 조건에서 걸려서 \"A\"가 설정되고 조건문을 빠져나가기 때문입니다. 조건문은 위에서부터 순차적으로 검사하며, 참인 조건을 만나면 해당 블록만 실행하고 나머지는 무시합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:11:53.000Z"
    },
    {
      "id": 273,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 조건은?\n\n```javascript\nlet weather = \"sunny\";\nlet temperature = 25;\n\nif (______) {\n    console.log(\"Perfect day for outdoor activities!\");\n} else {\n    console.log(\"Maybe stay indoors today.\");\n}\n```\n\n야외 활동하기 좋은 날씨는 맑고(sunny) 온도가 20도 이상이어야 한다고 가정할 때:",
      "option_a": "weather == \"sunny\" || temperature >= 20",
      "option_b": "weather == \"sunny\" && temperature >= 20",
      "option_c": "weather == \"sunny\" && temperature < 20",
      "option_d": "weather == \"sunny\" && temperature < 20",
      "correct_answer": "B",
      "explanation": "야외 활동하기 좋으려면 날씨가 맑으면서(AND) 동시에 온도가 20도 이상이어야 합니다. 두 조건이 모두 만족되어야 하므로 AND 연산자(`&&`)를 사용해야 합니다. OR 연산자(`||`)를 사용하면 둘 중 하나만 만족해도 참이 되어 의도와 다른 결과가 나옵니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:13:46.000Z"
    },
    {
      "id": 274,
      "subject_id": 1,
      "question": "다음 중첩된 if문의 실행 결과는?\n\n```javascript\nlet age = 25;\nlet hasLicense = true;\n\nif (age >= 18) {\n    if (hasLicense) {\n        console.log(\"운전 가능\");\n    } else {\n        console.log(\"면허 취득 필요\");\n    }\n} else {\n    console.log(\"나이 미달\");\n}\n```",
      "option_a": "\"운전 가능\"",
      "option_b": "\"면허 취득 필요\"",
      "option_c": "\"나이 미달\"",
      "option_d": "아무것도 출력되지 않음",
      "correct_answer": "A",
      "explanation": "중첩된 if문은 바깥쪽 조건부터 검사합니다. 첫 번째 조건 `age >= 18`이 참(25 >= 18)이므로 안쪽 if문으로 들어갑니다. 안쪽에서 `hasLicense`가 true이므로 \"운전 가능\"이 출력됩니다. 중첩된 if문을 사용하면 여러 조건을 단계적으로 검사할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:15:32.000Z"
    },
    {
      "id": 275,
      "subject_id": 1,
      "question": "다음 코드를 else if문을 사용하여 동일한 기능으로 변경할 때, 빈칸에 들어갈 조건은?\n\n```javascript\n// 원본 코드 (중첩 if)\nif (score >= 60) {\n    if (score >= 80) {\n        grade = \"우수\";\n    } else {\n        grade = \"보통\";\n    }\n} else {\n    grade = \"미흡\";\n}\n\n// 변경된 코드 (else if 사용)\nif (score >= 80) {\n    grade = \"우수\";\n} else if (______) {\n    grade = \"보통\";\n} else {\n    grade = \"미흡\";\n}\n```",
      "option_a": "score >= 60",
      "option_b": "score < 80",
      "option_c": "score >= 60 && score < 80",
      "option_d": "score < 60",
      "correct_answer": "C",
      "explanation": "\"보통\" 등급이 되려면 점수가 60점 이상이면서 80점 미만이어야 합니다. 첫 번째 조건 `score >= 80`이 거짓이면 이미 score < 80임을 알 수 있지만, score >= 60인지는 확인해야 합니다. 따라서 `score >= 60 && score < 80` 조건이 필요합니다. 단순히 `score >= 60`만 쓰면 80점 이상인 경우도 포함되어 잘못된 결과가 나올 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:17:42.000Z"
    },
    {
      "id": 276,
      "subject_id": 1,
      "question": "JavaScript에서 여러 조건 중 하나를 선택하여 실행할 때 사용하는 문법은?",
      "option_a": "select",
      "option_b": "choose",
      "option_c": "switch",
      "option_d": "option",
      "correct_answer": "C",
      "explanation": "JavaScript에서 `switch` 문은 하나의 표현식 값을 여러 case 값과 비교하여 일치하는 경우의 코드 블록을 실행하는 조건문입니다. 여러 개의 if-else if 문을 더 깔끔하게 표현할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:21:43.000Z"
    },
    {
      "id": 277,
      "subject_id": 1,
      "question": "다음 switch 문에서 빈칸에 들어갈 키워드는?\n\n```javascript\nswitch (day) {\n    ____ 1:\n        console.log(\"Monday\");\n        break;\n    ____ 2:\n        console.log(\"Tuesday\");\n        break;\n}\n```",
      "option_a": "when",
      "option_b": "if",
      "option_c": "case",
      "option_d": "option",
      "correct_answer": "C",
      "explanation": "`case` 키워드는 switch 문에서 각각의 조건을 나타냅니다. switch 표현식의 값과 case 뒤의 값이 일치하면 해당 코드 블록이 실행됩니다. 각 case는 콜론(:)으로 끝납니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:22:54.000Z"
    },
    {
      "id": 278,
      "subject_id": 1,
      "question": "switch 문에서 각 case 블록을 종료하기 위해 사용하는 키워드는?",
      "option_a": "stop",
      "option_b": "end",
      "option_c": "break",
      "option_d": "exit",
      "correct_answer": "C",
      "explanation": "`break` 키워드는 switch 블록에서 벗어나기 위해 사용됩니다. break가 없으면 다음 case로 계속 실행이 이어집니다(fall-through). 마지막 case에서는 break가 필수는 아니지만, 코드의 일관성을 위해 사용하는 것이 좋습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:23:51.000Z"
    },
    {
      "id": 279,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet day = 3;\nlet dayName;\nswitch (day) {\n    case 1:\n        dayName = \"Monday\";\n        break;\n    case 2:\n        dayName = \"Tuesday\";\n        break;\n    case 3:\n        dayName = \"Wednesday\";\n        break;\n    default:\n        dayName = \"Unknown\";\n}\nconsole.log(dayName);\n```",
      "option_a": "\"Monday\"",
      "option_b": "\"Tuesday\"",
      "option_c": "\"Wednesday\"",
      "option_d": "\"Unknown\"",
      "correct_answer": "C",
      "explanation": "day 변수의 값이 3이므로 `case 3:`과 일치합니다. 따라서 `dayName = \"Wednesday\"`가 실행되고, break에 의해 switch 문이 종료됩니다. 결과적으로 \"Wednesday\"가 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:25:04.000Z"
    },
    {
      "id": 280,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 키워드는?\n\n```javascript\nlet score = 100;\nswitch (score) {\n    case 90:\n        grade = \"A\";\n        break;\n    case 80:\n        grade = \"B\";\n        break;\n    ____:\n        grade = \"Unknown\";\n}\n```",
      "option_a": "else",
      "option_b": "default",
      "option_c": "otherwise",
      "option_d": "final",
      "correct_answer": "B",
      "explanation": "`default` 키워드는 어떤 case와도 일치하지 않을 때 실행되는 코드 블록을 지정합니다. 위 코드에서 score가 100이므로 어떤 case와도 일치하지 않아 default 블록이 실행되어 grade에 \"Unknown\"이 저장됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:25:52.000Z"
    },
    {
      "id": 281,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = 1;\nlet result = \"\";\nswitch (x) {\n    case 1:\n        result += \"One \";\n    case 2:\n        result += \"Two \";\n    case 3:\n        result += \"Three \";\n        break;\n    default:\n        result += \"Default\";\n}\nconsole.log(result);\n```",
      "option_a": "\"One \"",
      "option_b": "\"One Two Three \"",
      "option_c": "\"One Two \"",
      "option_d": "\"Default\"",
      "correct_answer": "B",
      "explanation": "case 1에 break가 없으므로 \"fall-through\" 현상이 발생합니다. x가 1이므로 case 1이 실행되어 \"One \"이 추가되고, break가 없으므로 case 2, case 3까지 계속 실행됩니다. case 3에서 break를 만나므로 최종 결과는 \"One Two Three \"입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:27:19.000Z"
    },
    {
      "id": 282,
      "subject_id": 1,
      "question": "다음 코드에서 공통 코드 블록을 공유하는 방법으로 올바른 것은?\n\n```javascript\n// 목표: case 4와 case 5는 \"Almost weekend\"\n//      case 6과 case 0은 \"Weekend\"를 출력\n\nswitch (day) {\n    // 빈칸 채우기\n}\n```",
      "option_a": "```javascript\ncase 4: case 5:\n    text = \"Almost weekend\";\n    break;\ncase 6: case 0:\n    text = \"Weekend\";\n    break;\n```",
      "option_b": "```javascript\ncase 4,5:\n    text = \"Almost weekend\";\n    break;\ncase 6,0:\n    text = \"Weekend\";\n    break;\n```",
      "option_c": "```javascript\ncase 4 || case 5:\n    text = \"Almost weekend\";\n    break;\ncase 6 || case 0:\n    text = \"Weekend\";\n    break;\n```",
      "option_d": "```javascript\ncase 4 and 5:\n    text = \"Almost weekend\";\n    break;\ncase 6 and 0:\n    text = \"Weekend\";\n    break;\n```",
      "correct_answer": "A",
      "explanation": "여러 case가 같은 코드를 실행하려면 case를 연속으로 나열하고 마지막에 break를 넣습니다. case 4와 case 5 사이에 break가 없으므로 둘 다 같은 코드 블록을 실행하게 됩니다. 이를 \"fall-through\"라고 하며, 의도적으로 활용하는 패턴입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:28:39.000Z"
    },
    {
      "id": 283,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet x = \"1\";\nswitch (x) {\n    case 1:\n        console.log(\"Number one\");\n        break;\n    case \"1\":\n        console.log(\"String one\");\n        break;\n    default:\n        console.log(\"No match\");\n}\n```",
      "option_a": "\"Number one\"",
      "option_b": "\"String one\"",
      "option_c": "\"No match\"",
      "option_d": "둘 다 출력됨",
      "correct_answer": "B",
      "explanation": "switch 문은 엄격한 비교(strict comparison, ===) 를 사용합니다. x는 문자열 \"1\"이므로 숫자 1과는 타입이 다르므로 `case 1`과 일치하지 않습니다. 하지만 `case \"1\"`과는 값과 타입이 모두 일치하므로 \"String one\"이 출력됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:29:57.000Z"
    },
    {
      "id": 284,
      "subject_id": 1,
      "question": "다음 코드에서 default의 위치에 관한 설명으로 올바른 것은?\n\n```javascript\nswitch (value) {\n    default:\n        console.log(\"Default case\");\n        break;\n    case 1:\n        console.log(\"Case 1\");\n        break;\n    case 2:\n        console.log(\"Case 2\");\n        break;\n}\n```",
      "option_a": "문법 오류가 발생한다",
      "option_b": "default는 반드시 마지막에 와야 한다",
      "option_c": "정상적으로 작동하지만 default에 break가 필요하다",
      "option_d": "default는 어느 위치에나 올 수 있다",
      "correct_answer": "C",
      "explanation": "default는 switch 문의 어느 위치에나 올 수 있습니다. 하지만 default가 마지막에 위치하지 않을 때는 반드시 break를 사용해야 합니다. 그렇지 않으면 default 이후의 case들이 계속 실행되는 fall-through가 발생합니다. 일반적으로는 가독성을 위해 default를 마지막에 두는 것이 관례입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:31:45.000Z"
    },
    {
      "id": 285,
      "subject_id": 1,
      "question": "다음 switch 문을 동등한 if-else 문으로 변환할 때 올바른 것은?\n```javascript\n// 원본 switch 문\nswitch (grade) {\n    case 'A':\n    case 'B':\n        console.log(\"Pass\");\n        break;\n    case 'C':\n        console.log(\"Conditional Pass\");\n        break;\n    default:\n        console.log(\"Fail\");\n}```",
      "option_a": "```javascript\nif (grade === 'A' && grade === 'B') {\n    console.log(\"Pass\");\n} else if (grade === 'C') {\n    console.log(\"Conditional Pass\");\n} else {\n    console.log(\"Fail\");\n}\n```",
      "option_b": "```javascript\nif (grade === 'A' || grade === 'B') {\n    console.log(\"Pass\");\n} else if (grade === 'C') {\n    console.log(\"Conditional Pass\");\n} else {\n    console.log(\"Fail\");\n}\n```",
      "option_c": "```javascript\nif (grade == 'A' || grade == 'B') {\n    console.log(\"Pass\");\n} else if (grade == 'C') {\n    console.log(\"Conditional Pass\");\n} else {\n    console.log(\"Fail\");\n}\n```",
      "option_d": "```javascript\nif (grade === 'A') {\n    console.log(\"Pass\");\n} if (grade === 'B') {\n    console.log(\"Pass\");\n} else if (grade === 'C') {\n    console.log(\"Conditional Pass\");\n} else {\n    console.log(\"Fail\");\n}\n```",
      "correct_answer": "B",
      "explanation": "switch 문에서 case 'A'와 case 'B'가 같은 코드 블록을 공유하므로, 이를 if-else로 변환할 때는 OR 연산자(`||`)를 사용해야 합니다. 그리고 switch는 엄격한 비교(===)를 사용하므로 if문에서도 `===`를 사용해야 정확히 동일한 동작을 합니다. `&&` 연산자를 사용하면 grade가 동시에 'A'이면서 'B'일 수 없으므로 항상 거짓이 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:33:25.000Z"
    },
    {
      "id": 286,
      "subject_id": 1,
      "question": "JavaScript에서 같은 코드를 반복적으로 실행할 때 사용하는 구문은?",
      "option_a": "repeat",
      "option_b": "loop",
      "option_c": "for",
      "option_d": "iterate",
      "correct_answer": "C",
      "explanation": "JavaScript에서 `for` 문은 지정된 조건에 따라 코드 블록을 반복적으로 실행하는 반복문입니다. 배열의 모든 요소를 처리하거나 특정 횟수만큼 같은 작업을 반복할 때 유용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:38:30.000Z"
    },
    {
      "id": 287,
      "subject_id": 1,
      "question": "다음 for 문의 기본 구조에서 빈칸에 들어갈 올바른 기호는?\n\n```javascript\nfor (let i = 0__i < 5__i++) {\n    console.log(i);\n}\n```",
      "option_a": ", ,",
      "option_b": "; ;",
      "option_c": ": :",
      "option_d": "| |",
      "correct_answer": "B",
      "explanation": "for 문의 구조는 `for (표현식1; 표현식2; 표현식3)`입니다. 세미콜론(`;`)으로 세 개의 표현식을 구분합니다. 표현식1은 초기화, 표현식2는 조건, 표현식3은 증감을 담당합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:39:40.000Z"
    },
    {
      "id": 288,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 출력되는 숫자는 몇 개인가?\n\n```javascript\nfor (let i = 0; i < 3; i++) {\n    console.log(\"Number: \" + i);\n}\n```",
      "option_a": "2개",
      "option_b": "3개",
      "option_c": "4개",
      "option_d": "무한대",
      "correct_answer": "B",
      "explanation": "초기값 i = 0부터 시작하여 i < 3 조건을 만족하는 동안 반복합니다. i가 0, 1, 2일 때 조건을 만족하므로 총 3번 실행됩니다. i가 3이 되면 i < 3이 거짓이 되어 반복문이 종료됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:40:35.000Z"
    },
    {
      "id": 289,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 표현식은?\n\n```javascript\nconst fruits = [\"apple\", \"banana\", \"orange\"];\nfor (let i = 0; ____; i++) {\n    console.log(fruits[i]);\n}\n```",
      "option_a": "i < 3",
      "option_b": "i <= 3",
      "option_c": "i < fruits.length",
      "option_d": "i <= fruits.length",
      "correct_answer": "C",
      "explanation": "배열의 모든 요소를 순회하려면 인덱스가 배열의 길이보다 작을 때까지 반복해야 합니다. `fruits.length`는 3이므로 `i < fruits.length`는 i가 0, 1, 2일 때 참이 되어 모든 배열 요소에 접근할 수 있습니다. `i <= fruits.length`를 사용하면 존재하지 않는 인덱스 3에 접근하여 undefined가 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:41:40.000Z"
    },
    {
      "id": 290,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet text = \"\";\nfor (let i = 1; i <= 3; i++) {\n    text += i + \" \";\n}\nconsole.log(text);\n```",
      "option_a": "\"1 2 3 \"",
      "option_b": "\"0 1 2 \"",
      "option_c": "\"1 2 3 4 \"",
      "option_d": "\"2 3 4 \"",
      "correct_answer": "A",
      "explanation": "초기값 i = 1부터 시작하여 i <= 3 조건을 만족하는 동안 반복합니다. i가 1, 2, 3일 때 각각 \"1 \", \"2 \", \"3 \"을 text에 추가하므로 최종 결과는 \"1 2 3 \"입니다. `+=` 연산자로 문자열을 누적하여 연결합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:42:27.000Z"
    },
    {
      "id": 291,
      "subject_id": 1,
      "question": "Expression 1을 생략한 다음 코드에서 빈칸에 들어갈 올바른 구문은?\n\n```javascript\nlet i = 5;\nfor (____; i < 8; i++) {\n    console.log(i);\n}\n```",
      "option_a": "let i = 5",
      "option_b": "i = 5",
      "option_c": "  (공백)",
      "option_d": "null",
      "correct_answer": "C",
      "explanation": "for 문의 첫 번째 표현식(Expression 1)은 생략 가능합니다. 이미 반복문 밖에서 변수 i가 초기화되었으므로 첫 번째 자리를 비워둘 수 있습니다. 세미콜론은 유지해야 하므로 `(; i < 8; i++)` 형태가 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:44:12.000Z"
    },
    {
      "id": 292,
      "subject_id": 1,
      "question": "다음 코드에서 여러 변수를 동시에 초기화하는 올바른 방법은?\n\n```javascript\nconst cars = [\"BMW\", \"Audi\"];\n// 빈칸을 채워 i, len, text를 동시에 초기화하세요\nfor (____; i < len; i++) {\n    text += cars[i];\n}\n```",
      "option_a": "`let i = 0; let len = cars.length; let text = \"\"`",
      "option_b": "`let i = 0, len = cars.length, text = \"\"`",
      "option_c": "`let i = 0 and len = cars.length and text = \"\"`",
      "option_d": "`let i = 0 | len = cars.length | text = \"\"`",
      "correct_answer": "B",
      "explanation": " for 문의 첫 번째 표현식에서 여러 변수를 동시에 초기화할 때는 쉼표(`,`)로 구분합니다. 모든 변수는 같은 키워드(`let`)로 선언되며, `let i = 0, len = cars.length, text = \"\"`처럼 작성합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:45:54.000Z"
    },
    {
      "id": 293,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nvar i = 5;\nfor (var i = 0; i < 3; i++) {\n    // some code\n}\nconsole.log(i);\n```",
      "option_a": "5",
      "option_b": "3",
      "option_c": "0",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "`var`는 함수 스코프를 가지므로 for 문 안에서 선언된 `var i`는 바깥의 `var i`를 재선언합니다. 반복문이 끝나면 i는 3이 됩니다(i < 3 조건을 만족하지 않아 종료될 때의 값). `var`는 블록 스코프가 없어 for 문 밖에서도 접근 가능합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:46:53.000Z"
    },
    {
      "id": 294,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet i = 5;\nfor (let i = 0; i < 3; i++) {\n    // some code\n}\nconsole.log(i);\n```",
      "option_a": "5",
      "option_b": "3",
      "option_c": "0",
      "option_d": "undefined",
      "correct_answer": "A",
      "explanation": "`let`은 블록 스코프를 가지므로 for 문 안의 `let i`와 밖의 `let i`는 서로 다른 변수입니다. for 문 안의 i는 블록이 끝나면 소멸되고, 밖의 i(값 5)는 영향을 받지 않습니다. 이것이 `var`와 `let`의 주요 차이점입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:47:55.000Z"
    },
    {
      "id": 295,
      "subject_id": 1,
      "question": "다음 코드에서 Expression 3를 생략하고 동일한 기능을 구현할 때 빈칸에 들어갈 코드는?\n\n```javascript\n// 원본 코드\nfor (let i = 0; i < 3; i++) {\n    console.log(i);\n}\n\n// 변경된 코드\nlet i = 0;\nfor (; i < 3; ) {\n    console.log(i);\n    ____;\n}\n```",
      "option_a": "`i--`",
      "option_b": "`i++`",
      "option_c": "`i += 2`",
      "option_d": "`i = i * 2`",
      "correct_answer": "B",
      "explanation": "원본 코드의 `i++`는 매 반복마다 i를 1씩 증가시킵니다. Expression 3을 생략했을 때는 반복문 내부에서 수동으로 증감을 처리해야 합니다. `i++`를 블록 내부에 넣어서 같은 동작을 구현할 수 있습니다. 만약 증감을 빼먹으면 무한반복이 발생할 수 있으므로 주의해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:49:00.000Z"
    },
    {
      "id": 296,
      "subject_id": 1,
      "question": "JavaScript에서 객체의 속성을 반복적으로 순회할 때 사용하는 반복문은?",
      "option_a": "for",
      "option_b": "for in",
      "option_c": "for each",
      "option_d": "for loop",
      "correct_answer": "B",
      "explanation": "`for in` 문은 객체의 속성(properties)을 순회하는데 사용되는 특별한 반복문입니다. 일반적인 `for` 문과 달리 객체의 키(key)를 하나씩 가져와서 해당 키에 접근할 수 있게 해줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:52:20.000Z"
    },
    {
      "id": 297,
      "subject_id": 1,
      "question": "다음 for-in 문의 기본 구조에서 빈칸에 들어갈 올바른 키워드는?\n\n```javascript\nfor (key ____ object) {\n    // code block\n}\n```",
      "option_a": "of",
      "option_b": "in",
      "option_c": "from",
      "option_d": "inside",
      "correct_answer": "B",
      "explanation": "for-in 문의 구조는 `for (변수 in 객체)`입니다. `in` 키워드는 지정된 객체의 모든 열거 가능한 속성을 순회하겠다는 의미입니다. 각 반복에서 변수에는 객체의 속성 이름(키)이 할당됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:53:22.000Z"
    },
    {
      "id": 298,
      "subject_id": 1,
      "question": "다음 코드에서 변수 `x`에 저장되는 것은?\n\n```javascript\nconst person = {name: \"John\", age: 30};\nfor (let x in person) {\n    console.log(x);\n}\n```",
      "option_a": "속성의 값 (\"John\", 30)",
      "option_b": "속성의 이름 (\"name\", \"age\")",
      "option_c": "객체 전체",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "for-in 문에서 반복 변수(여기서는 `x`)에는 객체의 속성 이름(키)이 저장됩니다. 따라서 \"name\", \"age\"가 순차적으로 출력됩니다. 속성의 값에 접근하려면 `person[x]`와 같이 사용해야 합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T03:54:28.000Z"
    },
    {
      "id": 299,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst car = {brand: \"Toyota\", model: \"Camry\", year: 2020};\nlet result = \"\";\nfor (let key in car) {\n    result += car[key] + \" \";\n}\nconsole.log(result);\n```",
      "option_a": "\"brand model year \"",
      "option_b": "\"Toyota Camry 2020 \"",
      "option_c": "\"Toyota\"",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "`key`에는 속성 이름이 저장되고, `car[key]`로 해당 속성의 값에 접근합니다. 각 반복에서 \"Toyota \", \"Camry \", \"2020 \"이 result에 추가되어 최종적으로 \"Toyota Camry 2020 \"이 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:55:27.000Z"
    },
    {
      "id": 300,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 표현은?\n\n```javascript\nconst colors = [\"red\", \"green\", \"blue\"];\nlet text = \"\";\nfor (let i ____ colors) {\n    text += _____;\n}\n```\n배열의 값들을 모두 출력하려고 할 때:",
      "option_a": "`in`, `i`",
      "option_b": "`in`, `colors[i]`",
      "option_c": "`of`, `i`",
      "option_d": "`of`, `colors[i]`",
      "correct_answer": "B",
      "explanation": "배열에서 for-in을 사용하면 `i`에는 배열의 인덱스(0, 1, 2)가 저장됩니다. 배열의 실제 값을 가져오려면 `colors[i]`를 사용해야 합니다. 결과는 \"redgreenblue\"가 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:56:52.000Z"
    },
    {
      "id": 301,
      "subject_id": 1,
      "question": "배열에 대해 for-in 문 사용 시 주의사항으로 올바른 것은?",
      "option_a": "for-in은 배열에 사용할 수 없다",
      "option_b": "인덱스 순서가 보장되지 않을 수 있다",
      "option_c": "배열의 길이만 반환한다",
      "option_d": "성능이 일반 for문보다 빠르다",
      "correct_answer": "B",
      "explanation": "for-in 문을 배열에 사용할 때 인덱스 순서는 구현에 따라 달라질 수 있어 예상한 순서대로 접근되지 않을 수 있습니다. 순서가 중요한 경우에는 일반 for 문, for-of 문, 또는 Array.forEach() 메서드를 사용하는 것이 좋습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T03:58:24.000Z"
    },
    {
      "id": 302,
      "subject_id": 1,
      "question": "다음 forEach 메서드에서 빈칸에 들어갈 올바른 구문은?\n\n```javascript\nconst numbers = [10, 20, 30];\nlet sum = 0;\nnumbers.______(function(value, index, array) {\n    sum += value;\n});\n```",
      "option_a": "for",
      "option_b": "forEach",
      "option_c": "forEachValue",
      "option_d": "iterate",
      "correct_answer": "B",
      "explanation": "`forEach()` 메서드는 배열의 각 요소에 대해 제공된 함수를 한 번씩 실행합니다. 콜백 함수는 세 개의 매개변수를 받습니다: value(값), index(인덱스), array(배열 자체). 이 코드에서는 모든 값을 더해서 sum에 저장합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T03:59:26.000Z"
    },
    {
      "id": 303,
      "subject_id": 1,
      "question": "다음 forEach 메서드의 콜백 함수 매개변수 순서로 올바른 것은?\n\n```javascript\narray.forEach(function(__, __, __) {\n    // code\n});\n```",
      "option_a": "index, value, array",
      "option_b": "value, index, array",
      "option_c": "array, value, index",
      "option_d": "value, array, index",
      "correct_answer": "B",
      "explanation": "forEach 메서드의 콜백 함수는 항상 `(value, index, array)` 순서로 매개변수를 받습니다. 첫 번째는 현재 요소의 값, 두 번째는 현재 인덱스, 세 번째는 배열 전체입니다. 필요하지 않은 매개변수는 생략할 수 있지만 순서는 고정되어 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T04:00:26.000Z"
    },
    {
      "id": 304,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst obj = {a: 1, b: 2, c: 3};\nlet keys = \"\";\nlet values = \"\";\n\nfor (let prop in obj) {\n    keys += prop + \" \";\n    values += obj[prop] + \" \";\n}\n\nconsole.log(keys);\nconsole.log(values);\n```",
      "option_a": "keys: \"a b c \", values: \"1 2 3 \"",
      "option_b": "keys: \"1 2 3 \", values: \"a b c \"",
      "option_c": "keys: \"a b c \", values: \"a b c \"",
      "option_d": "오류 발생",
      "correct_answer": "A",
      "explanation": "for-in 문에서 `prop`에는 속성 이름(\"a\", \"b\", \"c\")이 저장되고, `obj[prop]`으로 해당 속성의 값(1, 2, 3)에 접근합니다. 따라서 keys에는 속성 이름들이, values에는 속성 값들이 저장됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T04:01:24.000Z"
    },
    {
      "id": 305,
      "subject_id": 1,
      "question": "다음 중 배열 순회에 가장 적합한 방법은? (순서가 중요한 경우)\n```javascript\nconst fruits = [\"apple\", \"banana\", \"cherry\"];\n```",
      "option_a": "```javascript\nfor (let i in fruits) {\n    console.log(fruits[i]);\n}\n```",
      "option_b": "```javascript\nfor (let i = 0; i < fruits.length; i++) {\n    console.log(fruits[i]);\n}\n```",
      "option_c": "```javascript\nfruits.forEach(function(fruit) {\n    console.log(fruit);\n});\n```",
      "option_d": "2번과 3번 모두",
      "correct_answer": "D",
      "explanation": "배열에서 순서가 중요할 때는 일반 for 문(2번)이나 forEach 메서드(3번)를 사용하는 것이 좋습니다. for-in 문(1번)은 객체의 속성 순회에 최적화되어 있고 배열에서는 인덱스 순서가 보장되지 않을 수 있습니다. 2번은 전통적인 방식이고, 3번은 더 함수형 프로그래밍 스타일로 둘 다 순서를 보장합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T04:02:26.000Z"
    },
    {
      "id": 306,
      "subject_id": 1,
      "question": "JavaScript의 `for of` 반복문은 무엇을 반복할 수 있나요?",
      "option_a": "숫자만 가능",
      "option_b": "문자열만 가능",
      "option_c": "배열, 문자열, Map, NodeList 등 반복 가능한 객체",
      "option_d": "객체의 속성만 가능",
      "correct_answer": "C",
      "explanation": "`for of` 반복문은 iterable(반복 가능한) 객체의 값들을 반복할 수 있습니다. 배열(Arrays), 문자열(Strings), Map, NodeList 등 반복 가능한 데이터 구조를 모두 처리할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:03:54.000Z"
    },
    {
      "id": 307,
      "subject_id": 1,
      "question": "다음 중 `for of` 반복문의 올바른 기본 문법은?",
      "option_a": "for (variable in iterable) { }",
      "option_b": "for (variable of iterable) { }",
      "option_c": "for (variable : iterable) { }",
      "option_d": "for (variable => iterable) { }",
      "correct_answer": "B",
      "explanation": "`for of` 반복문의 기본 문법은 `for (variable of iterable) { }`입니다. `of` 키워드를 사용하여 반복 가능한 객체의 값들을 순회합니다. `for in`은 객체의 속성을 반복하는 다른 문법입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:04:56.000Z"
    },
    {
      "id": 308,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 키워드는?\n\n```javascript\nconst cars = [\"BMW\", \"Volvo\", \"Mini\"];\nlet text = \"\";\nfor (let x _____ cars) {\n    text += x;\n}\n```",
      "option_a": "in",
      "option_b": "of",
      "option_c": "from",
      "option_d": "through",
      "correct_answer": "B",
      "explanation": "배열의 값들을 순회하기 위해서는 `of` 키워드를 사용해야 합니다. `for (let x of cars)`는 cars 배열의 각 요소값(\"BMW\", \"Volvo\", \"Mini\")을 x 변수에 할당하며 반복합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:06:08.000Z"
    },
    {
      "id": 309,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst fruits = [\"apple\", \"banana\"];\nlet result = \"\";\nfor (let fruit of fruits) {\n    result += fruit + \" \";\n}\nconsole.log(result);\n```",
      "option_a": "apple banana ",
      "option_b": "0 1 ",
      "option_c": "apple,banana ",
      "option_d": "apple.banana ",
      "correct_answer": "A",
      "explanation": "`for of` 반복문은 배열의 값들을 순회합니다. 첫 번째 반복에서 `fruit`은 \"apple\"이 되고, 두 번째 반복에서는 \"banana\"가 됩니다. 각각에 공백을 추가하므로 결과는 \"apple banana \"가 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:07:17.000Z"
    },
    {
      "id": 310,
      "subject_id": 1,
      "question": "문자열에 `for of`를 사용했을 때의 결과를 예측해보세요.\n\n```javascript\nlet word = \"Hi\";\nlet output = \"\";\nfor (let char of word) {\n    output += char + \"-\";\n}\n```\n`output`의 최종 값은?",
      "option_a": "\"Hi-\"",
      "option_b": "\"H-i-\"",
      "option_c": "\"H-I-\"",
      "option_d": "\"Hi--\"",
      "correct_answer": "B",
      "explanation": "`for of`를 문자열에 사용하면 각 문자를 개별적으로 순회합니다. \"Hi\"는 \"H\"와 \"i\" 두 문자로 나뉘어 처리되며, 각 문자 뒤에 \"-\"가 추가되어 \"H-i-\"가 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T05:08:39.000Z"
    },
    {
      "id": 311,
      "subject_id": 1,
      "question": "다음 코드에서 변수 선언에 사용할 수 있는 키워드가 아닌 것은?\n\n```javascript\nconst numbers = [1, 2, 3];\nfor (_____ num of numbers) {\n    console.log(num);\n}\n```",
      "option_a": "let",
      "option_b": "const",
      "option_c": "var",
      "option_d": "function",
      "correct_answer": "D",
      "explanation": "`for of` 반복문에서 변수는 `const`, `let`, 또는 `var`로 선언할 수 있습니다. `function`은 함수를 정의할 때 사용하는 키워드로, 변수 선언에는 사용할 수 없습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T05:09:49.000Z"
    },
    {
      "id": 312,
      "subject_id": 1,
      "question": "다음 코드의 문제점은 무엇인가요?\n\n```javascript\nconst colors = [\"red\", \"blue\", \"green\"];\nfor (const color of colors) {\n    color = color.toUpperCase();\n    console.log(color);\n}\n```",
      "option_a": "`for of` 문법이 틀렸다",
      "option_b": "`const`로 선언된 변수를 재할당하려고 한다",
      "option_c": "`toUpperCase()`는 존재하지 않는 메소드다",
      "option_d": "배열을 `for of`로 반복할 수 없다",
      "correct_answer": "B",
      "explanation": "`const`로 선언된 변수는 재할당할 수 없습니다. `color = color.toUpperCase();`에서 `color` 변수에 새 값을 할당하려고 하므로 오류가 발생합니다. 이 경우 `let`을 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T05:11:40.000Z"
    },
    {
      "id": 313,
      "subject_id": 1,
      "question": "다음 두 코드의 실행 결과 차이점을 분석해보세요.\n코드 A:\n```javascript\nconst arr = [\"a\", \"b\"];\nfor (let i in arr) {\n    console.log(i);\n}\n```\n코드 B:\n```javascript\nconst arr = [\"a\", \"b\"];\nfor (let item of arr) {\n    console.log(item);\n}\n```",
      "option_a": "A는 `0, 1`을 출력하고, B는 `a, b`를 출력한다",
      "option_b": "A는 `a, b`를 출력하고, B는 `0, 1`을 출력한다",
      "option_c": "둘 다 `a, b`를 출력한다",
      "option_d": "둘 다 `0, 1`을 출력한다",
      "correct_answer": "A",
      "explanation": "`for in`은 객체의 속성 이름(배열의 경우 인덱스)을 반복하므로 \"0\", \"1\"을 출력합니다. 반면 `for of`는 실제 값들을 반복하므로 \"a\", \"b\"를 출력합니다. 이것이 `for in`과 `for of`의 핵심적인 차이점입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T05:13:48.000Z"
    },
    {
      "id": 314,
      "subject_id": 1,
      "question": "다음 코드에서 HTML 결과를 예측해보세요.\n```javascript\nconst animals = [\"cat\", \"dog\"];\nlet html = \"\";\nfor (let animal of animals) {\n    html += animal + \"<br>\";\n}\ndocument.getElementById(\"demo\").innerHTML = html;\n```\nHTML 요소에 표시될 내용은?",
      "option_a": "`cat<br>dog<br>`",
      "option_b": "`cat dog` (한 줄에)",
      "option_c": "`cat` (다음 줄에) `dog`",
      "option_d": "`[\"cat\", \"dog\"]`",
      "correct_answer": "C",
      "explanation": "`<br>` 태그는 HTML에서 줄바꿈을 의미합니다. `innerHTML`을 통해 HTML에 삽입될 때, `cat<br>dog<br>` 문자열이 실제 HTML로 해석되어 \"cat\" 다음에 줄바꿈이 일어나고, 그 다음 줄에 \"dog\"가 표시됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T05:15:53.000Z"
    },
    {
      "id": 315,
      "subject_id": 1,
      "question": "다음 중 `for of` 반복문을 사용할 수 없는 데이터 타입은?",
      "option_a": "`\"JavaScript\"` (문자열)",
      "option_b": "`[1, 2, 3]` (배열)",
      "option_c": "`{name: \"John\", age: 30}` (일반 객체)",
      "option_d": "`new Set([1, 2, 3])` (Set 객체)",
      "correct_answer": "C",
      "explanation": "일반 객체 `{name: \"John\", age: 30}`는 iterable(반복 가능한) 객체가 아니므로 `for of`를 직접 사용할 수 없습니다. 일반 객체의 속성을 반복하려면 `for in`을 사용하거나, `Object.keys()`, `Object.values()`, `Object.entries()` 등을 활용해야 합니다. 문자열, 배열, Set은 모두 iterable 객체이므로 `for of`로 반복할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T05:17:52.000Z"
    },
    {
      "id": 316,
      "subject_id": 1,
      "question": "While 반복문은 언제까지 실행되나요?",
      "option_a": "정확히 10번까지",
      "option_b": "지정된 조건이 참(true)인 동안",
      "option_c": "한 번만 실행됨",
      "option_d": "무한히 실행됨",
      "correct_answer": "B",
      "explanation": "While 반복문은 조건식이 참(true)인 동안 코드 블록을 반복 실행합니다. 조건이 거짓(false)이 되면 반복을 멈춥니다. 이것이 while 반복문의 핵심 개념입니다",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:34:17.000Z"
    },
    {
      "id": 317,
      "subject_id": 1,
      "question": "다음 중 while 반복문의 올바른 문법은?",
      "option_a": "while {condition} (code block)",
      "option_b": "while [condition] {code block}",
      "option_c": "while (condition) {code block}",
      "option_d": "while condition: {code block}",
      "correct_answer": "C",
      "explanation": "While 반복문의 올바른 문법은 `while (condition) {code block}`입니다. 조건식은 소괄호() 안에, 실행할 코드는 중괄호{} 안에 작성합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:35:04.000Z"
    },
    {
      "id": 318,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 키워드는?\n\n```javascript\nlet i = 0;\n_____ (i < 5) {\n    console.log(i);\n    i++;\n}\n```",
      "option_a": "for",
      "option_b": "while",
      "option_c": "if",
      "option_d": "do",
      "correct_answer": "B",
      "explanation": "조건이 참인 동안 반복 실행하는 구조이므로 `while` 키워드가 적합합니다. `i < 5`라는 조건이 참인 동안 코드 블록이 반복 실행됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:37:55.000Z"
    },
    {
      "id": 319,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nlet i = 0;\nlet result = \"\";\nwhile (i < 3) {\n    result += i + \" \";\n    i++;\n}\nconsole.log(result);\n```",
      "option_a": "\"0 1 2 \"",
      "option_b": "\"1 2 3 \"",
      "option_c": "\"0 1 2 3 \"",
      "option_d": "무한 반복",
      "correct_answer": "A",
      "explanation": "i가 0부터 시작해서 3보다 작은 동안 반복됩니다. i가 0일 때 \"0 \", i가 1일 때 \"1 \", i가 2일 때 \"2 \"가 추가되고, i가 3이 되면 조건이 거짓이 되어 반복이 종료됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:38:41.000Z"
    },
    {
      "id": 320,
      "subject_id": 1,
      "question": "Do While 반복문의 특징은 무엇인가요?\n\n```javascript\ndo {\n    // 코드 블록\n} while (condition);\n```",
      "option_a": "조건을 먼저 확인한 후 실행",
      "option_b": "최소 한 번은 실행된 후 조건을 확인",
      "option_c": "무조건 두 번 실행됨",
      "option_d": "while 반복문과 완전히 동일함",
      "correct_answer": "B",
      "explanation": "Do While 반복문은 코드 블록을 먼저 실행한 후에 조건을 확인합니다. 따라서 조건이 처음부터 거짓이어도 최소 한 번은 실행됩니다. 이것이 일반 while 반복문과의 차이점입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T05:39:34.000Z"
    },
    {
      "id": 321,
      "subject_id": 1,
      "question": "다음 코드에서 발생할 수 있는 문제는?\n\n```javascript\nlet i = 0;\nwhile (i < 10) {\n    console.log(\"The number is \" + i);\n    // i++; 이 줄이 누락됨\n}\n```",
      "option_a": "문법 오류가 발생함",
      "option_b": "한 번도 실행되지 않음",
      "option_c": "무한 반복이 발생하여 브라우저가 멈출 수 있음",
      "option_d": "정상적으로 10번 실행됨",
      "correct_answer": "C",
      "explanation": "`i++` 구문이 누락되어 i 값이 계속 0으로 유지됩니다. 따라서 `i < 10` 조건이 항상 참이 되어 무한 반복이 발생합니다. 이는 브라우저를 멈추게 할 수 있는 심각한 문제입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T05:40:30.000Z"
    },
    {
      "id": 322,
      "subject_id": 1,
      "question": "다음 Do While 반복문의 실행 결과를 예측해보세요.\n\n```javascript\nlet i = 10;\nlet count = 0;\ndo {\n    count++;\n} while (i < 5);\nconsole.log(count);\n```",
      "option_a": "0",
      "option_b": "1",
      "option_c": "5",
      "option_d": "10",
      "correct_answer": "B",
      "explanation": "Do While 반복문은 조건 확인 전에 먼저 코드를 실행합니다. i가 10이므로 `i < 5` 조건은 거짓이지만, 코드 블록이 먼저 한 번 실행되어 count가 1이 됩니다. 그 후 조건을 확인하고 거짓이므로 반복이 종료됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T05:41:23.000Z"
    },
    {
      "id": 323,
      "subject_id": 1,
      "question": "다음 코드의 while 반복문과 동일한 기능을 하는 for 반복문은?\n\n```javascript\nconst cars = [\"BMW\", \"Volvo\", \"Saab\"];\nlet i = 0;\nlet text = \"\";\nwhile (cars[i]) {\n    text += cars[i];\n    i++;\n}\n```",
      "option_a": "for (let i = 0; i < cars.length; i++)",
      "option_b": "for (;cars[i];)",
      "option_c": "for (let i in cars)",
      "option_d": "for (let car of cars)",
      "correct_answer": "B",
      "explanation": "빈칸에는 `while`이 들어가며, 이 while 반복문은 `cars[i]`가 존재하는 동안 실행됩니다. 동일한 로직의 for 반복문은 `for (;cars[i];)`입니다. 초기화와 증감은 for문 밖에서 처리하고, 조건부만 for문에서 확인하는 형태입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T05:43:31.000Z"
    },
    {
      "id": 324,
      "subject_id": 1,
      "question": "다음 두 코드의 차이점을 분석해보세요.\n코드 A (While):\n```javascript\nlet i = 5;\nwhile (i < 3) {\n    console.log(i);\n    i++;\n}\n```\n코드 B (Do While):\n```javascript\nlet i = 5;\ndo {\n    console.log(i);\n    i++;\n} while (i < 3);\n```",
      "option_a": "둘 다 아무것도 출력하지 않음",
      "option_b": "A는 아무것도 출력하지 않고, B는 5를 출력함",
      "option_c": "A는 5를 출력하고, B는 아무것도 출력하지 않음",
      "option_d": "둘 다 5를 출력함",
      "correct_answer": "B",
      "explanation": "코드 A에서는 조건 `i < 3`을 먼저 확인하는데, i가 5이므로 조건이 거짓이어서 한 번도 실행되지 않습니다. 코드 B에서는 조건 확인 전에 먼저 실행하므로 5가 출력된 후, 조건을 확인하고 거짓이므로 종료됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T05:44:51.000Z"
    },
    {
      "id": 325,
      "subject_id": 1,
      "question": "다음 코드의 최종 출력 결과는?\n```javascript\nlet text = \"\";\nlet i = 0;\nwhile (i < 3) {\n    text += \"<br>Number: \" + i;\n    i++;\n}\ndocument.getElementById(\"demo\").innerHTML = text;\n```\nHTML에서 실제로 보이는 모습은?",
      "option_a": "`<br>Number: 0<br>Number: 1<br>Number: 2`",
      "option_b": "`Number: 0` (다음 줄) `Number: 1` (다음 줄) `Number: 2`",
      "option_c": "`Number: 0 Number: 1 Number: 2` (한 줄에)",
      "option_d": "아무것도 표시되지 않음",
      "correct_answer": "B",
      "explanation": "`innerHTML`에 `<br>` 태그가 포함된 문자열이 삽입되면, 브라우저는 이를 실제 HTML로 해석합니다. <br> 태그는 줄바꿈을 의미하므로, \"Number: 0\" 다음에 줄바꿈이 일어나고, 그 다음 줄에 \"Number: 1\", 또 다음 줄에 \"Number: 2\"가 표시됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T05:46:40.000Z"
    },
    {
      "id": 326,
      "subject_id": 1,
      "question": "`break` 문의 기능은 무엇인가요?",
      "option_a": "반복문을 일시 정지시킨다",
      "option_b": "반복문에서 완전히 빠져나온다",
      "option_c": "반복문의 한 번의 반복을 건너뛴다",
      "option_d": "반복문을 처음부터 다시 시작한다",
      "correct_answer": "B",
      "explanation": "`break` 문은 반복문에서 완전히 \"빠져나오는(jumps out)\" 기능을 합니다. break 문을 만나면 반복문이 즉시 종료되고, 반복문 다음 코드로 실행이 이어집니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:48:51.000Z"
    },
    {
      "id": 327,
      "subject_id": 1,
      "question": "`continue` 문의 기능은 무엇인가요?",
      "option_a": "반복문을 완전히 종료한다",
      "option_b": "반복문에서 한 번의 반복을 건너뛰고 다음 반복으로 넘어간다",
      "option_c": "반복문을 일시 정지시킨다",
      "option_d": "반복문을 처음부터 다시 시작한다",
      "correct_answer": "B",
      "explanation": "`continue` 문은 현재 반복을 \"건너뛰고(jumps over)\" 다음 반복으로 바로 넘어갑니다. 반복문 자체는 계속 실행되지만, continue 이후의 코드는 실행되지 않고 다음 반복으로 이동합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:49:33.000Z"
    },
    {
      "id": 328,
      "subject_id": 1,
      "question": "다음 코드에서 반복문을 완전히 종료하기 위해 빈칸에 들어갈 올바른 키워드는?\n```javascript\nfor (let i = 0; i < 10; i++) {\n    if (i === 5) { _____; }\n    console.log(i);\n}\n```",
      "option_a": "continue",
      "option_b": "break",
      "option_c": "stop",
      "option_d": "exit",
      "correct_answer": "B",
      "explanation": "반복문을 완전히 종료하려면 `break` 키워드를 사용해야 합니다. i가 5일 때 break가 실행되어 반복문이 종료되고, 0, 1, 2, 3, 4만 출력됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:50:39.000Z"
    },
    {
      "id": 329,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nlet result = \"\";\nfor (let i = 0; i < 5; i++) {\n    if (i === 2) { break; }\n    result += i + \" \";\n}\nconsole.log(result);\n```",
      "option_a": "\"0 1 2 3 4 \"",
      "option_b": "\"0 1 \"",
      "option_c": "\"0 1 3 4 \"",
      "option_d": "\"2 3 4 \"",
      "correct_answer": "B",
      "explanation": "i가 2일 때 `break`가 실행되어 반복문이 완전히 종료됩니다. 따라서 i가 0일 때 \"0 \", i가 1일 때 \"1 \"이 추가되고, i가 2가 되는 순간 break로 인해 반복문이 끝납니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T05:51:23.000Z"
    },
    {
      "id": 330,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nlet result = \"\";\nfor (let i = 0; i < 5; i++) {\n    if (i === 2) { continue; }\n    result += i + \" \";\n}\nconsole.log(result);\n```",
      "option_a": "\"0 1 \"",
      "option_b": "\"0 1 2 3 4 \"",
      "option_c": "\"0 1 3 4 \"",
      "option_d": "\"2 \"",
      "correct_answer": "C",
      "explanation": "`continue`는 현재 반복만 건너뛰고 다음 반복으로 넘어갑니다. i가 2일 때 continue가 실행되어 `result += i + \" \"` 부분을 건너뛰고 다음 반복(i=3)으로 이동합니다. 따라서 2만 제외되고 \"0 1 3 4 \"가 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T05:52:18.000Z"
    },
    {
      "id": 331,
      "subject_id": 1,
      "question": "다음 코드에서 홀수만 출력하기 위해 빈칸에 들어갈 내용은?\n```javascript\nfor (let i = 0; i < 10; i++) {\n    if (i % 2 === 0) { _____; }\n    console.log(\"홀수: \" + i);\n}\n```",
      "option_a": "break",
      "option_b": "continue",
      "option_c": "return",
      "option_d": "skip",
      "correct_answer": "B",
      "explanation": "`i % 2 === 0`은 짝수를 의미합니다. 짝수일 때 `continue`를 사용하면 `console.log` 부분을 건너뛰고 다음 반복으로 넘어가므로, 결과적으로 홀수만 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T05:53:36.000Z"
    },
    {
      "id": 332,
      "subject_id": 1,
      "question": "JavaScript에서 레이블(label)의 문법은?\n```javascript\n_____: {\n    // 코드 블록\n}\n```",
      "option_a": "label(name)",
      "option_b": "[labelname]",
      "option_c": "labelname:",
      "option_d": "#labelname",
      "correct_answer": "C",
      "explanation": "JavaScript에서 레이블은 `labelname:` 형식으로 작성합니다. 레이블 이름 뒤에 콜론(:)을 붙여서 코드 블록이나 문장을 표시합니다. 이후 `break labelname` 또는 `continue labelname`으로 해당 레이블을 참조할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T05:54:36.000Z"
    },
    {
      "id": 333,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과를 예측해보세요.\n```javascript\nconst cars = [\"BMW\", \"Volvo\", \"Saab\", \"Ford\"];\nlet text = \"\";\nlist: {\n    text += cars[0] + \" \";\n    text += cars[1] + \" \";\n    break list;\n    text += cars[2] + \" \";\n    text += cars[3] + \" \";\n}\nconsole.log(text);\n```",
      "option_a": "\"BMW Volvo Saab Ford \"",
      "option_b": "\"BMW Volvo \"",
      "option_c": "\"Saab Ford \"",
      "option_d": "\"\"",
      "correct_answer": "B",
      "explanation": "레이블이 있는 코드 블록에서 `break list`가 실행되면 해당 레이블의 코드 블록을 완전히 빠져나옵니다. 따라서 \"BMW \"와 \"Volvo \"가 추가된 후 break에 의해 코드 블록이 종료되어, 나머지 두 줄은 실행되지 않습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T05:55:28.000Z"
    },
    {
      "id": 334,
      "subject_id": 1,
      "question": "다음 중첩 반복문에서의 실행 결과는?\n```javascript\nlet result = \"\";\nouter: for (let i = 0; i < 3; i++) {\n    for (let j = 0; j < 3; j++) {\n        if (i === 1 && j === 1) { break outer; }\n        result += i + \",\" + j + \" \";\n    }\n}\nconsole.log(result);\n```",
      "option_a": "\"0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2 \"",
      "option_b": "\"0,0 0,1 0,2 1,0 \"",
      "option_c": "\"0,0 0,1 0,2 1,0 1,2 2,0 2,1 2,2 \"",
      "option_d": "\"1,1 \"",
      "correct_answer": "B",
      "explanation": "`break outer`는 outer 레이블이 붙은 바깥쪽 반복문을 완전히 종료시킵니다. i가 0일 때는 정상적으로 j=0,1,2가 모두 실행되어 \"0,0 0,1 0,2 \"가 추가됩니다. i가 1이고 j가 1일 때 `break outer`가 실행되어 전체 이중 반복문이 종료되므로, 최종 결과는 \"0,0 0,1 0,2 1,0 \"입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T05:56:19.000Z"
    },
    {
      "id": 335,
      "subject_id": 1,
      "question": "다음 코드에서 `continue`와 `break`의 사용 제한에 대한 설명 중 올바른 것은?\n```javascript\n// 코드 예시들\nfunction example() {\n    for (let i = 0; i < 5; i++) {\n        if (i === 2) continue;  // A\n        console.log(i);\n    }\n    \n    if (true) {\n        break;  // B\n    }\n    \n    switch(1) {\n        case 1: break;  // C\n    }\n}\n```",
      "option_a": "A, B, C 모두 올바른 사용법이다",
      "option_b": "A와 C는 올바르지만, B는 잘못된 사용법이다",
      "option_c": "A만 올바른 사용법이다",
      "option_d": "B와 C만 올바른 사용법이다",
      "correct_answer": "B",
      "explanation": "`continue`는 반복문 안에서만 사용할 수 있고(A 올바름), `break`는 반복문이나 switch 문에서만 사용할 수 있습니다(C 올바름). 하지만 일반적인 if 문에서는 break를 사용할 수 없습니다(B 잘못됨). break는 레이블과 함께 사용할 때만 코드 블록을 빠져나올 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T05:57:32.000Z"
    },
    {
      "id": 336,
      "subject_id": 1,
      "question": "JavaScript Set의 가장 중요한 특징은 무엇인가요?",
      "option_a": "값들을 순서대로 저장한다",
      "option_b": "중복된 값을 허용하지 않는다",
      "option_c": "숫자만 저장할 수 있다",
      "option_d": "최대 10개의 값만 저장할 수 있다",
      "correct_answer": "B",
      "explanation": "JavaScript Set의 핵심 특징은 \"unique values의 집합\"이라는 것입니다. 즉, 같은 값이 여러 번 추가되어도 Set에는 단 한 번만 저장됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T06:07:59.000Z"
    },
    {
      "id": 337,
      "subject_id": 1,
      "question": "새로운 Set을 생성하는 방법이 아닌 것은?",
      "option_a": "new Set([\"a\", \"b\", \"c\"])",
      "option_b": "new Set()",
      "option_c": "Set.create()",
      "option_d": "빈 Set을 만들고 `add()` 메서드 사용",
      "correct_answer": "C",
      "explanation": "JavaScript에서는 `Set.create()`라는 메서드가 존재하지 않습니다. Set을 생성하는 올바른 방법은 `new Set()` 생성자를 사용하는 것입니다. 배열을 전달하거나, 빈 Set을 만든 후 `add()` 메서드로 값을 추가할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T06:09:20.000Z"
    },
    {
      "id": 338,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst letters = new Set();\nletters.add(\"a\");\nletters.add(\"b\");\nletters.add(\"c\");\nconsole.log(letters.size);\n```",
      "option_a": "0",
      "option_b": "2",
      "option_c": "3",
      "option_d": "undefined",
      "correct_answer": "C",
      "explanation": "빈 Set에 \"a\", \"b\", \"c\" 세 개의 서로 다른 값을 추가했으므로, Set의 크기는 3이 됩니다. `size` 속성을 사용하여 Set에 포함된 요소의 개수를 확인할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T06:10:27.000Z"
    },
    {
      "id": 339,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst letters = new Set();\nletters.add(\"a\");\nletters.add(\"b\");\nletters.add(\"c\");\nletters.add(\"c\");\nletters.add(\"c\");\nconsole.log(letters.size);\n```",
      "option_a": "3",
      "option_b": "5",
      "option_c": "6",
      "option_d": "오류 발생",
      "correct_answer": "A",
      "explanation": "Set은 중복된 값을 허용하지 않습니다. \"c\"를 여러 번 추가하더라도 Set에는 단 한 번만 저장됩니다. 따라서 실제로는 \"a\", \"b\", \"c\" 세 개의 값만 저장되어 size는 3이 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T06:12:02.000Z"
    },
    {
      "id": 340,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 코드는?\n```javascript\nconst letters = new Set([\"a\", \"b\", \"c\"]);\nlet text = \"\";\nfor (const x _____ letters) {\n    text += x;\n}\n```",
      "option_a": "in",
      "option_b": "of",
      "option_c": "on",
      "option_d": "from",
      "correct_answer": "B",
      "explanation": "Set의 값들을 순회하려면 `for...of` 루프를 사용해야 합니다. `for...in`은 객체의 속성을 순회할 때 사용되고, `for...of`는 이터러블 객체(배열, Set, Map 등)의 값들을 순회할 때 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T06:13:16.000Z"
    },
    {
      "id": 341,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst letters = new Set([\"a\", \"b\", \"c\"]);\nconsole.log(typeof letters);\n```",
      "option_a": "\"set\"",
      "option_b": "\"array\"",
      "option_c": "\"object\"",
      "option_d": "\"collection\"",
      "correct_answer": "C",
      "explanation": "JavaScript에서 Set은 기본적으로 객체(object)입니다. `typeof` 연산자는 Set에 대해 \"object\"를 반환합니다. 이는 배열이나 다른 복합 데이터 타입들과 마찬가지입니다. Set임을 확인하려면 `instanceof Set`을 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T06:14:18.000Z"
    },
    {
      "id": 342,
      "subject_id": 1,
      "question": "Set이 실제로 Set 객체인지 확인하는 올바른 방법은?\n```javascript\nconst letters = new Set([\"a\", \"b\", \"c\"]);\n```",
      "option_a": "typeof letters === \"set\"",
      "option_b": "letters.isSet()",
      "option_c": "letters instanceof Set",
      "option_d": "letters.constructor === \"Set\"",
      "correct_answer": "C",
      "explanation": "`instanceof` 연산자를 사용하여 객체가 특정 클래스의 인스턴스인지 확인할 수 있습니다. `letters instanceof Set`은 `true`를 반환합니다. `typeof`는 모든 객체에 대해 \"object\"를 반환하므로 Set을 구별할 수 없습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T06:15:43.000Z"
    },
    {
      "id": 343,
      "subject_id": 1,
      "question": "다음 코드에서 변수들을 Set에 추가한 후의 결과는?\n```javascript\nconst letters = new Set();\nconst a = \"a\";\nconst b = \"b\";\nconst c = \"c\";\nconst d = \"a\"; // 주목: 값이 \"a\"\n\nletters.add(a);\nletters.add(b);\nletters.add(c);\nletters.add(d);\n\nconsole.log(letters.size);\n```",
      "option_a": "3",
      "option_b": "4",
      "option_c": "오류 발생",
      "option_d": "undefined",
      "correct_answer": "A",
      "explanation": "Set은 값의 유일성을 보장합니다. 변수 `a`와 `d` 모두 \"a\"라는 같은 값을 가지고 있으므로, Set에는 \"a\" 값이 한 번만 저장됩니다. 따라서 실제로는 \"a\", \"b\", \"c\" 세 개의 고유한 값만 저장되어 size는 3이 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T06:17:01.000Z"
    },
    {
      "id": 344,
      "subject_id": 1,
      "question": "다음 코드의 출력 결과는?\n```javascript\nconst numbers = new Set([1, 2, 3, 1, \"1\"]);\nconsole.log(numbers.size);\n```",
      "option_a": "3",
      "option_b": "4",
      "option_c": "5",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "Set에서는 값의 타입도 고려하여 유일성을 판단합니다. 숫자 `1`과 문자열 `\"1\"`은 서로 다른 타입이므로 별개의 값으로 취급됩니다. 따라서 1(숫자), 2, 3, \"1\"(문자열) 총 4개의 고유한 값이 저장됩니다. 중복된 숫자 1은 한 번만 저장됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T06:18:18.000Z"
    },
    {
      "id": 345,
      "subject_id": 1,
      "question": "Set에 저장할 수 있는 값의 타입에 대한 설명으로 올바른 것은?",
      "option_a": "문자열과 숫자만 저장 가능하다",
      "option_b": "원시 타입(primitive)만 저장 가능하다",
      "option_c": "배열과 함수는 저장할 수 없다",
      "option_d": "원시 값과 객체 모든 타입을 저장할 수 있다",
      "correct_answer": "D",
      "explanation": "JavaScript Set은 문자열, 숫자, 불린값 등의 원시 타입뿐만 아니라 객체, 배열, 함수 등 모든 종류의 값을 저장할 수 있습니다. 이는 Set의 매우 유연한 특징 중 하나입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T06:19:14.000Z"
    },
    {
      "id": 346,
      "subject_id": 1,
      "question": "JavaScript Map 객체의 특징으로 올바른 것은?",
      "option_a": "키는 반드시 문자열이어야 한다",
      "option_b": "키-값 쌍을 저장하며, 키는 모든 데이터 타입이 가능하다",
      "option_c": "값만 저장할 수 있다",
      "option_d": "배열과 동일한 기능을 한다",
      "correct_answer": "B",
      "explanation": "Map 객체는 키-값 쌍(key-value pairs)을 저장하는 자료구조입니다. 일반 객체와 달리 키로 모든 데이터 타입(문자열, 숫자, 객체, 함수 등)을 사용할 수 있습니다. 이것이 Map의 가장 큰 특징 중 하나입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T06:47:41.000Z"
    },
    {
      "id": 347,
      "subject_id": 1,
      "question": "Map을 생성하는 방법이 아닌 것은?",
      "option_a": "`new Map()` 생성자 사용",
      "option_b": "배열을 `new Map()`에 전달",
      "option_c": "`Map.set()` 메서드로 요소 추가",
      "option_d": "`Map.create()` 메서드 사용",
      "correct_answer": "D",
      "explanation": "JavaScript에서 Map을 생성하는 방법은 `new Map()` 생성자를 사용하거나, 배열을 `new Map()`에 전달하는 방법입니다. `set()` 메서드는 요소를 추가하는 방법입니다. `Map.create()`라는 메서드는 존재하지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T06:49:13.000Z"
    },
    {
      "id": 348,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 메서드는?\n```javascript\nconst fruits = new Map();\nfruits.___(\"apples\", 500);\nfruits.___(\"bananas\", 300);\n```",
      "option_a": "add",
      "option_b": "put",
      "option_c": "set",
      "option_d": "insert",
      "correct_answer": "C",
      "explanation": "Map에 키-값 쌍을 추가하거나 수정할 때는 `set()` 메서드를 사용합니다. `set()` 메서드는 첫 번째 매개변수로 키를, 두 번째 매개변수로 값을 받습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T06:50:16.000Z"
    },
    {
      "id": 349,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst fruits = new Map([\n    [\"apples\", 500],\n    [\"bananas\", 300]\n]);\nconsole.log(fruits.get(\"apples\"));\n```",
      "option_a": "undefined",
      "option_b": "500",
      "option_c": "\"apples\"",
      "option_d": "[\"apples\", 500]",
      "correct_answer": "B",
      "explanation": "`get()` 메서드는 지정된 키에 해당하는 값을 반환합니다. \"apples\" 키의 값은 500이므로 500이 출력됩니다. `get()` 메서드는 키-값 쌍이 아닌 값만 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T06:51:15.000Z"
    },
    {
      "id": 350,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst fruits = new Map([[\"apples\", 500]]);\nfruits.set(\"apples\", 200);\nconsole.log(fruits.get(\"apples\"));\n```",
      "option_a": "500",
      "option_b": "200",
      "option_c": "[500, 200]",
      "option_d": "700",
      "correct_answer": "B",
      "explanation": "`set()` 메서드는 새로운 키-값 쌍을 추가할 뿐만 아니라 기존 키의 값을 변경하는 데도 사용됩니다. \"apples\" 키가 이미 존재하므로 기존 값 500이 200으로 변경되어 200이 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T06:52:07.000Z"
    },
    {
      "id": 351,
      "subject_id": 1,
      "question": "`typeof` 연산자를 Map에 사용했을 때의 결과는?\n```javascript\nconst myMap = new Map();\nconsole.log(typeof myMap);\n```",
      "option_a": "\"map\"",
      "option_b": "\"Map\"",
      "option_c": "\"object\"",
      "option_d": "\"function\"",
      "correct_answer": "C",
      "explanation": "JavaScript에서 Map은 객체의 한 종류이므로 `typeof` 연산자는 \"object\"를 반환합니다. Map인지 정확히 확인하려면 `instanceof Map` 연산자를 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T06:53:08.000Z"
    },
    {
      "id": 352,
      "subject_id": 1,
      "question": "Map이 일반 객체보다 가지는 장점이 아닌 것은?\n```javascript\nconst obj = {name: \"John\"};\nconst map = new Map([[\"name\", \"John\"]]);\n```",
      "option_a": "키로 모든 데이터 타입 사용 가능",
      "option_b": "직접적으로 반복(iterable) 가능",
      "option_c": "size 속성으로 크기 확인 가능",
      "option_d": "메모리 사용량이 항상 더 적음",
      "correct_answer": "D",
      "explanation": "Map의 장점은 키로 모든 데이터 타입 사용 가능, 직접 반복 가능, size 속성 제공, 삽입 순서 보장 등입니다. 하지만 메모리 사용량은 상황에 따라 다르며, 항상 Map이 더 적은 메모리를 사용하는 것은 아닙니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T06:54:09.000Z"
    },
    {
      "id": 353,
      "subject_id": 1,
      "question": "다음 코드에서 `instanceof` 연산자의 결과는?\n```javascript\nconst fruits = new Map([[\"apples\", 500]]);\nconst result1 = fruits instanceof Map;\nconst result2 = fruits instanceof Object;\nconsole.log(result1, result2);\n```",
      "option_a": "false, false",
      "option_b": "true, false",
      "option_c": "false, true",
      "option_d": "true, true",
      "correct_answer": "D",
      "explanation": "Map 객체는 Map의 인스턴스이면서 동시에 Object의 인스턴스이기도 합니다. JavaScript에서 모든 객체는 Object를 상속받기 때문입니다. 따라서 `fruits instanceof Map`과 `fruits instanceof Object` 모두 true를 반환합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T06:55:09.000Z"
    },
    {
      "id": 354,
      "subject_id": 1,
      "question": "JavaScript Objects와 Maps의 차이점에 대한 설명 중 틀린 것은?",
      "option_a": "Object의 키는 문자열(또는 Symbol)이어야 하지만, Map의 키는 모든 데이터 타입 가능",
      "option_b": "Object는 직접 반복할 수 없지만, Map은 직접 반복 가능",
      "option_c": "Object는 size 속성이 없지만, Map은 size 속성이 있음",
      "option_d": "Object의 키는 삽입 순서가 보장되지만, Map의 키는 순서가 보장되지 않음",
      "correct_answer": "D",
      "explanation": "설명이 반대입니다. Object의 키는 완전히 순서가 보장되지 않는 경우가 있지만, Map의 키는 삽입 순서가 항상 보장됩니다. Map은 키들이 삽입된 순서를 기억하고 유지하는 것이 특징입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T06:55:47.000Z"
    },
    {
      "id": 355,
      "subject_id": 1,
      "question": "다음 코드의 실행 과정을 분석했을 때 올바른 설명은?\n```javascript\nconst data = new Map([\n    [\"name\", \"John\"],\n    [\"age\", 30]\n]);\ndata.set(\"name\", \"Jane\");\ndata.set(\"city\", \"Seoul\");\nconsole.log(data.get(\"name\"), data.size);\n```",
      "option_a": "`\"John\", 2` 출력",
      "option_b": "`\"Jane\", 2` 출력",
      "option_c": "`\"Jane\", 3` 출력",
      "option_d": "`\"John\", 3` 출력",
      "correct_answer": "C",
      "explanation": "처음에 \"name\"과 \"age\" 두 개의 키-값 쌍이 있습니다. `set(\"name\", \"Jane\")`은 기존 \"name\" 키의 값을 \"Jane\"으로 변경합니다(크기는 그대로). `set(\"city\", \"Seoul\")`은 새로운 키-값 쌍을 추가합니다(크기가 3이 됨). 따라서 최종적으로 \"Jane\", 3이 출력됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T06:56:58.000Z"
    },
    {
      "id": 356,
      "subject_id": 1,
      "question": "Typed Arrays의 주요 특징으로 올바른 것은?",
      "option_a": "다양한 데이터 타입을 혼합해서 저장할 수 있다",
      "option_b": "동적으로 크기를 변경할 수 있다",
      "option_c": "고정된 길이와 고정된 타입의 요소를 저장한다",
      "option_d": "일반 배열과 완전히 동일하다",
      "correct_answer": "C",
      "explanation": " Typed Arrays는 고정된 길이(fixed length)와 고정된 타입의 요소들을 저장하는 배열 버퍼입니다. 일반 배열과 달리 크기를 동적으로 변경할 수 없고, 지정된 데이터 타입만 저장할 수 있습니다. 이는 바이너리 데이터를 효율적으로 처리하기 위한 설계입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T06:58:46.000Z"
    },
    {
      "id": 357,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 생성자는?\n```javascript\n// 10개의 8비트 부호있는 정수 배열 생성\nconst myArr = new _____(10);\n```",
      "option_a": "Array",
      "option_b": "Int8Array",
      "option_c": "Number",
      "option_d": "Buffer",
      "correct_answer": "B",
      "explanation": "`Int8Array`는 8비트 부호있는 정수(-128~127 범위)를 저장하는 Typed Array입니다. 생성자에 숫자를 전달하면 해당 크기만큼의 배열이 생성되며, 모든 요소는 0으로 초기화됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T06:59:36.000Z"
    },
    {
      "id": 358,
      "subject_id": 1,
      "question": "Typed Arrays가 언제 JavaScript에 도입되었나요?",
      "option_a": "ECMAScript 2009 (ES5)",
      "option_b": "ECMAScript 2015 (ES6)",
      "option_c": "ECMAScript 2017 (ES8)",
      "option_d": "ECMAScript 2020 (ES11)",
      "correct_answer": "B",
      "explanation": "Typed Arrays는 ECMAScript 2015(ES6) 사양의 일부로 2015년 6월에 도입되었습니다. 바이너리 데이터를 효율적으로 처리하기 위한 필요에 의해 추가된 기능입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:00:09.000Z"
    },
    {
      "id": 359,
      "subject_id": 1,
      "question": "다음 중 8비트 Typed Array가 아닌 것은?",
      "option_a": "Int8Array",
      "option_b": "Uint8Array",
      "option_c": "Uint8ClampedArray",
      "option_d": "Int16Array",
      "correct_answer": "D",
      "explanation": "`Int16Array`는 16비트(2바이트) 부호있는 정수를 저장하는 배열입니다. 나머지 세 개(`Int8Array`, `Uint8Array`, `Uint8ClampedArray`)는 모두 8비트(1바이트) 정수를 저장하는 배열입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:00:55.000Z"
    },
    {
      "id": 360,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst arr = new Int8Array(5);\nconsole.log(arr.length);\nconsole.log(arr[0]);\n```",
      "option_a": "undefined, undefined",
      "option_b": "5, undefined",
      "option_c": "5, 0",
      "option_d": "0, 0",
      "correct_answer": "C",
      "explanation": "`Int8Array(5)`는 길이가 5인 배열을 생성하고, 모든 요소를 0으로 초기화합니다. 따라서 `length`는 5이고, 첫 번째 요소 `arr[0]`은 0입니다. Typed Arrays는 생성 시 항상 0으로 초기화됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:01:46.000Z"
    },
    {
      "id": 361,
      "subject_id": 1,
      "question": "`Uint8Array`와 `Uint8ClampedArray`의 차이점은?\n```javascript\nconst arr1 = new Uint8Array(1);\nconst arr2 = new Uint8ClampedArray(1);\narr1[0] = 300;\narr2[0] = 300;\n```",
      "option_a": "둘 다 300을 저장한다",
      "option_b": "arr1은 44, arr2는 255를 저장한다",
      "option_c": "arr1은 255, arr2는 44를 저장한다",
      "option_d": "둘 다 오류가 발생한다",
      "correct_answer": "B",
      "explanation": "`Uint8Array`는 0-255 범위를 벗어나는 값에 대해 하위 8비트만 사용합니다(300의 하위 8비트는 44). 반면 `Uint8ClampedArray`는 범위를 벗어나는 값을 0 또는 255로 고정(clamp)합니다. 따라서 300은 255로 제한됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:02:43.000Z"
    },
    {
      "id": 362,
      "subject_id": 1,
      "question": "다음 코드에서 `BYTES_PER_ELEMENT`의 값은?\n```javascript\nconst arr = new Int32Array(10);\nconsole.log(arr.BYTES_PER_ELEMENT);\n```",
      "option_a": "1",
      "option_b": "2",
      "option_c": "4",
      "option_d": "8",
      "correct_answer": "C",
      "explanation": "`Int32Array`는 32비트(4바이트) 부호있는 정수를 저장합니다. `BYTES_PER_ELEMENT`는 각 요소가 차지하는 바이트 수를 나타내므로 4를 반환합니다. 32비트 = 4바이트입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:03:34.000Z"
    },
    {
      "id": 363,
      "subject_id": 1,
      "question": "다음 중 Typed Arrays의 주요 사용 사례가 아닌 것은?",
      "option_a": "WebGL과 Canvas에서의 빠른 그래픽 렌더링",
      "option_b": "File API에서의 빠른 파일 읽기/쓰기",
      "option_c": "일반적인 웹페이지 DOM 조작",
      "option_d": "WebSocket을 통한 효율적인 바이너리 데이터 전송",
      "correct_answer": "C",
      "explanation": " Typed Arrays는 바이너리 데이터를 효율적으로 처리하기 위해 설계되었습니다. WebGL/Canvas의 그래픽 처리, File API의 파일 처리, Media API의 오디오/비디오 처리, WebSocket의 바이너리 데이터 전송 등에 특화되어 있습니다. 일반적인 DOM 조작에는 적합하지 않습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:05:47.000Z"
    },
    {
      "id": 364,
      "subject_id": 1,
      "question": "다음 코드 분석에서 올바른 설명은?\n```javascript\nconst buffer = new ArrayBuffer(16);\nconst view1 = new Int8Array(buffer);\nconst view2 = new Int32Array(buffer);\nconsole.log(view1.length, view2.length);\n```",
      "option_a": "`16, 16` 출력",
      "option_b": "`16, 4` 출력",
      "option_c": "`4, 16` 출력",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "16바이트 크기의 ArrayBuffer를 생성했습니다. `Int8Array`는 1바이트씩 사용하므로 16개 요소, `Int32Array`는 4바이트씩 사용하므로 4개 요소를 가집니다. 같은 메모리 공간을 서로 다른 방식으로 해석하는 것이 Typed Arrays의 핵심 개념입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:07:36.000Z"
    },
    {
      "id": 365,
      "subject_id": 1,
      "question": "Iterable 객체의 정의로 올바른 것은?",
      "option_a": "숫자만 저장할 수 있는 객체",
      "option_b": "for..of 반복문으로 반복할 수 있는 객체",
      "option_c": "함수만 저장할 수 있는 객체",
      "option_d": "오직 배열만 해당하는 객체",
      "correct_answer": "B",
      "explanation": "Iterable 객체는 `for..of` 반복문을 사용하여 요소들을 순차적으로 반복할 수 있는 객체를 의미합니다. 이는 JavaScript에서 반복 가능한 모든 데이터 구조의 공통 특징입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:09:58.000Z"
    },
    {
      "id": 366,
      "subject_id": 1,
      "question": "다음 중 JavaScript에서 기본적으로 iterable한 객체가 아닌 것은?",
      "option_a": "String",
      "option_b": "Array",
      "option_c": "Set",
      "option_d": "일반 Object (`{}`)",
      "correct_answer": "D",
      "explanation": "JavaScript에서 기본적으로 iterable한 객체는 String, Array, Typed Arrays, Set, Map입니다. 일반 객체(`{}`)는 기본적으로 iterable하지 않으며, `for..of`를 직접 사용할 수 없습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:11:05.000Z"
    },
    {
      "id": 367,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 키워드는?\n```javascript\nconst letters = [\"a\", \"b\", \"c\"];\nfor (const x _____ letters) {\n    console.log(x);\n}\n```",
      "option_a": "in",
      "option_b": "of",
      "option_c": "from",
      "option_d": "with",
      "correct_answer": "B",
      "explanation": "Iterable 객체를 반복할 때는 `for..of` 구문을 사용합니다. `of` 키워드를 사용하여 배열의 각 요소값(\"a\", \"b\", \"c\")을 순차적으로 가져옵니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:12:15.000Z"
    },
    {
      "id": 368,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst name = \"Hi\";\nlet result = \"\";\nfor (const char of name) {\n    result += char + \"-\";\n}\nconsole.log(result);\n```",
      "option_a": "\"Hi-\"",
      "option_b": "\"H-i-\"",
      "option_c": "\"H-I-\"",
      "option_d": "\"Hi--\"",
      "correct_answer": "B",
      "explanation": "문자열은 iterable 객체이므로 `for..of`로 각 문자를 개별적으로 반복할 수 있습니다. \"Hi\"는 \"H\"와 \"i\" 두 문자로 나뉘어 처리되며, 각 문자 뒤에 \"-\"가 추가되어 \"H-i-\"가 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:13:15.000Z"
    },
    {
      "id": 369,
      "subject_id": 1,
      "question": "Map 객체를 `for..of`로 반복할 때 얻는 값의 형태는?\n```javascript\nconst fruits = new Map([\n    [\"apple\", 100],\n    [\"banana\", 200]\n]);\nfor (const x of fruits) {\n    console.log(x);\n}\n```",
      "option_a": "키만 출력: `\"apple\", \"banana\"`",
      "option_b": "값만 출력: `100, 200`",
      "option_c": "키-값 배열 출력: `[\"apple\", 100], [\"banana\", 200]`",
      "option_d": "문자열 출력: `\"apple:100\", \"banana:200\"`",
      "correct_answer": "C",
      "explanation": " Map 객체를 `for..of`로 반복하면 각 반복에서 `[키, 값]` 형태의 배열을 반환합니다. 따라서 `[\"apple\", 100]`과 `[\"banana\", 200]`이 순차적으로 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:14:52.000Z"
    },
    {
      "id": 370,
      "subject_id": 1,
      "question": "Iterator의 `next()` 메서드가 반환해야 하는 객체의 필수 속성은?\n\n```javascript\nfunction myIterator() {\n    return {\n        next: function() {\n            return { _____, _____ };\n        }\n    };\n}\n```",
      "option_a": "key, data",
      "option_b": "value, done",
      "option_c": "item, finished",
      "option_d": "result, complete",
      "correct_answer": "B",
      "explanation": "Iterator의 `next()` 메서드는 반드시 `value`(다음 값)와 `done`(완료 여부를 나타내는 boolean) 속성을 가진 객체를 반환해야 합니다. 이는 Iterator 프로토콜의 핵심 규칙입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:16:01.000Z"
    },
    {
      "id": 371,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 심볼은?\n```javascript\nconst myObject = {};\nmyObject[_____] = function() {\n    return {\n        next: function() {\n            return {value: 1, done: true};\n        }\n    };\n};\n```",
      "option_a": "Symbol.iterate",
      "option_b": "Symbol.iterator",
      "option_c": "Symbol.next",
      "option_d": "Symbol.next",
      "correct_answer": "B",
      "explanation": "객체를 iterable하게 만들려면 `Symbol.iterator` 메서드를 구현해야 합니다. 이 메서드는 Iterator 객체를 반환해야 하며, `for..of` 구문에서 자동으로 호출됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:17:09.000Z"
    },
    {
      "id": 372,
      "subject_id": 1,
      "question": "다음 홈메이드 Iterator의 실행 결과는?\n```javascript\nfunction myNumbers() {\n    let n = 0;\n    return {\n        next: function() {\n            n += 10;\n            return {value: n, done: false};\n        }\n    };\n}\nconst iterator = myNumbers();\nconsole.log(iterator.next().value);\nconsole.log(iterator.next().value);\nconsole.log(iterator.next().value);\n```",
      "option_a": "10, 10, 10",
      "option_b": "10, 20, 30",
      "option_c": "0, 10, 20",
      "option_d": "1, 2, 3",
      "correct_answer": "B",
      "explanation": "이 Iterator는 호출될 때마다 n을 10씩 증가시키고 그 값을 반환합니다. 첫 번째 호출에서 n=10, 두 번째에서 n=20, 세 번째에서 n=30이 됩니다. `done`이 항상 false이므로 무한히 값을 생성할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:18:18.000Z"
    },
    {
      "id": 373,
      "subject_id": 1,
      "question": "다음 코드에서 객체가 `for..of`와 호환되도록 만드는 올바른 구현은?\n```javascript\nmyNumbers = {};\nmyNumbers[Symbol.iterator] = function() {\n    let n = 0;\n    return {\n        next() {\n            n += 10;\n            if (n == 100) { _____ }\n            return {value: n, done: _____};\n        }\n    };\n};\n```",
      "option_a": "`done = true`, `done`",
      "option_b": "`return true`, `false`",
      "option_c": "`break`, `n >= 100`",
      "option_d": "`done = false`, `true`",
      "correct_answer": "A",
      "explanation": "Iterator가 완료 조건(n == 100)에 도달했을 때 `done = true`로 설정하고, 반환 객체의 `done` 속성에 이 값을 사용해야 합니다. 이렇게 하면 `for..of`가 언제 반복을 종료해야 할지 알 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:20:01.000Z"
    },
    {
      "id": 374,
      "subject_id": 1,
      "question": "다음 두 방법의 차이점에 대한 설명 중 올바른 것은?\n```javascript\n// 방법 1\nfor (const num of myNumbers) {\n    console.log(num);\n}\n\n// 방법 2\nlet iterator = myNumbers[Symbol.iterator]();\nwhile (true) {\n    const result = iterator.next();\n    if (result.done) break;\n    console.log(result.value);\n}\n```",
      "option_a": "방법 1이 더 빠르고, 방법 2는 더 느리다",
      "option_b": "방법 1은 자동으로 Iterator를 호출하고, 방법 2는 수동으로 제어한다",
      "option_c": "방법 1은 배열만 가능하고, 방법 2는 모든 객체에 가능하다",
      "option_d": "두 방법은 완전히 다른 결과를 출력한다",
      "correct_answer": "B",
      "explanation": "방법 1(`for..of`)은 JavaScript가 자동으로 `Symbol.iterator` 메서드를 호출하고 Iterator의 `next()` 메서드를 관리합니다. 방법 2는 개발자가 직접 Iterator를 생성하고 `next()` 메서드를 호출하여 수동으로 반복을 제어하는 방식입니다. 두 방법은 같은 결과를 출력하지만, 제어 방식이 다릅니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:21:33.000Z"
    },
    {
      "id": 375,
      "subject_id": 1,
      "question": "Iterator 객체가 반드시 가져야 하는 메서드는 무엇인가요?",
      "option_a": "iterate()",
      "option_b": "next()",
      "option_c": "hasNext()",
      "option_d": "getValue()",
      "correct_answer": "B",
      "explanation": "Iterator Protocol에 따르면, Iterator 객체는 반드시 `next()` 메서드를 가져야 합니다. 이 메서드가 Iterator의 핵심 기능을 담당하며, 순차적으로 요소에 접근할 수 있게 해줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:23:21.000Z"
    },
    {
      "id": 376,
      "subject_id": 1,
      "question": "`next()` 메서드가 반환하는 객체의 두 가지 속성은 무엇인가요?",
      "option_a": "`data`와 `finished`",
      "option_b": "`value`와 `done`",
      "option_c": "`item`과 `complete`",
      "option_d": "`element`와 `end`",
      "correct_answer": "B",
      "explanation": "`next()` 메서드는 항상 두 개의 속성을 가진 객체를 반환합니다:\n\n1) `value`: 현재 iteration에서의 값\n2) `done`: 더 이상 반복할 요소가 있는지를 나타내는 불린값 (true면 끝, false면 계속)",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:24:36.000Z"
    },
    {
      "id": 377,
      "subject_id": 1,
      "question": "다음 중 JavaScript에서 기본적으로 iterable한 객체가 아닌 것은?",
      "option_a": "String",
      "option_b": "Array",
      "option_c": "Object (일반 객체)",
      "option_d": "Set",
      "correct_answer": "C",
      "explanation": "일반 Object는 기본적으로 iterable하지 않습니다. String, Array, Set, Map, Typed Arrays 등은 prototype에 `Symbol.iterator` 메서드가 구현되어 있어 iterable하지만, 일반 객체는 그렇지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:25:19.000Z"
    },
    {
      "id": 378,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 메서드는?\n```javascript\nconst myIterator = Iterator.____([1, 2, 3, 4, 5]);\n```",
      "option_a": "create",
      "option_b": "from",
      "option_c": "new",
      "option_d": "make",
      "correct_answer": "B",
      "explanation": "`Iterator.from()` 메서드는 기존의 iterable 또는 iterator 객체로부터 새로운 iterator 객체를 생성하는 ES2025의 새로운 메서드입니다. 이를 통해 배열, 문자열 등의 iterable 객체를 iterator로 변환할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:26:05.000Z"
    },
    {
      "id": 379,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst myIterator = Iterator.from([10, 5, 30, 15]);\nconst result = myIterator.filter(x => x > 10);\n// result를 for...of로 순회했을 때 출력되는 값들은?\n```",
      "option_a": "10, 30",
      "option_b": "30, 15",
      "option_c": "5, 15",
      "option_d": "10, 5, 15",
      "correct_answer": "B",
      "explanation": "`filter()` 메서드는 주어진 조건을 만족하는 요소만을 포함하는 새로운 iterator를 반환합니다. 여기서 조건은 `x > 10`이므로, 30과 15만이 이 조건을 만족합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:26:57.000Z"
    },
    {
      "id": 380,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 알맞은 메서드는?\n```javascript\nconst myIterator = Iterator.from(\"123456\");\nconst first3 = myIterator.______(3);\n```\n위 코드는 처음 3개의 요소만 가져오려고 합니다.",
      "option_a": "slice",
      "option_b": "limit",
      "option_c": "take",
      "option_d": "first",
      "correct_answer": "C",
      "explanation": "`take()` 메서드는 지정된 개수만큼의 요소만을 포함하는 새로운 iterator를 반환합니다. `take(3)`은 처음 3개의 요소만 가져옵니다. 이는 lazy evaluation으로 동작하여 메모리 효율적입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:27:59.000Z"
    },
    {
      "id": 381,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst myIterator = Iterator.from([1, 2, 3]);\nconst mapped = myIterator.flatMap(x => [x, x * 10]);\n// mapped를 순회했을 때의 결과는?\n```",
      "option_a": "[1, 10], [2, 20], [3, 30]",
      "option_b": "1, 10, 2, 20, 3, 30",
      "option_c": "1, 2, 3, 10, 20, 30",
      "option_d": "11, 22, 33",
      "correct_answer": "B",
      "explanation": "`flatMap()` 메서드는 각 요소에 대해 매핑 함수를 적용한 후, 결과를 평탄화(flatten)합니다. 각 원소 x에 대해 `[x, x * 10]` 배열이 생성되고, 이들이 하나의 iterator로 평탄화되어 `1, 10, 2, 20, 3, 30` 순서로 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:29:15.000Z"
    },
    {
      "id": 382,
      "subject_id": 1,
      "question": "다음 코드에서 `result`의 값은?\n```javascript\nconst myIterator = Iterator.from([1, 2, 3, 4, 5, 6, 7, 8]);\nconst processed = myIterator.drop(3).take(3).map(x => x * 2);\nconst result = [...processed];\n```",
      "option_a": "[2, 4, 6]",
      "option_b": "[8, 10, 12]",
      "option_c": "[6, 8, 10]",
      "option_d": "[4, 5, 6]",
      "correct_answer": "B",
      "explanation": "메서드 체이닝을 단계별로 분석하면:\n\n1) `drop(3)`: 처음 3개 요소(1,2,3)를 건너뛰고 4,5,6,7,8이 남음\n2) `take(3)`: 남은 것 중 처음 3개(4,5,6)만 가져옴\n3) `map(x => x * 2)`: 각 요소에 2를 곱함 (8,10,12)\n\n따라서 최종 결과는 `[8, 10, 12]`입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:30:50.000Z"
    },
    {
      "id": 383,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 초기값은?\n```javascript\nconst myIterator = Iterator.from([5, 10, 15]);\nconst result = myIterator.reduce((acc, curr) => acc + curr, _____);\n// result가 50이 되려면?\n```",
      "option_a": "0",
      "option_b": "10",
      "option_c": "20",
      "option_d": "5",
      "correct_answer": "C",
      "explanation": "`reduce()` 메서드는 accumulator와 현재 값을 이용해 하나의 값으로 축약합니다. 배열의 합 (5+10+15=30)에 초기값을 더한 값이 최종 결과가 됩니다. 50이 되려면 30 + 초기값 = 50이므로, 초기값은 20이어야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:31:42.000Z"
    },
    {
      "id": 384,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst myIterator = Iterator.from(\"987654321\");\nconst hasAllGreaterThan5 = myIterator.every(x => Number(x) > 5);\nconst hasSomeGreaterThan8 = Iterator.from(\"987654321\").some(x => Number(x) > 8);\n\nconsole.log(hasAllGreaterThan5, hasSomeGreaterThan8);\n```",
      "option_a": "true, true",
      "option_b": "false, true",
      "option_c": "true, false",
      "option_d": "false, false",
      "correct_answer": "B",
      "explanation": "1) `every()`: 모든 요소가 조건을 만족하는지 확인합니다. 문자열 \"987654321\"에서 '4', '3', '2', '1'은 5보다 작으므로 `false`\n2) `some()`: 하나라도 조건을 만족하는지 확인합니다. '9'가 8보다 크므로 `true`\n\n따라서 결과는 `false, true`입니다. 주의할 점은 문자열의 각 문자를 숫자로 변환해야 한다는 것입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:32:55.000Z"
    },
    {
      "id": 385,
      "subject_id": 1,
      "question": "`typeof` 연산자의 역할은 무엇인가요?",
      "option_a": "변수의 값을 변경한다",
      "option_b": "변수나 표현식의 데이터 타입을 반환한다",
      "option_c": "변수를 삭제한다",
      "option_d": "변수의 값을 복사한다",
      "correct_answer": "B",
      "explanation": "`typeof` 연산자는 JavaScript에서 변수나 표현식의 데이터 타입을 문자열로 반환하는 연산자입니다. 예를 들어 `typeof \"Hello\"`는 \"string\"을 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:34:57.000Z"
    },
    {
      "id": 386,
      "subject_id": 1,
      "question": "JavaScript의 primitive(원시) 데이터 타입이 아닌 것은?",
      "option_a": "string",
      "option_b": "number",
      "option_c": "array",
      "option_d": "boolean",
      "correct_answer": "C",
      "explanation": "JavaScript에는 7가지 원시 데이터 타입이 있습니다: string, number, boolean, bigint, symbol, null, undefined입니다. array는 복합 데이터 타입으로, object의 한 종류입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:35:37.000Z"
    },
    {
      "id": 387,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\ntypeof 42\n```",
      "option_a": "\"integer\"",
      "option_b": "\"number\"",
      "option_c": "\"digit\"",
      "option_d": "\"numeric\"",
      "correct_answer": "B",
      "explanation": "JavaScript에서는 정수와 실수를 구분하지 않고 모든 숫자를 `number` 타입으로 처리합니다. 따라서 `typeof 42`는 \"number\"를 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:36:35.000Z"
    },
    {
      "id": 388,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 결과는?\n```javascript\ntypeof null // Returns _____\n```",
      "option_a": "\"null\"",
      "option_b": "\"undefined\"",
      "option_c": "\"object\"",
      "option_d": "\"empty\"",
      "correct_answer": "C",
      "explanation": "이것은 JavaScript의 잘 알려진 버그입니다. `null`은 원시 값이지만 `typeof null`은 \"object\"를 반환합니다. 이는 역사적인 이유로 인한 것이며, JavaScript 초기 버전부터 존재해온 문제입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:37:41.000Z"
    },
    {
      "id": 389,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\ntypeof [1, 2, 3, 4]\ntypeof {name: 'John'}\ntypeof new Date()\n```",
      "option_a": "\"array\", \"object\", \"date\"",
      "option_b": "\"object\", \"object\", \"object\"",
      "option_c": "\"array\", \"object\", \"object\"",
      "option_d": "\"array\", \"object\", \"object\"",
      "correct_answer": "B",
      "explanation": "`typeof` 연산자는 복합 데이터 타입에 대해 두 가지 결과만 반환합니다: \"object\"와 \"function\"입니다. 배열, 일반 객체, Date, Map, Set 등은 모두 \"object\"로 반환되며, 오직 함수만 \"function\"으로 반환됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:38:41.000Z"
    },
    {
      "id": 390,
      "subject_id": 1,
      "question": "배열인지 확인하는 올바른 방법은?\n```javascript\nconst fruits = [\"apple\", \"banana\"];\n// 배열인지 확인하는 방법은?\n```",
      "option_a": "typeof fruits === \"array\"",
      "option_b": "Array.isArray(fruits)",
      "option_c": "fruits instanceof Object",
      "option_d": "fruits.length !== undefined",
      "correct_answer": "B",
      "explanation": "`typeof`로는 배열을 구분할 수 없습니다(모두 \"object\"로 반환). ES5에서 도입된 `Array.isArray()` 메서드가 배열인지 확인하는 표준적이고 안전한 방법입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:39:35.000Z"
    },
    {
      "id": 391,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nlet car;\ntypeof car\n```",
      "option_a": "\"null\"",
      "option_b": "\"empty\"",
      "option_c": "\"undefined\"",
      "option_d": "\"unknown\"",
      "correct_answer": "C",
      "explanation": "선언되었지만 값이 할당되지 않은 변수는 `undefined` 값을 가지며, `typeof undefined`는 \"undefined\"를 반환합니다. 이는 변수가 초기화되지 않았음을 의미합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:40:30.000Z"
    },
    {
      "id": 392,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 연산자는?\n```javascript\nconst time = new Date();\nconst fruits = [\"apple\", \"banana\"];\n\nconsole.log(time _______ Date);    // true\nconsole.log(fruits _______ Array); // true\n```",
      "option_a": "typeof",
      "option_b": "instanceof",
      "option_c": "isInstanceOf",
      "option_d": "constructor",
      "correct_answer": "B",
      "explanation": "`instanceof` 연산자는 객체가 특정 생성자 함수의 인스턴스인지 확인합니다. `typeof`로는 구체적인 객체 타입을 구분할 수 없지만, `instanceof`를 사용하면 Date, Array, Map 등의 구체적인 타입을 확인할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:41:35.000Z"
    },
    {
      "id": 393,
      "subject_id": 1,
      "question": "다음 코드에서 `undefined`와 `null`의 비교 결과는?\n```javascript\ntypeof undefined    // A\ntypeof null         // B\nnull === undefined  // C\nnull == undefined   // D\n```\nA, B, C, D의 순서대로 올바른 결과는?",
      "option_a": "\"undefined\", \"null\", false, false",
      "option_b": "\"undefined\", \"object\", false, true",
      "option_c": "\"undefined\", \"undefined\", true, true",
      "option_d": "\"undefined\", \"object\", true, false",
      "correct_answer": "B",
      "explanation": "1) `typeof undefined`는 \"undefined\"\n2) `typeof null`는 \"object\" (JavaScript의 버그)\n3) `null === undefined`는 false (타입이 다름)\n4) `null == undefined`는 true (값이 같다고 간주)\n\n엄격 비교(===)는 타입까지 비교하지만, 동등 비교(==)는 값만 비교합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:43:03.000Z"
    },
    {
      "id": 394,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst checkType = (value) => {\n  if (Array.isArray(value)) return \"array\";\n  if (value === null) return \"null\";\n  if (value?.constructor === Date) return \"date\";\n  return typeof value;\n};\n\nconsole.log(checkType([1, 2, 3]));      // A\nconsole.log(checkType(null));           // B  \nconsole.log(checkType(new Date()));     // C\nconsole.log(checkType(\"hello\"));        // D\n```\nA, B, C, D의 순서대로 올바른 결과는?",
      "option_a": "\"object\", \"object\", \"object\", \"string\"",
      "option_b": "\"array\", \"null\", \"date\", \"string\"",
      "option_c": "\"array\", \"object\", \"date\", \"string\"",
      "option_d": "\"object\", \"null\", \"object\", \"string\"",
      "correct_answer": "B",
      "explanation": "이 함수는 `typeof`의 한계를 극복하기 위한 개선된 타입 체크 함수입니다:\n\n1) 배열: `Array.isArray()`로 체크하여 \"array\" 반환\n2) null: 명시적으로 체크하여 \"null\" 반환 (typeof의 버그 회피)\n3) Date: `constructor` 속성으로 체크하여 \"date\" 반환\n4) 기타: `typeof` 사용\n\n이런 방식으로 `typeof`만으로는 구분할 수 없는 구체적인 타입들을 정확히 식별할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:44:32.000Z"
    },
    {
      "id": 395,
      "subject_id": 1,
      "question": "`toString()` 메서드의 주요 역할은 무엇인가요?",
      "option_a": "변수의 값을 삭제한다",
      "option_b": "변수나 값을 문자열로 변환한다",
      "option_c": "변수의 타입을 변경한다",
      "option_d": "변수를 복사한다",
      "correct_answer": "B",
      "explanation": "`toString()` 메서드는 JavaScript에서 다양한 데이터 타입(숫자, 배열, 날짜, 객체 등)의 값을 문자열로 변환하는 내장 메서드입니다. 데이터를 읽기 쉬운 형태로 표시하거나 문자열이 필요한 상황에서 타입 호환성을 보장하는 데 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:46:40.000Z"
    },
    {
      "id": 396,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst fruits = [\"Apple\", \"Banana\", \"Cherry\"];\nconst result = fruits.toString();\n```",
      "option_a": "\"Apple Banana Cherry\"",
      "option_b": "\"Apple,Banana,Cherry\"",
      "option_c": "\"[Apple, Banana, Cherry]\"",
      "option_d": "\"Apple-Banana-Cherry\"",
      "correct_answer": "B",
      "explanation": "배열에 `toString()` 메서드를 사용하면 배열의 모든 요소를 쉼표로 구분한 문자열로 변환됩니다. 공백 없이 쉼표만으로 구분되는 것이 특징입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:47:23.000Z"
    },
    {
      "id": 397,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nlet num = 456;\nlet text = num.toString();\n```\n`text`의 값과 타입은?",
      "option_a": "값: 456, 타입: number",
      "option_b": "값: \"456\", 타입: string",
      "option_c": "값: 456, 타입: string",
      "option_d": "값: \"456\", 타입: number",
      "correct_answer": "B",
      "explanation": " 숫자에 `toString()` 메서드를 적용하면 해당 숫자를 문자열로 변환합니다. 따라서 숫자 456이 문자열 \"456\"으로 변환되며, 타입도 string이 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T07:48:17.000Z"
    },
    {
      "id": 398,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 매개변수는?\n```javascript\nlet num = 15;\nlet binary = num.toString(_____);  // 결과: \"1111\"\n```",
      "option_a": "10",
      "option_b": "8",
      "option_c": "2",
      "option_d": "16",
      "correct_answer": "C",
      "explanation": "`toString()` 메서드에 매개변수를 전달하면 해당 진법으로 숫자를 변환할 수 있습니다. 15를 2진법으로 변환하면 \"1111\"이 됩니다. 매개변수 2는 binary(이진법)를 의미합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:48:57.000Z"
    },
    {
      "id": 399,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst today = new Date();\nconst dateString = today.toString();\n```\n`dateString`에는 어떤 형태의 값이 저장될까요?",
      "option_a": "\"2025-08-06\"",
      "option_b": "\"2025-08-06\"",
      "option_c": "\"Wed Aug 06 2025 13:40:02 GMT+0900 (한국 표준시)\"",
      "option_d": "\"1691303202000\"",
      "correct_answer": "C",
      "explanation": "Date 객체에 `toString()` 메서드를 사용하면 사람이 읽기 쉬운 형태의 전체 날짜와 시간 문자열을 반환합니다. 요일, 월, 일, 년도, 시간, 시간대 정보가 모두 포함된 완전한 형태로 표시됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:50:24.000Z"
    },
    {
      "id": 400,
      "subject_id": 1,
      "question": "다음 중 `toString()` 메서드의 용도가 아닌 것은?",
      "option_a": "데이터를 표시용으로 읽기 쉬운 형태로 변환",
      "option_b": "문자열이 필요한 경우 타입 호환성 보장",
      "option_c": "객체를 디버깅할 때 사용자 정의 표현 제공",
      "option_d": "변수의 메모리 주소 확인",
      "correct_answer": "D",
      "explanation": "`toString()` 메서드는 데이터를 문자열로 변환하여 표시, 타입 호환성 확보, 디버깅용 사용자 정의 표현 등에 사용됩니다. 하지만 변수의 메모리 주소를 확인하는 기능은 제공하지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:51:09.000Z"
    },
    {
      "id": 401,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nlet person = {\n  name: \"John\",\n  age: 30\n};\nlet result = person.toString();\n```",
      "option_a": "\"John, 30\"",
      "option_b": "\"{name: John, age: 30}\"",
      "option_c": "\"[object Object]\"",
      "option_d": "\"person\"",
      "correct_answer": "C",
      "explanation": "일반 객체에 `toString()` 메서드를 사용하면 기본적으로 \"[object Object]\"라는 문자열을 반환합니다. 이는 객체의 실제 내용을 보여주지 않는 한계가 있어, 의미 있는 문자열 표현을 원한다면 객체 정의에서 `toString()` 메서드를 오버라이드해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T07:52:00.000Z"
    },
    {
      "id": 402,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nlet number = 255;\nconsole.log(number.toString(16));  // A\nconsole.log(number.toString(8));   // B  \nconsole.log(number.toString(2));   // C\n```\nA, B, C의 순서대로 올바른 결과는?",
      "option_a": "\"ff\", \"377\", \"11111111\"",
      "option_b": "\"255\", \"255\", \"255\"",
      "option_c": "\"FF\", \"377\", \"11111111\"",
      "option_d": "\"ff\", \"377\", \"10101010\"",
      "correct_answer": "A",
      "explanation": "숫자의 `toString()` 메서드에 진법을 지정하면:\n\n1) `toString(16)`: 16진법 → 255 = \"ff\" (소문자)\n2) `toString(8)`: 8진법 → 255 = \"377\"\n3) `toString(2)`: 2진법 → 255 = \"11111111\"\n\n16진법 결과는 소문자로 출력됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:53:19.000Z"
    },
    {
      "id": 403,
      "subject_id": 1,
      "question": "다음 코드에서 `funcString`에 저장되는 내용은?\n```javascript\nfunction greet(name) {\n  return \"Hello, \" + name + \"!\";\n}\n\nlet funcString = greet.toString();\n```",
      "option_a": "\"greet\"",
      "option_b": "\"function\"",
      "option_c": "함수의 전체 소스 코드",
      "option_d": "\"[object Function]\"",
      "correct_answer": "C",
      "explanation": "함수에 `toString()` 메서드를 사용하면 해당 함수의 전체 소스 코드를 문자열로 반환합니다. 즉, 함수 정의 전체 (`function greet(name) { return \"Hello, \" + name + \"!\"; }`)가 문자열 형태로 반환됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:55:37.000Z"
    },
    {
      "id": 404,
      "subject_id": 1,
      "question": "다음 코드의 모든 빈칸에 들어갈 메서드는?\n```javascript\nconst data = [10, 20, 30];\nconst num = 42;\nconst date = new Date('2025-01-01');\n\n// 각각을 문자열로 변환\nconst arrayStr = data.______();     // \"10,20,30\"\nconst numStr = num.______();        // \"42\" \nconst dateStr = date.______();      // 전체 날짜 문자열\n\n// 특별한 진법 변환\nconst binary = num.______(2);       // \"101010\"\nconst hex = num.______(16);         // \"2a\"\n```",
      "option_a": "convert",
      "option_b": "toString",
      "option_c": "stringify",
      "option_d": "toText",
      "correct_answer": "B",
      "explanation": "모든 빈칸에는 `toString`이 들어갑니다. JavaScript의 `toString()` 메서드는:\n\n1) 배열: 요소들을 쉼표로 구분한 문자열 반환\n2) 숫자: 문자열로 변환, 매개변수로 진법 지정 가능 (42의 2진법 = \"101010\", 16진법 = \"2a\")\n3) 날짜: 읽기 쉬운 날짜/시간 문자열 반환\n\n이처럼 `toString()`은 다양한 데이터 타입에서 일관되게 사용할 수 있는 강력한 변환 메서드입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T07:57:26.000Z"
    },
    {
      "id": 405,
      "subject_id": 1,
      "question": "JavaScript에서 타입 변환이 일어나는 방법은?",
      "option_a": "JavaScript 함수를 사용해서만 가능",
      "option_b": "수동으로만 가능",
      "option_c": "JavaScript 함수 사용 또는 자동 변환",
      "option_d": "오직 자동으로만 가능",
      "correct_answer": "C",
      "explanation": "JavaScript에서 타입 변환은 두 가지 방법으로 일어납니다: 1) `Number()`, `String()` 같은 JavaScript 함수를 명시적으로 사용하는 방법, 2) JavaScript 엔진이 연산 과정에서 자동으로 수행하는 방법입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T10:44:28.000Z"
    },
    {
      "id": 406,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nNumber(\"3.14\")\n```",
      "option_a": "\"3.14\"",
      "option_b": "3.14",
      "option_c": "NaN",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "`Number()` 함수는 문자열을 숫자로 변환합니다. 숫자 형태의 문자열 \"3.14\"는 숫자 3.14로 성공적으로 변환됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T10:45:24.000Z"
    },
    {
      "id": 407,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 결과는?\n```javascript\nNumber(\"\")     // _____\nNumber(\"John\") // _____\n```",
      "option_a": "0, NaN",
      "option_b": "NaN, NaN",
      "option_c": "\"\", \"John\"",
      "option_d": "undefined, undefined",
      "correct_answer": "A",
      "explanation": "`Number()` 함수의 변환 규칙:\n\n1) 빈 문자열(\"\")은 0으로 변환됩니다\n2) 숫자가 아닌 문자열(\"John\")은 NaN(Not a Number)으로 변환됩니다",
      "difficulty": "easy",
      "created_at": "2025-08-06T10:46:33.000Z"
    },
    {
      "id": 408,
      "subject_id": 1,
      "question": "unary(단항) + 연산자의 사용 결과는?\n```javascript\nlet y = \"5\";\nlet x = + y;\n\nconsole.log(typeof y, typeof x);\n```",
      "option_a": "\"string\", \"string\"",
      "option_b": "\"number\", \"number\"",
      "option_c": "\"string\", \"number\"",
      "option_d": "\"number\", \"string\"",
      "correct_answer": "C",
      "explanation": "unary + 연산자는 변수를 숫자로 변환하는 간단한 방법입니다. `y`는 원래 문자열 \"5\"이므로 타입이 \"string\"이고, `+y`는 숫자 5로 변환되므로 x의 타입은 \"number\"가 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T10:49:24.000Z"
    },
    {
      "id": 409,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nString(123)\n(123).toString()\n```",
      "option_a": "123, \"123\"",
      "option_b": "\"123\", \"123\"",
      "option_c": "\"123\", 123",
      "option_d": "123, 123",
      "correct_answer": "B",
      "explanation": "숫자를 문자열로 변환하는 두 가지 방법입니다:\n\n1) `String(123)`: 전역 String() 함수 사용\n2) `(123).toString()`: 숫자의 toString() 메서드 사용\n\n두 방법 모두 숫자 123을 문자열 \"123\"으로 변환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T10:50:54.000Z"
    },
    {
      "id": 410,
      "subject_id": 1,
      "question": "Boolean을 Number로 변환한 결과(A, B의 값)는?\n```javascript\nNumber(true)   // A\nNumber(false)  // B\n```",
      "option_a": "1, 0",
      "option_b": "\"true\", \"false\"",
      "option_c": "true, false",
      "option_d": "NaN, NaN",
      "correct_answer": "A",
      "explanation": "Boolean을 숫자로 변환할 때:\n\n1) `true`는 1로 변환됩니다\n2) `false`는 0으로 변환됩니다\n\n이는 논리 연산에서 유용하게 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T10:52:53.000Z"
    },
    {
      "id": 411,
      "subject_id": 1,
      "question": "다음 자동 타입 변환의 결과는?\n```javascript\n\"5\" + 2    // A\n\"5\" - 2    // B  \n\"5\" * \"2\"  // C\n```\nA, B, C의 순서대로 올바른 결과는?",
      "option_a": "7, 3, 10",
      "option_b": "\"52\", 3, 10",
      "option_c": "\"7\", \"3\", \"10\"",
      "option_d": "52, \"3\", \"10\"",
      "correct_answer": "B",
      "explanation": "JavaScript의 자동 타입 변환 규칙:\n\n1) `\"5\" + 2`: + 연산자는 문자열 연결을 우선하므로 2가 \"2\"로 변환되어 \"52\"\n2) `\"5\" - 2`: - 연산자는 수치 연산만 가능하므로 \"5\"가 5로 변환되어 3\n3) `\"5\" * \"2\"`: * 연산자는 수치 연산이므로 둘 다 숫자로 변환되어 10",
      "difficulty": "hard",
      "created_at": "2025-08-06T10:56:26.000Z"
    },
    {
      "id": 412,
      "subject_id": 1,
      "question": "다음 코드에서 자동 문자열 변환의 결과는?\n```javascript\nlet myVar1 = [1, 2, 3, 4];\nlet myVar2 = {name: \"John\"};\nlet myVar3 = new Date();\n\n// innerHTML에 할당할 때 자동으로 toString() 호출\ndocument.getElementById(\"demo\").innerHTML = myVar1; // A\ndocument.getElementById(\"demo\").innerHTML = myVar2; // B\n```\nA와 B의 결과는?",
      "option_a": "\"[1, 2, 3, 4]\", \"{name: John}\"",
      "option_b": "\"1,2,3,4\", \"[object Object]\"",
      "option_c": "\"Array\", \"Object\"",
      "option_d": "\"1-2-3-4\", \"name: John\"",
      "correct_answer": "B",
      "explanation": "JavaScript가 객체나 변수를 출력할 때 자동으로 `toString()` 메서드를 호출합니다:\n\n1) 배열의 `toString()`: 요소들을 쉼표로 구분한 문자열 \"1,2,3,4\"\n2) 일반 객체의 `toString()`: \"[object Object]\" 문자열\n3) Date 객체라면 전체 날짜 문자열이 반환됩니다",
      "difficulty": "hard",
      "created_at": "2025-08-06T10:58:01.000Z"
    },
    {
      "id": 413,
      "subject_id": 1,
      "question": "다음 복합적인 타입 변환 상황을 분석하세요:\n```javascript\nlet a = \"10\";\nlet b = \"5\";\nlet c = true;\n\nlet result1 = +a + +b;           // A\nlet result2 = a + b;             // B\nlet result3 = Number(c) + +a;    // C\nlet result4 = String(+a + +b);   // D\n```\nA, B, C, D의 순서대로 올바른 결과는?",
      "option_a": "15, \"105\", 11, \"15\"",
      "option_b": "\"15\", \"105\", \"11\", 15",
      "option_c": "15, \"105\", \"11\", \"15\"",
      "option_d": "105, 15, 11, 15",
      "correct_answer": "A",
      "explanation": "각각의 변환 과정을 단계별로 분석하면:\n\n1) `+a + +b`: unary +로 \"10\"→10, \"5\"→5, 따라서 10+5=15\n2) `a + b`: 문자열 + 문자열이므로 \"10\"+\"5\"=\"105\"\n3) `Number(c) + +a`: true→1, \"10\"→10, 따라서 1+10=11\n4) `String(+a + +b)`: 먼저 +a+b=15 계산 후 String()으로 \"15\"\n\n이처럼 연산자의 순서와 타입 변환 규칙을 정확히 이해하는 것이 중요합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T10:59:48.000Z"
    },
    {
      "id": 414,
      "subject_id": 1,
      "question": "Destructuring Assignment의 주요 역할은 무엇인가요?",
      "option_a": "객체나 배열의 값을 삭제한다",
      "option_b": "객체 속성이나 배열 요소를 개별 변수로 추출한다",
      "option_c": "객체나 배열을 복사한다",
      "option_d": "객체나 배열을 정렬한다",
      "correct_answer": "B",
      "explanation": "Destructuring Assignment(구조 분해 할당)는 객체의 속성이나 배열의 요소를 개별 변수로 \"풀어내는(unpack)\" 문법입니다. 복잡한 데이터 구조에서 필요한 값들을 간편하게 추출할 수 있게 해줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T11:02:00.000Z"
    },
    {
      "id": 415,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  age: 30\n};\n\nlet {firstName, lastName} = person;\nconsole.log(firstName, lastName);\n```",
      "option_a": "undefined undefined",
      "option_b": "\"firstName\" \"lastName\"",
      "option_c": "\"John\" \"Doe\"",
      "option_d": "오류 발생",
      "correct_answer": "C",
      "explanation": "객체 destructuring에서 `{firstName, lastName}`는 `person` 객체의 `firstName`과 `lastName` 속성 값을 동일한 이름의 변수에 할당합니다. 따라서 \"John\"과 \"Doe\"가 출력됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T11:03:05.000Z"
    },
    {
      "id": 416,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 문법은?\n```javascript\nconst fruits = [\"Apple\", \"Banana\", \"Cherry\"];\nlet _____ = fruits;\n// fruit1 = \"Apple\", fruit2 = \"Banana\"\n```",
      "option_a": "{fruit1, fruit2}",
      "option_b": "[fruit1, fruit2]",
      "option_c": "(fruit1, fruit2)",
      "option_d": "fruit1, fruit2",
      "correct_answer": "B",
      "explanation": "배열 destructuring은 대괄호 `[]`를 사용합니다. `[fruit1, fruit2] = fruits`는 배열의 첫 번째와 두 번째 요소를 각각 `fruit1`, `fruit2` 변수에 할당합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T11:04:21.000Z"
    },
    {
      "id": 417,
      "subject_id": 1,
      "question": "다음 코드에서 `country` 변수의 값은?\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  age: 30\n};\n\nlet {firstName, lastName, country = \"US\"} = person;\n```",
      "option_a": "undefined",
      "option_b": "null",
      "option_c": "\"US\"",
      "option_d": "빈 문자열",
      "correct_answer": "C",
      "explanation": "Destructuring에서 기본값(default value)을 설정할 수 있습니다. `person` 객체에 `country` 속성이 없으므로, 설정한 기본값 \"US\"가 할당됩니다. 이는 존재하지 않을 수 있는 속성에 대한 안전장치 역할을 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T11:05:24.000Z"
    },
    {
      "id": 418,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst fruits = [\"Bananas\", \"Oranges\", \"Apples\", \"Mangos\"];\nlet [fruit1,,,fruit2] = fruits;\nconsole.log(fruit1, fruit2);\n```",
      "option_a": "\"Bananas\" \"Oranges\"",
      "option_b": "\"Bananas\" \"Mangos\"",
      "option_c": "\"Oranges\" \"Apples\"",
      "option_d": "\"Apples\" \"Mangos\"",
      "correct_answer": "B",
      "explanation": "배열 destructuring에서 쉼표를 연속으로 사용하면 해당 위치의 요소를 건너뛸 수 있습니다. `[fruit1,,,fruit2]`는 첫 번째 요소(\"Bananas\")와 네 번째 요소(\"Mangos\")만 가져옵니다. 빈 쉼표 3개는 2번째, 3번째 요소를 건너뜀을 의미합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T11:06:24.000Z"
    },
    {
      "id": 419,
      "subject_id": 1,
      "question": "Property Alias(별칭) 사용의 올바른 예는?\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\"\n};\n\n// lastName을 name이라는 변수명으로 사용하고 싶을 때\n```",
      "option_a": "let {lastName = name} = person;",
      "option_b": "let {lastName as name} = person;",
      "option_c": "let {lastName : name} = person;",
      "option_d": "let {lastName -> name} = person;",
      "correct_answer": "C",
      "explanation": "JavaScript destructuring에서 속성 별칭은 콜론(`:`)을 사용합니다. `{lastName : name}`은 `person.lastName` 값을 `name`이라는 새로운 변수에 할당합니다. 이는 기존 속성명과 다른 변수명을 사용하고 싶을 때 유용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T11:07:52.000Z"
    },
    {
      "id": 420,
      "subject_id": 1,
      "question": "다음 문자열 destructuring의 결과는?\n```javascript\nlet name = \"HELLO\";\nlet [a1, a2, a3] = name;\nconsole.log(a1, a2, a3);\n```",
      "option_a": "\"HELLO\" undefined undefined",
      "option_b": "\"H\" \"E\" \"L\"",
      "option_c": "\"H\" \"ELLO\" undefined",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "문자열은 iterable이므로 destructuring이 가능합니다. 문자열의 각 문자가 개별 요소로 취급되어 `a1`에는 \"H\", `a2`에는 \"E\", `a3`에는 \"L\"이 할당됩니다. 문자열도 배열처럼 각 문자에 인덱스로 접근할 수 있기 때문입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T11:08:57.000Z"
    },
    {
      "id": 421,
      "subject_id": 1,
      "question": "Rest Property(...) 사용의 결과는?\n```javascript\nconst numbers = [10, 20, 30, 40, 50];\nconst [first, second, ...remaining] = numbers;\n\nconsole.log(first);        // A\nconsole.log(second);       // B  \nconsole.log(remaining);    // C\n```\nA, B, C의 순서대로 올바른 결과는?",
      "option_a": "10, 20, [30, 40, 50]",
      "option_b": "10, [20, 30, 40, 50], undefined",
      "option_c": "[10], [20], [30, 40, 50]",
      "option_d": "10, 20, 30",
      "correct_answer": "A",
      "explanation": "Rest property(`...remaining`)는 나머지 모든 요소를 새로운 배열에 수집합니다. `first`는 첫 번째 요소(10), `second`는 두 번째 요소(20), `remaining`은 나머지 요소들을 담은 배열([30, 40, 50])이 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T11:10:39.000Z"
    },
    {
      "id": 422,
      "subject_id": 1,
      "question": "다음 Map destructuring 코드의 빈칸을 채우세요:\n```javascript\nconst fruits = new Map([\n  [\"apples\", 500],\n  [\"bananas\", 300]\n]);\n\nfor (const _____ of fruits) {\n  console.log(key + \" costs \" + value);\n}\n```",
      "option_a": "{key, value}",
      "option_b": "[key, value]",
      "option_c": "(key, value)",
      "option_d": "key, value",
      "correct_answer": "B",
      "explanation": "Map의 각 항목은 [key, value] 형태의 배열입니다. `for...of` 루프에서 Map을 순회할 때, 각 반복에서 `[key, value]` 배열을 destructuring하여 키와 값을 개별 변수로 추출할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T11:11:37.000Z"
    },
    {
      "id": 423,
      "subject_id": 1,
      "question": "다음 변수 교환(swapping) 코드의 실행 결과는?\n```javascript\nlet a = \"First\";\nlet b = \"Second\";\nlet c = \"Third\";\n\n// 다음 destructuring 후의 결과는?\n[a, b, c] = [c, a, b];\n\nconsole.log(a, b, c);\n```",
      "option_a": "\"First\" \"Second\" \"Third\"",
      "option_b": "\"Third\" \"First\" \"Second\"",
      "option_c": "\"Second\" \"Third\" \"First\"",
      "option_d": "\"Third\" \"Second\" \"First\"",
      "correct_answer": "B",
      "explanation": "이것은 circular rotation(순환 교환)의 예입니다. 우측의 `[c, a, b]`는 `[\"Third\", \"First\", \"Second\"]` 배열을 만들고, 이것이 좌측의 `[a, b, c]`에 각각 할당됩니다:\n\n1) `a` = \"Third\" (c의 원래 값)\n2) `b` = \"First\" (a의 원래 값)\n3) `c` = \"Second\" (b의 원래 값)\n\n이처럼 destructuring을 사용하면 임시 변수 없이도 여러 변수의 값을 한 번에 교환할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T11:13:04.000Z"
    },
    {
      "id": 424,
      "subject_id": 1,
      "question": "JavaScript에서 비트와이즈 AND 연산자는 무엇입니까?",
      "option_a": "&&",
      "option_b": "&",
      "option_c": "|",
      "option_d": "^",
      "correct_answer": "B",
      "explanation": "JavaScript에서 비트와이즈 AND 연산자는 `&`입니다. `&&`는 논리 AND 연산자이고, `&`는 비트와이즈 AND 연산자입니다. 비트와이즈 AND는 두 비트가 모두 1일 때만 1을 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T23:46:41.000Z"
    },
    {
      "id": 425,
      "subject_id": 1,
      "question": "다음 중 비트와이즈 OR 연산자의 동작을 올바르게 설명한 것은?",
      "option_a": "두 비트가 모두 1일 때만 1을 반환한다",
      "option_b": "두 비트 중 하나라도 1이면 1을 반환한다",
      "option_c": "두 비트가 다르면 1을 반환한다",
      "option_d": "모든 비트를 반전시킨다",
      "correct_answer": "B",
      "explanation": "비트와이즈 OR 연산자(`|`)는 두 비트 중 하나라도 1이면 1을 반환합니다. 예를 들어, `1 | 0 = 1`, `0 | 1 = 1`, `1 | 1 = 1`, `0 | 0 = 0`입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T23:47:55.000Z"
    },
    {
      "id": 426,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 연산자는 무엇입니까?\n```javascript\nlet x = 5 __ 1;  // 결과: 1\n```",
      "option_a": "&",
      "option_b": "|",
      "option_c": "^",
      "option_d": "~",
      "correct_answer": "A",
      "explanation": "5를 이진수로 표현하면 `0101`이고, 1을 이진수로 표현하면 `0001`입니다. AND 연산(`&`)을 수행하면:\n\n0101 (5)\n0001 (1)\n----\n0001 (1)\n\n따라서 `5 & 1 = `1입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-06T23:50:13.000Z"
    },
    {
      "id": 427,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇입니까?\n```javascript\nlet result = 5 | 1;\nconsole.log(result);\n```",
      "option_a": "1",
      "option_b": "4",
      "option_c": "5",
      "option_d": "6",
      "correct_answer": "C",
      "explanation": "5를 이진수로 표현하면 `0101`이고, 1을 이진수로 표현하면 `0001`입니다. OR 연산(`|`)을 수행하면:\n\n0101 (5)\n0001 (1)\n----\n0101 (5)\n\n따라서 `5 | 1 = 5`입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T23:51:25.000Z"
    },
    {
      "id": 428,
      "subject_id": 1,
      "question": "XOR 연산자(`^`)의 특징으로 올바른 것은?",
      "option_a": "두 비트가 같으면 1을 반환한다",
      "option_b": "두 비트가 다르면 1을 반환한다",
      "option_c": "항상 1을 반환한다",
      "option_d": "항상 0을 반환한다",
      "correct_answer": "B",
      "explanation": "XOR(배타적 OR) 연산자는 두 비트가 다를 때만 1을 반환합니다:\n\n1) `0 ^ 0 = 0`\n2) `0 ^ 1 = 1`\n3) `1 ^ 0 = 1`\n4) `1 ^ 1 = 0`",
      "difficulty": "medium",
      "created_at": "2025-08-06T23:52:58.000Z"
    },
    {
      "id": 429,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇입니까?\n```javascript\nlet x = ~5;\nconsole.log(x);\n```",
      "option_a": "5",
      "option_b": "-5",
      "option_c": "-6",
      "option_d": "6",
      "correct_answer": "C",
      "explanation": "NOT 연산자(`~`)는 모든 비트를 반전시킵니다. JavaScript는 32비트 부호 있는 정수를 사용하므로:\n\n1) 5: `00000000000000000000000000000101`\n2) ~5: `11111111111111111111111111111010` (이는 -6을 의미)\n\nJavaScript는 2의 보수법을 사용하므로 ~5는 -6이 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T23:54:10.000Z"
    },
    {
      "id": 430,
      "subject_id": 1,
      "question": "왼쪽 시프트 연산자(`<<`)에 대한 설명으로 올바른 것은?",
      "option_a": "오른쪽에서 0을 채워 넣으며 왼쪽으로 이동시킨다",
      "option_b": "왼쪽에서 0을 채워 넣으며 오른쪽으로 이동시킨다",
      "option_c": "부호 비트를 복사하며 오른쪽으로 이동시킨다부호 비트를 복사하며 오른쪽으로 이동시킨다",
      "option_d": "모든 비트를 반전시킨다",
      "correct_answer": "A",
      "explanation": "왼쪽 시프트 연산자(`<<`)는 비트들을 왼쪽으로 이동시키고, 오른쪽에서는 0으로 채워집니다. 왼쪽 끝의 비트들은 사라집니다. 예: `5 << 1`은 `0101`을 `1010`으로 만들어 10이 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-06T23:55:23.000Z"
    },
    {
      "id": 431,
      "subject_id": 1,
      "question": "다음 코드의 빈칸을 올바르게 채워주세요:\n```javascript\nfunction dec2bin(dec){\n    return (dec ___ 0).toString(2);\n}\n```",
      "option_a": "&",
      "option_b": "|",
      "option_c": "^",
      "option_d": ">>>",
      "correct_answer": "D",
      "explanation": "`dec2bin` 함수는 10진수를 2진수로 변환하는 함수입니다. `>>> 0`은 제로 필 우측 시프트 연산으로, 실제로는 시프트하지 않고(0만큼 시프트) 단지 32비트 부호 없는 정수로 변환하는 트릭입니다. 이렇게 하면 음수도 올바른 32비트 2진수 표현으로 변환됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T23:57:41.000Z"
    },
    {
      "id": 432,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇입니까?\n```javascript\nlet result = -5 >> 1;\nconsole.log(result);\n```",
      "option_a": "-2",
      "option_b": "-3",
      "option_c": "2",
      "option_d": "3",
      "correct_answer": "B",
      "explanation": "부호 보존 우측 시프트(`>>`)는 왼쪽에서 부호 비트(최상위 비트)의 복사본을 채워 넣습니다.\n\n1) -5: `11111111111111111111111111111011`\n2) -5 >> 1: `11111111111111111111111111111101` (이는 -3)\n\n음수의 경우 왼쪽에서 1로 채워지므로 여전히 음수가 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T23:58:39.000Z"
    },
    {
      "id": 433,
      "subject_id": 1,
      "question": "JavaScript에서 비트와이즈 연산에 대한 설명 중 올바른 것은?",
      "option_a": "모든 연산은 64비트에서 수행된다",
      "option_b": "연산 전에 32비트 부호 있는 정수로 변환되고, 연산 후 다시 64비트로 변환된다",
      "option_c": "부동소수점 숫자에서 직접 수행된다",
      "option_d": "문자열에서도 비트와이즈 연산이 가능하다",
      "correct_answer": "B",
      "explanation": "JavaScript는 숫자를 64비트 부동소수점으로 저장하지만, 비트와이즈 연산이 수행되기 전에 32비트 부호 있는 정수로 변환됩니다. 연산이 완료된 후 결과는 다시 64비트 JavaScript 숫자로 변환됩니다. 이것이 `~5`가 -6이 되는 이유입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-06T23:59:42.000Z"
    },
    {
      "id": 434,
      "subject_id": 1,
      "question": "정규표현식(Regular Expression)의 줄임말은 무엇입니까?",
      "option_a": "RegEx",
      "option_b": "Regex",
      "option_c": "RegExp",
      "option_d": "모두 정답",
      "correct_answer": "D",
      "explanation": "정규표현식을 줄여서 부르는 방법에는 여러 가지가 있습니다:\n\n1) RegEx, Regex: 일반적으로 사용되는 줄임말\n2) RegExp: JavaScript에서 정규표현식 객체의 이름\n\n모두 정규표현식을 의미하는 올바른 표현입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T00:01:55.000Z"
    },
    {
      "id": 435,
      "subject_id": 1,
      "question": "다음 정규표현식 구문에서 빈칸에 들어갈 올바른 기호는 무엇입니까?\n```javascript\n_pattern_modifier flags;\n```",
      "option_a": "[, ]",
      "option_b": "{, }",
      "option_c": "/, /",
      "option_d": "(, )",
      "correct_answer": "C",
      "explanation": "JavaScript에서 정규표현식의 기본 구문은 `/pattern/modifier flags` 입니다. 슬래시(`/`)로 패턴을 감싸고, 그 뒤에 수정자(modifier)나 플래그를 붙입니다. 예: `/hello/i`",
      "difficulty": "easy",
      "created_at": "2025-08-07T00:03:44.000Z"
    },
    {
      "id": 436,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇입니까?\n```javascript\nlet text = \"Is this all there is?\";\nconst pattern = /is/g;\nlet result = text.match(pattern);\n```",
      "option_a": "[\"is\"]",
      "option_b": "[\"is\", \"is\"]",
      "option_c": "[\"Is\", \"is\", \"is\"]",
      "option_d": "null",
      "correct_answer": "B",
      "explanation": "`/g` 플래그는 전역 검색을 의미하므로 모든 매치를 찾습니다. 하지만 i 플래그가 없으므로 대소문자를 구분합니다. 따라서:\n\n1) \"Is\"는 매치되지 않음 (대문자 I)\n2) \"this\"의 \"is\"와 마지막 \"is\"만 매치됨\n\n결과: `[\"is\", \"is\"]`",
      "difficulty": "medium",
      "created_at": "2025-08-07T00:06:21.000Z"
    },
    {
      "id": 437,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 메타문자는 무엇입니까?\n```javascript\nlet text = \"Give 100%!\";\nconst pattern = /_/g;  // 숫자만 찾기\nlet result = text.match(pattern);\n// 결과: [\"1\", \"0\", \"0\"]\n```",
      "option_a": "\\w",
      "option_b": "\\d",
      "option_c": "\\s",
      "option_d": "\\b",
      "correct_answer": "B",
      "explanation": "메타문자들의 의미:\n\n1) \\d : 숫자(digits) 0-9를 매치\n2) \\w : 단어 문자(a-z, A-Z, 0-9, _)를 매치\n3) \\s : 공백 문자를 매치\n4) \\b : 단어 경계를 매치\n\n숫자만 찾으려면 \\d 를 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T00:08:14.000Z"
    },
    {
      "id": 438,
      "subject_id": 1,
      "question": "다음 정규표현식의 의미는 무엇입니까?\n```javascript\nlet pattern = /red|green|blue/g;\n```",
      "option_a": "\"red\", \"green\", \"blue\"를 모두 포함하는 문자열",
      "option_b": "\"red\" 또는 \"green\" 또는 \"blue\" 중 하나라도 매치",
      "option_c": "\"red green blue\" 순서대로 나타나는 패턴",
      "option_d": "\"redgreenblue\"가 연결된 문자열",
      "correct_answer": "B",
      "explanation": "`|`는 OR 연산자(alternation)로, 여러 선택지 중 하나라도 매치되면 됩니다. `/red|green|blue/g`는 \"red\", \"green\", \"blue\" 중 어느 것이든 찾아서 모두 반환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T00:09:14.000Z"
    },
    {
      "id": 439,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇입니까?\n```javascript\nlet text = \"1, 100 or 1000?\";\nconst pattern = /10?/g;\nlet result = text.match(pattern);\n```",
      "option_a": "[\"1\", \"10\", \"100\"]",
      "option_b": "[\"1\", \"10\", \"10\"]",
      "option_c": "[\"10\", \"100\", \"1000\"]",
      "option_d": "[\"100\", \"1000\"]",
      "correct_answer": "B",
      "explanation": "`?` 퀀티파이어는 \"0개 또는 1개\"를 의미합니다. `/10?/`는:\n\n1) \"1\" 다음에 \"0\"이 0개 또는 1개 오는 패턴\n2) \"1\" → 매치 (0이 0개)\n3) \"100\" → \"10\" 매치 (0이 1개), 남은 \"0\"에서 \"1\" 없으므로 매치 안됨\n4) \"1000\" → \"10\" 매치 (0이 1개), 남은 \"00\"에서 \"1\" 없으므로 매치 안됨",
      "difficulty": "medium",
      "created_at": "2025-08-07T00:10:26.000Z"
    },
    {
      "id": 440,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇입니까?\n```javascript\nlet text = \"Give 100%!\";\nconst pattern = /\\w/g;\nlet result = text.match(pattern);\n```",
      "option_a": "[\"Give\", \"100\"]",
      "option_b": "[\"G\", \"i\", \"v\", \"e\", \"1\", \"0\", \"0\"]",
      "option_c": "[\"Give 100\"]",
      "option_d": "[\"100\"]",
      "correct_answer": "B",
      "explanation": "`\\w` 메타문자는 단어 문자(word character)를 의미하며, a-z, A-Z, 0-9, _ 를 포함합니다.\n\n1) \"Give\"에서: G, i, v, e 각각 매치\n2) 공백은 단어 문자가 아니므로 매치 안됨\n3) \"100\"에서: 1, 0, 0 각각 매치\n4) \"%!\"는 단어 문자가 아니므로 매치 안됨\n\n`/g` 플래그로 인해 모든 개별 문자가 배열로 반환됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T00:13:13.000Z"
    },
    {
      "id": 441,
      "subject_id": 1,
      "question": "다음 문자 클래스(Character Classes) 중에서 숫자 0부터 9까지를 모두 매치하는 것은?\n```javascript\nlet text = \"More than 1000 times\";\nconst pattern = /___/g;  // 빈칸을 채우세요\nlet result = text.match(pattern);\n// 결과: [\"1\", \"0\", \"0\", \"0\"]\n```",
      "option_a": "[a-z]",
      "option_b": "[A-Z]",
      "option_c": "[0-9]",
      "option_d": "[abc]",
      "correct_answer": "C",
      "explanation": "문자 클래스는 대괄호 `[]` 안에 문자들을 나열하여 그 중 하나를 매치합니다:\n\n1) `[0-9]`: 0부터 9까지의 숫자 (=`\\d`와 동일)\n2) `[a-z]`: 소문자 a부터 z까지\n3) `[A-Z]`: 대문자 A부터 Z까지\n4) `[abc]`: a, b, c 중 하나\n\n`[0-9]`는 모든 숫자를 매치하므로 \"1000\"에서 각 숫자를 개별적으로 찾아 `[\"1\", \"0\", \"0\", \"0\"]`를 반환합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T00:17:52.000Z"
    },
    {
      "id": 442,
      "subject_id": 1,
      "question": "다음 표현식의 결과는 무엇입니까?\n```javascript\nlet x = 100 + 50 * 3;\n```",
      "option_a": "450",
      "option_b": "250",
      "option_c": "350",
      "option_d": "200",
      "correct_answer": "B",
      "explanation": "연산자 우선순위에 따라 곱셈(`*`)이 덧셈(`+`)보다 먼저 실행됩니다.\n\n1) 먼저: `50 * 3 = 150`\n2) 그 다음: `100 + 150 = 250`\n\n수학에서와 마찬가지로 곱셈과 나눗셈이 덧셈과 뺄셈보다 우선순위가 높습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T00:20:34.000Z"
    },
    {
      "id": 443,
      "subject_id": 1,
      "question": "괄호의 역할은 무엇입니까?\n```javascript\nlet x = (100 + 50) * 3;\n```",
      "option_a": "괄호는 아무런 영향을 주지 않는다",
      "option_b": "괄호 안의 연산을 나중에 수행한다",
      "option_c": "괄호 안의 연산을 먼저 수행한다",
      "option_d": "괄호는 에러를 발생시킨다",
      "correct_answer": "C",
      "explanation": "괄호(`()`)는 가장 높은 우선순위(18)를 가지므로 다른 모든 연산보다 먼저 수행됩니다.\n\n1) 먼저: `(100 + 50) = 150`\n2) 그 다음: `150 * 3 = 450`\n\n괄호를 사용하면 기본 연산자 우선순위를 무시하고 원하는 순서로 계산할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T00:21:52.000Z"
    },
    {
      "id": 444,
      "subject_id": 1,
      "question": "같은 우선순위를 가진 연산자들은 어떤 순서로 계산됩니까?\n```javascript\nlet x = 100 / 50 * 3;\n```",
      "option_a": "오른쪽에서 왼쪽으로",
      "option_b": "왼쪽에서 오른쪽으로",
      "option_c": "랜덤하게",
      "option_d": "동시에",
      "correct_answer": "B",
      "explanation": "곱셈(`*`)과 나눗셈(`/`)은 같은 우선순위(12)를 가지므로 왼쪽에서 오른쪽으로 계산됩니다.\n\n1) 먼저: `100 / 50 = 2`\n2) 그 다음: `2 * 3 = 6`\n\n만약 오른쪽에서 왼쪽으로 계산했다면 `50 * 3 = 150`, `100 / 150 = 0.67`이 되어 다른 결과가 나옵니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T00:23:37.000Z"
    },
    {
      "id": 445,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇입니까?\n```javascript\nlet result = 10 + 5 * 2 - 3;\n```",
      "option_a": "27",
      "option_b": "17",
      "option_c": "22",
      "option_d": "30",
      "correct_answer": "B",
      "explanation": "연산자 우선순위에 따라 계산 순서가 결정됩니다:\n\n1) 곱셈 먼저: `5 * 2 = 10`\n2) 왼쪽에서 오른쪽으로: `10 + 10 = 20`\n3) 마지막으로: `20 - 3 = 17`\n\n곱셈(`*`)의 우선순위(12)가 덧셈(`+`)과 뺄셈(`-`)의 우선순위(11)보다 높습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T00:25:23.000Z"
    },
    {
      "id": 446,
      "subject_id": 1,
      "question": "다음 코드에서 가장 먼저 실행되는 연산은 무엇입니까?\n```javascript\nlet x = ++i * (5 + 3) / 2;\n```",
      "option_a": "++i",
      "option_b": "5 + 3",
      "option_c": "* (곱셈)",
      "option_d": "/ (나눗셈)",
      "correct_answer": "B",
      "explanation": "연산자 우선순위 순서:\n\n1) `()` 괄호: 18 → `5 + 3 = 8` (가장 먼저)\n2) `++` 전위 증가: 14 → `++i`\n3) `*` 곱셈: 12 → `(증가된 i) * 8`\n4) `/` 나눗셈: 12 → `결과 / 2`\n\n괄호가 가장 높은 우선순위를 가지므로 괄호 안의 연산이 먼저 수행됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T00:30:15.000Z"
    },
    {
      "id": 447,
      "subject_id": 1,
      "question": "다음 중에서 우선순위가 가장 높은 연산자는 무엇입니까?",
      "option_a": "`**` (지수 연산)",
      "option_b": "`*` (곱셈)",
      "option_c": "`++` (증가 연산자)",
      "option_d": "`()` (괄호)",
      "correct_answer": "D",
      "explanation": "각 연산자의 우선순위:\n\n1) `()` 괄호: 18\n2) `++` 증가 연산자: 14 또는 15 (전위/후위)\n3) `**` 지수 연산: 13\n4) `*` 곱셈: 12\n\n괄호는 모든 연산자 중에서 가장 높은 우선순위를 가집니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T00:31:45.000Z"
    },
    {
      "id": 448,
      "subject_id": 1,
      "question": "JavaScript에서 에러를 처리하기 위해 사용하는 기본 구문은 무엇입니까?",
      "option_a": "if...else",
      "option_b": "try...catch",
      "option_c": "switch...case",
      "option_d": "for...while",
      "correct_answer": "B",
      "explanation": "JavaScript에서 에러 처리를 위한 기본 구문은 `try...catch`입니다.\n\n1) `try` 블록: 에러가 발생할 가능성이 있는 코드를 실행\n2) `catch` 블록: 에러가 발생했을 때 실행할 코드를 정의\n\n이 구문을 사용하면 프로그램이 에러로 인해 중단되지 않고 적절히 처리할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T00:56:30.000Z"
    },
    {
      "id": 449,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 키워드는 무엇입니까?\n```javascript\ntry {\n    adddlert(\"Hello\");\n}\n____(err) {\n    console.log(err.message);\n}\n```",
      "option_a": "error",
      "option_b": "catch",
      "option_c": "handle",
      "option_d": "except",
      "correct_answer": "B",
      "explanation": "`catch` 키워드는 `try` 블록에서 발생한 에러를 잡아서 처리하는 역할을 합니다.\n\n1) `catch(err)`: 매개변수 `err`는 발생한 에러 객체를 받습니다\n2) `err.message`: 에러 메시지를 확인할 수 있습니다\n\n위 코드에서 `adddlert`는 존재하지 않는 함수이므로 에러가 발생하고, `catch` 블록에서 처리됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T00:58:09.000Z"
    },
    {
      "id": 450,
      "subject_id": 1,
      "question": "사용자 정의 에러를 생성하기 위해 사용하는 키워드는 무엇입니까?",
      "option_a": "error",
      "option_b": "create",
      "option_c": "throw",
      "option_d": "raise",
      "correct_answer": "C",
      "explanation": "`throw` 키워드는 사용자 정의 에러를 생성하고 발생시킵니다.\n```javascript\nthrow \"Too big\";        // 문자열 에러\nthrow 500;             // 숫자 에러  \nthrow true;            // 불린 에러\nthrow new Error(\"Custom error\");  // Error 객체\n```\n`throw`를 사용하면 프로그램의 흐름을 제어하고 맞춤형 에러 메시지를 생성할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T00:59:29.000Z"
    },
    {
      "id": 451,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇입니까?\n```javascript\ntry {\n    let x = 10;\n    if (x > 5) throw \"Too big\";\n    console.log(\"Success\");\n}\ncatch(err) {\n    console.log(\"Error: \" + err);\n}\n```",
      "option_a": "Success",
      "option_b": "Error: Too big",
      "option_c": "에러 발생으로 프로그램 중단",
      "option_d": "아무것도 출력되지 않음",
      "correct_answer": "B",
      "explanation": "실행 순서:\n\n1) `x = 10` 할당\n2) `x > 5` 조건이 참이므로 `throw \"Too big\"` 실행\n3) `throw`로 인해 즉시 `catch` 블록으로 이동\n4) `console.log(\"Success\")`는 실행되지 않음\n5) `catch` 블록에서 \"Error: Too big\" 출력\n\n`throw`가 실행되면 그 즉시 `catch` 블록으로 제어가 넘어갑니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T01:03:17.000Z"
    },
    {
      "id": 452,
      "subject_id": 1,
      "question": "에러가 발생하든 발생하지 않든 항상 실행되는 블록은 무엇입니까?\n```javascript\ntry {\n    // 코드 실행\n}\ncatch(err) {\n    // 에러 처리\n}\n____ {\n    // 항상 실행되는 코드\n}\n```",
      "option_a": "always",
      "option_b": "finally",
      "option_c": "complete",
      "option_d": "end",
      "correct_answer": "B",
      "explanation": "`finally` 블록은 `try...catch` 구문에서 에러 발생 여부와 관계없이 항상 실행됩니다.\n```javascript\ntry {\n    // 성공하든 실패하든\n}\ncatch(err) {\n    // 에러가 발생할 때만\n}\nfinally {\n    // 항상 실행됨 (정리 작업 등)\n}\n```\n주로 파일 닫기, 연결 해제 등의 정리 작업에 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T01:05:05.000Z"
    },
    {
      "id": 453,
      "subject_id": 1,
      "question": "JavaScript Error 객체의 기본 속성으로 올바른 것은?",
      "option_a": "`name`, `message`",
      "option_b": "`type`, `description`",
      "option_c": "`error`, `info`",
      "option_d": "`code`, `detail`",
      "correct_answer": "A",
      "explanation": "JavaScript의 기본 Error 객체는 두 가지 주요 속성을 가집니다:\n\n1) `name`: 에러의 이름 (예: \"ReferenceError\", \"TypeError\")\n2) `message`: 에러에 대한 설명 메시지\n\n```javascript\ntry {\n    someUndefinedFunction();\n}\ncatch(err) {\n    console.log(err.name);     // \"ReferenceError\"\n    console.log(err.message);  // \"someUndefinedFunction is not defined\"\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-07T01:07:16.000Z"
    },
    {
      "id": 454,
      "subject_id": 1,
      "question": "다음 코드에서 발생할 에러의 종류는 무엇입니까?\n```javascript\ntry {\n    let x = 5;\n    x = y + 1;  // y는 선언되지 않음\n}\ncatch(err) {\n    console.log(err.name);\n}\n```",
      "option_a": "TypeError",
      "option_b": "SyntaxError",
      "option_c": "ReferenceError",
      "option_d": "RangeError",
      "correct_answer": "C",
      "explanation": "`ReferenceError`는 선언되지 않은 변수를 참조하려고 할 때 발생합니다.\n\n1) `y`가 선언되지 않았는데 `y + 1`에서 참조하려고 함\n2) \"y is not defined\"라는 메시지와 함께 `ReferenceError` 발생\n\n다른 에러 타입들:\n\n1) `TypeError`: 잘못된 타입의 연산\n2) `SyntaxError`: 문법 오류\n3) `RangeError`: 범위를 벗어난 값",
      "difficulty": "medium",
      "created_at": "2025-08-07T01:09:22.000Z"
    },
    {
      "id": 455,
      "subject_id": 1,
      "question": "다음 입력 검증 코드의 빈칸을 올바르게 채우세요:\n```javascript\nfunction validateInput(x) {\n    try {\n        if(x.trim() == \"\") ____ \"empty\";\n        if(isNaN(x)) ____ \"not a number\";\n        x = Number(x);\n        if(x < 5) ____ \"too low\";\n        if(x > 10) ____ \"too high\";\n    }\n    catch(err) {\n        return \"Input is \" + err;\n    }\n}\n```",
      "option_a": "return",
      "option_b": "throw",
      "option_c": "break",
      "option_d": "continue",
      "correct_answer": "B",
      "explanation": "입력 검증에서 각 조건에 맞지 않을 때 사용자 정의 에러를 발생시켜야 합니다:\n\n```javascript\nif(x.trim() == \"\") throw \"empty\";        // 빈 문자열\nif(isNaN(x)) throw \"not a number\";       // 숫자가 아님  \nif(x < 5) throw \"too low\";               // 너무 작음\nif(x > 10) throw \"too high\";             // 너무 큼\n```\n\n`throw`로 에러를 발생시키면 즉시 `catch` 블록으로 이동하여 에러 메시지를 처리할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T01:12:03.000Z"
    },
    {
      "id": 456,
      "subject_id": 1,
      "question": "다음 코드에서 발생할 에러의 종류는 무엇입니까?\n```javascript\ntry {\n    let num = 1;\n    num.toUpperCase();  // 숫자에 문자열 메서드 적용\n}\ncatch(err) {\n    console.log(err.name);\n}\n```",
      "option_a": "ReferenceError",
      "option_b": "TypeError",
      "option_c": "SyntaxError",
      "option_d": "RangeError",
      "correct_answer": "B",
      "explanation": "`TypeError`는 값의 타입이 예상과 다를 때 발생합니다:\n\n1) `num`은 숫자(1)인데 문자열 메서드 `toUpperCase()`를 호출\n2) 숫자에는 `toUpperCase()` 메서드가 존재하지 않음\n3) \"num.toUpperCase is not a function\" 메시지와 함께 `TypeError` 발생\n\n`TypeError`의 다른 예시:\n\n1) `null.someMethod()`: null에 메서드 호출\n2) `undefined.property`: undefined의 속성 접근",
      "difficulty": "hard",
      "created_at": "2025-08-07T01:13:50.000Z"
    },
    {
      "id": 457,
      "subject_id": 1,
      "question": "다음 복합 에러 처리 코드의 실행 결과는 무엇입니까?\n```javascript\nfunction complexFunction() {\n    console.log(\"1\");\n    try {\n        console.log(\"2\");\n        throw \"Custom Error\";\n        console.log(\"3\");\n    }\n    catch(err) {\n        console.log(\"4\");\n        return \"Error handled\";\n    }\n    finally {\n        console.log(\"5\");\n    }\n    console.log(\"6\"); \n}\n\nlet result = complexFunction();\n```\n출력되는 숫자의 순서는?",
      "option_a": "1, 2, 3, 4, 5, 6",
      "option_b": "1, 2, 4, 5",
      "option_c": "1, 2, 4, 6",
      "option_d": "1, 2, 5, 4",
      "correct_answer": "B",
      "explanation": "코드 실행 순서:\n\n1) `console.log(\"1\")` 실행 → \"1\" 출력\n2) `try` 블록 시작, `console.log(\"2\")` 실행 → \"2\" 출력\n3) `throw \"Custom Error\"` 실행 → 즉시 `catch` 블록으로 이동\n4) `console.log(\"3\")`은 실행되지 않음 (`throw` 이후 코드)\n5) `catch` 블록에서 `console.log(\"4\")` 실행 → \"4\" 출력\n6) `catch`에서 `return` 실행되지만 `finally`가 먼저 실행됨\n7) `finally` 블록에서 `console.log(\"5\")` 실행 → \"5\" 출력\n8) `return` 실행으로 함수 종료\n9) `console.log(\"6\")`은 실행되지 않음 (`return` 이후 코드)\n\n`finally`는 `return`보다도 먼저 실행되는 특별한 블록입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T01:18:31.000Z"
    },
    {
      "id": 458,
      "subject_id": 1,
      "question": "JavaScript에서 변수의 스코프(scope) 종류는 몇 가지입니까?",
      "option_a": "2가지 (전역, 지역)",
      "option_b": "3가지 (블록, 함수, 전역)",
      "option_c": "4가지 (블록, 함수, 지역, 전역)",
      "option_d": "5가지",
      "correct_answer": "B",
      "explanation": "JavaScript 변수는 3가지 타입의 스코프를 가집니다:\n\n1) Block Scope (블록 스코프): `{}` 블록 내에서만 접근 가능\n2) Function Scope (함수 스코프): 함수 내에서만 접근 가능\n3) Global Scope (전역 스코프): 어디서든 접근 가능\n\nES6(2015) 이전에는 함수 스코프와 전역 스코프만 있었지만, `let`과 `const` 키워드가 도입되면서 블록 스코프가 추가되었습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T01:24:00.000Z"
    },
    {
      "id": 459,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 키워드는 무엇입니까?\n```javascript\n{\n    ___ x = 2;\n}\n// x can NOT be used here (블록 외부에서 접근 불가)\n```",
      "option_a": "var",
      "option_b": "let",
      "option_c": "function",
      "option_d": "global",
      "correct_answer": "B",
      "explanation": "`let` (그리고 `const`)으로 선언된 변수는 블록 스코프를 가집니다:\n\n1) `{}` 블록 내에서만 접근 가능\n2) 블록 외부에서는 접근할 수 없음\n\n반면 `var`로 선언된 변수는 블록 스코프를 가지지 않아서 블록 외부에서도 접근할 수 있습니다:\n```javascript\n{\n    var x = 2;  // 블록 외부에서도 접근 가능\n}\n// x CAN be used here\n```",
      "difficulty": "easy",
      "created_at": "2025-08-07T01:28:17.000Z"
    },
    {
      "id": 460,
      "subject_id": 1,
      "question": "함수 내부에서 선언된 변수를 무엇이라고 부릅니까?\n```javascript\nfunction myFunction() {\n    let carName = \"Volvo\";  // 이 변수의 종류는?\n}\n```",
      "option_a": "전역 변수 (Global Variable)",
      "option_b": "지역 변수 (Local Variable)",
      "option_c": "블록 변수 (Block Variable)",
      "option_d": "함수 변수 (Function Variable)",
      "correct_answer": "B",
      "explanation": "함수 내부에서 선언된 변수는 **지역 변수(Local Variable)**라고 부릅니다:\n\n1) 해당 함수 내에서만 접근 가능\n2) 함수 외부에서는 접근할 수 없음\n3) 함수가 시작될 때 생성되고, 함수가 완료될 때 삭제됨\n\n지역 변수는 함수 스코프를 가지며, `var`, `let`, `const` 모두 함수 내에서는 동일하게 함수 스코프를 가집니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T01:52:13.000Z"
    },
    {
      "id": 461,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇입니까?\n```javascript\nlet carName = \"Volvo\";\n\nfunction myFunction() {\n    console.log(carName);\n}\n\nmyFunction();\n```",
      "option_a": "undefined",
      "option_b": "\"Volvo\"",
      "option_c": "에러 발생",
      "option_d": "아무것도 출력되지 않음",
      "correct_answer": "B",
      "explanation": "함수 외부에서 선언된 `carName`은 **전역 변수(Global Variable)**입니다:\n\n1) 전역 스코프를 가져서 어디서든 접근 가능\n2) 함수 내부에서도 접근할 수 있음\n3) 모든 스크립트와 함수에서 사용 가능\n\n따라서 `myFunction()` 내부에서 전역 변수 `carName`에 접근하여 \"Volvo\"를 출력합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T01:53:45.000Z"
    },
    {
      "id": 462,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 키워드는 무엇입니까?\n```javascript\n___ carName = \"Volvo\";\n// code here can use window.carName (HTML 환경에서)\n\n___ carName2 = \"BMW\";  \n// code here can NOT use window.carName2\n```",
      "option_a": "`var`, `let`",
      "option_b": "`let`, `var`",
      "option_c": "`const`, `var`",
      "option_d": "`var`, `const`",
      "correct_answer": "A",
      "explanation": "HTML 환경에서 전역 변수의 동작 차이:\n\n1) `var`로 선언된 전역 변수: `window` 객체의 속성이 됨\n```javascript\nvar carName = \"Volvo\";\nconsole.log(window.carName);  // \"Volvo\"\n```\n2) `let`과 `const`로 선언된 전역 변수: `window` 객체의 속성이 되지 않음\n```javascript\nlet carName2 = \"BMW\";\nconsole.log(window.carName2);  // undefined\n```",
      "difficulty": "medium",
      "created_at": "2025-08-07T01:57:16.000Z"
    },
    {
      "id": 463,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇입니까?\n```javascript\nfunction myFunction() {\n    let carName = \"Volvo\";\n    console.log(typeof carName);\n}\n\nmyFunction();\nconsole.log(typeof carName);  // 함수 외부\n```",
      "option_a": "`\"string\"`, `\"string\"`",
      "option_b": "`\"string\"`, `\"undefined\"`",
      "option_c": "`\"undefined\"`, `\"undefined\"`",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "지역 변수의 스코프 동작:\n\n1) 함수 내부: `let carName = \"Volvo\"`로 지역 변수 생성\n`typeof carName`은 `\"string\"` 반환\n\n2) 함수 외부: 지역 변수 `carName`에 접근할 수 없음\n`carName`이 존재하지 않으므로 `typeof carName`은 `\"undefined\"` 반환\n\n\n지역 변수는 함수가 완료되면 삭제되므로 외부에서 접근할 수 없습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T02:00:23.000Z"
    },
    {
      "id": 464,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇입니까?\n```javascript\nvar x = 1;\nlet y = 2;\nconst z = 3;\n\n{\n    var x = 10;\n    let y = 20;\n    const z = 30;\n    console.log(x, y, z);  // 블록 내부\n}\n\nconsole.log(x, y, z);  // 블록 외부\n```",
      "option_a": "`10, 20, 30`과 `1, 2, 3`",
      "option_b": "`10, 20, 30`과 `10, 2, 3`",
      "option_c": "`1, 2, 3`과 `10, 20, 30`",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "키워드별 스코프 동작:\n\n1) `var`: 블록 스코프가 없음\n\n블록 내 `var x = 10`이 전역 `var x = 1`을 덮어씀\n블록 외부에서도 `x = 10`\n\n2) `let`과 `const`: 블록 스코프를 가짐\n\n블록 내에서만 새로운 변수 생성\n블록 외부의 원래 값은 그대로 유지\n\n\n결과:\n\n1) 블록 내부: `10, 20, 30` (모두 블록 내 값)\n2) 블록 외부: `10, 2, 3` (var는 변경됨, let/const는 원래 값)",
      "difficulty": "hard",
      "created_at": "2025-08-07T02:04:46.000Z"
    },
    {
      "id": 465,
      "subject_id": 1,
      "question": "다음 코드에서 함수 매개변수의 스코프는 무엇입니까?\n```javascript\nfunction calculateArea(width, height) {\n    let area = width * height;\n    return area;\n}\n\n// 함수 외부에서 width, height 접근 가능한가?\n```",
      "option_a": "전역 스코프 - 어디서든 접근 가능",
      "option_b": "블록 스코프 - 특정 블록에서만 접근 가능",
      "option_c": "함수 스코프 - 해당 함수 내에서만 접근 가능",
      "option_d": "매개변수 스코프 - 별도의 스코프",
      "correct_answer": "C",
      "explanation": "함수 매개변수(parameters)의 특징:\n\n1) 함수 스코프를 가짐\n2) 함수 내에서 지역 변수처럼 동작\n3) 함수 외부에서는 접근할 수 없음\n4) 함수가 완료되면 삭제됨\n```javascript\nfunction calculateArea(width, height) {  // 매개변수\n    console.log(width, height);  // 함수 내부에서 접근 가능\n}\n\ncalculateArea(10, 20);\nconsole.log(width);  // 에러! 함수 외부에서 접근 불가\n```\n함수 인수는 함수 내에서 지역 변수로 작동합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T02:07:00.000Z"
    },
    {
      "id": 466,
      "subject_id": 1,
      "question": "JavaScript에서 \"호이스팅(Hoisting)\"이란 무엇인가요?",
      "option_a": "변수를 삭제하는 JavaScript의 기본 동작",
      "option_b": "선언을 현재 스코프의 맨 위로 이동시키는 JavaScript의 기본 동작",
      "option_c": "변수의 값을 초기화하는 JavaScript의 기본 동작",
      "option_d": "함수를 실행하는 JavaScript의 기본 동작",
      "correct_answer": "B",
      "explanation": "호이스팅은 JavaScript의 기본 동작으로, 모든 선언(declaration)을 현재 스코프의 맨 위로 이동시키는 것을 의미합니다. 즉, 변수나 함수가 선언되기 전에 사용되어도 JavaScript 엔진이 내부적으로 선언 부분을 코드의 맨 위로 끌어올려 처리합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T02:16:38.000Z"
    },
    {
      "id": 467,
      "subject_id": 1,
      "question": "다음 두 코드 중 어떤 것이 맞는 설명인가요?\n```javascript\n// 코드 A\nx = 5;\nvar x;\n\n// 코드 B  \nvar x;\nx = 5;\n```",
      "option_a": "코드 A는 에러가 발생하고, 코드 B는 정상 작동한다",
      "option_b": "코드 A는 정상 작동하고, 코드 B는 에러가 발생한다",
      "option_c": "두 코드 모두 에러가 발생한다",
      "option_d": "두 코드 모두 같은 결과를 보여준다",
      "correct_answer": "D",
      "explanation": "호이스팅 때문에 코드 A와 코드 B는 완전히 같은 결과를 보여줍니다. JavaScript 엔진은 코드 A를 내부적으로 코드 B처럼 해석합니다. `var x` 선언이 자동으로 맨 위로 이동되어 `x = 5` 할당 전에 실행되기 때문입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T02:17:33.000Z"
    },
    {
      "id": 468,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 키워드는?\n```javascript\ncarName = \"Volvo\";\n_____ carName; // 이 코드는 ReferenceError를 발생시킨다\n```",
      "option_a": "var",
      "option_b": "let",
      "option_c": "function",
      "option_d": "const",
      "correct_answer": "B",
      "explanation": "`let`으로 선언된 변수는 호이스팅은 되지만 초기화되지 않습니다. 따라서 선언 전에 사용하려고 하면 ReferenceError가 발생합니다. 이를 \"temporal dead zone\"이라고 합니다. `var`의 경우는 호이스팅되어 `undefined`로 초기화되므로 에러가 발생하지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T02:28:49.000Z"
    },
    {
      "id": 469,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 올바른 것은?\n```javascript\nconsole.log(x);\nconsole.log(y);\nvar x = 5;\nlet y = 10;\n```",
      "option_a": "5, 10",
      "option_b": "undefined, 10",
      "option_c": "undefined, ReferenceError",
      "option_d": "ReferenceError, ReferenceError",
      "correct_answer": "C",
      "explanation": "`var x`는 호이스팅되어 `undefined`로 초기화되므로 첫 번째 `console.log(x)`는 `undefined`를 출력합니다. 하지만 `let y`는 호이스팅되지만 초기화되지 않으므로 선언 전에 접근하려고 하면 ReferenceError가 발생합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T02:34:14.000Z"
    },
    {
      "id": 470,
      "subject_id": 1,
      "question": "JavaScript에서 초기화(initialization)에 대한 올바른 설명은?",
      "option_a": "초기화도 선언과 함께 호이스팅된다",
      "option_b": "초기화는 호이스팅되지 않는다",
      "option_c": "초기화만 호이스팅되고 선언은 호이스팅되지 않는다",
      "option_d": "let과 const의 초기화만 호이스팅된다",
      "correct_answer": "B",
      "explanation": "JavaScript에서는 선언(declaration)만 호이스팅되고, 초기화(initialization)는 호이스팅되지 않습니다. 예를 들어 `var x = 5;`에서 `var x` 부분만 맨 위로 이동하고, `= 5` 부분은 원래 위치에 남아있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T02:35:38.000Z"
    },
    {
      "id": 471,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 내용은?\n```javascript\ncarName = \"Volvo\";\n_____ carName; // 이 코드는 syntax error를 발생시켜 실행되지 않는다\n```",
      "option_a": "var",
      "option_b": "let",
      "option_c": "const",
      "option_d": "function",
      "correct_answer": "C",
      "explanation": "`const` 변수를 선언 전에 사용하려고 하면 syntax error가 발생하여 코드가 아예 실행되지 않습니다. `let`의 경우 runtime에 ReferenceError가 발생하지만, `const`는 parse 단계에서 syntax error가 발생합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T02:38:10.000Z"
    },
    {
      "id": 472,
      "subject_id": 1,
      "question": "다음 코드와 동일한 의미로 JavaScript 엔진이 해석하는 코드는?\n```javascript\nvar x = 5;\nelem = document.getElementById(\"demo\");\nelem.innerHTML = x + \" \" + y;\nvar y = 7;\n```",
      "option_a": "```javascript\nvar x = 5;\nvar y = 7;\nelem = document.getElementById(\"demo\");\nelem.innerHTML = x + \" \" + y;\n```",
      "option_b": "```javascript\nvar x, y;\nx = 5;\nelem = document.getElementById(\"demo\");\nelem.innerHTML = x + \" \" + y;\ny = 7;\n```",
      "option_c": "```javascript\nvar x = 5;\nvar y;\nelem = document.getElementById(\"demo\");\nelem.innerHTML = x + \" \" + y;\ny = 7;\n```",
      "option_d": "```javascript\nelem = document.getElementById(\"demo\");\nvar x = 5;\nvar y = 7;\nelem.innerHTML = x + \" \" + y;\n```",
      "correct_answer": "B",
      "explanation": "호이스팅에 의해 모든 `var` 선언이 스코프 맨 위로 이동하지만, 초기화는 원래 위치에 남습니다. 따라서 `var x, y;`가 맨 위에 오고, 각각의 값 할당인 `x = 5`와 `y = 7`은 원래 위치에서 실행됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T02:39:47.000Z"
    },
    {
      "id": 473,
      "subject_id": 1,
      "question": "호이스팅으로 인한 버그를 방지하기 위한 가장 좋은 방법은?",
      "option_a": "var 대신 let과 const만 사용한다",
      "option_b": "모든 변수를 스코프의 시작 부분에 선언한다",
      "option_c": "변수를 사용한 후에 선언한다",
      "option_d": "초기화 없이 선언만 한다",
      "correct_answer": "B",
      "explanation": "호이스팅으로 인한 버그를 방지하는 가장 좋은 방법은 모든 변수를 스코프의 시작 부분에 선언하는 것입니다. 이렇게 하면 JavaScript 엔진이 내부적으로 수행하는 호이스팅과 코드의 실제 모습이 일치하게 되어 예상치 못한 동작을 방지할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T02:40:35.000Z"
    },
    {
      "id": 474,
      "subject_id": 1,
      "question": "다음 중 \"temporal dead zone\"에 대한 올바른 설명은?",
      "option_a": "var 변수가 undefined로 초기화되는 구간",
      "option_b": "let과 const 변수가 선언은 되었지만 사용할 수 없는 구간",
      "option_c": "함수가 호이스팅되는 구간",
      "option_d": "변수가 메모리에서 삭제되는 구간",
      "correct_answer": "B",
      "explanation": "\"Temporal dead zone\"은 `let`과 `const` 변수가 호이스팅되어 블록의 시작부터 실제 선언문까지의 구간을 말합니다. 이 구간에서는 변수가 존재하지만 아직 초기화되지 않아서 접근하려고 하면 ReferenceError가 발생합니다. `var`와 달리 `let`, `const`는 호이스팅되지만 `undefined`로 자동 초기화되지 않기 때문입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T02:42:29.000Z"
    },
    {
      "id": 475,
      "subject_id": 1,
      "question": "JavaScript에서 \"use strict\"는 무엇인가요?",
      "option_a": "JavaScript 코드를 빠르게 실행하는 명령문",
      "option_b": "JavaScript 코드를 엄격한 모드로 실행하도록 지시하는 디렉티브",
      "option_c": "JavaScript 변수를 자동으로 선언하는 기능",
      "option_d": "JavaScript 함수를 정의하는 키워드",
      "correct_answer": "B",
      "explanation": "\"use strict\"는 JavaScript 코드가 엄격한 모드(strict mode)로 실행되어야 함을 나타내는 디렉티브입니다. 명령문(statement)이 아닌 리터럴 표현식으로, ECMAScript 5에서 새로 도입되었습니다. 엄격한 모드에서는 더 안전하고 깨끗한 코드 작성을 도와줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T02:44:48.000Z"
    },
    {
      "id": 476,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 내용은?\n```javascript\n_______;\nx = 3.14; // 이 코드는 에러를 발생시킨다\n```",
      "option_a": "\"use normal\"",
      "option_b": "\"use strict\"",
      "option_c": "\"strict mode\"",
      "option_d": "use strict",
      "correct_answer": "B",
      "explanation": "\"use strict\" 디렉티브를 코드 맨 위에 추가하면 엄격한 모드가 활성화됩니다. 엄격한 모드에서는 선언되지 않은 변수를 사용할 수 없으므로 `x = 3.14`는 에러를 발생시킵니다. 따옴표 없이 사용하면 안 되며, 정확히 \"use strict\"로 써야 합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T02:45:46.000Z"
    },
    {
      "id": 477,
      "subject_id": 1,
      "question": "\"use strict\"를 함수 내부에서 선언했을 때의 효과는?\n```javascript\nx = 3.14; // 첫 번째 할당\nmyFunction();\n\nfunction myFunction() {\n    \"use strict\";\n    y = 3.14; // 두 번째 할당\n}\n```",
      "option_a": "두 할당 모두 에러 발생",
      "option_b": "두 할당 모두 정상 동작",
      "option_c": "첫 번째만 에러 발생",
      "option_d": "두 번째만 에러 발생",
      "correct_answer": "D",
      "explanation": "\"use strict\"가 함수 내부에 선언되면 지역 스코프(local scope)를 가집니다. 따라서 함수 외부의 `x = 3.14`는 일반 모드에서 실행되어 정상 동작하지만, 함수 내부의 `y = 3.14`는 엄격한 모드에서 실행되어 선언되지 않은 변수 사용으로 에러가 발생합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T02:46:52.000Z"
    },
    {
      "id": 478,
      "subject_id": 1,
      "question": "다음 중 \"use strict\" 모드에서 허용되지 않는 것은?",
      "option_a": "let 변수 선언",
      "option_b": "const 변수 선언",
      "option_c": "선언 없이 변수 사용",
      "option_d": "함수 선언",
      "correct_answer": "C",
      "explanation": "엄격한 모드의 주요 목적 중 하나는 선언되지 않은 변수의 사용을 방지하는 것입니다. 일반 JavaScript에서는 변수명을 잘못 입력하면 새로운 전역 변수가 생성되지만, 엄격한 모드에서는 이런 실수를 에러로 처리하여 더 안전한 코드 작성을 돕습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T02:47:38.000Z"
    },
    {
      "id": 479,
      "subject_id": 1,
      "question": "다음 코드들 중 엄격한 모드에서 에러가 발생하지 않는 것은?",
      "option_a": "let x = 010; // 8진수 리터럴",
      "option_b": "delete myVariable;",
      "option_c": "let eval = 3.14;",
      "option_d": "let myVar = 10; console.log(myVar);",
      "correct_answer": "D",
      "explanation": "엄격한 모드에서는 여러 제한사항이 있습니다: ① 8진수 리터럴 사용 금지 ② 변수나 함수 삭제 금지 ③ \"eval\", \"arguments\" 같은 예약어를 변수명으로 사용 금지. 하지만 정상적인 변수 선언과 사용은 당연히 허용됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T02:50:40.000Z"
    },
    {
      "id": 480,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 수 없는 예약어는?\n```javascript\n\"use strict\";\nlet _____ = 1500; // 미래 버전을 위해 예약된 키워드는 사용할 수 없음\n```",
      "option_a": "myVariable",
      "option_b": "public",
      "option_c": "userName",
      "option_d": "counter",
      "correct_answer": "B",
      "explanation": "엄격한 모드에서는 미래 JavaScript 버전을 위해 예약된 키워드들을 변수명으로 사용할 수 없습니다. \"public\"은 예약어에 해당하며, 다른 예약어로는 implements, interface, let, package, private, protected, static, yield 등이 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T02:51:40.000Z"
    },
    {
      "id": 481,
      "subject_id": 1,
      "question": "엄격한 모드에서 `this` 키워드의 동작에 대한 올바른 설명은?\n```javascript\n\"use strict\";\nfunction myFunction() {\n    console.log(this);\n}\nmyFunction(); // 이 함수 호출의 결과는?\n```",
      "option_a": "window 객체를 반환한다",
      "option_b": "undefined를 반환한다",
      "option_c": "null을 반환한다",
      "option_d": "함수 객체 자신을 반환한다",
      "correct_answer": "B",
      "explanation": "엄격한 모드에서는 `this` 키워드의 동작이 달라집니다. 일반 모드에서는 객체가 지정되지 않은 함수에서 `this`가 전역 객체(브라우저의 경우 window)를 가리키지만, 엄격한 모드에서는 `undefined`를 반환합니다. 이는 더 예측 가능하고 안전한 코드 작성을 돕습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T02:53:03.000Z"
    },
    {
      "id": 482,
      "subject_id": 1,
      "question": "다음 코드에서 에러가 발생하는 이유는?\n```javascript\n\"use strict\";\nconst obj = {};\nObject.defineProperty(obj, \"name\", {value: \"John\", writable: false});\nobj.name = \"Jane\"; // 에러 발생\n```",
      "option_a": "const 객체는 수정할 수 없음",
      "option_b": "읽기 전용 속성에 값을 할당하려 했음",
      "option_c": "Object.defineProperty 사용법이 틀림",
      "option_d": "\"name\" 속성이 예약어임",
      "correct_answer": "B",
      "explanation": "`Object.defineProperty`에서 `writable: false`로 설정된 속성은 읽기 전용입니다. 일반 모드에서는 이런 속성에 값을 할당해도 조용히 무시되지만, 엄격한 모드에서는 에러를 발생시킵니다. 이는 개발자가 의도치 않은 동작을 쉽게 발견할 수 있게 도와줍니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T02:54:13.000Z"
    },
    {
      "id": 483,
      "subject_id": 1,
      "question": "다음 중 `with` 문에 대한 올바른 설명은?\n```javascript\n\"use strict\";\nwith (Math) {\n    x = cos(2); // 이 코드의 문제점은?\n}\n```",
      "option_a": "with 문은 엄격한 모드에서 허용되지 않음",
      "option_b": "Math 객체 사용법이 틀림",
      "option_c": "cos 함수 사용법이 틀림",
      "option_d": "변수 x가 선언되지 않음",
      "correct_answer": "A",
      "explanation": "`with` 문은 엄격한 모드에서 완전히 금지됩니다. `with` 문은 스코프 체인을 복잡하게 만들어 코드의 성능을 저하시키고 디버깅을 어렵게 만들기 때문입니다. 엄격한 모드는 이런 \"나쁜 문법\"을 실제 에러로 처리하여 더 깨끗하고 유지보수하기 쉬운 코드 작성을 유도합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T02:55:18.000Z"
    },
    {
      "id": 484,
      "subject_id": 1,
      "question": "JavaScript Classes가 도입된 ECMAScript 버전과 다른 이름은?",
      "option_a": "ES5, ECMAScript 2010",
      "option_b": "ES6, ECMAScript 2015",
      "option_c": "ES7, ECMAScript 2016",
      "option_d": "ES8, ECMAScript 2017",
      "correct_answer": "B",
      "explanation": "JavaScript Classes는 ECMAScript 2015 (ES6)에서 도입되었습니다. 이는 JavaScript 객체 지향 프로그래밍을 더 쉽고 명확하게 만들어주는 중요한 기능입니다. ES6는 ECMAScript 2015의 줄임말로, 같은 버전을 의미합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T07:34:44.000Z"
    },
    {
      "id": 485,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 키워드는?\n```javascript\n_____ Car {\n    constructor(name, year) {\n        this.name = name;\n        this.year = year;\n    }\n}\n```",
      "option_a": "function",
      "option_b": "class",
      "option_c": "object",
      "option_d": "newv",
      "correct_answer": "B",
      "explanation": "JavaScript에서 클래스를 만들 때는 `class` 키워드를 사용합니다. 이는 클래스를 정의하는 전용 키워드로, 함수나 객체와는 다른 문법입니다. `class` 키워드 다음에 클래스 이름을 써주면 클래스가 생성됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T07:35:47.000Z"
    },
    {
      "id": 486,
      "subject_id": 1,
      "question": "JavaScript Class에 대한 올바른 설명은?",
      "option_a": "JavaScript Class는 객체이다",
      "option_b": "JavaScript Class는 JavaScript 객체를 위한 템플릿이다",
      "option_c": "JavaScript Class는 함수이다",
      "option_d": "JavaScript Class는 변수이다",
      "correct_answer": "B",
      "explanation": "JavaScript Class는 객체 자체가 아니라 JavaScript 객체를 만들기 위한 템플릿(틀)입니다. 클래스를 정의한 후 `new` 키워드를 사용해서 실제 객체들을 생성할 수 있습니다. 마치 건축 설계도가 집 자체는 아니지만 집을 짓기 위한 틀인 것과 같습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T07:36:45.000Z"
    },
    {
      "id": 487,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 특별한 메서드 이름은?\n```javascript\nclass Car {\n    _________(name, year) {\n        this.name = name;\n        this.year = year;\n    }\n}\n```",
      "option_a": "init",
      "option_b": "create",
      "option_c": "constructor",
      "option_d": "setup",
      "correct_answer": "C",
      "explanation": "`constructor`는 클래스의 특별한 메서드로, 새로운 객체가 생성될 때 자동으로 실행됩니다. 이 메서드는 반드시 \"constructor\"라는 정확한 이름을 가져야 하며, 객체의 초기 속성값을 설정하는 데 사용됩니다. 다른 이름을 사용하면 생성자로 인식되지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T07:37:37.000Z"
    },
    {
      "id": 488,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nclass Car {\n    constructor(name, year) {\n        this.name = name;\n        this.year = year;\n    }\n}\n\nconst myCar1 = new Car(\"Ford\", 2014);\nconst myCar2 = new Car(\"Audi\", 2019);\nconsole.log(myCar1.name + \" \" + myCar2.name);\n```",
      "option_a": "\"Car Car\"",
      "option_b": "\"Ford Audi\"",
      "option_c": "\"2014 2019\"",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "`new Car(\"Ford\", 2014)`는 name이 \"Ford\"이고 year이 2014인 Car 객체를 생성합니다. 마찬가지로 `new Car(\"Audi\", 2019)`는 name이 \"Audi\"인 객체를 생성합니다. 따라서 `myCar1.name + \" \" + myCar2.name`은 \"Ford Audi\"를 출력합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T07:40:39.000Z"
    },
    {
      "id": 489,
      "subject_id": 1,
      "question": "constructor 메서드에 대한 올바른 설명이 아닌 것은?",
      "option_a": "정확히 \"constructor\"라는 이름을 가져야 한다",
      "option_b": "새로운 객체가 생성될 때 자동으로 실행된다",
      "option_c": "객체 속성을 초기화하는 데 사용된다",
      "option_d": "클래스에서 여러 개 정의할 수 있다",
      "correct_answer": "D",
      "explanation": "constructor 메서드는 클래스당 하나만 존재할 수 있습니다. 만약 constructor를 정의하지 않으면 JavaScript가 자동으로 빈 constructor를 추가해줍니다. constructor는 객체 생성 시 자동 실행되며, 객체의 초기 상태를 설정하는 특별한 메서드입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T07:41:21.000Z"
    },
    {
      "id": 490,
      "subject_id": 1,
      "question": "다음 클래스 메서드의 실행 결과는? (현재 년도를 2025년이라고 가정)\n```javascript\nclass Car {\n    constructor(name, year) {\n        this.name = name;\n        this.year = year;\n    }\n    \n    age() {\n        const date = new Date();\n        return date.getFullYear() - this.year;\n    }\n}\n\nconst myCar = new Car(\"Ford\", 2014);\nconsole.log(myCar.age());\n```",
      "option_a": "2014",
      "option_b": "2015",
      "option_c": "11",
      "option_d": "-11",
      "correct_answer": "C",
      "explanation": "`age()` 메서드는 현재 연도에서 자동차가 만들어진 연도를 빼서 자동차의 나이를 계산합니다. `date.getFullYear()`는 현재 연도(2025)를 반환하고, `this.year`는 객체가 생성될 때 설정된 2014를 가리킵니다. 따라서 2025 - 2014 = 11이 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T07:42:23.000Z"
    },
    {
      "id": 491,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 내용은?\n```javascript\nclass Car {\n    constructor(name, year) {\n        this.name = name;\n        this.year = year;\n    }\n    \n    age(_____) {\n        return x - this.year;\n    }\n}\n\nconst myCar = new Car(\"Ford\", 2014);\nconsole.log(myCar.age(2025));\n```",
      "option_a": "year",
      "option_b": "x",
      "option_c": "date",
      "option_d": "current",
      "correct_answer": "B",
      "explanation": "메서드의 매개변수 이름은 `x`이고, 메서드 내부에서 `return x - this.year`로 사용됩니다. 매개변수 이름과 사용되는 변수명이 일치해야 합니다. `myCar.age(2025)`를 호출하면 x에 2025가 전달되어 2025 - 2014 = 11을 반환합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T07:43:29.000Z"
    },
    {
      "id": 492,
      "subject_id": 1,
      "question": "클래스 메서드 정의에 대한 올바른 구조는?\n```javascript\nclass ClassName {\n    constructor() { ... }\n    _____() { ... }\n    _____() { ... }\n}\n```\n빈칸에 들어갈 수 있는 것은?",
      "option_a": "function method_1, function method_2",
      "option_b": "method_1, method_2",
      "option_c": "var method_1, var method_2var method_1, var method_2",
      "option_d": "let method_1, let method_2",
      "correct_answer": "B",
      "explanation": "클래스 내부에서 메서드를 정의할 때는 `function` 키워드나 변수 선언 키워드(`var`, `let`, `const`)를 사용하지 않습니다. 그냥 메서드 이름과 매개변수, 중괄호만 사용하면 됩니다. 이는 클래스 문법의 특별한 규칙입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T07:44:36.000Z"
    },
    {
      "id": 493,
      "subject_id": 1,
      "question": "다음 코드의 실행 과정에서 일어나는 일을 순서대로 나열한 것은?\n```javascript\nclass Car {\n    constructor(name) {\n        console.log(\"Creating car: \" + name);\n        this.name = name;\n    }\n    \n    start() {\n        console.log(this.name + \" is starting\");\n    }\n}\n\nconst myCar = new Car(\"Tesla\");\nmyCar.start();\n```",
      "option_a": "\"Tesla is starting\" → \"Creating car: Tesla\"",
      "option_b": "\"Creating car: Tesla\" → \"Tesla is starting\"",
      "option_c": "\"Tesla is starting\" 만 출력",
      "option_d": "\"Creating car: Tesla\" 만 출력",
      "correct_answer": "B",
      "explanation": "JavaScript에서 `new Car(\"Tesla\")`를 실행하면 constructor가 자동으로 호출되어 먼저 \"Creating car: Tesla\"가 출력됩니다. 그 다음 `myCar.start()`를 명시적으로 호출하면 \"Tesla is starting\"이 출력됩니다. constructor는 객체 생성 시 자동 실행되지만, 다른 메서드들은 명시적으로 호출해야 실행됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T07:45:50.000Z"
    },
    {
      "id": 494,
      "subject_id": 1,
      "question": "JavaScript 모듈(Modules)의 주요 목적은 무엇인가요?",
      "option_a": "코드를 더 빠르게 실행하기 위해",
      "option_b": "코드를 별도의 파일로 나누어 유지보수를 쉽게 하기 위해",
      "option_c": "메모리 사용량을 줄이기 위해",
      "option_d": "브라우저 호환성을 높이기 위해",
      "correct_answer": "B",
      "explanation": "JavaScript 모듈의 주요 목적은 코드를 여러 개의 별도 파일로 나누어 코드베이스를 더 쉽게 유지보수할 수 있게 하는 것입니다. 큰 프로젝트에서 모든 코드를 하나의 파일에 작성하면 관리가 어려워지는데, 모듈을 사용하면 기능별로 파일을 분리하여 더 체계적으로 코드를 관리할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T07:48:17.000Z"
    },
    {
      "id": 495,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 내용은?\n```html\n<script ______=\"module\">\nimport message from \"./message.js\";\n</script>\n```",
      "option_a": "src",
      "option_b": "type",
      "option_c": "id",
      "option_d": "class",
      "correct_answer": "B",
      "explanation": "JavaScript 모듈을 사용하려면 `<script>` 태그에 `type=\"module\"`을 반드시 지정해야 합니다. 이는 브라우저에게 이 스크립트가 모듈 형태임을 알려주는 역할을 합니다. 일반적인 script 태그와 달리 모듈을 사용할 때는 이 속성이 필수입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T07:49:37.000Z"
    },
    {
      "id": 496,
      "subject_id": 1,
      "question": "JavaScript에서 모듈을 가져올 때 사용하는 키워드는?",
      "option_a": "include",
      "option_b": "require",
      "option_c": "import",
      "option_d": "load",
      "correct_answer": "C",
      "explanation": "JavaScript에서 모듈을 가져올 때는 `import` 키워드를 사용합니다. 이는 ES6(ES2015)에서 도입된 표준 문법으로, 다른 파일에서 내보낸(export) 함수, 변수, 클래스 등을 현재 파일로 가져올 수 있게 해줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T07:50:31.000Z"
    },
    {
      "id": 497,
      "subject_id": 1,
      "question": "JavaScript 모듈에서 export의 종류는 몇 가지인가요?",
      "option_a": "1가지 (Default Export만)",
      "option_b": "2가지 (Named Export와 Default Export)",
      "option_c": "3가지 (Named, Default, Anonymous Export)",
      "option_d": "4가지 (Named, Default, Class, Function Export)",
      "correct_answer": "B",
      "explanation": "JavaScript 모듈에서는 두 가지 종류의 export가 있습니다. Named Export는 이름을 가진 여러 개의 항목을 내보낼 수 있고, Default Export는 파일당 하나만 존재할 수 있는 기본 내보내기입니다. 각각 다른 import 문법을 사용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T07:51:31.000Z"
    },
    {
      "id": 498,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 문법은?\n```javascript\n// person.js 파일\nconst name = \"Jesse\";\nconst age = 40;\n______ {name, age};\n```",
      "option_a": "import",
      "option_b": "export",
      "option_c": "module",
      "option_d": "return",
      "correct_answer": "B",
      "explanation": "다른 파일에서 사용할 수 있도록 변수나 함수를 내보낼 때는 `export` 키워드를 사용합니다. `export {name, age}`는 name과 age 변수를 Named Export 방식으로 내보내는 문법입니다. 이렇게 내보낸 변수들은 다른 파일에서 import할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T07:52:45.000Z"
    },
    {
      "id": 499,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 import 문법은?\n```javascript\n// person.js 파일에는 다음과 같이 내보내기 했습니다:\n// export const name = \"Jesse\";\n// export const age = 40;\n\n// main.js 파일에서 가져오기:\nimport _____ from \"./person.js\";\n```",
      "option_a": "name, age",
      "option_b": "{name, age}",
      "option_c": "(name, age)",
      "option_d": "[name, age]",
      "correct_answer": "B",
      "explanation": "Named Export로 내보낸 항목들을 import할 때는 반드시 중괄호 `{}`를 사용해야 합니다. `import {name, age} from \"./person.js\"`가 올바른 문법입니다. 중괄호는 구체적으로 어떤 이름의 export를 가져올지 명시하는 역할을 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T07:54:58.000Z"
    },
    {
      "id": 500,
      "subject_id": 1,
      "question": "다음 두 파일의 코드에서 결과로 출력될 내용은?\n```javascript\n// message.js\nconst message = () => {\n    const name = \"Jesse\";\n    const age = 40;\n    return name + ' is ' + age + ' years old.';\n};\nexport default message;\n\n// main.js\nimport message from \"./message.js\";\nconsole.log(message());\n```",
      "option_a": "\"Jesse is 40 years old.\"",
      "option_b": "\"message is undefined years old.\"",
      "option_c": "에러 발생",
      "option_d": "undefined",
      "correct_answer": "A",
      "explanation": "`message.js`에서 `message` 함수를 default export로 내보내고, `main.js`에서 이를 import하여 호출합니다. `message()` 함수가 실행되면 내부에서 정의된 name(\"Jesse\")과 age(40)를 사용하여 \"Jesse is 40 years old.\"라는 문자열을 반환합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T07:56:20.000Z"
    },
    {
      "id": 501,
      "subject_id": 1,
      "question": "다음 Named Export의 두 가지 방식 중 올바른 것들은?\n방식 1:\n```javascript\nexport const name = \"Jesse\";\nexport const age = 40;\n```\n방식 2:\n```javascript\nconst name = \"Jesse\";\nconst age = 40;\nexport {name, age};\n```",
      "option_a": "방식 1만 올바름",
      "option_b": "방식 2만 올바름",
      "option_c": "둘 다 올바름",
      "option_d": "둘 다 틀림",
      "correct_answer": "C",
      "explanation": "Named Export는 두 가지 방식으로 할 수 있습니다. 방식 1은 각 변수를 선언하면서 바로 export하는 인라인 방식이고, 방식 2는 변수들을 먼저 선언한 후 마지막에 한꺼번에 export하는 방식입니다. 두 방식 모두 완전히 동일한 결과를 가져오므로 개발자의 선호에 따라 선택할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T07:57:38.000Z"
    },
    {
      "id": 502,
      "subject_id": 1,
      "question": "JavaScript 모듈이 작동하지 않는 환경은?",
      "option_a": "HTTP 프로토콜 (http://)",
      "option_b": "HTTPS 프로토콜 (https://)",
      "option_c": "로컬 서버 환경",
      "option_d": "파일 프로토콜 (file://)",
      "correct_answer": "D",
      "explanation": "JavaScript 모듈은 보안상의 이유로 HTTP(s) 프로토콜에서만 작동합니다. `file://` 프로토콜로 직접 HTML 파일을 열면 import/export가 작동하지 않고 CORS 에러가 발생합니다. 따라서 모듈을 테스트할 때는 반드시 웹 서버(로컬 서버 포함)를 통해 파일을 서빙해야 합니다. 이는 브라우저의 보안 정책 때문입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T07:58:40.000Z"
    },
    {
      "id": 503,
      "subject_id": 1,
      "question": "JSON의 정식 명칭과 주요 용도는?",
      "option_a": "JavaScript Object Notation, 데이터 저장 및 전송 포맷",
      "option_b": "JavaScript Online Network, 네트워크 연결 프로토콜",
      "option_c": "JavaScript Original Node, 서버 관리 시스템",
      "option_d": "JavaScript Object Number, 숫자 계산 형식",
      "correct_answer": "A",
      "explanation": "JSON은 JavaScript Object Notation의 줄임말로, 데이터를 저장하고 전송하기 위한 경량 데이터 교환 포맷입니다. 서버에서 웹 페이지로 데이터를 보낼 때 자주 사용되며, 언어에 독립적이고 이해하기 쉬운 \"자기 설명적\" 특성을 가지고 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T08:01:55.000Z"
    },
    {
      "id": 504,
      "subject_id": 1,
      "question": "다음 중 올바른 JSON 문법 규칙이 아닌 것은?",
      "option_a": "데이터는 이름/값 쌍으로 구성된다",
      "option_b": "데이터는 쉼표로 구분된다",
      "option_c": "중괄호는 객체를 담는다",
      "option_d": "대괄호는 문자열을 담는다",
      "correct_answer": "D",
      "explanation": "JSON의 기본 문법 규칙은 다음과 같습니다: ① 데이터는 이름/값 쌍 ② 쉼표로 구분 ③ 중괄호 {}는 객체 ④ 대괄호 []는 배열. 대괄호는 문자열이 아닌 배열을 담는 데 사용됩니다. 문자열은 큰따옴표로 묶어서 표현합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T08:02:35.000Z"
    },
    {
      "id": 505,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 함수는?\n```javascript\nlet text = '{\"name\":\"John\", \"age\":30}';\nconst obj = JSON._______(text);\nconsole.log(obj.name); // \"John\"\n```",
      "option_a": "convert",
      "option_b": "parse",
      "option_c": "transform",
      "option_d": "decode",
      "correct_answer": "B",
      "explanation": "`JSON.parse()` 함수는 JSON 문자열을 JavaScript 객체로 변환하는 내장 함수입니다. 서버에서 받은 JSON 데이터를 JavaScript에서 사용할 수 있는 객체로 만들 때 사용합니다. 반대로 객체를 JSON 문자열로 변환할 때는 `JSON.stringify()`를 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T08:03:30.000Z"
    },
    {
      "id": 506,
      "subject_id": 1,
      "question": "다음 코드 중 올바른 들여쓰기 규칙을 따르는 것은?",
      "option_a": "```javascript\nfunction toCelsius(fahrenheit) {\n    return (5 / 9) * (fahrenheit - 32);\n}\n```",
      "option_b": "```javascript\nfunction toCelsius(fahrenheit) {\n  return (5 / 9) * (fahrenheit - 32);\n}\n```",
      "option_c": "```javascript\nfunction toCelsius(fahrenheit) {\nreturn (5 / 9) * (fahrenheit - 32);\n}\n```",
      "option_d": "```javascript\nfunction toCelsius(fahrenheit){\nreturn (5 / 9) * (fahrenheit - 32);\n}\n```",
      "correct_answer": "B",
      "explanation": "코드 블록의 들여쓰기로 2개의 공백을 사용하도록 권장합니다. 탭 문자는 다른 에디터에서 다르게 해석될 수 있으므로 사용하지 않습니다. 또한 여는 중괄호 앞에는 한 칸의 공백을 두어야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T08:05:43.000Z"
    },
    {
      "id": 507,
      "subject_id": 1,
      "question": "다음 중 전역 변수 사용을 피해야 하는 이유로 올바른 것은?",
      "option_a": "메모리를 많이 사용하기 때문",
      "option_b": "실행 속도가 느려지기 때문",
      "option_c": "다른 스크립트에 의해 덮어쓰여질 수 있기 때문",
      "option_d": "브라우저 호환성 문제가 발생하기 때문",
      "correct_answer": "C",
      "explanation": "전역 변수와 함수는 다른 스크립트에 의해 덮어쓰여질 수 있어 예상치 못한 오류를 발생시킬 수 있습니다. 대신 지역 변수를 사용하고 클로저(closures)를 활용하는 것이 좋습니다. 전역 변수는 모든 데이터 타입, 객체, 함수에 적용되는 문제입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T08:06:26.000Z"
    },
    {
      "id": 508,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 선언 키워드는?\n```javascript\n_____ car = {type:\"Fiat\", model:\"500\", color:\"white\"};\ncar = \"Fiat\"; // 이 코드가 실행되지 않도록 하려면?\n```",
      "option_a": "var",
      "option_b": "let",
      "option_c": "const",
      "option_d": "global",
      "correct_answer": "C",
      "explanation": "객체를 `const`로 선언하면 객체 자체를 다른 값으로 재할당하는 것을 방지할 수 있습니다. `let car`로 선언하면 `car = \"Fiat\"`처럼 객체를 문자열로 변경할 수 있지만, `const car`로 선언하면 이런 실수를 방지할 수 있습니다. 객체의 내부 속성은 여전히 변경 가능합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T08:07:42.000Z"
    },
    {
      "id": 509,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nlet x = 5 + \"7\";\nlet y = \"5\" - 7;\nconsole.log(typeof x, typeof y);\n```",
      "option_a": "\"number string\"",
      "option_b": "\"string number\"",
      "option_c": "\"number number\"",
      "option_d": "\"string string\"",
      "correct_answer": "B",
      "explanation": "JavaScript의 자동 타입 변환으로 인해 `5 + \"7\"`은 문자열 연결이 되어 \"57\" (string)이 되고, `\"5\" - 7`은 숫자 연산이 되어 -2 (number)가 됩니다. 덧셈(+)은 문자열 연결로 우선 해석되지만, 뺄셈(-)은 숫자 연산만 가능하므로 문자열이 숫자로 변환됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T08:09:13.000Z"
    },
    {
      "id": 510,
      "subject_id": 1,
      "question": "다음 비교 연산의 결과로 올바른 것은?\n```javascript\nconsole.log(0 == \"\");     // A\nconsole.log(0 === \"\");    // B\nconsole.log(1 == true);   // C\nconsole.log(1 === true);  // D\n```",
      "option_a": "A: false, B: false, C: false, D: false",
      "option_b": "A: true, B: false, C: true, D: false",
      "option_c": "A: false, B: true, C: false, D: true",
      "option_d": "A: true, B: true, C: true, D: true",
      "correct_answer": "B",
      "explanation": "`==` 연산자는 타입 변환 후 비교하므로 `0 == \"\"`와 `1 == true`는 모두 true입니다. 하지만 `===` 연산자는 타입과 값을 모두 비교하므로 `0 === \"\"`(숫자 vs 문자열)와 `1 === true`(숫자 vs 불린)는 모두 false입니다. 따라서 정확한 비교를 위해 `===`를 사용해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T08:10:41.000Z"
    },
    {
      "id": 511,
      "subject_id": 1,
      "question": "다음 중 피해야 할 JavaScript 관습이 아닌 것은?",
      "option_a": "`new String()` 사용하기",
      "option_b": "`eval()` 함수 사용하기",
      "option_c": "전역 변수 사용하기",
      "option_d": "`const` 키워드로 배열 선언하기",
      "correct_answer": "D",
      "explanation": "`const`로 배열을 선언하는 것은 권장되는 좋은 관습입니다. 이렇게 하면 실수로 배열을 다른 타입으로 변경하는 것을 방지할 수 있습니다. 반면 `new String()`, `eval()`, 전역 변수 사용은 모두 피해야 할 관습들입니다. `new Object()` 대신 `{}`를, `new Array()` 대신 `[]`를 사용하는 것이 좋습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T08:12:21.000Z"
    },
    {
      "id": 512,
      "subject_id": 1,
      "question": "다음 중 JavaScript에서 변수명으로 사용할 수 없는 예약어는?",
      "option_a": "userName",
      "option_b": "function",
      "option_c": "myClass",
      "option_d": "getData",
      "correct_answer": "B",
      "explanation": "`function`은 JavaScript의 예약어로, 함수를 정의할 때 사용하는 키워드입니다. 예약어는 언어에서 특별한 의미를 가지는 단어들로, 변수명이나 함수명으로 사용할 수 없습니다. `userName`, `myClass`, `getData`는 모두 일반적인 식별자로 사용 가능합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T09:10:57.000Z"
    },
    {
      "id": 513,
      "subject_id": 1,
      "question": "다음 코드에서 에러가 발생하는 이유는?\n```javascript\nlet class = \"Mathematics\";\nconsole.log(class);\n```",
      "option_a": "let 키워드 사용법이 틀림",
      "option_b": "class는 예약어이므로 변수명으로 사용 불가",
      "option_c": "문자열 할당 방법이 틀림",
      "option_d": "console.log 사용법이 틀림",
      "correct_answer": "B",
      "explanation": "`class`는 ES6에서 도입된 예약어로, 클래스를 정의할 때 사용됩니다. 따라서 변수명으로 사용할 수 없습니다. ES5와 ES6에서 새로 추가된 예약어들(`class`, `const`, `let`, `import`, `export` 등)은 모두 변수명으로 사용이 금지됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T09:20:09.000Z"
    },
    {
      "id": 514,
      "subject_id": 1,
      "question": "다음 중 피해야 할 변수명은?",
      "option_a": "myArray",
      "option_b": "Array",
      "option_c": "arrayList",
      "option_d": "userArray",
      "correct_answer": "B",
      "explanation": "`Array`는 JavaScript의 내장 객체 이름입니다. 예약어는 아니지만, 내장 객체, 속성, 메서드의 이름을 변수명으로 사용하면 예상치 못한 오류가 발생할 수 있습니다. `Array`, `Object`, `String`, `Number`, `Date` 등의 내장 객체 이름은 변수명으로 사용하지 않는 것이 좋습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T09:22:11.000Z"
    },
    {
      "id": 515,
      "subject_id": 1,
      "question": "ECMAScript 2015(ES6)에서 새로 도입된 기능이 아닌 것은?",
      "option_a": "Arrow Functions",
      "option_b": "let과 const 키워드",
      "option_c": "Classes",
      "option_d": "JSON.parse()",
      "correct_answer": "D",
      "explanation": "`JSON.parse()`는 ECMAScript 2009(ES5)에서 도입된 기능입니다. ES6(2015)에서는 Arrow Functions, let/const 키워드, Classes, Promises, Map/Set 객체, 템플릿 리터럴 등이 새로 도입되었습니다. ES5에서는 JSON 관련 메서드, 배열 메서드(forEach, map, filter 등), strict mode 등이 추가되었습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T09:24:57.000Z"
    },
    {
      "id": 516,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 ES6 문법은?\n```javascript\n// ES6 화살표 함수\n_____ add = (a, b) => a + b;\nconsole.log(add(2, 3)); // 5\n```",
      "option_a": "var",
      "option_b": "let",
      "option_c": "const",
      "option_d": "function",
      "correct_answer": "C",
      "explanation": "화살표 함수를 변수에 할당할 때는 `const`를 사용하는 것이 좋습니다. 함수는 일반적으로 재할당되지 않으므로 `const`로 선언하여 실수로 다른 값이 할당되는 것을 방지할 수 있습니다. ES6에서는 `const`와 `let`이 새로 도입되어 블록 스코프를 제공합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T09:25:59.000Z"
    },
    {
      "id": 517,
      "subject_id": 1,
      "question": "다음 중 HTML 이벤트 핸들러와 충돌을 피하기 위해 변수명으로 사용하지 말아야 할 것은?",
      "option_a": "clickHandler",
      "option_b": "onclick",
      "option_c": "handleClick",
      "option_d": "buttonClick",
      "correct_answer": "B",
      "explanation": "`onclick`은 HTML 이벤트 핸들러 이름입니다. `onblur`, `onfocus`, `onkeydown`, `onmouseover`, `onsubmit` 등과 같은 이벤트 핸들러 이름들은 변수명으로 사용하면 HTML 요소의 이벤트 속성과 충돌할 수 있습니다. 이런 이름들은 피하고 `clickHandle`r와 같이 명확한 이름을 사용하는 것이 좋습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T09:40:57.000Z"
    },
    {
      "id": 518,
      "subject_id": 1,
      "question": "다음 코드에서 사용된 ES2020의 새로운 연산자는?\n```javascript\nconst user = {\n    name: \"John\",\n    age: null\n};\n\nconst displayAge = user.age _____ \"나이 정보 없음\";\nconsole.log(displayAge); // \"나이 정보 없음\"\n```",
      "option_a": "||",
      "option_b": "&&",
      "option_c": "??",
      "option_d": "?.",
      "correct_answer": "C",
      "explanation": "`??`는 ES2020에서 도입된 Nullish Coalescing 연산자입니다. 이 연산자는 왼쪽 값이 `null`이나 `undefined`일 때만 오른쪽 값을 반환합니다. `||` 연산자와 달리 `0`, `\"\"`, `false`는 falsy하지만 nullish하지 않으므로 왼쪽 값을 그대로 반환합니다. `?.`는 Optional Chaining 연산자입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T09:42:56.000Z"
    },
    {
      "id": 519,
      "subject_id": 1,
      "question": "JavaScript 2022년에 새로 추가된 기능으로 올바른 것은?\n```javascript\nconst arr = [1, 2, 3, 4, 5];\nconst element = arr.____(-1); // 마지막 요소에 접근\nconsole.log(element); // 5\n```",
      "option_a": "get",
      "option_b": "at",
      "option_c": "item",
      "option_d": "index",
      "correct_answer": "B",
      "explanation": "`at()` 메서드는 JavaScript 2022에서 배열과 문자열에 추가된 메서드입니다. 음수 인덱스를 사용하여 뒤에서부터 요소에 접근할 수 있습니다. `arr.at(-1)`은 마지막 요소, `arr.at(-2)`는 뒤에서 두 번째 요소를 반환합니다. 이는 `arr[arr.length - 1]`보다 간편한 문법입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T09:44:15.000Z"
    },
    {
      "id": 520,
      "subject_id": 1,
      "question": "JavaScript 문자열의 기본 특성에 대한 설명으로 올바른 것은?",
      "option_a": "문자열은 변경 가능(mutable)하며, 원본 문자열을 직접 수정할 수 있다",
      "option_b": "문자열은 변경 불가능(immutable)하며, 모든 문자열 메서드는 새로운 문자열을 반환한다",
      "option_c": "문자열은 배열과 동일한 데이터 타입이다",
      "option_d": "문자열 메서드는 원본 문자열을 수정하고 undefined를 반환한다",
      "correct_answer": "B",
      "explanation": "JavaScript 문자열은 원시(primitive) 타입이며 불변(immutable)합니다. 즉, 한 번 생성된 문자열은 변경할 수 없으며, 모든 문자열 메서드들은 원본 문자열을 그대로 두고 새로운 문자열을 생성하여 반환합니다. 이는 메모리 효율성과 데이터 안정성을 위한 JavaScript의 설계 철학입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T09:58:45.000Z"
    },
    {
      "id": 521,
      "subject_id": 1,
      "question": "빈칸에 들어갈 올바른 코드는?\n```javascript\nlet text = \"Hello World\";\nlet length = text.______;\n```",
      "option_a": "size()",
      "option_b": "count",
      "option_c": "length",
      "option_d": "getLength()",
      "correct_answer": "C",
      "explanation": "JavaScript에서 문자열의 길이를 구하는 것은 `length` 프로퍼티를 사용합니다. 이는 메서드가 아닌 속성(property)이므로 괄호()를 붙이지 않습니다. `text.length`는 11을 반환합니다 (공백 포함).",
      "difficulty": "easy",
      "created_at": "2025-08-07T10:00:01.000Z"
    },
    {
      "id": 522,
      "subject_id": 1,
      "question": "다음 코드에서 `char` 변수의 값은?\n```javascript\nlet text = \"JAVASCRIPT\";\nlet char = text.charAt(4);\n```",
      "option_a": "\"S\"",
      "option_b": "\"A\"",
      "option_c": "\"C\"",
      "option_d": "\"R\"",
      "correct_answer": "C",
      "explanation": "`charAt()` 메서드는 지정된 인덱스의 문자를 반환합니다. JavaScript는 0부터 인덱스를 세므로:\n\n1) 인덱스 0: \"J\"\n2) 인덱스 1: \"A\"\n3) 인덱스 2: \"V\"\n4) 인덱스 3: \"A\"\n5) 인덱스 4: \"S\"\n따라서 `charAt(4)`는 \"S\"를 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T10:01:47.000Z"
    },
    {
      "id": 523,
      "subject_id": 1,
      "question": "다음 중 ES2022에서 새로 도입된 문자열 메서드로, 음수 인덱스를 지원하는 것은?\n```javascript\nconst name = \"JavaScript\";\nlet result = name.___(-2);\n```",
      "option_a": "charAt(-2)",
      "option_b": "at(-2)",
      "option_c": "get(-2)",
      "option_d": "index(-2)",
      "correct_answer": "B",
      "explanation": "`at()` 메서드는 ES2022에서 새로 도입된 메서드로, `charAt()`과 달리 음수 인덱스를 지원합니다. `name.at(-2)`는 뒤에서 두 번째 문자인 \"p\"를 반환합니다. `charAt()` 메서드는 음수 인덱스를 지원하지 않으며, 음수를 전달하면 빈 문자열을 반환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T10:02:59.000Z"
    },
    {
      "id": 524,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 올바른 것은?\n```javascript\nlet text = \"Apple, Banana, Kiwi\";\nlet part = text.slice(7, 13);\n```",
      "option_a": "\"Apple\"",
      "option_b": "\"Banana\"",
      "option_c": "\", Bana\"",
      "option_d": "\"Banana,\"",
      "correct_answer": "B",
      "explanation": "`slice()` 메서드는 시작 인덱스부터 끝 인덱스 직전까지의 부분 문자열을 추출합니다.\n\n1) 인덱스 7부터 12까지 (13은 포함되지 않음)\n2) 인덱스 7: \"B\", 8: \"a\", 9: \"n\", 10: \"a\", 11: \"n\", 12: \"a\"\n따라서 \"Banana\"가 반환됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T10:04:01.000Z"
    },
    {
      "id": 525,
      "subject_id": 1,
      "question": "속성 접근 방식 `[]`과 `charAt()` 메서드의 차이점으로 올바른 것은?\n```javascript\nlet text = \"Hello\";\nconsole.log(text[10]);     // A\nconsole.log(text.charAt(10)); // B\n```",
      "option_a": "A: undefined, B: undefined",
      "option_b": "A: \" \", B: \" \"",
      "option_c": "A: undefined, B: \" \"",
      "option_d": "A: \" \", B: undefined",
      "correct_answer": "C",
      "explanation": "존재하지 않는 인덱스에 접근할 때:\n\n1) 속성 접근 방식 `[]`은 `undefined`를 반환\n2) `charAt()` 메서드는 빈 문자열 `\" \"`을 반환\n\n이는 중요한 차이점으로, `charAt()`이 더 안전한 방법으로 간주됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T10:05:29.000Z"
    },
    {
      "id": 526,
      "subject_id": 1,
      "question": "양쪽 끝의 공백만 제거하고 싶을 때 빈칸에 들어갈 메서드는?\n```javascript\nlet text = \"  Hello World!  \";\nlet result = text.____();\n```",
      "option_a": "trimStart",
      "option_b": "trimEnd",
      "option_c": "trim",
      "option_d": "removeSpaces",
      "correct_answer": "C",
      "explanation": "1) `trim()`: 문자열 양쪽 끝의 공백 제거\n2) `trimStart()`: 문자열 시작 부분의 공백만 제거\n3) `trimEnd()`: 문자열 끝 부분의 공백만 제거\n4) `removeSpaces()`는 존재하지 않는 메서드\n\n`trim()`을 사용하면 \"Hello World!\"가 반환됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T10:06:58.000Z"
    },
    {
      "id": 527,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nlet text = \"5\";\nlet result = text.padStart(4, \"0\");\nconsole.log(result);\n```",
      "option_a": "\"5000\"",
      "option_b": "\"0005\"",
      "option_c": "\"0050\"",
      "option_d": "\"5005\"",
      "correct_answer": "B",
      "explanation": "`padStart()` 메서드는 문자열의 시작 부분에 지정된 문자로 패딩을 추가하여 목표 길이에 맞춥니다.\n\n1) 현재 문자열 \"5\"의 길이: 1\n2) 목표 길이: 4\n3) 부족한 길이: 3\n4) 패딩 문자: \"0\"\n\n따라서 시작 부분에 \"000\"을 추가하여 \"0005\"가 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T10:08:30.000Z"
    },
    {
      "id": 528,
      "subject_id": 1,
      "question": "다음 코드에서 `newText`의 값은?\n```javascript\nlet text = \"Please visit Microsoft and Microsoft!\";\nlet newText = text.replace(\"Microsoft\", \"Google\");\n```",
      "option_a": "\"Please visit Google and Google!\"",
      "option_b": "\"Please visit Microsoft and Google!\"",
      "option_c": "\"Please visit Google and Microsoft!\"",
      "option_d": "\"Please visit Google!\"",
      "correct_answer": "C",
      "explanation": "`replace()` 메서드는 기본적으로 첫 번째로 일치하는 문자열만 교체합니다. 모든 일치하는 문자열을 교체하려면 정규표현식의 global 플래그(`/Microsoft/g`)를 사용하거나 ES2021의 `replaceAll()` 메서드를 사용해야 합니다. 따라서 첫 번째 \"Microsoft\"만 \"Google\"로 바뀌어 \"Please visit Google and Microsoft!\"가 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T10:09:41.000Z"
    },
    {
      "id": 529,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 올바른 것은?\n```javascript\nlet text = \"JavaScript Programming\";\nlet result = text.split(\" \");\nconsole.log(result.length);\nconsole.log(result[1]);\n```",
      "option_a": "length: 2, result[1]: \"Programming\"",
      "option_b": "length: 1, result[1]: undefined",
      "option_c": "length: 2, result[1]: \"JavaScript\"",
      "option_d": "length: 3, result[1]: \" \"",
      "correct_answer": "A",
      "explanation": "`split(\" \")` 메서드는 공백을 기준으로 문자열을 배열로 분할합니다.\n\n1) \"JavaScript Programming\"을 공백으로 나누면\n2) 결과 배열: [\"JavaScript\", \"Programming\"]\n3) 배열의 길이: 2\n4) result[0]: \"JavaScript\"\n5) result[1]: \"Programming\"\n\n따라서 `result.length`는 2이고, `result[1]`은 \"Programming\"입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T10:11:03.000Z"
    },
    {
      "id": 530,
      "subject_id": 1,
      "question": "JavaScript에서 숫자를 문자열로 변환하는 기본 메서드는 무엇인가요?",
      "option_a": "toNumber()",
      "option_b": "toString()",
      "option_c": "convertString()",
      "option_d": "stringValue()",
      "correct_answer": "B",
      "explanation": "`toString()` 메서드는 숫자를 문자열로 변환하는 가장 기본적인 메서드입니다. 예를 들어 `(123).toString()`은 `\"123\"`을 반환합니다. 이 메서드는 모든 숫자 타입(리터럴, 변수, 표현식)에 사용할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T10:31:42.000Z"
    },
    {
      "id": 531,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇인가요?\n```javascript\nlet x = 123;\nlet result = x.toString(2);\nconsole.log(result);\n```",
      "option_a": "\"123\"",
      "option_b": "\"1111011\"",
      "option_c": "\"246\"",
      "option_d": "\"error\"",
      "correct_answer": "B",
      "explanation": "`toString()` 메서드에 매개변수를 전달하면 해당 진법으로 변환됩니다. `toString(2)`는 2진법으로 변환하므로, 십진수 123은 이진수 \"1111011\"로 변환됩니다. 이는 진법 변환에 매우 유용한 기능입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T10:32:41.000Z"
    },
    {
      "id": 532,
      "subject_id": 1,
      "question": "금액 계산에 가장 적합한 메서드는 무엇인가요?\n```javascript\nlet price = 29.996;\nlet displayPrice = price.________(2);\n// displayPrice = \"30.00\"\n```",
      "option_a": "toPrecision(2)",
      "option_b": "toExponential(2)",
      "option_c": "toFixed(2)",
      "option_d": "toString(2)",
      "correct_answer": "C",
      "explanation": "`toFixed()` 메서드는 소수점 이하 자릿수를 고정하여 반올림합니다. 매개변수로 소수점 이하 자릿수를 지정할 수 있어 금액 표시에 완벽합니다. `toFixed(2)`는 항상 소수점 이하 2자리를 표시하므로 통화 표시에 이상적입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T10:33:49.000Z"
    },
    {
      "id": 533,
      "subject_id": 1,
      "question": "다음 중 `toPrecision()` 메서드에 대한 올바른 설명은?",
      "option_a": "소수점 이하 자릿수를 고정한다",
      "option_b": "지수 표기법으로만 변환한다",
      "option_c": "전체 자릿수(유효숫자)를 지정한다",
      "option_d": "진법을 변환한다",
      "correct_answer": "C",
      "explanation": "`toPrecision()` 메서드는 전체 유효 자릿수를 지정합니다. 예를 들어 `(9.656).toPrecision(4)`는 \"9.656\"을 반환하고, `(9.656).toPrecision(2)`는 \"9.7\"을 반환합니다. `toFixed()`와 달리 소수점 위치가 아닌 전체 자릿수를 기준으로 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T10:35:04.000Z"
    },
    {
      "id": 534,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 구문은?\n```javascript\nlet str = \"42.7years\";\nlet num = ________;\n// num = 42.7\n```",
      "option_a": "Number(str)",
      "option_b": "parseInt(str)",
      "option_c": "parseFloat(str)",
      "option_d": "Number.isInteger(str)",
      "correct_answer": "C",
      "explanation": "`parseFloat()`는 문자열에서 처음 나오는 유효한 부동소수점 숫자를 추출합니다. \"42.7years\"에서 \"42.7\"만 추출하여 숫자로 변환합니다. `Number(str)`은 전체 문자열이 숫자가 아니면 NaN을 반환하고, `parseInt()`는 정수 부분만 추출하여 42를 반환할 것입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T10:36:08.000Z"
    },
    {
      "id": 535,
      "subject_id": 1,
      "question": "다음 중 Static Method(정적 메서드)가 아닌 것은?",
      "option_a": "Number.isInteger()",
      "option_b": "Number.parseFloat()",
      "option_c": "Number.isFinite()",
      "option_d": "valueOf()",
      "correct_answer": "D",
      "explanation": "`valueOf()`는 인스턴스 메서드로, 특정 숫자 객체에서 호출됩니다(예: `x.valueOf()`). 반면 1,2,3번은 모두 `Number` 객체의 정적 메서드로 `Number.메서드명()` 형식으로 호출됩니다. 정적 메서드는 객체 생성 없이 직접 클래스에서 호출할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T10:37:22.000Z"
    },
    {
      "id": 536,
      "subject_id": 1,
      "question": "다음 중 `Number()` 함수의 결과가 다른 것은?",
      "option_a": "Number(true)",
      "option_b": "Number(\"10\")",
      "option_c": "Number(\" 10 \")",
      "option_d": "Number(\"10,33\")",
      "correct_answer": "D",
      "explanation": "`Number()` 함수는 다양한 타입을 숫자로 변환합니다. `Number(true)`는 1, `Number(\"10\")`과 `Number(\" 10 \")`는 모두 10을 반환합니다(앞뒤 공백은 무시됨). 하지만 `Number(\"10,33\")`는 쉼표가 포함되어 있어 유효하지 않은 숫자 형식이므로 NaN을 반환합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T10:39:23.000Z"
    },
    {
      "id": 537,
      "subject_id": 1,
      "question": "다음 코드에서 올바른 NaN 검사 방법은?\n```javascript\nlet result = Number(\"abc\");\n// result는 NaN\n```",
      "option_a": "result == NaN",
      "option_b": "result === NaN",
      "option_c": "Number.isNaN(result)",
      "option_d": "result.isNaN()",
      "correct_answer": "C",
      "explanation": "NaN은 특수한 값으로 자기 자신과도 같지 않은 유일한 값입니다. 따라서 `==`이나 `===`로 비교할 수 없습니다. `Number.isNaN()`이 NaN을 확인하는 권장 방법입니다. 이는 전역 함수 `isNaN()`보다 더 정확하며, 실제로 NaN인 값만 true를 반환합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T10:40:29.000Z"
    },
    {
      "id": 538,
      "subject_id": 1,
      "question": "JavaScript에서 가장 큰 수를 나타내는 상수는 무엇인가요?",
      "option_a": "Number.MAX_VALUE",
      "option_b": "Number.BIG_NUMBER",
      "option_c": "Number.LARGEST",
      "option_d": "Number.MAXIMUM",
      "correct_answer": "A",
      "explanation": "`Number.MAX_VALUE`는 JavaScript에서 표현 가능한 가장 큰 수를 나타내는 상수입니다. 이 값은 약 1.7976931348623157e+308입니다. 이는 64비트 부동소수점 표현의 최대값으로, 이보다 큰 수는 Infinity로 표현됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T10:43:19.000Z"
    },
    {
      "id": 539,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇인가요?\n```javascript\nlet x = 6;\nconsole.log(x.MAX_VALUE);\n```",
      "option_a": "1.7976931348623157e+308",
      "option_b": "undefined",
      "option_c": "6",
      "option_d": "error",
      "correct_answer": "B",
      "explanation": "Number 속성들은 `Number` 객체에만 속하며, 변수나 리터럴 값에서는 사용할 수 없습니다. `x.MAX_VALUE`처럼 변수에서 Number 속성을 사용하면 `undefined`가 반환됩니다. 올바른 사용법은 `Number.MAX_VALUE`입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T10:44:42.000Z"
    },
    {
      "id": 540,
      "subject_id": 1,
      "question": "빈칸에 들어갈 올바른 속성은 무엇인가요?\n```javascript\nlet smallest = Number.________;\n// smallest = 5e-324 (가장 작은 양수)\n```",
      "option_a": "MIN_VALUE",
      "option_b": "SMALLEST_VALUE",
      "option_c": "MINIMUM_VALUE",
      "option_d": "TINY_VALUE",
      "correct_answer": "A",
      "explanation": "`Number.MIN_VALUE`는 JavaScript에서 표현 가능한 가장 작은 양수(0보다 큰 가장 작은 수)를 나타냅니다. 이 값은 5e-324입니다. 주의할 점은 이것이 가장 작은 '음수'가 아니라 0에 가장 가까운 '양수'라는 것입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T10:45:56.000Z"
    },
    {
      "id": 541,
      "subject_id": 1,
      "question": "다음 중 안전한 정수의 최대값을 나타내는 것은?",
      "option_a": "9007199254740991",
      "option_b": "1.7976931348623157e+308",
      "option_c": "2.220446049250313e-16",
      "option_d": "Infinity",
      "correct_answer": "A",
      "explanation": "`Number.MAX_SAFE_INTEGER`의 값은 9007199254740991로, 이는 2<sup>53</sup>-1입니다. 이 범위 내의 정수들은 정확하게 표현될 수 있습니다. 이를 초과하는 정수는 부정확하게 표현될 수 있어 계산 오류가 발생할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T10:48:57.000Z"
    },
    {
      "id": 542,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconsole.log(1 / 0);\nconsole.log(-1 / 0);\n```",
      "option_a": "Error, Error",
      "option_b": "NaN, NaN",
      "option_c": "Infinity, -Infinity",
      "option_d": "undefined, undefined",
      "correct_answer": "C",
      "explanation": "JavaScript에서 양수를 0으로 나누면 `Infinity`가, 음수를 0으로 나누면 `-Infinity`가 반환됩니다. 이는 수학적 오버플로우 상황을 나타내며, `Number.POSITIVE_INFINITY`와 `Number.NEGATIVE_INFINITY` 상수값과 동일합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T10:50:48.000Z"
    },
    {
      "id": 543,
      "subject_id": 1,
      "question": "다음 중 NaN을 반환하는 연산은?",
      "option_a": "1 / 0",
      "option_b": "-1 / 0",
      "option_c": "100 / \"Apple\"",
      "option_d": "Number.MAX_VALUE + 1",
      "correct_answer": "C",
      "explanation": "`100 / \"Apple\"`은 숫자가 아닌 문자열과의 산술 연산이므로 NaN(Not a Number)을 반환합니다. 1/0은 Infinity, -1/0은 -Infinity를 반환하고, Number.MAX_VALUE + 1은 여전히 Number.MAX_VALUE를 반환합니다(부동소수점의 정밀도 한계로 인해).",
      "difficulty": "hard",
      "created_at": "2025-08-07T10:51:46.000Z"
    },
    {
      "id": 544,
      "subject_id": 1,
      "question": "JavaScript 배열의 크기(길이)를 알아내는 속성은 무엇인가요?",
      "option_a": "size",
      "option_b": "length",
      "option_c": "count",
      "option_d": "dimension",
      "correct_answer": "B",
      "explanation": "`length` 속성은 배열의 요소 개수를 반환합니다. 예를 들어 `[\"Apple\", \"Banana\"].length`는 2를 반환합니다. 이 속성은 읽기뿐만 아니라 쓰기도 가능하여 배열의 길이를 직접 설정할 수도 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T11:01:20.000Z"
    },
    {
      "id": 545,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇인가요?\n```javascript\nconst fruits = [\"Apple\", \"Banana\", \"Orange\"];\nconsole.log(fruits.toString());\n```",
      "option_a": "[\"Apple\", \"Banana\", \"Orange\"]",
      "option_b": "Apple,Banana,Orange",
      "option_c": "Apple Banana Orange",
      "option_d": "AppleBananaOrange",
      "correct_answer": "B",
      "explanation": "`toString()` 메서드는 배열의 모든 요소를 쉼표로 구분된 문자열로 변환합니다. 결과는 \"Apple,Banana,Orange\"입니다. JavaScript는 배열을 텍스트로 표시해야 할 때 내부적으로 이 메서드를 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T11:02:14.000Z"
    },
    {
      "id": 546,
      "subject_id": 1,
      "question": "빈칸에 들어갈 올바른 메서드는 무엇인가요?\n```javascript\nconst fruits = [\"Apple\", \"Banana\", \"Orange\"];\nlet result = fruits.______(\" * \");\n// result = \"Apple * Banana * Orange\"\n```",
      "option_a": "toString",
      "option_b": "join",
      "option_c": "connect",
      "option_d": "combine",
      "correct_answer": "B",
      "explanation": "`join()` 메서드는 `toString()`과 비슷하지만 구분자를 지정할 수 있습니다. `fruits.join(\" * \")`는 배열 요소들을 \" * \"로 연결하여 \"Apple * Banana * Orange\"를 반환합니다. 매개변수를 생략하면 쉼표가 기본 구분자로 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T11:09:43.000Z"
    },
    {
      "id": 547,
      "subject_id": 1,
      "question": "다음 코드 실행 후 배열의 상태는?\n```javascript\nconst numbers = [1, 2, 3, 4];\nlet removed = numbers.pop();\nconsole.log(numbers);\nconsole.log(removed);\n```",
      "option_a": "[1, 2, 3, 4], undefined",
      "option_b": "[1, 2, 3], 4",
      "option_c": "[2, 3, 4], 1",
      "option_d": "[1, 2, 3, 4], 4",
      "correct_answer": "B",
      "explanation": "`pop()` 메서드는 배열의 마지막 요소를 제거하고 그 값을 반환합니다. 따라서 `numbers`는 [1, 2, 3]이 되고, `removed`는 4가 됩니다. 이는 스택의 LIFO(Last In First Out) 구조와 같습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T11:10:58.000Z"
    },
    {
      "id": 548,
      "subject_id": 1,
      "question": "다음 중 배열의 첫 번째 요소를 제거하는 메서드는?",
      "option_a": "pop()",
      "option_b": "push()",
      "option_c": "shift()",
      "option_d": "unshift()",
      "correct_answer": "C",
      "explanation": "`shift()` 메서드는 배열의 첫 번째 요소를 제거하고 나머지 요소들을 왼쪽으로 이동시킵니다. `pop()`은 마지막 요소를 제거하고, `push()`는 끝에 추가, `unshift()`는 앞에 추가합니다. shift는 \"이동\"의 의미로 요소들이 앞으로 이동한다고 생각하면 기억하기 쉽습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T11:11:53.000Z"
    },
    {
      "id": 549,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 메서드는?\n```javascript\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\nconst result = arr1.______(arr2);\n// arr1은 변경되지 않고, result = [1, 2, 3, 4]\n```",
      "option_a": "merge",
      "option_b": "concat",
      "option_c": "append",
      "option_d": "combine",
      "correct_answer": "B",
      "explanation": "`concat()` 메서드는 기존 배열을 변경하지 않고 새로운 배열을 생성하여 반환합니다. 원본 배열 `arr1`은 그대로 유지되고, `result`에는 두 배열이 합쳐진 새로운 배열 [1, 2, 3, 4]가 저장됩니다. 여러 개의 배열이나 값을 한 번에 연결할 수도 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:12:57.000Z"
    },
    {
      "id": 550,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst fruits = [\"Apple\", \"Orange\", \"Apple\", \"Mango\"];\nlet pos1 = fruits.indexOf(\"Apple\");\nlet pos2 = fruits.lastIndexOf(\"Apple\");\nconsole.log(pos1, pos2);\n```",
      "option_a": "0, 0",
      "option_b": "0, 2",
      "option_c": "1, 3",
      "option_d": "-1, -1",
      "correct_answer": "B",
      "explanation": "`indexOf()`는 찾는 요소의 첫 번째 위치를, `lastIndexOf()`는 마지막 위치를 반환합니다. \"Apple\"은 인덱스 0과 2에 있으므로 결과는 0, 2입니다. 배열 인덱스는 0부터 시작한다는 점을 기억해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:13:54.000Z"
    },
    {
      "id": 551,
      "subject_id": 1,
      "question": "ES2016에서 도입된 다음 메서드의 특징으로 올바른 것은?\n```javascript\nconst fruits = [\"Apple\", \"Banana\", \"Orange\"];\nconsole.log(fruits.includes(\"Banana\")); // true\n```",
      "option_a": "인덱스를 반환한다",
      "option_b": "NaN 값을 찾을 수 없다",
      "option_c": "boolean 값을 반환한다",
      "option_d": "첫 번째 발견 위치만 찾는다",
      "correct_answer": "C",
      "explanation": "`includes()` 메서드는 배열에 특정 요소가 포함되어 있는지 확인하여 `true` 또는 `false`를 반환합니다. `indexOf()`와 달리 NaN 값도 찾을 수 있으며, 위치가 아닌 존재 여부만 확인할 때 유용합니다. ECMAScript 2016에서 도입되었습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:14:56.000Z"
    },
    {
      "id": 552,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 메서드는?\n```javascript\nconst numbers = [4, 9, 16, 25, 29];\nlet result = numbers.______(value => value > 18);\n// result = 25 (18보다 큰 첫 번째 값)\n```",
      "option_a": "find",
      "option_b": "findIndex",
      "option_c": "filter",
      "option_d": "search",
      "correct_answer": "A",
      "explanation": "`find()` 메서드는 주어진 테스트 함수를 만족하는 첫 번째 요소의 값을 반환합니다. `findIndex()`는 값이 아닌 인덱스를 반환하고, `filter()`는 조건을 만족하는 모든 요소의 배열을 반환합니다. ES6에서 도입된 메서드입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:16:05.000Z"
    },
    {
      "id": 553,
      "subject_id": 1,
      "question": "ES2023에서 도입된 다음 두 메서드의 차이점은?\n```javascript\n// 방법 1: findLast()\nconst temp = [27, 28, 30, 40, 42, 35, 30];\nlet last1 = temp.findLast(x => x > 40); // 42\n\n// 방법 2: findLastIndex()  \nlet last2 = temp.findLastIndex(x => x > 40); // 4\n```",
      "option_a": "둘 다 값을 반환한다",
      "option_b": "둘 다 인덱스를 반환한다",
      "option_c": "findLast()는 값을, findLastIndex()는 인덱스를 반환한다",
      "option_d": "검색 방향이 다르다",
      "correct_answer": "C",
      "explanation": "`findLast()`는 조건을 만족하는 마지막 요소의 값을 반환하고, `findLastIndex()`는 그 요소의 인덱스를 반환합니다. 둘 다 배열의 끝에서부터 검색하지만 반환하는 것이 다릅니다. 42 > 40이고 배열에서 마지막에 있는 42의 값은 42, 인덱스는 4입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:17:13.000Z"
    },
    {
      "id": 554,
      "subject_id": 1,
      "question": "JavaScript 배열을 알파벳 순으로 정렬하는 기본 메서드는 무엇인가요?",
      "option_a": "order()",
      "option_b": "sort()",
      "option_c": "arrange()",
      "option_d": "alphabetize()",
      "correct_answer": "B",
      "explanation": "`sort()` 메서드는 배열 요소를 기본적으로 알파벳 순(사전식 순서)으로 정렬합니다. 예를 들어 `[\"Banana\", \"Apple\", \"Orange\"].sort()`는 `[\"Apple\", \"Banana\", \"Orange\"]`를 반환합니다. 이 메서드는 원본 배열을 변경합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T11:20:41.000Z"
    },
    {
      "id": 555,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇인가요?\n```javascript\nconst fruits = [\"Banana\", \"Orange\", \"Apple\"];\nfruits.reverse();\nconsole.log(fruits);\n```",
      "option_a": "[\"Apple\", \"Banana\", \"Orange\"]",
      "option_b": "[\"Apple\", \"Orange\", \"Banana\"]",
      "option_c": "[\"Orange\", \"Banana\", \"Apple\"]",
      "option_d": "[\"Banana\", \"Orange\", \"Apple\"]",
      "correct_answer": "C",
      "explanation": "`reverse()` 메서드는 배열의 요소 순서를 뒤바꿉니다. 원본 배열 `[\"Banana\", \"Orange\", \"Apple\"]`이 `[\"Apple\", \"Orange\", \"Banana\"]`로 변경됩니다. 이 메서드도 원본 배열을 직접 수정합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T11:22:09.000Z"
    },
    {
      "id": 556,
      "subject_id": 1,
      "question": "ES2023에서 도입된 다음 메서드의 특징은 무엇인가요?\n```javascript\nconst months = [\"Jan\", \"Feb\", \"Mar\"];\nconst result = months.______();\n// months는 변경되지 않고, result에 정렬된 새 배열이 저장됨\n```",
      "option_a": "sort",
      "option_b": "toSort",
      "option_c": "toSorted",
      "option_d": "sortSafe",
      "correct_answer": "C",
      "explanation": "`toSorted()` 메서드는 ES2023에서 도입된 \"안전한\" 정렬 메서드입니다. 기존 `sort()`와 달리 원본 배열을 변경하지 않고 정렬된 새로운 배열을 반환합니다. 이는 함수형 프로그래밍 스타일에 더 적합합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T11:23:03.000Z"
    },
    {
      "id": 557,
      "subject_id": 1,
      "question": "다음 코드에서 숫자 배열을 오름차순으로 정렬하려면 빈칸에 무엇이 들어가야 하나요?\n```javascript\nconst numbers = [40, 100, 1, 25, 10];\nnumbers.sort(function(a, b) {\n    return ________;\n});\n```",
      "option_a": "a > b",
      "option_b": "a - b",
      "option_c": "b - a",
      "option_d": "a < b",
      "correct_answer": "B",
      "explanation": "숫자 배열을 올바르게 정렬하려면 비교 함수를 제공해야 합니다. `a - b`는 오름차순 정렬을 위한 표준 패턴입니다. 결과가 음수면 a가 b보다 앞에, 양수면 b가 a보다 앞에 위치합니다. `sort()` 메서드는 기본적으로 문자열로 변환해서 정렬하므로 숫자는 예상과 다른 결과가 나올 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T11:24:01.000Z"
    },
    {
      "id": 558,
      "subject_id": 1,
      "question": "배열을 내림차순으로 정렬하는 올바른 방법은?",
      "option_a": "arr.sort().reverse()",
      "option_b": "arr.sort(function(a, b) { return b - a })",
      "option_c": "arr.reverse().sort()",
      "option_d": "1번과 2번 모두 올바름",
      "correct_answer": "D",
      "explanation": "두 방법 모두 내림차순 정렬이 가능합니다. 방법 1은 먼저 오름차순으로 정렬한 후 순서를 뒤집고, 방법 2는 비교 함수에서 `b - a`를 반환하여 직접 내림차순으로 정렬합니다. 단, 방법 2가 더 효율적입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T11:26:03.000Z"
    },
    {
      "id": 559,
      "subject_id": 1,
      "question": "다음 중 Fisher-Yates 셔플 알고리즘의 핵심 아이디어는 무엇인가요?\n```javascript\nfor (let i = arr.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1));\n    // 요소 교환\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n}\n```",
      "option_a": "배열을 역순으로 정렬한다",
      "option_b": "마지막 요소부터 임의의 앞 요소와 교환한다",
      "option_c": "첫 요소부터 차례로 정렬한다",
      "option_d": "모든 요소를 임의로 섞는다",
      "correct_answer": "B",
      "explanation": "Fisher-Yates 알고리즘은 배열을 뒤에서부터 순회하면서 각 요소를 그보다 앞에 있는(자기 자신 포함) 임의의 요소와 교환합니다. 이 방법은 `Math.random()`을 사용한 단순한 셔플보다 훨씬 균등한 분포를 보장합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:32:41.000Z"
    },
    {
      "id": 560,
      "subject_id": 1,
      "question": "배열에서 최솟값을 찾는 가장 효율적인 방법은?",
      "option_a": "arr.sort()[0]",
      "option_b": "Math.min.apply(null, arr)",
      "option_c": "직접 반복문으로 구현",
      "option_d": "`arr.reduce()`로 구현",
      "correct_answer": "C",
      "explanation": "단순히 최솟값만 찾는다면 전체 배열을 정렬하는 것(`arr.sort()`)은 비효율적입니다. `Math.min.apply(null, arr)`는 간단하지만 스택 오버플로우 위험이 있고, 직접 구현한 반복문이 가장 빠르고 안전합니다. `reduce()`도 좋은 방법이지만 순수 반복문보다는 약간 느립니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:33:59.000Z"
    },
    {
      "id": 561,
      "subject_id": 1,
      "question": "다음 중 `Math.min.apply(null, arr)`와 동일한 효과를 내는 현대적인 JavaScript 문법은?",
      "option_a": "Math.min(...arr)",
      "option_b": "Math.min(arr)",
      "option_c": "arr.min()",
      "option_d": "min(arr)",
      "correct_answer": "A",
      "explanation": "`Math.min(...arr)`는 ES6의 전개 연산자(spread operator)를 사용한 현대적인 문법입니다. `Math.min.apply(null, arr)`와 완전히 동일한 동작을 하지만 더 간결하고 읽기 쉽습니다. `Math.min()`은 개별 인수들을 받아야 하므로, 배열을 전개 연산자로 펼쳐서 전달하는 것입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:35:53.000Z"
    },
    {
      "id": 562,
      "subject_id": 1,
      "question": "다음 중 JavaScript에서 배열의 각 요소에 대해 함수를 한 번씩 호출하는 메서드는?",
      "option_a": "forEach()",
      "option_b": "forAll()",
      "option_c": "eachElement()",
      "option_d": "iterateAll()",
      "correct_answer": "A",
      "explanation": "`forEach()` 메서드는 배열의 각 요소에 대해 제공된 함수를 한 번씩 실행합니다. 이는 배열을 순회하면서 각 요소에 대해 특정 작업을 수행할 때 사용하는 가장 기본적인 반복 메서드입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T11:39:23.000Z"
    },
    {
      "id": 563,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 메서드는?\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.______(function(value) {\n    return value * 2;\n});\n// doubled = [2, 4, 6, 8, 10]\n```",
      "option_a": "forEach",
      "option_b": "map",
      "option_c": "filter",
      "option_d": "reduce",
      "correct_answer": "B",
      "explanation": "`map()` 메서드는 배열의 모든 요소에 대해 함수를 실행하고, 그 결과로 새로운 배열을 생성합니다. 원본 배열은 변경되지 않으며, 각 요소를 변형하여 새 배열을 만들 때 사용합니다. 위 예제에서는 각 숫자를 2배로 만든 새 배열을 생성합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T11:40:24.000Z"
    },
    {
      "id": 564,
      "subject_id": 1,
      "question": "다음 코드에서 `forEach()` 메서드의 콜백 함수가 받는 매개변수의 순서는?\n```javascript\nconst fruits = [\"apple\", \"banana\", \"orange\"];\nfruits.forEach(function(a, b, c) {\n    console.log(a, b, c);\n});\n```",
      "option_a": "value, array, index",
      "option_b": "index, value, array",
      "option_c": "value, index, array",
      "option_d": "array, value, index",
      "correct_answer": "C",
      "explanation": "`forEach()` 메서드의 콜백 함수는 세 개의 매개변수를 받습니다: 첫 번째는 현재 요소의 값(value), 두 번째는 현재 요소의 인덱스(index), 세 번째는 원본 배열(array) 자체입니다. 이 순서는 대부분의 배열 반복 메서드에서 동일합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T11:41:29.000Z"
    },
    {
      "id": 565,
      "subject_id": 1,
      "question": "다음 중 원본 배열을 변경하지 않는 메서드들로만 구성된 것은?",
      "option_a": "`forEach()`, `map()`, `filter()`",
      "option_b": "`map()`, `filter()`, `reduce()`",
      "option_c": "`push()`, `pop()`, `forEach()`",
      "option_d": "`sort()`, `reverse()`, `map()`",
      "correct_answer": "B",
      "explanation": "`map()`, `filter()`, `reduce()` 모두 원본 배열을 변경하지 않고 새로운 값이나 배열을 반환합니다. 반면 `forEach()`는 값을 반환하지 않으며, `push()`, `pop()`, `sort()`, `reverse()` 등은 원본 배열을 직접 수정합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T11:43:23.000Z"
    },
    {
      "id": 566,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 `filter`가 들어갈 때의 결과는?\n```javascript\nconst numbers = [10, 20, 30, 40];\nconst result = numbers.______(function(value) {\n    return value > 25;\n});\nconsole.log(result);\n```",
      "option_a": "[30, 40]",
      "option_b": "[10, 20]",
      "option_c": "true",
      "option_d": "false",
      "correct_answer": "A",
      "explanation": "`filter()` 메서드는 주어진 조건을 만족하는 요소들로만 구성된 새 배열을 반환합니다. 조건 `value > 25`를 만족하는 요소는 30과 40이므로, 결과는 `[30, 40]`입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T11:44:37.000Z"
    },
    {
      "id": 567,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 메서드와 그 결과는?\n```javascript\nconst numbers = [5, 10, 15, 20];\nconst result = numbers.______(function(total, value) {\n    return total + value;\n}, 100);\nconsole.log(result);\n```",
      "option_a": "`map` - `[105, 110, 115, 120]`",
      "option_b": "`filter` - `[5, 10, 15, 20]`",
      "option_c": "`reduce` - `150`",
      "option_d": "`forEach` - `undefined`",
      "correct_answer": "C",
      "explanation": "`reduce()` 메서드는 배열의 각 요소에 대해 함수를 실행하여 하나의 값으로 축약합니다. 초기값이 100이고, 각 요소(5, 10, 15, 20)를 순서대로 더하면: 100 + 5 + 10 + 15 + 20 = 150이 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:46:00.000Z"
    },
    {
      "id": 568,
      "subject_id": 1,
      "question": "다음 중 ES2019(ES10)에서 추가된 메서드는?\n```javascript\nconst arr = [1, 2, 3];\nconst result = arr.______((x) => [x, x * 2]);\n// result = [1, 2, 2, 4, 3, 6]\n```",
      "option_a": "map",
      "option_b": "flatMap",
      "option_c": "flatten",
      "option_d": "expand",
      "correct_answer": "B",
      "explanation": "`flatMap()` 메서드는 ES2019에서 추가되었습니다. 이 메서드는 먼저 각 요소에 대해 매핑 함수를 실행한 후, 결과를 평탄화(flatten)합니다. 위 예제에서는 각 숫자 x에 대해 [x, x*2] 배열을 만들고, 이를 하나의 평탄한 배열로 합칩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:46:53.000Z"
    },
    {
      "id": 569,
      "subject_id": 1,
      "question": "다음 코드에서 `every()`와 `some()` 메서드의 차이점을 보여주는 올바른 설명은?\n```javascript\nconst numbers = [2, 4, 6, 8, 9];\nconst allEven = numbers.every(x => x % 2 === 0);\nconst someEven = numbers.some(x => x % 2 === 0);\n```",
      "option_a": "allEven = true, someEven = true",
      "option_b": "allEven = false, someEven = true",
      "option_c": "allEven = true, someEven = false",
      "option_d": "allEven = false, someEven = false",
      "correct_answer": "B",
      "explanation": "`every()` 메서드는 모든 요소가 조건을 만족할 때만 true를 반환합니다. 배열에 9(홀수)가 있으므로 `allEven`은 false입니다. `some()` 메서드는 하나 이상의 요소가 조건을 만족하면 true를 반환합니다. 2, 4, 6, 8이 모두 짝수이므로 `someEven`은 true입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:48:05.000Z"
    },
    {
      "id": 570,
      "subject_id": 1,
      "question": "다음 spread 연산자를 사용한 코드의 결과는?\n```javascript\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\nconst arr3 = [5, 6];\nconst result = [0, ...arr1, ...arr2, ...arr3, 7];\n```",
      "option_a": "[0, [1,2], [3,4], [5,6], 7]",
      "option_b": "[0, 1, 2, 3, 4, 5, 6, 7]",
      "option_c": "[[0], [1,2], [3,4], [5,6], [7]]",
      "option_d": "Error",
      "correct_answer": "B",
      "explanation": "spread 연산자(`...`)는 배열을 개별 요소로 전개합니다. `...arr1`은 1, 2가 되고, `...arr2`는 3, 4가 되며, `...arr3`은 5, 6이 됩니다. 따라서 결과는 `[0, 1, 2, 3, 4, 5, 6, 7]`이 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:49:55.000Z"
    },
    {
      "id": 571,
      "subject_id": 1,
      "question": "다음 rest 연산자를 사용한 구조분해할당 코드에서 `rest`의 값은?\n```javascript\nconst numbers = [10, 20, 30, 40, 50, 60];\nconst [first, second, ...rest] = numbers;\n```",
      "option_a": "[30, 40, 50, 60]",
      "option_b": "[40, 50, 60]",
      "option_c": "[10, 20]",
      "option_d": "60",
      "correct_answer": "A",
      "explanation": "rest 연산자(`...`)를 구조분해할당에서 사용하면, 지정되지 않은 나머지 모든 요소를 배열로 수집합니다. `first`는 10, `second`는 20을 받고, 나머지 요소들인 `[30, 40, 50, 60]`이 `rest` 변수에 할당됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T11:51:35.000Z"
    },
    {
      "id": 572,
      "subject_id": 1,
      "question": "ES6(ECMAScript 2015)에서 배열 선언 시 권장되는 키워드는?",
      "option_a": "var",
      "option_b": "let",
      "option_c": "const",
      "option_d": "array",
      "correct_answer": "C",
      "explanation": "ES6에서는 배열을 선언할 때 `const` 키워드 사용이 일반적인 관례가 되었습니다. `const`로 선언된 배열은 재할당은 불가능하지만, 배열의 요소들은 변경할 수 있어 실용적입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T11:55:15.000Z"
    },
    {
      "id": 573,
      "subject_id": 1,
      "question": "다음 코드에서 어떤 오류가 발생할까요?\n```javascript\nconst cars = [\"Saab\", \"Volvo\", \"BMW\"];\ncars = [\"Toyota\", \"Volvo\", \"Audi\"];\n```",
      "option_a": "SyntaxError",
      "option_b": "TypeError: Assignment to constant variable",
      "option_c": "ReferenceError",
      "option_d": "오류가 발생하지 않음",
      "correct_answer": "B",
      "explanation": "`const`로 선언된 변수는 재할당할 수 없습니다. `const cars`로 선언된 배열에 새로운 배열을 할당하려고 하면 \"TypeError: Assignment to constant variable\" 오류가 발생합니다. `const`는 상수 참조를 정의하지, 상수 배열을 정의하는 것이 아닙니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T11:56:31.000Z"
    },
    {
      "id": 574,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst cars = [\"Saab\", \"Volvo\", \"BMW\"];\ncars[0] = \"Toyota\";\ncars.push(\"Audi\");\nconsole.log(cars);\n```",
      "option_a": "TypeError가 발생함",
      "option_b": "[\"Saab\", \"Volvo\", \"BMW\"]",
      "option_c": "[\"Toyota\", \"Volvo\", \"BMW\", \"Audi\"]",
      "option_d": "[\"Toyota\", \"Volvo\", \"BMW\"]",
      "correct_answer": "C",
      "explanation": "`const`로 선언된 배열은 재할당은 불가능하지만, 배열의 요소들은 변경할 수 있습니다. `cars[0] = \"Toyota\"`로 첫 번째 요소를 변경하고, `cars.push(\"Audi\")`로 새 요소를 추가할 수 있습니다. `const`는 배열 자체에 대한 참조를 상수로 만들 뿐, 배열의 내용까지 불변으로 만들지는 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T11:57:41.000Z"
    },
    {
      "id": 575,
      "subject_id": 1,
      "question": "다음 코드에서 block scope에 대한 올바른 설명은?\n```javascript\nconst cars = [\"Saab\", \"Volvo\", \"BMW\"];\n// 여기서 cars[0]은 \"Saab\"\n{\n    const cars = [\"Toyota\", \"Volvo\", \"BMW\"];\n    // 여기서 cars[0]은 ______\n}\n// 여기서 cars[0]은 ______\n```",
      "option_a": "블록 내부: \"Saab\", 블록 외부: \"Saab\"",
      "option_b": "블록 내부: \"Toyota\", 블록 외부: \"Toyota\"",
      "option_c": "블록 내부: \"Toyota\", 블록 외부: \"Saab\"",
      "option_d": "SyntaxError가 발생함",
      "correct_answer": "C",
      "explanation": "`const`로 선언된 변수는 블록 스코프를 가집니다. 블록(`{}`) 내부에서 선언된 `const cars`는 블록 내부에서만 유효하며, 외부의 `cars` 변수와는 별개입니다. 따라서 블록 내부에서는 `cars[0]`이 \"Toyota\"이고, 블록을 벗어나면 다시 원래의 \"Saab\"이 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T11:59:22.000Z"
    },
    {
      "id": 576,
      "subject_id": 1,
      "question": "다음 중 `const`로 선언된 배열에 대한 올바른 설명들을 모두 고른 것은?\n\nA. `const`로 선언된 배열은 선언과 동시에 초기화되어야 한다\nB. `const`로 선언된 배열은 같은 스코프에서 재선언할 수 없다\nC. `const`로 선언된 배열은 다른 블록에서는 같은 이름으로 재선언 가능하다\nD. `const`로 선언된 배열의 요소는 변경할 수 없다",
      "option_a": "A, B만 맞음",
      "option_b": "A, B, C만 맞음",
      "option_c": "A, C, D만 맞음",
      "option_d": "모두 맞음",
      "correct_answer": "B",
      "explanation": "1) A (맞음): `const` 변수는 선언할 때 반드시 값을 할당해야 합니다. `const cars;`는 구문 오류입니다.\n2) B (맞음): 같은 스코프나 블록에서 `const`로 선언된 변수를 재선언하면 오류가 발생합니다.\n3) C (맞음): 다른 블록 스코프에서는 같은 이름의 `const` 변수를 새로 선언할 수 있습니다.\n4) D (틀림): `const`는 참조를 상수로 만들 뿐, 배열의 요소들은 변경 가능합니다. `cars[0] = \"newValue\"`나 `cars.push()`같은 작업이 가능합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T12:01:25.000Z"
    },
    {
      "id": 577,
      "subject_id": 1,
      "question": "JavaScript에서 함수를 정의하는 가장 기본적인 방법은 무엇인가요?\n```javascript\n_______ myFunction(a, b) {\n    return a * b;\n}\n```",
      "option_a": "var",
      "option_b": "let",
      "option_c": "function",
      "option_d": "const",
      "correct_answer": "C",
      "explanation": "JavaScript에서 함수를 선언할 때는 `function` 키워드를 사용합니다. 함수 선언(Function Declaration)의 기본 구조는 `function 함수이름(매개변수) { 실행할 코드 }`입니다. `var`, `let`, `const`는 변수 선언에 사용되는 키워드이며, 함수 표현식에서 변수에 함수를 할당할 때 사용될 수 있지만, 함수를 직접 선언할 때는 `function` 키워드가 필요합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T12:05:37.000Z"
    },
    {
      "id": 578,
      "subject_id": 1,
      "question": "다음 코드에서 함수 표현식(Function Expression)으로 작성된 것은?",
      "option_a": "function myFunction(a, b) {\n    return a * b;\n}",
      "option_b": "const x = function(a, b) {\n    return a * b;\n};",
      "option_c": "myFunction(4, 3);",
      "option_d": "function(a, b) {\n    return a * b;\n}",
      "correct_answer": "B",
      "explanation": "함수 표현식은 함수를 변수에 저장하는 방식입니다. `const x = function(a, b) { return a * b; };`에서 익명 함수가 변수 `x`에 할당되어 있습니다. ①번은 함수 선언문이고, ③번은 함수 호출이며, ④번은 문법적으로 올바르지 않습니다. 함수 표현식의 특징은 변수에 함수가 저장되고, 세미콜론으로 끝나며, 함수에 이름이 없어도 된다는 점입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T12:08:05.000Z"
    },
    {
      "id": 579,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇인가요?\n```javascript\nmyFunction(5);\n\nfunction myFunction(y) {\n    return y * y;\n}\n```",
      "option_a": "오류 발생",
      "option_b": "undefined",
      "option_c": "25",
      "option_d": "5",
      "correct_answer": "C",
      "explanation": "이것은 JavaScript의 \"호이스팅(Hoisting)\" 개념과 관련이 있습니다. 함수 선언문은 호이스팅되어 코드의 맨 위로 끌어올려지기 때문에, 함수가 선언되기 전에 호출해도 정상적으로 작동합니다. 따라서 `myFunction(5)`는 5 × 5 = 25를 반환합니다. 하지만 함수 표현식은 호이스팅되지 않으므로, 만약 `const myFunction = function(y) { return y * y; }`로 작성되었다면 함수 선언 전에 호출할 수 없습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T12:10:19.000Z"
    },
    {
      "id": 580,
      "subject_id": 1,
      "question": "다음 빈칸에 들어갈 올바른 코드는?\n```javascript\n___________________ {\n    let x = \"Hello! I called myself\";\n})();\n```",
      "option_a": "function()",
      "option_b": "(function()",
      "option_c": "const myFunction = function()",
      "option_d": "function myFunction()",
      "correct_answer": "B",
      "explanation": "이것은 즉시 실행 함수 표현식(IIFE: Immediately Invoked Function Expression)입니다. 함수를 정의하자마자 바로 실행하는 패턴으로, `(function() { 코드 })();` 형태로 사용됩니다. 함수를 괄호로 감싸서 함수 표현식임을 명시하고, 마지막에 `()`를 붙여서 즉시 실행합니다. 함수 선언문은 즉시 실행할 수 없기 때문에 반드시 괄호로 감싸서 함수 표현식으로 만들어야 합니다. 이 패턴은 변수의 전역 오염을 방지하고 코드를 캡슐화할 때 자주 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T12:11:54.000Z"
    },
    {
      "id": 581,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nfunction myFunction(a, b) {\n    return arguments.length;\n}\n\nlet result1 = myFunction(4, 3);\nlet result2 = myFunction.toString().includes(\"arguments\");\nconsole.log(result1, result2);\n```",
      "option_a": "2, true",
      "option_b": "2, false",
      "option_c": "undefined, true",
      "option_d": "7, false",
      "correct_answer": "A",
      "explanation": "1) `arguments.length`는 함수에 전달된 인수의 개수를 반환합니다. `myFunction(4, 3)`에서 두 개의 인수(4, 3)가 전달되었으므로 `result1`은 2입니다.\n2) `toString()` 메서드는 함수를 문자열로 변환합니다. 함수의 전체 코드가 문자열로 반환되므로 \"arguments\"라는 단어가 포함되어 있습니다. 따라서 `includes(\"arguments\")`는 `true`를 반환합니다.\n\nJavaScript 함수는 객체의 성격을 가지고 있어서 `properties`와 `methods`를 가집니다. `arguments`는 함수 내부에서 사용할 수 있는 특별한 객체로, 함수에 전달된 모든 인수를 담고 있으며, `toString()`은 함수 객체의 메서드로 함수를 문자열 형태로 반환합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T12:14:11.000Z"
    },
    {
      "id": 582,
      "subject_id": 1,
      "question": "Arrow Function(화살표 함수)은 어느 버전의 JavaScript에서 도입되었나요?",
      "option_a": "ES5 (ECMAScript 2009)",
      "option_b": "ES6 (ECMAScript 2015)",
      "option_c": "ES7 (ECMAScript 2016)",
      "option_d": "ES8 (ECMAScript 2017)",
      "correct_answer": "B",
      "explanation": "Arrow Function은 ES6(ECMAScript 2015)에서 도입되었습니다. 이는 기존 함수 표현식보다 더 간결한 문법을 제공하여 코드를 더 읽기 쉽게 만들어줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T12:39:43.000Z"
    },
    {
      "id": 583,
      "subject_id": 1,
      "question": "다음 중 빈칸에 들어갈 올바른 Arrow Function 문법은?\n```javascript\nlet myFunction = (a, b) ______ a * b;\n```",
      "option_a": "=>",
      "option_b": "function(a, b) =>",
      "option_c": "->",
      "option_d": "===",
      "correct_answer": "A",
      "explanation": "Arrow Function은 `(매개변수) => 표현식` 또는 `(매개변수) => { 함수 본문 }` 형태로 사용합니다. `function` 키워드나 `return` 키워드를 생략할 수 있어 코드가 더 간결해집니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T12:42:42.000Z"
    },
    {
      "id": 584,
      "subject_id": 1,
      "question": "다음 Arrow Function에서 괄호를 생략할 수 있는 경우는?\n```javascript\n// A: 매개변수가 없는 경우\nlet func1 = () => \"Hello\";\n\n// B: 매개변수가 하나인 경우  \nlet func2 = (name) => \"Hello \" + name;\n\n// C: 매개변수가 두 개인 경우\nlet func3 = (a, b) => a + b;\n```",
      "option_a": "A만 가능",
      "option_b": "B만 가능",
      "option_c": "A와 B 모두 가능",
      "option_d": "모두 불가능",
      "correct_answer": "B",
      "explanation": "Arrow Function에서 매개변수가 정확히 하나일 때만 괄호를 생략할 수 있습니다. 즉, `let func2 = name => \"Hello \" + name;`으로 쓸 수 있습니다. 매개변수가 없거나 두 개 이상일 때는 반드시 괄호가 필요합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T12:44:23.000Z"
    },
    {
      "id": 585,
      "subject_id": 1,
      "question": "다음 코드에서 어떤 것이 올바른 Arrow Function 작성법인가요?\n```javascript\n// 여러 줄 함수 작성시\n\n// A\nlet myFunction = (x, y) => { x * y };\n\n// B  \nlet myFunction = (x, y) => return x * y;\n\n// C\nlet myFunction = (x, y) => { return x * y };\n\n// D\nlet myFunction = (x, y) => x * y;\n```",
      "option_a": "A만 올바름",
      "option_b": "B만 올바름",
      "option_c": "C와 D가 올바름",
      "option_d": "모두 올바름",
      "correct_answer": "C",
      "explanation": "1) A는 틀림: 중괄호를 사용하면 반드시 `return` 키워드가 필요합니다.\n2) B는 틀림: `return` 앞에 중괄호가 없으면 구문 오류입니다.\n3) C는 맞음: 중괄호와 `return`을 함께 사용한 올바른 문법입니다.\n4) D는 맞음: 단일 표현식은 중괄호와 `return` 없이 바로 반환할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T12:45:56.000Z"
    },
    {
      "id": 586,
      "subject_id": 1,
      "question": "다음 코드에서 regular function과 arrow function의 `this` 바인딩 차이에 대한 올바른 설명은?\n```javascript\n// Regular Function\nlet regular = function() {\n    console.log(\"Regular:\", this);\n}\n\n// Arrow Function  \nlet arrow = () => {\n    console.log(\"Arrow:\", this);\n}\n\nwindow.addEventListener(\"load\", regular);\nwindow.addEventListener(\"load\", arrow);\n\ndocument.getElementById(\"btn\").addEventListener(\"click\", regular);\ndocument.getElementById(\"btn\").addEventListener(\"click\", arrow);\n```",
      "option_a": "두 함수 모두 호출한 객체를 `this`로 참조한다",
      "option_b": "두 함수 모두 항상 window 객체를 `this`로 참조한다",
      "option_c": "regular function은 호출한 객체를, arrow function은 정의된 스코프의 객체를 참조한다",
      "option_d": "regular function은 정의된 스코프의 객체를, arrow function은 호출한 객체를 참조한다",
      "correct_answer": "C",
      "explanation": "이것이 Arrow Function의 핵심적인 특징입니다:\n\n1) Regular Function: `this`는 함수를 호출한 객체에 따라 달라집니다. window에서 호출하면 window 객체를, 버튼에서 호출하면 버튼 객체를 참조합니다.\n2) Arrow Function: `this`는 함수가 정의된 시점의 상위 스코프(여기서는 전역 스코프)의 `this`를 그대로 사용합니다. 따라서 누가 호출하든 항상 같은 객체(보통 window)를 참조합니다.\n\n이러한 특성 때문에 Arrow Function은 객체 메서드 정의에는 적합하지 않고, 콜백 함수나 이벤트 핸들러에서 `this` 바인딩을 유지하고 싶을 때 유용합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T12:47:56.000Z"
    },
    {
      "id": 587,
      "subject_id": 1,
      "question": "JavaScript 함수에서 매개변수가 전달되지 않았을 때의 기본값은 무엇인가요?\n```javascript\nfunction test(x, y) {\n    console.log(y);\n}\ntest(5); // y에 전달된 값은?\n```",
      "option_a": "null",
      "option_b": "undefined",
      "option_c": "0",
      "option_d": "\"\"",
      "correct_answer": "B",
      "explanation": "JavaScript에서 함수 매개변수에 값이 전달되지 않으면 자동으로 `undefined`가 할당됩니다. 위 예제에서 `test(5)`로 호출했을 때, `x`는 5가 되고 `y`는 `undefined`가 됩니다. 이는 JavaScript 함수가 전달받은 인수의 개수를 확인하지 않기 때문입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T12:53:39.000Z"
    },
    {
      "id": 588,
      "subject_id": 1,
      "question": "ES6에서 도입된 기본 매개변수(Default Parameters) 문법으로 빈칸에 들어갈 것은?\n```javascript\nfunction myFunction(x, y ______ 10) {\n    return x + y;\n}\n```",
      "option_a": "default",
      "option_b": "||",
      "option_c": "=",
      "option_d": ":",
      "correct_answer": "C",
      "explanation": "ES6에서는 `=` 기호를 사용하여 기본 매개변수 값을 설정할 수 있습니다. `function myFunction(x, y = 10)`처럼 작성하면, `y`가 전달되지 않거나 `undefined`일 때 자동으로 10이 할당됩니다. 이는 ES6 이전에 `if (y === undefined) { y = 10; }` 같은 코드를 작성하던 것을 간단하게 만들어줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T12:55:34.000Z"
    },
    {
      "id": 589,
      "subject_id": 1,
      "question": "다음 코드에서 Rest Parameter의 올바른 사용법으로 빈칸에 들어갈 것은?\n```javascript\nfunction sum(______args) {\n    let total = 0;\n    for (let arg of args) {\n        total += arg;\n    }\n    return total;\n}\nsum(1, 2, 3, 4, 5); // 모든 인수를 배열로 받고 싶음\n```",
      "option_a": "*",
      "option_b": "...",
      "option_c": "[]",
      "option_d": "&",
      "correct_answer": "B",
      "explanation": "Rest Parameter는 `...` (세 개의 점) 문법을 사용합니다. `function sum(...args)`로 작성하면, 함수에 전달된 모든 인수들이 `args` 배열에 저장됩니다. 이를 통해 가변 개수의 인수를 받는 함수를 쉽게 만들 수 있습니다. 위 예제에서 `args`는 `[1, 2, 3, 4, 5]` 배열이 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T12:57:07.000Z"
    },
    {
      "id": 590,
      "subject_id": 1,
      "question": "다음 코드들의 실행 결과와 동작 방식에 대한 올바른 설명은?\n```javascript\n// 코드 A: 원시값 전달\nfunction changeValue(x) {\n    x = 100;\n}\nlet num = 5;\nchangeValue(num);\nconsole.log(num); // 결과 A\n\n// 코드 B: 객체 전달\nfunction changeObject(obj) {\n    obj.value = 100;\n}\nlet myObj = { value: 5 };\nchangeObject(myObj);\nconsole.log(myObj.value); // 결과 B\n```",
      "option_a": "결과 A: 100, 결과 B: 5",
      "option_b": "결과 A: 5, 결과 B: 5",
      "option_c": "결과 A: 5, 결과 B: 100",
      "option_d": "결과 A: 100, 결과 B: 100",
      "correct_answer": "C",
      "explanation": "이는 JavaScript의 중요한 개념인 \"값에 의한 전달(pass by value)\"과 \"참조에 의한 전달(pass by reference)\"을 보여줍니다:\n\n코드 A (원시값):\n\n1) `num`(원시값 5)이 함수에 전달될 때, 값의 복사본이 전달됩니다\n2) 함수 내에서 `x = 100`으로 변경해도 원본 `num`에는 영향을 주지 않습니다\n3) 따라서 `num`은 여전히 5입니다\n\n코드 B (객체):\n\n1) 객체는 참조로 전달됩니다 (정확히는 참조값이 복사되어 전달)\n2) `obj`와 `myObj`는 같은 객체를 가리키므로, `obj.value = 100`은 원본 객체를 변경합니다\n3) 따라서 `myObj.value`는 100이 됩니다\n\n이 차이점을 이해하는 것은 JavaScript에서 함수 사용 시 매우 중요합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T12:59:58.000Z"
    },
    {
      "id": 591,
      "subject_id": 1,
      "question": "JavaScript에서 함수 내부의 코드가 실행되는 시점은 언제인가요?\n```javascript\nfunction myFunction() {\n    console.log(\"Hello World!\");\n}\n// 위 코드만으로는 콘솔에 아무것도 출력되지 않습니다.\n```",
      "option_a": "함수가 정의될 때",
      "option_b": "함수가 호출(invoke)될 때",
      "option_c": "페이지가 로드될 때",
      "option_d": "변수에 할당될 때",
      "correct_answer": "B",
      "explanation": "JavaScript에서 함수 내부의 코드는 함수가 정의될 때가 아니라 호출(invoke)될 때 실행됩니다. 함수 정의는 단지 코드 블록을 메모리에 저장하는 것이고, 실제 실행은 `myFunction()`과 같이 함수를 호출할 때 이루어집니다. 이것이 함수의 기본 동작 원리입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T13:03:18.000Z"
    },
    {
      "id": 592,
      "subject_id": 1,
      "question": "HTML 환경에서 전역 함수로 선언된 함수는 자동으로 어느 객체의 메서드가 되나요?\n```javascript\nfunction myFunction() {\n    return \"Hello\";\n}\n\n// myFunction()과 ______.myFunction()은 동일합니다\n```",
      "option_a": "document",
      "option_b": "window",
      "option_c": "global",
      "option_d": "html",
      "correct_answer": "B",
      "explanation": "HTML 환경에서 전역으로 선언된 함수는 자동으로 `window` 객체의 메서드가 됩니다. 따라서 `myFunction()`과 `window.myFunction()`은 완전히 동일한 함수 호출입니다. 브라우저에서 `window`는 전역 객체이며, 모든 전역 변수와 함수들이 이 객체의 속성으로 등록됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T13:04:35.000Z"
    },
    {
      "id": 593,
      "subject_id": 1,
      "question": "빈칸에 들어갈 올바른 키워드는?\n```javascript\nfunction globalFunction() {\n    return ______;\n}\n\nlet result = globalFunction();\nconsole.log(result); // [object Window] 출력\n```",
      "option_a": "global",
      "option_b": "self",
      "option_c": "this",
      "option_d": "window",
      "correct_answer": "C",
      "explanation": "전역 함수에서 `this` 키워드는 전역 객체를 가리킵니다. HTML 환경에서 전역 객체는 `window` 객체이므로, `this`는 `window` 객체를 반환합니다. 단, strict mode(\"use strict\")에서는 `this`가 `undefined`가 됩니다. 이는 JavaScript에서 `this`의 값이 함수 호출 방식에 따라 달라지는 중요한 특징입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T13:06:05.000Z"
    },
    {
      "id": 594,
      "subject_id": 1,
      "question": "다음 객체 메서드에서 `this`가 가리키는 것은 무엇인가요?\n```javascript\nconst person = {\n    name: \"John\",\n    age: 30,\n    introduce: function() {\n        return \"My name is \" + this.name;\n    }\n};\n\nperson.introduce(); // \"My name is John\" 출력\n```",
      "option_a": "window",
      "option_b": "person",
      "option_c": "global",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "객체의 메서드로 호출된 함수에서 `this`는 해당 객체(메서드의 소유자)를 가리킵니다. `person.introduce()`로 호출했을 때, `this`는 `person` 객체를 가리키므로 `this.name`은 `person.name`인 \"John\"을 반환합니다. 이는 전역 함수에서의 `this`와는 다른 동작입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T13:08:53.000Z"
    },
    {
      "id": 595,
      "subject_id": 1,
      "question": "빈칸에 들어갈 올바른 키워드들은?\n```javascript\nfunction Person(firstName, lastName) {\n    ______.firstName = firstName;\n    ______.lastName = lastName;\n}\n\nconst john = ______ Person(\"John\", \"Doe\");\nconsole.log(john.firstName); // \"John\" 출력\n```",
      "option_a": "`this`, `this`, `call`",
      "option_b": "`this`, `this`, `new`",
      "option_c": "`self`, `self`, `new`",
      "option_d": "`window`, `window`, `new`",
      "correct_answer": "B",
      "explanation": "생성자 함수에서는 다음과 같은 특별한 규칙이 적용됩니다:\n\n1. 함수 내부의 `this`: 생성자 함수 내에서 `this`는 새로 생성될 객체를 가리킵니다. 따라서 `this.firstName`과 `this.lastName`으로 새 객체의 속성을 설정합니다.\n2. `new` 키워드: 생성자 함수는 반드시 `new` 키워드와 함께 호출해야 합니다. `new Person(\"John\", \"Doe\")`로 호출하면:\n\n1) 새로운 빈 객체가 생성됩니다\n2) 이 객체가 `this`로 설정됩니다\n3) 함수가 실행되어 객체의 속성들이 설정됩니다\n4) 새로 생성된 객체가 자동으로 반환됩니다\n\n`new` 키워드 없이 일반 함수로 호출하면 `this`는 전역 객체(`window`)를 가리키게 되어 의도한 대로 작동하지 않습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T13:12:28.000Z"
    },
    {
      "id": 596,
      "subject_id": 1,
      "question": "JavaScript에서 `this` 키워드에 대한 올바른 설명은 무엇인가요?",
      "option_a": "`this`는 변수이므로 값을 변경할 수 있다",
      "option_b": "`this`는 키워드이며 값을 변경할 수 없다",
      "option_c": "`this`는 함수이므로 호출할 수 있다",
      "option_d": "`this`는 상수이므로 재선언할 수 있다",
      "correct_answer": "B",
      "explanation": "`this`는 JavaScript의 예약된 키워드입니다. 키워드이기 때문에 변수처럼 값을 직접 변경할 수 없으며, 사용 방식과 컨텍스트에 따라 자동으로 다른 객체를 참조합니다. `this`는 변수, 함수, 상수가 아닌 특별한 키워드로, JavaScript 엔진이 실행 컨텍스트에 따라 적절한 객체를 바인딩합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T13:15:24.000Z"
    },
    {
      "id": 597,
      "subject_id": 1,
      "question": "빈칸에 들어갈 올바른 키워드는?\n```javascript\nlet x = ______;\nconsole.log(x); // [object Window] 출력 (브라우저 환경에서)\n```",
      "option_a": "window",
      "option_b": "global",
      "option_c": "this",
      "option_d": "document",
      "correct_answer": "C",
      "explanation": "전역 스코프에서 `this`를 단독으로 사용하면 전역 객체를 가리킵니다. 브라우저 환경에서 전역 객체는 `window` 객체이므로, `let x = this;`는 `let x = window;`와 같은 결과를 가져옵니다. 이는 strict mode를 사용하더라도 동일하게 작동합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T13:17:04.000Z"
    },
    {
      "id": 598,
      "subject_id": 1,
      "question": "일반 함수에서 strict mode를 사용할 때 `this`의 값은 무엇인가요?\n```javascript\n\"use strict\";\nfunction myFunction() {\n    return this;\n}\nconsole.log(myFunction()); // undefined 출력\n```",
      "option_a": "window",
      "option_b": "global",
      "option_c": "null",
      "option_d": "undefined",
      "correct_answer": "D",
      "explanation": "strict mode(\"use strict\")에서는 기본 바인딩이 허용되지 않습니다. 일반적으로 함수 내에서 `this`는 전역 객체(window)를 가리키지만, strict mode에서는 `undefined`가 됩니다. 이는 실수로 전역 객체를 수정하는 것을 방지하기 위한 안전 장치입니다. strict mode가 아닐 때는 `this`가 전역 객체를 가리키지만, strict mode에서는 명시적으로 `undefined`를 반환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T13:20:06.000Z"
    },
    {
      "id": 599,
      "subject_id": 1,
      "question": "이 코드가 올바르게 작동하도록 빈칸에 들어갈 키워드는?\n```html\n<button onclick=\"______.style.display='none'\">\n    Click to Remove Me!\n</button>\n```",
      "option_a": "window",
      "option_b": "document",
      "option_c": "event",
      "option_d": "this",
      "correct_answer": "D",
      "explanation": "HTML 이벤트 핸들러에서 `this`는 이벤트를 받은 HTML 요소 자체를 가리킵니다. 위 예제에서 `this`는 버튼 요소를 의미하므로, `this.style.display='none'`은 해당 버튼의 스타일을 변경하여 버튼을 숨깁니다. 이는 이벤트가 발생한 요소를 쉽게 참조할 수 있게 해주는 편리한 기능입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T13:21:38.000Z"
    },
    {
      "id": 600,
      "subject_id": 1,
      "question": "`this` 바인딩의 우선순위를 올바른 순서대로 나열한 것은? (높은 우선순위부터)",
      "option_a": "bind() → call()/apply() → 객체 메서드 → 전역 스코프",
      "option_b": "전역 스코프 → 객체 메서드 → call()/apply() → bind()",
      "option_c": "객체 메서드 → 전역 스코프 → call()/apply() → bind()",
      "option_d": "call()/apply() → bind() → 전역 스코프 → 객체 메서드",
      "correct_answer": "A",
      "explanation": "JavaScript에서 `this` 바인딩의 우선순위는 다음과 같습니다:\n\n1. bind() (최고 우선순위)\n`func.bind(obj)`로 명시적으로 바인딩된 함수는 다른 어떤 방법으로도 `this`를 변경할 수 없습니다.\n\n2. call()/apply()\n`func.call(obj)` 또는 `func.apply(obj)`로 명시적으로 호출 시 `this`를 지정합니다.\n\n3. 객체 메서드\n`obj.method()`처럼 객체의 메서드로 호출될 때 `this`는 해당 객체를 가리킵니다.\n\n4. 전역 스코프 (최저 우선순위)\n일반 함수 호출이나 전역에서 사용할 때의 기본 바인딩입니다.\n\n이 우선순위를 기억하면 복잡한 상황에서도 `this`가 무엇을 가리키는지 정확히 판단할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T13:24:08.000Z"
    },
    {
      "id": 601,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 메서드는 무엇인가요?\n```javascript\nconst person = {\n    fullName: function() {\n        return this.firstName + \" \" + this.lastName;\n    }\n};\n\nconst mary = { firstName: \"Mary\", lastName: \"Smith\" };\nconst result = person.fullName.______(mary);\nconsole.log(result); // \"Mary Smith\" 출력\n```",
      "option_a": "apply",
      "option_b": "bind",
      "option_c": "call",
      "option_d": "invoke",
      "correct_answer": "C",
      "explanation": "`call()` 메서드를 사용하면 `person` 객체의 `fullName` 메서드를 `mary` 객체의 컨텍스트에서 실행할 수 있습니다. `person.fullName.call(mary)`는 `fullName`함수 내부의 `this`를 `mary` 객체로 설정하여 실행하므로, `this.firstName`은 \"Mary\", `this.lastName`은 \"Smith\"가 되어 \"Mary Smith\"를 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-07T13:30:31.000Z"
    },
    {
      "id": 602,
      "subject_id": 1,
      "question": "빈칸에 들어갈 메서드는?\n```javascript\nconst person = {\n    info: function(city, country) {\n        return this.name + \" lives in \" + city + \", \" + country;\n    }\n};\n\nconst john = { name: \"John\" };\n\n// 방법 1: person.info.______(john, \"Seoul\", \"Korea\");\n// 방법 2: person.info.______(john, [\"Seoul\", \"Korea\"]);\n```",
      "option_a": "방법 1: `call`, 방법 2: `apply`",
      "option_b": "방법 1: `apply`, 방법 2: `call`",
      "option_c": "둘 다 `call` 사용",
      "option_d": "둘 다 `apply` 사용",
      "correct_answer": "A",
      "explanation": "1) `call()` 메서드: 인수들을 개별적으로(따로따로) 전달합니다. `call(thisArg, arg1, arg2, arg3, ...)`\n2) `apply()` 메서드: 인수들을 배열 형태로 전달합니다. `apply(thisArg, [arg1, arg2, arg3, ...])`\n\n따라서 방법 1은 `call(john, \"Seoul\", \"Korea\")`이고, 방법 2는 `apply(john, [\"Seoul\", \"Korea\"])`입니다. 결과는 동일하지만 인수 전달 방식이 다릅니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T13:32:55.000Z"
    },
    {
      "id": 603,
      "subject_id": 1,
      "question": "다음 `Math.max.apply()` 사용 예제에서 첫 번째 인수에 들어갈 수 있는 값들로 올바른 것은?\n```javascript\nconst numbers = [1, 5, 3, 9, 2];\nconst maxValue = Math.max.apply(______, numbers);\nconsole.log(maxValue); // 9 출력\n```",
      "option_a": "`null`만 가능",
      "option_b": "`Math`만 가능",
      "option_c": "`null`, `Math`, `\" \"`, `0` 모두 가능",
      "option_d": "아무 값도 넣을 수 없음",
      "correct_answer": "C",
      "explanation": "`Math.max()` 메서드는 정적 메서드이므로 `this` 값을 사용하지 않습니다. 따라서 `apply()`의 첫 번째 인수(thisArg)에는 어떤 값을 넣어도 결과에 영향을 주지 않습니다. `null`, `Math`, `\" \"`, `0` 등 어떤 값이든 상관없이 모두 동일한 결과(9)를 반환합니다. 하지만 관례적으로 `null`이나 해당 객체(`Math`)를 사용하는 것이 좋습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-07T13:35:00.000Z"
    },
    {
      "id": 604,
      "subject_id": 1,
      "question": "다음 코드들의 실행 결과를 올바르게 예측한 것은?\n```javascript\nconst obj1 = {\n    name: \"Object1\",\n    greet: function(greeting, punctuation) {\n        return greeting + \" \" + this.name + punctuation;\n    }\n};\n\nconst obj2 = { name: \"Object2\" };\n\n// 코드 A\nconst resultA = obj1.greet.call(obj2, \"Hello\", \"!\");\n\n// 코드 B  \nconst resultB = obj1.greet.apply(obj2, [\"Hi\", \"?\"]);\n\n// 코드 C\nconst resultC = obj1.greet(\"Hey\", \".\");\n```",
      "option_a": "A: \"Hello Object2!\", B: \"Hi Object2?\", C: \"Hey Object1.\"",
      "option_b": "A: \"Hello Object1!\", B: \"Hi Object1?\", C: \"Hey Object2.\"",
      "option_c": "A: \"Hello Object2!\", B: \"Hi Object1?\", C: \"Hey Object1.\"",
      "option_d": "A: \"Hello Object1!\", B: \"Hi Object2?\", C: \"Hey Object1.\"",
      "correct_answer": "A",
      "explanation": "1. 코드 A: `obj1.greet.call(obj2, \"Hello\", \"!\")`\n\n1) `call()`을 사용해 `obj1`의 `greet` 메서드를 `obj2` 컨텍스트에서 실행\n2) `this.name`은 `obj2.name`인 \"Object2\"를 가리킴\n3) 결과: \"Hello Object2!\"\n\n2. 코드 B: `obj1.greet.apply(obj2, [\"Hi\", \"?\"])`\n\n1) `apply()`를 사용해 `obj1`의 `greet` 메서드를 `obj2` 컨텍스트에서 실행\n2) 인수는 배열로 전달되지만 함수 내부에서는 개별 매개변수로 받음\n3) `this.name`은 `obj2.name`인 \"Object2\"를 가리킴\n4) 결과: \"Hi Object2?\"\n\n3. 코드 C: `obj1.greet(\"Hey\", \".\")`\n\n1) 일반적인 메서드 호출로 `this`는 `obj1`을 가리킴\n2) `this.name`은 `obj1.name`인 \"Object1\"을 가리킴\n3) 결과: \"Hey Object1.\"\n\n이 예제는 `call()`과 `apply()`가 `this` 바인딩을 어떻게 변경하는지를 보여줍니다.",
      "difficulty": "hard",
      "created_at": "2025-08-07T13:38:53.000Z"
    },
    {
      "id": 605,
      "subject_id": 1,
      "question": "JavaScript에서 `this` 키워드가 참조하는 것에 대한 설명으로 틀린 것은?",
      "option_a": "객체 메서드에서 `this`는 해당 객체를 참조한다",
      "option_b": "함수에서 `this`는 전역 객체를 참조한다",
      "option_c": "strict mode에서 함수 내부의 `this`는 `undefined`이다",
      "option_d": "`this`는 변수이므로 값을 변경할 수 있다",
      "correct_answer": "D",
      "explanation": "`this`는 키워드이지 변수가 아닙니다. 따라서 `this`의 값을 직접 변경할 수 없습니다. `this`가 무엇을 참조하는지는 함수가 어떻게 호출되는지에 따라 결정됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T02:43:13.000Z"
    },
    {
      "id": 606,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 메서드는?\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  fullName: function() {\n    return this.firstName + \" \" + this.lastName;\n  }\n}\n\nconst member = {\n  firstName: \"Hege\",\n  lastName: \"Nilsen\"\n}\n\nlet fullName = person.fullName.______(member);\n```",
      "option_a": "call",
      "option_b": "apply",
      "option_c": "bind",
      "option_d": "attach",
      "correct_answer": "C",
      "explanation": "`bind()` 메서드는 함수의 `this` 값을 특정 객체로 고정한 새로운 함수를 반환합니다. 여기서는 `person.fullName` 함수의 `this`를 `member` 객체로 바인딩하여 새로운 함수를 생성합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T02:44:54.000Z"
    },
    {
      "id": 607,
      "subject_id": 1,
      "question": "전역 변수와 지역 변수에 대한 설명으로 올바른 것은?",
      "option_a": "지역 변수는 함수 외부에서도 접근할 수 있다",
      "option_b": "전역 변수는 웹페이지가 닫힐 때까지 유지된다",
      "option_c": "지역 변수는 전역 변수보다 오래 살아있다",
      "option_d": "같은 이름의 전역 변수와 지역 변수는 동일한 변수이다",
      "correct_answer": "B",
      "explanation": "전역 변수는 웹페이지가 다른 페이지로 이동하거나 창이 닫힐 때까지 유지됩니다. 반면 지역 변수는 함수가 실행될 때 생성되고 함수가 끝나면 삭제되어 수명이 짧습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T02:45:44.000Z"
    },
    {
      "id": 608,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  display: function() {\n    console.log(this.firstName + \" \" + this.lastName);\n  }\n}\n\nsetTimeout(person.display, 1000);\n```",
      "option_a": "\"John Doe\"",
      "option_b": "\"undefined undefined\"",
      "option_c": "에러 발생",
      "option_d": "아무것도 출력되지 않음",
      "correct_answer": "B",
      "explanation": "`setTimeout`에 `person.display`를 전달할 때, 함수가 객체에서 분리되어 전달됩니다. 따라서 함수 내부의 `this`는 `person` 객체가 아닌 전역 객체(또는 undefined)를 참조하게 되어 \"undefined undefined\"가 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T02:47:18.000Z"
    },
    {
      "id": 609,
      "subject_id": 1,
      "question": "다음 코드처럼 키워드 없이 변수를 선언하면 어떻게 될까요?\n```javascript\nfunction myFunction() {\n  a = 4;  // let, var, const 없음\n  return a * a;\n}\n```",
      "option_a": "에러가 발생한다",
      "option_b": "지역 변수가 생성된다",
      "option_c": "전역 변수가 생성된다",
      "option_d": "undefined가 반환된다",
      "correct_answer": "C",
      "explanation": "키워드(`var`, `let`, `const`) 없이 선언된 변수는 함수 내부에서 선언되더라도 항상 전역 변수가 됩니다. 이는 의도하지 않은 버그를 발생시킬 수 있으므로 피해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T02:50:26.000Z"
    },
    {
      "id": 610,
      "subject_id": 1,
      "question": "다음 클로저 예제의 실행 결과는?\n\n```javascript\nfunction myCounter() {\n  let counter = 0;\n  return function() {\n    counter++;\n    return counter;\n  };\n}\n\nconst add = myCounter();\nconsole.log(add());  // 첫 번째 호출\nconsole.log(add());  // 두 번째 호출\nconsole.log(add());  // 세 번째 호출\n```",
      "option_a": "1, 1, 1",
      "option_b": "1, 2, 3",
      "option_c": "0, 1, 2",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "클로저가 형성되어 내부 함수가 외부 함수의 `counter` 변수에 접근할 수 있습니다. `myCounter()`는 한 번만 실행되어 `counter = 0`으로 초기화되고, 반환된 함수는 같은 `counter` 변수를 계속 참조하여 1, 2, 3이 차례로 출력됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T02:52:11.000Z"
    },
    {
      "id": 611,
      "subject_id": 1,
      "question": "다음 코드에서 문제점과 해결방법을 찾으세요:\n\n```javascript\nlet counter = 0;\n\nfunction add() {\n  let counter = 0;  // 지역 변수\n  counter += 1;\n}\n\nadd();\nadd();\nadd();\nconsole.log(counter);  // 결과는?\n```",
      "option_a": "3이 출력됨 - 문제없음",
      "option_b": "0이 출력됨 - 전역 counter와 지역 counter가 다른 변수임",
      "option_c": "1이 출력됨 - 마지막 호출 결과만 반영됨",
      "option_d": "undefined 출력됨 - 변수가 제대로 선언되지 않음",
      "correct_answer": "B",
      "explanation": "함수 내부의 `counter`는 지역 변수이고, `console.log`에서 출력하는 `counter`는 전역 변수입니다. 지역 변수는 함수가 끝날 때마다 삭제되므로 전역 변수에는 영향을 주지 않습니다. 해결하려면 지역 변수 선언을 제거하거나 클로저를 사용해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T02:53:43.000Z"
    },
    {
      "id": 612,
      "subject_id": 1,
      "question": "다음 중 클로저의 주요 용도가 아닌 것은?",
      "option_a": "프라이빗 변수 생성",
      "option_b": "함수 호출 간 상태 보존",
      "option_c": "전역 변수 사용량 증가",
      "option_d": "커링(currying)과 메모이제이션 구현",
      "correct_answer": "C",
      "explanation": "클로저는 오히려 전역 변수 사용을 줄이는 데 도움이 됩니다. 클로저를 사용하면 프라이빗 변수를 만들어 데이터를 캡슐화하고, 함수 호출 간에 상태를 보존하며, 고급 함수형 프로그래밍 기법을 구현할 수 있습니다. 현대 JavaScript에서는 `let`과 `const`가 도입되어 클로저의 필요성이 줄어들었지만, 여전히 중요한 개념입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T02:54:30.000Z"
    },
    {
      "id": 613,
      "subject_id": 1,
      "question": "JavaScript에서 가장 간단하고 권장되는 객체 생성 방법은?\n\n```javascript\n// 방법 1\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  age: 50\n};\n\n// 방법 2\nconst person = new Object({\n  firstName: \"John\",\n  lastName: \"Doe\",\n  age: 50\n});\n```",
      "option_a": "방법 1 - 객체 리터럴 방식",
      "option_b": "방법 2 - new Object() 방식",
      "option_c": "둘 다 동일하게 권장됨",
      "option_d": "성능상 차이는 없으므로 상관없음",
      "correct_answer": "A",
      "explanation": "객체 리터럴 방식(`{}`)이 가장 간단하고 권장되는 방법입니다. `new Object()` 방식도 동일한 결과를 만들지만, 가독성, 단순성, 실행 속도 면에서 객체 리터럴이 더 우수합니다. 두 방법 모두 동일한 객체를 생성하지만, 객체 리터럴이 더 깔끔하고 효율적입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T02:56:34.000Z"
    },
    {
      "id": 614,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\nconst fruits = [\n  [\"apples\", 300],\n  [\"pears\", 900],\n  [\"bananas\", 500]\n];\n\nconst myObj = Object.__________(fruits);\nconsole.log(myObj.pears); // 900\n```",
      "option_a": "create",
      "option_b": "assign",
      "option_c": "fromEntries",
      "option_d": "entries",
      "correct_answer": "C",
      "explanation": "`Object.fromEntries()` 메서드는 키-값 쌍의 배열(이터러블)을 객체로 변환합니다. 여기서 `fruits` 배열은 각 요소가 `[키, 값]` 형태의 배열이므로, `fromEntries()`를 사용하면 `{apples: 300, pears: 900, bananas: 500}` 객체가 생성됩니다. 이 메서드는 ES2019에서 추가되었습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T02:57:46.000Z"
    },
    {
      "id": 615,
      "subject_id": 1,
      "question": "다음 `Object.create()` 코드의 실행 결과는?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  language: \"EN\"\n};\n\nconst man = Object.create(person);\nman.firstName = \"Peter\";\n\nconsole.log(person.firstName + \" and \" + man.firstName);\n```",
      "option_a": "\"John and John\"",
      "option_b": "\"Peter and Peter\"",
      "option_c": "\"John and Peter\"",
      "option_d": "\"undefined and Peter\"",
      "correct_answer": "C",
      "explanation": "`Object.create(person)`은 `person` 객체를 프로토타입으로 하는 새로운 객체 `man`을 생성합니다. `man.firstName = \"Peter\"`는 `man` 객체에만 새로운 `firstName` 속성을 추가하므로 원본 `person` 객체는 변경되지 않습니다. 따라서 `person.firstName`은 여전히 \"John\"이고, `man.firstName`은 \"Peter\"가 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T02:59:41.000Z"
    },
    {
      "id": 616,
      "subject_id": 1,
      "question": "다음 `Object.assign()` 코드의 실행 후 `person1` 객체는?\n\n```javascript\nconst person1 = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  age: 50,\n  eyeColor: \"blue\"\n};\n\nconst person2 = {\n  firstName: \"Anne\",\n  lastName: \"Smith\"\n};\n\nObject.assign(person1, person2);\n```",
      "option_a": "{firstName: \"John\", lastName: \"Doe\", age: 50, eyeColor: \"blue\"}",
      "option_b": "{firstName: \"Anne\", lastName: \"Smith\", age: 50, eyeColor: \"blue\"}",
      "option_c": "{firstName: \"Anne\", lastName: \"Smith\"}",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "`Object.assign(target, source)`는 소스 객체(`person2`)의 속성들을 타겟 객체(`person1`)로 복사합니다. 같은 이름의 속성이 있으면 소스 객체의 값으로 덮어씁니다. 따라서 `person1`의 `firstName`과 `lastName`은 `person2`의 값으로 변경되고, `age`와 `eyeColor`는 그대로 유지됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T03:01:22.000Z"
    },
    {
      "id": 617,
      "subject_id": 1,
      "question": "다음 코드들의 실행결과는?\n\n```javascript\n// 코드 A\nconst person = {firstName: \"John\", lastName: \"Doe\"};\nconst man = Object.create(person);\nman.firstName = \"Peter\";\n\n// 코드 B\nconst person1 = {firstName: \"John\", lastName: \"Doe\"};\nconst person2 = {firstName: \"Peter\"};\nObject.assign(person1, person2);\n\nconsole.log(\"A:\", man.lastName);      // ?\nconsole.log(\"B:\", person1.lastName);  // ?\n```",
      "option_a": "A: \"undefined\", B: \"Doe\"",
      "option_b": "A: \"Doe\", B: \"undefined\"",
      "option_c": "A: \"Doe\", B: \"Doe\"",
      "option_d": "A: \"undefined\", B: \"undefined\"",
      "correct_answer": "C",
      "explanation": "1) 코드 A: `Object.create(person)`으로 생성된 `man` 객체는 `person`을 프로토타입으로 가지므로, `man.lastName`을 접근하면 프로토타입 체인을 통해 `person.lastName`인 \"Doe\"를 반환합니다.\n2) 코드 B: `Object.assign(person1, person2)`는 `person2`의 속성만 복사하므로 `person1.lastName`은 기존 값 \"Doe\"를 유지합니다.\n\n따라서 두 경우 모두 \"Doe\"가 출력됩니다. `Object.create()`는 프로토타입 상속을, `Object.assign()`은 속성 복사를 수행한다는 차이가 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T03:06:20.000Z"
    },
    {
      "id": 618,
      "subject_id": 1,
      "question": "생성자 함수에 대한 설명으로 옳은 것은?\n\n```javascript\nfunction Person(first, last, age) {\n  this.firstName = first;\n  this.lastName = last;\n  this.age = age;\n}\n```",
      "option_a": "생성자 함수는 소문자로 시작하는 것이 좋다",
      "option_b": "생성자 함수는 대문자로 시작하는 것이 좋다",
      "option_c": "생성자 함수 내부에서 `this`는 undefined이다",
      "option_d": "생성자 함수는 return 문이 반드시 필요하다",
      "correct_answer": "B",
      "explanation": "생성자 함수는 대문자로 시작하는 것이 JavaScript의 관례입니다. 이는 일반 함수와 구분하기 위한 네이밍 컨벤션입니다. 생성자 함수 내부에서 `this`는 새로 생성될 객체를 참조하며, 명시적으로 return을 쓰지 않아도 자동으로 새 객체가 반환됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T03:09:41.000Z"
    },
    {
      "id": 619,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 키워드는?\n\n```javascript\nfunction Person(first, last) {\n  this.firstName = first;\n  this.lastName = last;\n}\n\nconst myFather = ____ Person(\"John\", \"Doe\");\n```",
      "option_a": "call",
      "option_b": "apply",
      "option_c": "new",
      "option_d": "create",
      "correct_answer": "C",
      "explanation": "생성자 함수를 사용하여 새로운 객체를 생성할 때는 `new` 키워드를 사용해야 합니다. `new Person(\"John\", \"Doe\")`를 실행하면 새로운 Person 객체가 생성되고 `myFather` 변수에 할당됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T03:11:03.000Z"
    },
    {
      "id": 620,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nfunction Person(first, last) {\n  this.firstName = first;\n  this.lastName = last;\n  this.nationality = \"English\";\n}\n\nconst person1 = new Person(\"John\", \"Doe\");\nconst person2 = new Person(\"Jane\", \"Smith\");\n\nperson1.nationality = \"American\";\n\nconsole.log(person2.nationality);\n```",
      "option_a": "\"American\"",
      "option_b": "\"English\"",
      "option_c": "undefined",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "`person1.nationality = \"American\"`은 `person1` 객체의 `nationality` 속성만 변경합니다. `person2`는 별개의 객체이므로 여전히 생성자 함수에서 설정된 기본값인 \"English\"를 유지합니다. 각 객체는 독립적인 속성을 가집니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T03:12:10.000Z"
    },
    {
      "id": 621,
      "subject_id": 1,
      "question": "생성자 함수에 새로운 속성을 추가하는 올바른 방법은?\n\n```javascript\nfunction Person(first, last) {\n  this.firstName = first;\n  this.lastName = last;\n}\n\n// 방법 A\nPerson.nationality = \"English\";\n\n// 방법 B  \nPerson.prototype.nationality = \"English\";\n```",
      "option_a": "방법 A만 올바르다",
      "option_b": "방법 B만 올바르다",
      "option_c": "둘 다 올바르다",
      "option_d": "둘 다 틀렸다",
      "correct_answer": "B",
      "explanation": "생성자 함수에 새로운 속성을 추가하려면 `prototype`을 사용해야 합니다. 방법 A는 Person 함수 자체에 속성을 추가하는 것이므로, 이 생성자로 만든 객체들은 이 속성에 접근할 수 없습니다. 방법 B는 모든 Person 객체가 `nationality` 속성을 상속받을 수 있도록 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T03:13:05.000Z"
    },
    {
      "id": 622,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과를 예측하세요:\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.changeName = function(newName) {\n  this.name = newName;\n}\n\nconst person1 = new Person(\"Alice\");\nconst person2 = new Person(\"Bob\");\n\nperson1.changeName = function(newName) {\n  this.name = \"Mr. \" + newName;\n}\n\nperson1.changeName(\"Charlie\");\nperson2.changeName(\"David\");\n\nconsole.log(person1.name + \" and \" + person2.name);\n```",
      "option_a": "\"Alice and Bob\"",
      "option_b": "\"Mr. Charlie and David\"",
      "option_c": "\"Charlie and David\"",
      "option_d": "\"Mr. Charlie and Mr. David\"",
      "correct_answer": "B",
      "explanation": "1) `person1`에게는 개별적으로 `changeName` 메서드가 재정의되어 \"Mr. \"를 앞에 붙입니다.\n2) `person2`는 prototype의 원래 `changeName` 메서드를 사용하므로 단순히 이름만 변경됩니다.\n3) 객체에 직접 추가된 메서드는 prototype의 같은 이름 메서드보다 우선순위가 높습니다.\n4) 따라서 `person1.name`은 \"Mr. Charlie\", `person2.name`은 \"David\"가 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T03:15:19.000Z"
    },
    {
      "id": 623,
      "subject_id": 1,
      "question": "JavaScript에서 `this` 키워드에 대한 설명으로 틀린 것은?",
      "option_a": "`this`는 키워드이다",
      "option_b": "`this`는 변수가 아니다",
      "option_c": "`this`의 값을 직접 변경할 수 있다",
      "option_d": "`this`가 참조하는 객체는 사용되는 방식에 따라 달라진다",
      "correct_answer": "C",
      "explanation": "`this`는 키워드이므로 변수처럼 직접 값을 할당하여 변경할 수 없습니다. `this`가 무엇을 참조하는지는 함수가 어떻게 호출되는지에 따라 자동으로 결정됩니다. `call()`, `apply()`, `bind()` 메서드를 사용하면 `this`가 참조할 객체를 지정할 수 있지만, 이는 직접 변경하는 것이 아닙니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T03:17:33.000Z"
    },
    {
      "id": 624,
      "subject_id": 1,
      "question": "다음 코드에서 `this`가 참조하는 것은?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  fullName: function() {\n    return ____.firstName + \" \" + ____.lastName;\n  }\n};\n\nconsole.log(person.fullName());\n```",
      "option_a": "전역 객체",
      "option_b": "person 객체",
      "option_c": "undefined",
      "option_d": "window 객체",
      "correct_answer": "B",
      "explanation": "객체 메서드에서 `this`는 해당 객체를 참조합니다. `person.fullName()`이 호출될 때, `fullName` 메서드 내부의 `this`는 `person` 객체를 가리킵니다. 따라서 `this.firstName`은 \"John\", `this.lastName`은 \"Doe\"가 되어 \"John Doe\"가 출력됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T03:18:48.000Z"
    },
    {
      "id": 625,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst person1 = {\n  fullName: function() {\n    return this.firstName + \" \" + this.lastName;\n  }\n}\n\nconst person2 = {\n  firstName: \"John\",\n  lastName: \"Doe\"\n}\n\nconst result = person1.fullName.call(person2);\nconsole.log(result);\n```",
      "option_a": "\"undefined undefined\"",
      "option_b": "\"John Doe\"",
      "option_c": "에러 발생",
      "option_d": "null",
      "correct_answer": "B",
      "explanation": "`call()` 메서드는 함수를 호출하면서 `this`가 참조할 객체를 첫 번째 인수로 지정할 수 있습니다. `person1.fullName.call(person2)`는 `person1`의 `fullName` 메서드를 `person2`를 `this`로 사용하여 호출합니다. 따라서 `this.firstName`은 \"John\", `this.lastName`은 \"Doe\"가 되어 \"John Doe\"가 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T03:20:14.000Z"
    },
    {
      "id": 626,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  fullName: function() {\n    return this.firstName + \" \" + this.lastName;\n  }\n}\n\nconst member = {\n  firstName: \"Hege\",\n  lastName: \"Nilsen\"\n}\n\nlet boundFunction = person.fullName.______(member);\nconsole.log(boundFunction()); // \"Hege Nilsen\"\n```",
      "option_a": "call",
      "option_b": "apply",
      "option_c": "bind",
      "option_d": "attach",
      "correct_answer": "C",
      "explanation": "`bind()` 메서드는 `this`가 특정 객체로 고정된 새로운 함수를 반환합니다. `person.fullName.bind(member)`는 `this`가 `member` 객체로 바인딩된 새로운 함수를 생성합니다. 이 함수를 나중에 호출하면 항상 `member` 객체를 `this`로 사용하여 \"Hege Nilsen\"이 출력됩니다. `call()`이나 `apply()`는 함수를 즉시 실행하지만, `bind()`는 바인딩된 새 함수를 반환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T03:21:46.000Z"
    },
    {
      "id": 627,
      "subject_id": 1,
      "question": "다음 코드들을 우선순위가 높은 것부터 낮은 것 순서로 나열한 것은?\n\n```javascript\n// A. 객체 메서드\nobj.method();\n\n// B. bind() 사용\nboundFunc = func.bind(obj);\nboundFunc();\n\n// C. call() 사용  \nfunc.call(obj);\n\n// D. 전역 스코프에서 함수 호출\nfunc();\n```",
      "option_a": "A → B → C → D",
      "option_b": "B → C → A → D",
      "option_c": "D → A → C → B",
      "option_d": "C → B → A → D",
      "correct_answer": "B",
      "explanation": "JavaScript에서 `this`의 우선순위는 다음과 같습니다:\n\n1) bind() (가장 높음) - `bind()`로 바인딩된 함수는 다른 방법으로 호출해도 바인딩된 객체를 유지\n2) call()/apply() - 명시적으로 `this`를 지정하여 함수 호출\n3) 객체 메서드 - 객체의 메서드로 호출될 때 해당 객체가 `this`\n4) 전역 스코프 (가장 낮음) - 일반 함수 호출시 전역 객체 또는 undefined(strict mode)\n\n따라서 B(bind) → C(call) → A(객체 메서드) → D(전역)이 올바른 우선순위입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T03:24:08.000Z"
    },
    {
      "id": 628,
      "subject_id": 1,
      "question": "JavaScript에서 모든 객체가 속성과 메서드를 상속받는 곳은?",
      "option_a": "클래스(Class)",
      "option_b": "프로토타입(Prototype)",
      "option_c": "생성자 함수(Constructor Function)",
      "option_d": "전역 객체(Global Object)",
      "correct_answer": "B",
      "explanation": "JavaScript의 모든 객체는 프로토타입(Prototype)으로부터 속성과 메서드를 상속받습니다. 예를 들어, Date 객체는 Date.prototype에서, Array 객체는 Array.prototype에서, Person 객체는 Person.prototype에서 상속받습니다. 이것이 JavaScript의 프로토타입 기반 상속의 핵심 개념입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T03:34:37.000Z"
    },
    {
      "id": 629,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nfunction Person(first, last) {\n  this.firstName = first;\n  this.lastName = last;\n}\n\nPerson.nationality = \"English\";\nconst person1 = new Person(\"John\", \"Doe\");\n\nconsole.log(person1.nationality);\n```",
      "option_a": "\"English\"",
      "option_b": "undefined",
      "option_c": "null",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "`Person.nationality = \"English\"`는 Person 생성자 함수 자체에 속성을 추가하는 것이므로, 생성된 객체 `person1`에서는 이 속성에 접근할 수 없습니다. 따라서 `person1.nationality`는 `undefined`를 반환합니다. 생성된 모든 객체가 접근할 수 있게 하려면 `Person.prototype.nationality = \"English\"`를 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T03:37:03.000Z"
    },
    {
      "id": 630,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 코드는?\n\n```javascript\nfunction Person(first, last) {\n  this.firstName = first;\n  this.lastName = last;\n}\n\nPerson.________.name = function() {\n  return this.firstName + \" \" + this.lastName;\n};\n\nconst person1 = new Person(\"John\", \"Doe\");\nconsole.log(person1.name()); // \"John Doe\"\n```",
      "option_a": "constructor",
      "option_b": "function",
      "option_c": "prototype",
      "option_d": "method",
      "correct_answer": "C",
      "explanation": "생성자 함수에 새로운 메서드를 추가하려면 `prototype` 속성을 사용해야 합니다. `Person.prototype.name = function() { ... }`은 모든 Person 객체가 `name()` 메서드를 상속받을 수 있게 해줍니다. 이렇게 하면 `person1.name()`을 호출할 때 \"John Doe\"가 반환됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T03:38:20.000Z"
    },
    {
      "id": 631,
      "subject_id": 1,
      "question": "다음 중 올바른 상속 체인은?\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nconst person1 = new Person(\"John\");\n```",
      "option_a": "person1 → Person → Object.prototype",
      "option_b": "person1 → Person.prototype → Object.prototype",
      "option_c": "person1 → Object.prototype → Person.prototype",
      "option_d": "Person → person1 → Object.prototype",
      "correct_answer": "B",
      "explanation": "JavaScript의 프로토타입 상속 체인은 다음과 같습니다:\n\n1) `person1` 객체는 `Person.prototype`에서 속성과 메서드를 상속받습니다\n2) `Person.prototype`은 다시 `Object.prototype`에서 상속받습니다\n3) `Object.prototype`이 프로토타입 상속 체인의 최상위입니다\n\n따라서 상속 체인은 `person1 → Person.prototype → Object.prototype` 순서입니다. 이는 Date 객체의 경우 `Date 객체 → Date.prototype → Object.prototype`, Array 객체의 경우 `Array 객체 → Array.prototype → Object.prototype`와 같은 패턴을 따릅니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T03:40:27.000Z"
    },
    {
      "id": 632,
      "subject_id": 1,
      "question": "다음 코드에서 객체의 모든 키(key)를 배열로 반환하는 메서드는?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  age: 50,\n  eyeColor: \"blue\"\n};\n\nconst result = Object.______(person);\n// 결과: [\"firstName\", \"lastName\", \"age\", \"eyeColor\"]\n```",
      "option_a": "values",
      "option_b": "keys",
      "option_c": "entries",
      "option_d": "properties",
      "correct_answer": "B",
      "explanation": "`Object.keys()` 메서드는 객체의 모든 키(속성명)를 배열로 반환합니다. 이 메서드는 객체의 열거 가능한 속성들의 이름만을 배열 형태로 제공하므로, 객체의 구조를 파악하거나 반복 작업을 할 때 유용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T03:42:30.000Z"
    },
    {
      "id": 633,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  age: 50\n};\n\nconst result = Object.values(person);\nconsole.log(result);\n```",
      "option_a": "[\"firstName\", \"lastName\", \"age\"]",
      "option_b": "[\"John\", \"Doe\", 50]",
      "option_c": "[[\"firstName\", \"John\"], [\"lastName\", \"Doe\"], [\"age\", 50]]",
      "option_d": "{firstName: \"John\", lastName: \"Doe\", age: 50}",
      "correct_answer": "B",
      "explanation": "`Object.values()` 메서드는 객체의 모든 값(value)들을 배열로 반환합니다. 키는 포함하지 않고 오직 값만 배열 형태로 제공합니다. 따라서 `[\"John\", \"Doe\", 50]`이 출력됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T03:43:32.000Z"
    },
    {
      "id": 634,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\nconst fruits = [\n  [\"apples\", 300],\n  [\"pears\", 900],\n  [\"bananas\", 500]\n];\n\nconst myObj = Object.________(fruits);\nconsole.log(myObj.pears); // 900\n```",
      "option_a": "entries",
      "option_b": "values",
      "option_c": "fromEntries",
      "option_d": "assign",
      "correct_answer": "C",
      "explanation": "`Object.fromEntries()` 메서드는 키-값 쌍의 배열(이터러블)을 객체로 변환합니다. 여기서 `fruits` 배열의 각 요소는 `[키, 값]` 형태이므로, `fromEntries()`를 사용하면 `{apples: 300, pears: 900, bananas: 500}` 객체가 생성됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T04:48:22.000Z"
    },
    {
      "id": 635,
      "subject_id": 1,
      "question": "다음 코드에서 `Object.entries()`의 활용 예시로 올바른 것은?\n\n```javascript\nconst fruits = {Bananas: 300, Oranges: 200, Apples: 500};\n\n// A: 객체를 반복문에서 사용\nfor (let [fruit, value] of Object.entries(fruits)) {\n  console.log(fruit + \": \" + value);\n}\n\n// B: 객체를 Map으로 변환\nconst myMap = new Map(Object.entries(fruits));\n```",
      "option_a": "A만 올바르다",
      "option_b": "B만 올바르다",
      "option_c": "A, B 둘 다 올바르다",
      "option_d": "A, B 둘 다 틀렸다",
      "correct_answer": "C",
      "explanation": "`Object.entries()` 메서드는 객체의 키-값 쌍을 `[키, 값]` 형태의 배열들로 구성된 2차원 배열을 반환합니다.\n\n1) A: 구조 분해 할당(`[fruit, value]`)을 사용하여 객체를 쉽게 반복할 수 있습니다.\n2) B: `Object.entries()`의 반환값은 Map 생성자가 받는 형태와 정확히 일치하므로 객체를 Map으로 변환할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T04:49:41.000Z"
    },
    {
      "id": 636,
      "subject_id": 1,
      "question": "다음 `Object.groupBy()` 코드의 실행 결과로 생성되는 객체는?\n\n```javascript\nconst fruits = [\n  {name: \"apples\", quantity: 300},\n  {name: \"bananas\", quantity: 500},\n  {name: \"oranges\", quantity: 200},\n  {name: \"kiwi\", quantity: 150}\n];\n\nfunction myCallback({quantity}) {\n  return quantity > 200 ? \"ok\" : \"low\";\n}\n\nconst result = Object.groupBy(fruits, myCallback);\n```",
      "option_a": "`{ok: 2, low: 2}`",
      "option_b": "`{ok: [\"apples\", \"bananas\"], low: [\"oranges\", \"kiwi\"]}`",
      "option_c": "`{ok: [{name:\"apples\", quantity:300}, {name:\"bananas\", quantity:500}], low: [{name:\"oranges\", quantity:200}, {name:\"kiwi\", quantity:150}]}`",
      "option_d": "`[\"ok\", \"low\"]`",
      "correct_answer": "C",
      "explanation": "`Object.groupBy()` 메서드는 ES2024에서 추가된 메서드로, 배열의 요소들을 콜백 함수의 반환값에 따라 그룹화합니다.\n\n1) 콜백 함수 `myCallback`은 `quantity > 200`인 경우 \"ok\", 그렇지 않으면 \"low\"를 반환합니다.\n2) apples(300)와 bananas(500)는 \"ok\" 그룹에 속합니다.\n3) oranges(200)와 kiwi(150)는 \"low\" 그룹에 속합니다.\n4) 결과는 그룹명을 키로 하고, 해당 그룹에 속하는 원본 객체들의 배열을 값으로 가지는 객체입니다.\n\n따라서 결과는 `{ok: [apples 객체, bananas 객체], low: [oranges 객체, kiwi 객체]}`가 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T04:52:36.000Z"
    },
    {
      "id": 637,
      "subject_id": 1,
      "question": "다음 코드에서 객체에 새로운 속성을 추가하는 메서드는?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\"\n};\n\nObject.________(person, \"age\", {value: 30});\nconsole.log(person.age); // 30\n```",
      "option_a": "addProperty",
      "option_b": "defineProperty",
      "option_c": "setProperty",
      "option_d": "createProperty",
      "correct_answer": "B",
      "explanation": "`Object.defineProperty()` 메서드는 객체에 새로운 속성을 추가하거나 기존 속성을 수정할 때 사용합니다. 이 메서드를 사용하면 단순히 값을 설정하는 것뿐만 아니라 속성의 메타데이터(writable, enumerable, configurable 등)도 함께 설정할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T04:55:22.000Z"
    },
    {
      "id": 638,
      "subject_id": 1,
      "question": "다음 두 메서드의 차이점으로 올바른 것은?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  language: \"EN\"\n};\n\nObject.defineProperty(person, \"language\", {enumerable: false});\n\nconst result1 = Object.getOwnPropertyNames(person);\nconst result2 = Object.keys(person);\n```",
      "option_a": "두 메서드 모두 동일한 결과를 반환한다",
      "option_b": "`getOwnPropertyNames()`는 모든 속성을, `keys()`는 열거 가능한 속성만 반환한다",
      "option_c": "`keys()`는 모든 속성을, `getOwnPropertyNames()`는 열거 가능한 속성만 반환한다",
      "option_d": "두 메서드 모두 열거 불가능한 속성만 반환한다",
      "correct_answer": "B",
      "explanation": "1) `Object.getOwnPropertyNames()`는 열거 가능 여부에 관계없이 객체의 모든 속성을 반환합니다.\n2) `Object.keys()`는 오직 열거 가능한(enumerable: true) 속성만 반환합니다.\n3) 예시에서 `language` 속성이 `enumerable: false`로 설정되었으므로, `getOwnPropertyNames()`에는 포함되지만 `keys()`에는 포함되지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T04:57:14.000Z"
    },
    {
      "id": 639,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst person = {firstName: \"John\", lastName: \"Doe\"};\n\nObject.defineProperty(person, \"language\", {\n  value: \"EN\",\n  writable: false\n});\n\nperson.language = \"NO\";\nconsole.log(person.language);\n```",
      "option_a": "\"NO\"",
      "option_b": "\"EN\"",
      "option_c": "undefined",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "`writable: false`로 설정된 속성은 값을 변경할 수 없습니다. `person.language = \"NO\"`로 값을 변경하려고 시도해도 무시되며, 원래 값인 \"EN\"이 그대로 유지됩니다. strict mode에서는 에러가 발생하지만, 일반 모드에서는 조용히 무시됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T04:58:17.000Z"
    },
    {
      "id": 640,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 키워드는?\n\n```javascript\nconst person = {firstName: \"John\", lastName: \"Doe\"};\n\nObject.defineProperty(person, \"fullName\", {\n  ____: function() {\n    return this.firstName + \" \" + this.lastName;\n  }\n});\n\nconsole.log(person.fullName); // \"John Doe\"\n```",
      "option_a": "value",
      "option_b": "get",
      "option_c": "set",
      "option_d": "function",
      "correct_answer": "B",
      "explanation": "`get` 키워드는 getter 함수를 정의할 때 사용합니다. getter는 속성에 접근할 때 자동으로 호출되는 함수로, `person.fullName`처럼 속성에 접근하면 정의된 함수가 실행되어 결과값을 반환합니다. 이는 계산된 속성을 만들 때 매우 유용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T04:59:09.000Z"
    },
    {
      "id": 641,
      "subject_id": 1,
      "question": "다음 카운터 객체 코드의 실행 결과는?\n\n```javascript\nconst obj = {counter: 0};\n\nObject.defineProperty(obj, \"reset\", {\n  get: function() { this.counter = 0; }\n});\n\nObject.defineProperty(obj, \"add\", {\n  set: function(value) { this.counter += value; }\n});\n\nobj.add = 5;      // 1단계\nobj.counter++;    // 2단계  \nobj.reset;        // 3단계\nobj.add = 3;      // 4단계\n\nconsole.log(obj.counter);\n```",
      "option_a": "0",
      "option_b": "3",
      "option_c": "6",
      "option_d": "9",
      "correct_answer": "B",
      "explanation": "단계별로 실행 과정을 분석해보겠습니다:\n\n1) 초기 상태: `counter = 0`\n2) 1단계 `obj.add = 5`: setter가 호출되어 `counter += 5` → `counter = 5`\n3) 2단계 `obj.counter++`: 직접 증가 → `counter = 6`\n4) 3단계 `obj.reset`: getter가 호출되어 `counter = 0`으로 리셋 → `counter = 0`\n5) 4단계 `obj.add = 3`: setter가 호출되어 `counter += 3` → `counter = 3`\n\n따라서 최종 결과는 3입니다. 이 예시는 getter와 setter를 활용하여 속성처럼 보이지만 실제로는 함수 호출이 일어나는 방식을 보여줍니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T05:01:21.000Z"
    },
    {
      "id": 642,
      "subject_id": 1,
      "question": "JavaScript에서 객체의 속성에 접근할 때 사용하는 getter와 setter의 키워드는 무엇인가요?",
      "option_a": "`function`과 `method`",
      "option_b": "`get`과 `set`",
      "option_c": "`read`와 `write`",
      "option_d": "`access`와 `modify`",
      "correct_answer": "B",
      "explanation": "JavaScript에서는 `get` 키워드를 사용해 getter를 정의하고, `set` 키워드를 사용해 setter를 정의합니다. getter는 속성값을 읽을 때 실행되는 함수이고, setter는 속성값을 설정할 때 실행되는 함수입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T05:04:25.000Z"
    },
    {
      "id": 643,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 키워드는 무엇인가요?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  _____ fullName() {\n    return this.firstName + \" \" + this.lastName;\n  }\n};\nconsole.log(person.fullName); // \"John Doe\"\n```",
      "option_a": "function",
      "option_b": "method",
      "option_c": "get",
      "option_d": "property",
      "correct_answer": "C",
      "explanation": "`get` 키워드를 사용하면 `person.fullName`과 같이 함수 호출 괄호 없이 속성처럼 접근할 수 있습니다. 만약 일반 함수로 정의했다면 `person.fullName()`처럼 괄호를 붙여야 합니다. getter를 사용하면 더 간단하고 직관적인 문법을 제공합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T05:05:25.000Z"
    },
    {
      "id": 644,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇인가요?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  language: \"en\",\n  get lang() {\n    return this.language.toUpperCase();\n  }\n};\nconsole.log(person.lang);\n```",
      "option_a": "\"en\"",
      "option_b": "\"EN\"",
      "option_c": "undefined",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "getter 함수 내에서 `this.language.toUpperCase()`를 호출하므로, 원본 값 \"en\"이 대문자로 변환되어 \"EN\"이 반환됩니다. getter는 단순히 값을 반환하는 것뿐만 아니라 값을 가공해서 반환할 수도 있습니다. 이는 데이터 품질을 향상시키는 데 유용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T05:06:08.000Z"
    },
    {
      "id": 645,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 코드는 무엇인가요?\n\n```javascript\nconst person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  language: \"\",\n  set lang(value) {\n    ______________;\n  }\n};\nperson.lang = \"korean\";\nconsole.log(person.language); // \"KOREAN\"\n```",
      "option_a": "this.language = value",
      "option_b": "this.language = value.toUpperCase()",
      "option_c": "return value.toUpperCase()",
      "option_d": "language = value.toUpperCase()",
      "correct_answer": "B",
      "explanation": "setter에서 받은 값을 대문자로 변환하여 `language` 속성에 저장해야 합니다. `this.language = value.toUpperCase()`가 정답입니다. setter는 값을 설정하는 함수이므로 return문이 필요 없고, `this`를 사용해 객체의 속성에 접근해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T05:07:03.000Z"
    },
    {
      "id": 646,
      "subject_id": 1,
      "question": "`Object.defineProperty()`를 사용한 다음 코드의 실행 결과는 무엇인가요?\n\n```javascript\nconst obj = {counter: 0};\n\nObject.defineProperty(obj, \"reset\", {\n  get: function() { this.counter = 0; }\n});\n\nObject.defineProperty(obj, \"add\", {\n  set: function(value) { this.counter += value; }\n});\n\nobj.counter = 10;\nobj.add = 5;\nobj.reset;\nconsole.log(obj.counter);\n```",
      "option_a": "0",
      "option_b": "5",
      "option_c": "10",
      "option_d": "15",
      "correct_answer": "A",
      "explanation": "코드 실행 순서를 따라가면:\n\n1) `obj.counter` = 10 → counter가 10이 됨\n2) `obj.add = 5` → setter가 실행되어 counter에 5를 더함 (10 + 5 = 15)\n3) `obj.reset` → getter가 실행되어 counter를 0으로 리셋\n4) 최종 결과: 0\n\n`Object.defineProperty()`는 getter와 setter를 정의하는 또 다른 방법으로, 객체 리터럴 문법과 동일한 기능을 제공합니다. 이 예제는 카운터를 구현하는 실용적인 사례를 보여줍니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T05:08:14.000Z"
    },
    {
      "id": 647,
      "subject_id": 1,
      "question": "JavaScript에서 객체의 속성 추가를 방지하는 메서드는 무엇인가요?",
      "option_a": "Object.preventExtensions()",
      "option_b": "Object.preventAdditions()",
      "option_c": "Object.blockProperties()",
      "option_d": "Object.stopExtending()",
      "correct_answer": "A",
      "explanation": "`Object.preventExtensions()` 메서드는 객체에 새로운 속성이 추가되는 것을 방지합니다. 이 메서드를 사용하면 기존 속성은 수정하거나 삭제할 수 있지만, 새로운 속성을 추가할 수는 없습니다. 배열도 객체이므로 배열에도 적용 가능하며, 이 경우 `push()` 같은 메서드로 새 요소를 추가할 수 없게 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T05:11:23.000Z"
    },
    {
      "id": 648,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇인가요?\n\n```javascript\nconst person = {firstName: \"John\", lastName: \"Doe\"};\nObject.preventExtensions(person);\nconsole.log(Object.isExtensible(person));\n```",
      "option_a": "true",
      "option_b": "false",
      "option_c": "undefined",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "`Object.preventExtensions()`를 적용한 후 `Object.isExtensible()`로 확인하면 `false`를 반환합니다. `Object.isExtensible()` 메서드는 객체가 확장 가능한지(새 속성을 추가할 수 있는지)를 확인하는 메서드로, 확장 가능하면 `true`, 불가능하면 `false`를 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T05:12:39.000Z"
    },
    {
      "id": 649,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 메서드는 무엇인가요?\n\n```javascript\n\"use strict\";\nconst person = {firstName: \"John\", age: 30};\n__________(person);\n// 이제 속성 추가와 삭제가 모두 불가능하지만, 기존 속성 값은 변경 가능\nperson.age = 31; // 성공\ndelete person.age; // TypeError 발생\nperson.nationality = \"Korean\"; // TypeError 발생\n```",
      "option_a": "Object.preventExtensions",
      "option_b": "Object.seal",
      "option_c": "Object.freeze",
      "option_d": "Object.lock",
      "correct_answer": "B",
      "explanation": "`Object.seal()` 메서드는 객체를 봉인(seal)하여 새로운 속성 추가와 기존 속성 삭제를 모두 방지합니다. 하지만 기존 속성의 값은 여전히 변경할 수 있습니다. 이는 `Object.preventExtensions()`보다 더 제한적이고, `Object.freeze()`보다는 덜 제한적인 중간 단계의 보호 수준입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T05:13:47.000Z"
    },
    {
      "id": 650,
      "subject_id": 1,
      "question": "다음 중 집합 A가 집합 B의 부분집합임을 나타내는 기호는? (A ⊂ B)",
      "option_a": "A ⊂ B (A는 B의 부분집합)",
      "option_b": "A ⊃ B (A는 B의 상위집합)",
      "option_c": "A ∈ B (A는 B의 원소)",
      "option_d": "A ∉ B (A는 B의 원소가 아님)",
      "correct_answer": "A",
      "explanation": "⊂ 기호는 \"부분집합\"을 나타내는 수학 기호입니다. A ⊂ B는 \"A는 B의 부분집합이다\"를 의미합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T05:16:10.000Z"
    },
    {
      "id": 651,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 올바른 것은 무엇인가요?\n\n```javascript\nconst fruits = [\"Apple\", \"Banana\"];\nObject.freeze(fruits);\n\nconsole.log(Object.isFrozen(fruits));  // A\nconsole.log(Object.isSealed(fruits));  // B\nconsole.log(Object.isExtensible(fruits)); // C\n```",
      "option_a": "A: false, B: false, C: true",
      "option_b": "A: true, B: false, C: false",
      "option_c": "A: true, B: true, C: false",
      "option_d": "A: false, B: true, C: true",
      "correct_answer": "C",
      "explanation": "`Object.freeze()`는 가장 강력한 보호 메서드로, 객체를 완전히 읽기 전용으로 만듭니다. frozen 객체는 자동으로 sealed이기도 하고, extensible하지도 않습니다. 따라서:\n\n1) `Object.isFrozen()`: true (frozen 상태)\n2) `Object.isSealed()`: true (frozen 객체는 항상 sealed)\n3) `Object.isExtensible()`: false (frozen 객체는 확장 불가)\n\n이는 포함 관계로 이해할 수 있습니다: Frozen ⊂ Sealed ⊂ Non-extensible",
      "difficulty": "medium",
      "created_at": "2025-08-08T05:19:30.000Z"
    },
    {
      "id": 652,
      "subject_id": 1,
      "question": "다음 코드에서 각 단계별로 가능한 작업을 올바르게 설명한 것은 무엇인가요?\n\n```javascript\n\"use strict\";\nconst data = {name: \"JavaScript\", version: \"ES6\"};\n\n// 단계 1: 초기 상태\n// 단계 2: Object.preventExtensions(data);\n// 단계 3: Object.seal(data);  \n// 단계 4: Object.freeze(data);\n```",
      "option_a": "단계1: 모든 작업 가능 / 단계2: 수정,삭제 가능 / 단계3: 수정만 가능 / 단계4: 아무것도 불가능",
      "option_b": "단계1: 추가,수정,삭제 가능 / 단계2: 추가 불가능 / 단계3: 추가,삭제 불가능 / 단계4: 추가,수정,삭제 모두 불가능",
      "option_c": "단계1: 수정만 가능 / 단계2: 삭제만 가능 / 단계3: 추가만 가능 / 단계4: 모든 작업 가능",
      "option_d": "단계1: 읽기만 가능 / 단계2: 읽기,쓰기 가능 / 단계3: 읽기,수정 가능 / 단계4: 모든 작업 가능",
      "correct_answer": "B",
      "explanation": "JavaScript의 객체 보호 메서드들은 단계적으로 더 강한 제한을 가합니다:\n\n1. 단계 1 (일반 객체): 속성 추가, 수정, 삭제 모두 가능\n\n2. 단계 2 (preventExtensions):\n1) ❌ 속성 추가 불가능\n2) ✅ 기존 속성 수정 가능\n3) ✅ 기존 속성 삭제 가능\n\n3. 단계 3 (seal):\n1) ❌ 속성 추가 불가능 (preventExtensions 포함)\n2) ✅ 기존 속성 수정 가능\n3) ❌ 기존 속성 삭제 불가능\n\n4. 단계 4 (freeze):\n1) ❌ 속성 추가 불가능 (seal 포함)\n2) ❌ 기존 속성 수정 불가능\n3) ❌ 기존 속성 삭제 불가능\n\n각 메서드는 이전 단계의 제한을 포함하면서 추가적인 제한을 가합니다. `freeze`는 객체를 완전히 불변(immutable)으로 만드는 가장 강력한 보호 수준입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T05:23:03.000Z"
    },
    {
      "id": 653,
      "subject_id": 1,
      "question": "JavaScript에서 클래스를 생성할 때 반드시 포함해야 하는 특별한 메서드는 무엇인가요?",
      "option_a": "init()",
      "option_b": "constructor()",
      "option_c": "create()",
      "option_d": "new()",
      "correct_answer": "B",
      "explanation": "JavaScript 클래스에서 `constructor()` 메서드는 필수적인 특별한 메서드입니다. 이 메서드는 새로운 객체가 생성될 때 자동으로 호출되며, 객체의 초기 속성을 설정하는 역할을 합니다. `constructor`라는 정확한 이름을 가져야 하며, 만약 정의하지 않으면 JavaScript가 자동으로 빈 constructor를 추가합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T05:25:23.000Z"
    },
    {
      "id": 654,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 키워드는 무엇인가요?\n\n```javascript\n_____ Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\nconst john = _____ Person(\"John\", 25);\n```",
      "option_a": "`function`, `create`",
      "option_b": "`class`, `new`",
      "option_c": "`object`, `make`",
      "option_d": "`template`, `build`",
      "correct_answer": "B",
      "explanation": "첫 번째 빈칸에는 `class` 키워드가 들어가며, 이는 클래스를 정의할 때 사용합니다. 두 번째 빈칸에는 `new` 키워드가 들어가며, 이는 클래스로부터 새로운 객체 인스턴스를 생성할 때 사용합니다. `new` 키워드는 constructor 메서드를 자동으로 호출하여 객체를 초기화합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T05:26:29.000Z"
    },
    {
      "id": 655,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇인가요?\n\n```javascript\nclass Car {\n  constructor(brand, year) {\n    this.brand = brand;\n    this.year = year;\n  }\n  \n  age() {\n    return 2024 - this.year;\n  }\n}\n\nconst myCar = new Car(\"Toyota\", 2020);\nconsole.log(myCar.age());\n```",
      "option_a": "2020",
      "option_b": "4",
      "option_c": "2024",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "`age()` 메서드는 현재 연도(2024)에서 자동차 제조 연도(2020)를 빼서 자동차의 나이를 계산합니다. 2024 - 2020 = 4이므로 결과는 4입니다. 클래스 메서드는 객체의 속성에 `this` 키워드를 통해 접근할 수 있으며, 이를 이용해 동적인 계산을 수행할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T05:27:29.000Z"
    },
    {
      "id": 656,
      "subject_id": 1,
      "question": "다음 상속 코드에서 빈칸에 들어갈 올바른 키워드들은 무엇인가요?\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak() {\n    return this.name + \" makes a sound\";\n  }\n}\n\nclass Dog _______ Animal {\n  constructor(name, breed) {\n    _______(name);\n    this.breed = breed;\n  }\n}\n\nconst myDog = new Dog(\"Buddy\", \"Golden Retriever\");\n```",
      "option_a": "`inherits`, `parent`",
      "option_b": "`extends`, `super`",
      "option_c": "`from`, `base`",
      "option_d": "`copies`, `original`",
      "correct_answer": "B",
      "explanation": "`extends` 키워드는 클래스 상속을 구현할 때 사용합니다. `Dog extends Animal`은 Dog 클래스가 Animal 클래스의 모든 메서드와 속성을 상속받는다는 의미입니다. `super()` 메서드는 부모 클래스의 constructor를 호출하여 부모 클래스의 속성을 초기화합니다. 상속을 통해 코드의 재사용성이 크게 향상됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T05:28:44.000Z"
    },
    {
      "id": 657,
      "subject_id": 1,
      "question": "다음 코드에서 C, D, E의 실행 결과는?\n\n```javascript\nclass Temperature {\n  constructor(celsius) {\n    this._celsius = celsius;\n  }\n  \n  // A\n  get fahrenheit() {\n    return this._celsius * 9/5 + 32;\n  }\n  \n  // B  \n  set fahrenheit(value) {\n    this._celsius = (value - 32) * 5/9;\n  }\n}\n\nconst temp = new Temperature(25);\nconsole.log(temp.fahrenheit);  // C\ntemp.fahrenheit = 86;          // D\nconsole.log(temp._celsius);    // E\n```",
      "option_a": "C: `77`, D: setter 실행됨, E: `30`",
      "option_b": "C: `25`, D: 오류 발생, E: `25`",
      "option_c": "C: `77`, D: setter 실행됨, E: `25`",
      "option_d": "C: 오류 발생, D: 오류 발생, E: `25`",
      "correct_answer": "A",
      "explanation": "1) C: `77` - getter가 실행되어 섭씨 25도를 화씨로 변환: 25 × 9/5 + 32 = 77\n2) D: setter 실행됨 - `temp.fahrenheit = 86`는 setter를 호출하여 화씨 86도를 섭씨로 변환하여 `_celsius`에 저장: (86 - 32) × 5/9 = 30\n3) E: `30` - setter에 의해 변경된 값이 출력됨\n\n중요한 개념들:\n\n1) getter는 메서드이지만 속성처럼 괄호 없이 접근 (`temp.fahrenheit`)\n2) setter도 메서드이지만 할당 연산자로 사용 (`temp.fahrenheit = 86`)\n3) 언더스코어(`_`)는 private 속성임을 나타내는 관례 (실제로는 접근 가능)\n4) getter/setter 이름은 실제 속성 이름과 달라야 함",
      "difficulty": "hard",
      "created_at": "2025-08-08T05:32:31.000Z"
    },
    {
      "id": 658,
      "subject_id": 1,
      "question": "JavaScript Set의 가장 중요한 특징은 무엇인가요?",
      "option_a": "요소들이 순서대로 정렬됨",
      "option_b": "중복된 값을 허용하지 않음",
      "option_c": "숫자만 저장할 수 있음",
      "option_d": "최대 10개의 요소만 저장 가능",
      "correct_answer": "B",
      "explanation": "Set의 가장 중요한 특징은 유일한 값만 저장한다는 것입니다. 같은 값을 여러 번 추가하려고 해도 Set에는 하나만 저장됩니다. 예를 들어:\n```javascript\nconst mySet = new Set();\nmySet.add(\"a\");\nmySet.add(\"a\");\nmySet.add(\"a\");\nconsole.log(mySet.size); // 1 (3이 아님)\n```\n이 특성 때문에 Set은 중복 제거, 유니크한 값 관리 등에 매우 유용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T05:35:42.000Z"
    },
    {
      "id": 659,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇인가요?\n\n```javascript\nconst fruits = new Set([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]);\nconsole.log(fruits.size);\n```",
      "option_a": "5",
      "option_b": "3",
      "option_c": "2",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "Set은 중복된 값을 자동으로 제거합니다. 배열 `[\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]`에서 중복을 제거하면:\n\n\"apple\" (1개)\n\"banana\" (1개)\n\"orange\" (1개)\n\n총 3개의 유니크한 값만 남게 됩니다. `size` 속성은 Set에 포함된 요소의 개수를 반환하므로 결과는 3입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T05:36:48.000Z"
    },
    {
      "id": 660,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 메서드는 무엇인가요?\n\n```javascript\nconst colors = new Set([\"red\", \"green\", \"blue\"]);\n\n// 'yellow' 색상이 Set에 있는지 확인\nif (colors.______(\"yellow\")) {\n    console.log(\"Yellow exists\");\n} else {\n    console.log(\"Yellow does not exist\");\n}\n```",
      "option_a": "includes",
      "option_b": "contains",
      "option_c": "has",
      "option_d": "exists",
      "correct_answer": "C",
      "explanation": "Set에서 특정 값이 존재하는지 확인할 때는 `has()` 메서드를 사용합니다. 이 메서드는 불린 값(true/false)을 반환합니다:\n\n`set.has(value)`: 값이 존재하면 true, 없으면 false\n\n배열의 `includes()`와 비슷한 역할을 하지만, Set에서는 `has()`를 사용합니다. 위 코드에서 \"yellow\"는 Set에 없으므로 \"Yellow does not exist\"가 출력됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T05:38:10.000Z"
    },
    {
      "id": 661,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 올바른 것은 무엇인가요?\n\n```javascript\nconst letters = new Set([\"a\", \"b\", \"c\"]);\n\nfor (const entry of letters.entries()) {\n    console.log(entry);\n}\n```",
      "option_a": "`a`, `b`, `c`",
      "option_b": "`[\"a\"]`, `[\"b\"]`, `[\"c\"]`",
      "option_c": "`[\"a\", \"a\"]`, `[\"b\", \"b\"]`, `[\"c\", \"c\"]`",
      "option_d": "`[0, \"a\"]`, `[1, \"b\"]`, `[2, \"c\"]`",
      "correct_answer": "C",
      "explanation": "`entries()` 메서드는 `[value, value]` 형태의 배열을 반환합니다. Set은 키(key)가 없기 때문에 Map과의 호환성을 위해 값을 두 번 반복합니다:\n\n1) `[\"a\", \"a\"]`\n2) `[\"b\", \"b\"]`\n3) `[\"c\", \"c\"]`\n\n이것이 Set의 `entries()` 메서드의 특징입니다. 일반적으로 Set을 순회할 때는 `for...of` 루프나 `forEach()`를 더 많이 사용합니다:\n\n```javascript\nfor (const value of letters) {\n    console.log(value); // \"a\", \"b\", \"c\"\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-08T05:40:20.000Z"
    },
    {
      "id": 662,
      "subject_id": 1,
      "question": "다음 코드의 결과는?\n\n```javascript\nconst mySet = new Set([\"x\", \"y\", \"z\"]);\n\nconsole.log([...mySet.keys()]);     // A\nconsole.log([...mySet.values()]);   // B\nconsole.log(mySet.keys() === mySet.values()); // C\n```",
      "option_a": "A: `[\"x\", \"y\", \"z\"]`, B: `[\"x\", \"y\", \"z\"]`, C: `true`",
      "option_b": "A: `[0, 1, 2]`, B: `[\"x\", \"y\", \"z\"]`, C: `false`",
      "option_c": "A: `[\"x\", \"y\", \"z\"]`, B: `[\"x\", \"y\", \"z\"]`, C: `false`",
      "option_d": "A: `undefined`, B: `[\"x\", \"y\", \"z\"]`, C: `false`",
      "correct_answer": "C",
      "explanation": "Set에서 `keys()`와 `values()` 메서드는 특별한 특징을 가집니다:\n\n1) A와 B: Set은 키가 없기 때문에 `keys()`와 `values()` 모두 같은 값들을 반환합니다. 둘 다 `[\"x\", \"y\", \"z\"]`를 출력합니다.\n\n2) C: 하지만 `mySet.keys() === mySet.values()`는 `false`입니다. 이는 두 메서드가 서로 다른 Iterator 객체를 반환하기 때문입니다. JavaScript에서 객체는 참조로 비교되므로, 내용이 같아도 다른 객체이면 `===` 비교 결과는 false가 됩니다.\n\n중요한 개념들:\n\n1) Set의 `keys()`와 `values()`는 동일한 값을 반환 (Map 호환성을 위함)\n2) 매번 새로운 Iterator 객체를 생성하므로 참조가 다름\n3) 실제 개발에서는 `values()`나 직접 `for...of` 순회를 더 많이 사용",
      "difficulty": "hard",
      "created_at": "2025-08-08T05:43:28.000Z"
    },
    {
      "id": 663,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는 무엇인가요?\n\n```javascript\nconst A = new Set(['a', 'b', 'c']);\nconst B = new Set(['b', 'c', 'd']);\nconst C = A.union(B);\nconsole.log([...C].join(''));\n```",
      "option_a": "abc",
      "option_b": "bcd",
      "option_c": "abcd",
      "option_d": "bc",
      "correct_answer": "C",
      "explanation": "`union()` 메서드는 두 집합의 합집합을 반환합니다. 합집합은 두 집합 중 어느 하나라도 포함된 모든 요소를 포함합니다:\n\n1) Set A: `['a', 'b', 'c']`\n2) Set B: `['b', 'c', 'd']`\n3) A.union(B): `['a', 'b', 'c', 'd']`\n\nSet의 특성상 중복된 값(`'b'`, `'c'`)은 한 번만 포함되므로 결과는 `abcd`입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T05:53:46.000Z"
    },
    {
      "id": 664,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 메서드는 무엇인가요?\n\n```javascript\nconst students1 = new Set(['Alice', 'Bob', 'Charlie']);\nconst students2 = new Set(['Bob', 'Charlie', 'David']);\n\n// 두 반 모두에 속한 학생들을 찾기\nconst commonStudents = students1._______(students2);\nconsole.log([...commonStudents]); // ['Bob', 'Charlie']\n```",
      "option_a": "union",
      "option_b": "intersection",
      "option_c": "difference",
      "option_d": "symmetricDifference",
      "correct_answer": "B",
      "explanation": "`intersection()` 메서드는 두 집합의 교집합을 반환합니다. 교집합은 두 집합 모두에 공통으로 포함된 요소들만을 포함합니다:\n\n1) students1: `['Alice', 'Bob', 'Charlie']`\n2) students2: `['Bob', 'Charlie', 'David']`\n3) 교집합: `['Bob', 'Charlie']`\n\n문제에서 \"두 반 모두에 속한 학생들\"을 찾는 것이므로 `intersection()` 메서드가 적합합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T05:55:09.000Z"
    },
    {
      "id": 665,
      "subject_id": 1,
      "question": "JavaScript에서 Map 객체를 생성하는 올바른 방법은?\n\n```javascript\nconst fruits = ______([\n  [\"apples\", 500],\n  [\"bananas\", 300],\n  [\"oranges\", 200]\n]);\n```",
      "option_a": "new Array",
      "option_b": "new Map",
      "option_c": "new Object",
      "option_d": "new Set",
      "correct_answer": "B",
      "explanation": "JavaScript Map 객체는 `new Map()` 생성자를 사용하여 생성합니다. 생성자에 2차원 배열을 전달하면 각 내부 배열의 첫 번째 요소는 키(key), 두 번째 요소는 값(value)으로 설정됩니다. Map은 키-값 쌍을 저장하는 컬렉션으로, 일반 객체와 달리 어떤 타입의 값도 키로 사용할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T05:58:58.000Z"
    },
    {
      "id": 666,
      "subject_id": 1,
      "question": "다음 코드에서 `fruits` Map에 저장된 요소의 개수를 확인하는 올바른 방법은?\n\n```javascript\nconst fruits = new Map([\n  [\"apples\", 500],\n  [\"bananas\", 300],\n  [\"oranges\", 200]\n]);\n```",
      "option_a": "fruits.length",
      "option_b": "fruits.count()",
      "option_c": "fruits.size",
      "option_d": "fruits.getSize()",
      "correct_answer": "C",
      "explanation": "Map 객체에서 저장된 요소의 개수를 확인할 때는 `size` 속성을 사용합니다. 배열의 `length` 속성과 달리, Map은 `size` 속성을 제공합니다. 이 예제에서 `fruits.size`는 3을 반환하게 됩니다. `size`는 속성이므로 괄호()를 붙이지 않는다는 점도 주의해야 합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T06:00:14.000Z"
    },
    {
      "id": 667,
      "subject_id": 1,
      "question": "빈칸에 들어갈 메서드와 출력 결과로 올바른 것은?\n\n```javascript\nconst fruits = new Map();\nfruits.set(\"apples\", 500);\nfruits.set(\"bananas\", 300);\nfruits.______(\"apples\");\nconsole.log(fruits.has(\"apples\"));\n```",
      "option_a": "`get` → `true`",
      "option_b": "`delete` → `false`",
      "option_c": "`clear` → `true`",
      "option_d": "`remove` → `undefined`",
      "correct_answer": "B",
      "explanation": "`delete()` 메서드는 Map에서 지정된 키의 요소를 제거합니다. \"apples\" 키를 삭제한 후 `has(\"apples\")`를 호출하면, 해당 키가 더 이상 존재하지 않으므로 `false`를 반환합니다. `has()` 메서드는 Map에 특정 키가 존재하는지 확인하여 존재하면 `true`, 존재하지 않으면 `false`를 반환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T06:02:21.000Z"
    },
    {
      "id": 668,
      "subject_id": 1,
      "question": "다음 코드에서 Map의 모든 값들의 합을 구하는 올바른 코드는?\n\n```javascript\nconst fruits = new Map([\n  [\"apples\", 500],\n  [\"bananas\", 300],\n  [\"oranges\", 200]\n]);\n\nlet total = 0;\nfor (const x of fruits.______()) {\n  total += x;\n}\n```",
      "option_a": "keys",
      "option_b": "entries",
      "option_c": "values",
      "option_d": "forEach",
      "correct_answer": "C",
      "explanation": "`values()` 메서드는 Map의 모든 값들에 대한 이터레이터를 반환합니다. for...of 루프와 함께 사용하면 각 값을 순회할 수 있습니다. 이 코드에서는 500, 300, 200을 차례로 더하여 총합 1000을 구하게 됩니다. `keys()`는 키만, `entries()`는 [키, 값] 배열을 반환하므로 값만 필요한 이 상황에는 적합하지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T06:03:25.000Z"
    },
    {
      "id": 669,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst apples = {name: 'Apples'};\nconst bananas = {name: 'Bananas'};\n\nconst fruits = new Map();\nfruits.set(apples, 500);\nfruits.set(bananas, 300);\n\nconsole.log(fruits.get(\"apples\"));\nconsole.log(fruits.get(apples));\n```",
      "option_a": "`500`, `500`",
      "option_b": "`undefined`, `500`",
      "option_c": "`500`, `undefined`",
      "option_d": "`undefined`, `undefined`",
      "correct_answer": "B",
      "explanation": "이 문제는 Map에서 객체를 키로 사용할 때의 중요한 개념을 다룹니다. Map에서는 객체 자체가 키가 되며, 문자열과는 완전히 다른 키로 취급됩니다.\n\n1) `fruits.get(\"apples\")`는 `undefined`를 반환합니다. 왜냐하면 키로 저장된 것은 문자열 \"apples\"가 아니라 `apples` 객체이기 때문입니다.\n2) `fruits.get(apples)`는 `500`을 반환합니다. 실제로 키로 사용된 `apples` 객체 참조를 사용했기 때문입니다.\n\nMap의 키 비교는 SameValueZero 알고리즘을 사용하므로, 객체 키의 경우 동일한 참조여야만 같은 키로 인식됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T06:05:11.000Z"
    },
    {
      "id": 670,
      "subject_id": 1,
      "question": "JavaScript에서 가장 권장되는 표준 날짜 형식은 무엇인가요?\n\n```javascript\nconst d = new Date(\"______\");\n```",
      "option_a": "`\"03/25/2015\"` (Short Date)",
      "option_b": "`\"2015-03-25\"` (ISO Date)",
      "option_c": "`\"Mar 25 2015\"` (Long Date)",
      "option_d": "`\"25-03-2015\"` (European Date)",
      "correct_answer": "B",
      "explanation": "ISO 8601 형식(`YYYY-MM-DD`)은 JavaScript에서 가장 권장되는 국제 표준 날짜 형식입니다. 이 형식은 브라우저 간 호환성이 가장 좋고, 엄격한 표준을 따르므로 예측 가능한 결과를 보장합니다. 다른 형식들은 브라우저에 따라 다르게 해석될 수 있거나 오류를 발생시킬 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T06:07:36.000Z"
    },
    {
      "id": 671,
      "subject_id": 1,
      "question": "다음 코드에서 ISO 날짜 형식에 시간을 추가할 때 사용하는 구분자는?\n\n```javascript\nconst d = new Date(\"2015-03-25______12:00:00Z\");\n```",
      "option_a": "T",
      "option_b": ":",
      "option_c": "`  `(공백)",
      "option_d": "-",
      "correct_answer": "A",
      "explanation": "ISO 8601 표준에서는 날짜와 시간을 구분할 때 대문자 `T`를 사용합니다. 예를 들어 `\"2015-03-25T12:00:00Z\"`와 같이 작성합니다. 여기서 `T`는 시간(Time)을 의미하며, 마지막의 `Z`는 UTC 시간임을 나타냅니다. 이 형식을 정확히 따르지 않으면 브라우저마다 다른 결과를 얻을 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T06:08:50.000Z"
    },
    {
      "id": 672,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 가장 적절한 것은?\n\n```javascript\nconst d1 = new Date(\"2015-03\");\nconst d2 = new Date(\"2015\");\nconsole.log(d1); // 결과 1\nconsole.log(d2); // 결과 2\n```",
      "option_a": "결과 1: 2015년 3월 1일, 결과 2: 2015년 1월 1일",
      "option_b": "결과 1: 2015년 2월 28일, 결과 2: 2014년 12월 31일",
      "option_c": "결과 1: 오류 발생, 결과 2: 오류 발생",
      "option_d": "시간대에 따라 결과가 달라질 수 있음",
      "correct_answer": "D",
      "explanation": "ISO 날짜에서 일부 정보가 생략되면 시간대에 따라 결과가 달라질 수 있습니다.\n\n1) `\"2015-03\"`은 2015년 3월을 의미하지만, 시간대에 따라 2월 28일 또는 3월 1일로 표시될 수 있습니다.\n2) `\"2015\"`는 2015년을 의미하지만, 시간대에 따라 2014년 12월 31일 또는 2015년 1월 1일로 표시될 수 있습니다.\n\n이는 JavaScript가 누락된 정보를 UTC 시간 기준으로 해석한 후, 사용자의 브라우저 시간대로 변환하기 때문입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T06:10:24.000Z"
    },
    {
      "id": 673,
      "subject_id": 1,
      "question": "다음 코드에서 문자열을 밀리초로 변환하는 메서드는?\n\n```javascript\nlet msec = Date.______(\"March 21, 2012\");\nconst d = new Date(msec);\n```",
      "option_a": "convert",
      "option_b": "parse",
      "option_c": "toMilliseconds",
      "option_d": "valueOf",
      "correct_answer": "B",
      "explanation": "`Date.parse()` 메서드는 유효한 날짜 문자열을 1970년 1월 1일 00:00:00 UTC부터의 밀리초 수로 변환합니다. 이 메서드는 정적 메서드로, Date 생성자 없이 `Date.parse()`로 직접 호출할 수 있습니다. 반환된 밀리초 값은 `new Date()`의 인수로 사용하여 다시 Date 객체로 변환할 수 있습니다. 이는 날짜 문자열을 숫자로 저장하거나 계산할 때 유용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T06:11:19.000Z"
    },
    {
      "id": 674,
      "subject_id": 1,
      "question": "다음 코드들의 실행 결과에 대한 설명으로 올바른 것은?\n\n```javascript\n// 코드 A\nconst dateA = new Date(\"2015-03-25T12:00:00Z\");\n\n// 코드 B  \nconst dateB = new Date(\"2015-03-25T12:00:00-06:00\");\n\n// 코드 C\nconst dateC = new Date(\"03/25/2015\");\n\n// 코드 D\nconst dateD = new Date(\"2015/03/25\");\n```",
      "option_a": "A, B, C, D 모두 같은 날짜와 시간을 표시한다",
      "option_b": "A와 B는 시간대 정보가 있어 정확하지만, C는 브라우저 시간대를 사용하고, D는 오류가 발생할 수 있다",
      "option_c": "A만 UTC 시간이고 나머지는 모두 로컬 시간이다",
      "option_d": "C와 D는 같은 결과를 보여준다",
      "correct_answer": "B",
      "explanation": "이 문제는 JavaScript Date의 복잡한 동작을 다룹니다:\n\n1) 코드 A: `Z`는 UTC 시간을 명시적으로 나타내므로 모든 브라우저에서 일관된 결과를 보입니다.\n2) 코드 B: `-06:00`은 UTC보다 6시간 빠른 시간대를 의미하므로, 명확한 시간대 정보가 있어 정확합니다.\n3) 코드 C: `MM/DD/YYYY` 형식은 유효하지만, 시간대 정보가 없어 브라우저의 로컬 시간대를 사용합니다.\n4) 코드 D: `YYYY/MM/DD` 형식은 표준이 아니므로 브라우저에 따라 해석이 다르거나 `NaN`을 반환할 수 있습니다.\n\n시간대 정보가 포함된 ISO 형식을 사용하는 것이 가장 안전하고 예측 가능한 방법입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T06:12:58.000Z"
    },
    {
      "id": 675,
      "subject_id": 1,
      "question": "JavaScript에서 현재 날짜와 시간을 가진 Date 객체를 생성하는 올바른 방법은?\n\n```javascript\nconst currentDate = ______;\n```",
      "option_a": "new Date.now()",
      "option_b": "new Date()",
      "option_c": "Date.current()",
      "option_d": "new CurrentDate()",
      "correct_answer": "B",
      "explanation": "JavaScript에서 현재 날짜와 시간을 포함한 Date 객체를 생성할 때는 `new Date()`를 사용합니다. 매개변수 없이 호출하면 자동으로 현재 날짜와 시간이 설정됩니다. `Date.now()`는 밀리초 값만 반환하며 Date 객체가 아닙니다. Date 객체가 생성되면 그 시점의 시간이 고정되며, 시계처럼 계속 변하지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T06:16:07.000Z"
    },
    {
      "id": 676,
      "subject_id": 1,
      "question": "다음 코드에서 월(month) 정보를 가져오는 올바른 메서드는?\n\n```javascript\nconst d = new Date(\"2021-03-25\");\nconst month = d.______();\n```\n위 코드가 실행될 때 반환되는 값은?",
      "option_a": "`getMonth()` → 3",
      "option_b": "`getMonth()` → 2",
      "option_c": "`getMonthName()` → \"March\"",
      "option_d": "`getMonthNumber()` → 3",
      "correct_answer": "B",
      "explanation": "`getMonth()` 메서드는 월을 숫자로 반환하는데, 0부터 시작합니다. 즉, 1월은 0, 2월은 1, 3월은 2, ..., 12월은 11로 반환됩니다. 따라서 2021년 3월 25일에서 `getMonth()`를 호출하면 2를 반환합니다. 이는 JavaScript Date의 중요한 특징 중 하나로, 실제 사용 시 주의해야 할 부분입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T06:17:22.000Z"
    },
    {
      "id": 677,
      "subject_id": 1,
      "question": "빈칸에 들어갈 메서드와 그 의미로 올바른 것은?\n\n```javascript\nconst d = new Date(\"2021-03-25\");\nconsole.log(d.______());  // 4\n```",
      "option_a": "`getDay()` → 목요일 (일요일이 0부터 시작)",
      "option_b": "`getDate()` → 25일",
      "option_c": "`getWeek()` → 4번째 주",
      "option_d": "`getDayNumber()` → 4번째 날",
      "correct_answer": "A",
      "explanation": "`getDay()` 메서드는 요일을 숫자로 반환합니다. 일요일이 0, 월요일이 1, 화요일이 2, 수요일이 3, 목요일이 4, 금요일이 5, 토요일이 6입니다. 2021년 3월 25일은 목요일이므로 4를 반환합니다. `getDate()`는 날짜(1-31)를 반환하므로 25를 반환할 것입니다. 이 메서드들을 혼동하지 않도록 주의해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T06:18:27.000Z"
    },
    {
      "id": 678,
      "subject_id": 1,
      "question": "다음 코드에서 1970년 1월 1일부터의 밀리초를 반환하는 메서드는?\n\n```javascript\nconst d = new Date(\"2021-03-25\");\nconst milliseconds = d.______();\n\n// 또는 현재 시간의 밀리초를 얻으려면\nconst now = Date.______();\n```",
      "option_a": "`getMilliseconds()`, `currentTime()`",
      "option_b": "`getTime()`, `now()`",
      "option_c": "`valueOf()`, `current()`",
      "option_d": "`toMilliseconds()`, `getTime()`",
      "correct_answer": "B",
      "explanation": "`getTime()` 메서드는 1970년 1월 1일 00:00:00 UTC부터 해당 날짜까지의 밀리초 수를 반환합니다. 이는 날짜 계산이나 비교에 매우 유용합니다. `Date.now()`는 정적 메서드로 현재 시간의 밀리초를 바로 반환합니다. 주의할 점은 `getMilliseconds()`는 현재 시간의 밀리초 부분(0-999)만 반환하는 다른 메서드라는 것입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T06:19:35.000Z"
    },
    {
      "id": 679,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과에 대한 설명으로 올바른 것은?\n\n```javascript\nconst d = new Date(\"2021-03-25T15:30:45\");\n\nconsole.log(d.getHours());     // 결과 A\nconsole.log(d.getUTCHours());  // 결과 B\nconsole.log(d.getTimezoneOffset()); // 결과 C\n\nconst months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \n                \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\nconsole.log(months[d.getMonth()]); // 결과 D\n```",
      "option_a": "A와 B는 항상 같은 값, C는 0, D는 \"March\"",
      "option_b": "A는 로컬 시간, B는 UTC 시간으로 다를 수 있고, C는 시간대 차이(분), D는 \"Mar\"",
      "option_c": "A는 15, B도 15, C는 시간대 정보 없음, D는 3",
      "option_d": "모든 get 메서드는 UTC 기준으로 동일한 값 반환",
      "correct_answer": "B",
      "explanation": "이 문제는 로컬 시간과 UTC 시간의 차이를 다룹니다:\n\n1) `getHours()`: 로컬 시간대의 시간을 반환 (한국은 UTC+9이므로 실제로는 24시간 또는 0시간이 될 수 있음)\n2) `getUTCHours()`: UTC 시간 기준의 시간을 반환 (15시간)\n3) `getTimezoneOffset()`: 로컬 시간과 UTC 시간의 차이를 분 단위로 반환 (한국의 경우 -540분, 즉 -9시간)\n4) 월 이름 배열 활용: `getMonth()`는 2를 반환하므로 배열의 인덱스 2인 \"Mar\"가 출력됩니다.\n\n시간대가 다른 환경에서는 로컬 시간 메서드와 UTC 시간 메서드의 결과가 다를 수 있다는 점이 핵심입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T06:21:25.000Z"
    },
    {
      "id": 680,
      "subject_id": 1,
      "question": "Date 객체의 월(month)을 설정하는 올바른 메서드는?\n\n```javascript\nconst d = new Date(\"January 01, 2025\");\nd.______(11);  // 12월로 설정\n```",
      "option_a": "setMonth()",
      "option_b": "changeMonth()",
      "option_c": "updateMonth()",
      "option_d": "modifyMonth()",
      "correct_answer": "A",
      "explanation": "`setMonth()` 메서드는 Date 객체의 월을 설정하는 데 사용됩니다. JavaScript에서 월은 0부터 시작하므로, 0은 1월, 1은 2월, ..., 11은 12월을 의미합니다. 따라서 `setMonth(11)`을 호출하면 12월로 설정됩니다. 이는 `getMonth()` 메서드와 마찬가지로 0 기반 인덱스를 사용한다는 점을 기억해야 합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T06:23:48.000Z"
    },
    {
      "id": 681,
      "subject_id": 1,
      "question": "다음 코드에서 날짜를 15일로 설정하는 올바른 메서드는?\n\n```javascript\nconst d = new Date(\"January 01, 2025\");\nd.______(15);\n```",
      "option_a": "setDay(15)",
      "option_b": "setDate(15)",
      "option_c": "setDayOfMonth(15)",
      "option_d": "setCalendarDate(15)",
      "correct_answer": "B",
      "explanation": "`setDate()` 메서드는 Date 객체의 날짜(일)를 설정합니다. 매개변수로 1부터 31까지의 값을 받으며, 해당 월의 몇 번째 날인지를 나타냅니다. `setDay()`는 존재하지 않는 메서드이고, 실제로는 `getDay()`가 요일(0-6)을 반환하는 메서드입니다. `setDate(15)`를 호출하면 해당 월의 15일로 설정됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T06:24:43.000Z"
    },
    {
      "id": 682,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst d = new Date(\"January 01, 2025\");\nd.setDate(d.getDate() + 50);\nconsole.log(d.getMonth()); // 출력값은?\n```",
      "option_a": "0 (1월)",
      "option_b": "1 (2월)",
      "option_c": "2 (3월)",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "`setDate()` 메서드는 단순히 날짜를 설정하는 것뿐만 아니라, 날짜를 더하거나 뺄 때도 사용할 수 있습니다. 1월 1일에 50일을 더하면 2월 20일이 됩니다. JavaScript Date 객체는 월이나 연도의 경계를 자동으로 처리합니다. 즉, 1월 31일을 넘어가는 날짜는 자동으로 다음 달로 넘어갑니다. 1월 1일 + 50일 = 2월 20일이므로, `getMonth()`는 1을 반환합니다(2월).",
      "difficulty": "medium",
      "created_at": "2025-08-08T06:25:34.000Z"
    },
    {
      "id": 683,
      "subject_id": 1,
      "question": "다음 코드에서 시간, 분, 초를 한 번에 설정하는 올바른 방법은?\n\n```javascript\nconst d = new Date(\"January 01, 2025\");\nd.______(22, 10, 20); // 22시 10분 20초로 설정\n```",
      "option_a": "setTime(22, 10, 20)",
      "option_b": "setHours(22, 10, 20)",
      "option_c": "setDateTime(22, 10, 20)",
      "option_d": "setHMS(22, 10, 20)",
      "correct_answer": "B",
      "explanation": "`setHours()` 메서드는 시간뿐만 아니라 분과 초도 선택적으로 설정할 수 있습니다. 메서드의 시그니처는 `setHours(hour, min, sec, ms)`입니다.\n\n1) 첫 번째 매개변수: 시간 (0-23)\n2) 두 번째 매개변수: 분 (0-59) - 선택적\n3) 세 번째 매개변수: 초 (0-59) - 선택적\n4) 네 번째 매개변수: 밀리초 (0-999) - 선택적\n\n따라서 `setHours(22, 10, 20)`은 22시 10분 20초로 설정합니다. 이렇게 한 번의 호출로 여러 시간 구성 요소를 설정할 수 있어 편리합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T06:26:47.000Z"
    },
    {
      "id": 684,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과에 대한 설명으로 올바른 것은?\n\n```javascript\nconst d = new Date(\"January 01, 2025\");\nd.setFullYear(2020, 11, 3);\n\nconst today = new Date();\nconst future = new Date();\nfuture.setFullYear(2100, 0, 14);\n\nif (future > today) {\n    console.log(\"미래 날짜입니다.\");\n} else {\n    console.log(\"과거 날짜입니다.\");\n}\n```",
      "option_a": "`d`는 2020년 11월 3일이 되고, 비교문은 항상 \"과거 날짜입니다.\" 출력",
      "option_b": "`d`는 2020년 12월 3일이 되고, 비교문은 \"미래 날짜입니다.\" 출력",
      "option_c": "`setFullYear()` 메서드는 월과 일을 동시에 설정할 수 없어 오류 발생",
      "option_d": "Date 객체끼리 직접 비교할 수 없어 오류 발생",
      "correct_answer": "B",
      "explanation": "이 문제는 여러 Date 메서드의 복합적 이해를 요구합니다:\n\n1. `setFullYear()` 메서드 분석:\n\n1) `setFullYear(2020, 11, 3)`는 연도, 월, 일을 한 번에 설정할 수 있습니다\n2) 월은 0부터 시작하므로 11은 12월을 의미합니다\n3) 따라서 `d`는 2020년 12월 3일이 됩니다\n\n2. Date 객체 비교:\n\n1) JavaScript에서 Date 객체는 직접 비교 연산자(`>`, `<`, `>=`, `<=`)를 사용할 수 있습니다\n2) 내부적으로 밀리초 값으로 변환되어 비교됩니다\n3) `future.setFullYear(2100, 0, 14)`는 2100년 1월 14일로 설정\n4) 현재 날짜(2025년)보다 미래이므로 \"미래 날짜입니다.\"가 출력됩니다\n\n이처럼 `setFullYear()` 메서드는 매우 유연하며, Date 객체의 비교는 자연스럽게 동작합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T06:29:10.000Z"
    },
    {
      "id": 685,
      "subject_id": 1,
      "question": "문자열에서 모든 패턴을 찾고자 할 때 사용하는 정규식 플래그는?\n\n```javascript\nlet text = \"Is this all there is?\";\nconst pattern = /is/____;\nlet result = text.match(pattern);\n// 결과: [\"is\", \"is\"] (모든 \"is\"를 찾음)\n```",
      "option_a": "/g",
      "option_b": "/i",
      "option_c": "/m",
      "option_d": "/s",
      "correct_answer": "A",
      "explanation": "`/g` 플래그는 \"global\"을 의미하며, 첫 번째 매치에서 멈추지 않고 문자열 전체에서 모든 패턴을 찾습니다. 플래그 없이 `/is/`만 사용하면 첫 번째 \"is\"만 찾지만, `/is/g`를 사용하면 문자열에 있는 모든 \"is\"를 찾아서 배열로 반환합니다. 이는 텍스트 처리에서 매우 자주 사용되는 중요한 플래그입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T06:56:09.000Z"
    },
    {
      "id": 686,
      "subject_id": 1,
      "question": "다음 코드에서 줄바꿈 문자(\\n)도 `.` 메타문자와 매치되도록 하는 플래그는?\n```javascript\nlet text = \"Line\\nLine.\";\nconst pattern = /Line./_____;\nlet result = text.match(pattern);\n// 결과: [\"Line\\n\", \"Line.\"] (줄바꿈 포함하여 매치)\n```",
      "option_a": "/g",
      "option_b": "/m",
      "option_c": "/gs",
      "option_d": "/y",
      "correct_answer": "C",
      "explanation": "`/s` 플래그는 \"single line\" 또는 \"dotAll\" 플래그라고 불리며, `.` 메타문자가 줄바꿈 문자(\\n)까지 매치하도록 합니다. 기본적으로 `.`는 줄바꿈 문자를 제외한 모든 문자와 매치되지만, `/s` 플래그를 사용하면 줄바꿈 문자도 포함됩니다. 이 예제에서는 `/g` 플래그와 함께 사용하여 `/gs`로 표기했으며, 이는 전역 검색과 dotAll 기능을 모두 활성화합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T06:58:35.000Z"
    },
    {
      "id": 687,
      "subject_id": 1,
      "question": "특정 위치에서부터 \"sticky\" 검색을 수행하는 플래그와 속성의 올바른 조합은?\n\n```javascript\nlet text = \"abc def ghi\";\nconst pattern = /\\w+/____;\npattern.lastIndex = 4;\nlet result = text.match(pattern);\n// 결과: [\"def\"] (4번째 위치부터 검색)\n```",
      "option_a": "`/y` 플래그, `sticky` 속성",
      "option_b": "`/s` 플래그, `dotAll` 속성",
      "option_c": "`/g` 플래그, `global` 속성",
      "option_d": "`/m` 플래그, `multiline` 속성",
      "correct_answer": "A",
      "explanation": "`/y` 플래그는 \"sticky\" 검색을 수행합니다. 이 플래그를 사용하면 `lastIndex` 속성에 지정된 정확한 위치에서부터 매치를 시도합니다. 일반적인 검색과 달리, sticky 검색은 지정된 위치에서 정확히 시작해야 매치가 성공합니다. 이 예제에서 `lastIndex = 4`로 설정하면 4번째 위치(공백 다음)에서 시작하는 \"def\"를 찾습니다. 정규식 객체의 `sticky` 속성으로 `/y` 플래그 설정 여부를 확인할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T07:00:27.000Z"
    },
    {
      "id": 688,
      "subject_id": 1,
      "question": "반복 가능한 객체(iterable object)로부터 새로운 Typed Array를 생성하는 메서드는?\n\n```javascript\nconst myArr = Int16Array.______(\"1234567890\");\n// 결과: [1,2,3,4,5,6,7,8,9,0]\n```",
      "option_a": "create()",
      "option_b": "from()",
      "option_c": "new()",
      "option_d": "generate()",
      "correct_answer": "B",
      "explanation": "`from()` 메서드는 문자열, 배열, 또는 다른 반복 가능한 객체로부터 새로운 Typed Array를 생성합니다. 이 예제에서 `Int16Array.from(\"1234567890\")`은 문자열의 각 문자를 숫자로 변환하여 16비트 정수 배열을 만듭니다. 이 메서드는 기존 데이터를 Typed Array로 변환할 때 가장 자주 사용되는 방법입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T07:02:57.000Z"
    },
    {
      "id": 689,
      "subject_id": 1,
      "question": "다음 코드에서 각 배열 요소가 차지하는 바이트 수를 반환하는 속성은?\n\n```javascript\nconst myArr = new Int32Array(10);\nconsole.log(myArr.______); // 출력: 4\n```",
      "option_a": "ELEMENT_SIZE",
      "option_b": "BYTES_PER_ELEMENT",
      "option_c": "BYTE_LENGTH",
      "option_d": "SIZE_OF_ELEMENT",
      "correct_answer": "B",
      "explanation": "`BYTES_PER_ELEMENT` 속성은 해당 Typed Array 타입에서 각 요소가 차지하는 바이트 수를 반환합니다. `Int32Array`는 32비트(4바이트) 정수를 저장하므로 4를 반환합니다. 이 속성은 메모리 사용량을 계산하거나 배열의 전체 바이트 크기를 알아야 할 때 유용합니다. 예를 들어, `Int16Array`는 2바이트, `Int8Array`는 1바이트를 반환합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T07:03:57.000Z"
    },
    {
      "id": 690,
      "subject_id": 1,
      "question": "다음 코드에서 Typed Array의 모든 요소를 특정 값으로 채우는 메서드로 빈칸에 들어갈 것은?\n```javascript\nconst myArr = new Int16Array(10);\nmyArr.______(200, 0, 3); // 인덱스 0부터 2까지만 200으로 채움\n```",
      "option_a": "fill",
      "option_b": "set",
      "option_c": "assign",
      "option_d": "populate",
      "correct_answer": "A",
      "explanation": "`fill()` 메서드는 Typed Array의 모든 요소 또는 지정된 범위의 요소를 특정 값으로 채웁니다. 매개변수는 다음과 같습니다:\n\n1) 첫 번째: 채울 값 (200)\n2) 두 번째: 시작 인덱스 (0) - 포함\n3) 세 번째: 끝 인덱스 (3) - 제외\n\n따라서 `fill(200, 0, 3)`은 인덱스 0, 1, 2의 요소만 200으로 채웁니다. 두 번째, 세 번째 매개변수를 생략하면 전체 배열을 채웁니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T07:05:23.000Z"
    },
    {
      "id": 691,
      "subject_id": 1,
      "question": "다음 코드에서 조건을 만족하는 첫 번째 요소를 찾는 메서드로 빈칸에 들어갈 것과 반환값으로 올바른 것은?\n\n```javascript\nconst myArr = Int16Array.from([10, 15, 20, 25, 30]);\nconst result = myArr.______(x => x > 18);\nconsole.log(result); // 출력값은?\n```",
      "option_a": "`find` → `20`",
      "option_b": "`some` → `true`",
      "option_c": "`filter` → `[20, 25, 30]`",
      "option_d": "`indexOf` → `2`",
      "correct_answer": "A",
      "explanation": "`find()` 메서드는 제공된 테스트 함수를 만족하는 첫 번째 요소의 값을 반환합니다. 이 예제에서 `x > 18` 조건을 만족하는 첫 번째 요소는 20입니다.\n\n다른 메서드들과의 차이점:\n\n1) `some()`: 조건을 만족하는 요소가 있는지 불린값 반환\n2) `filter()`: 조건을 만족하는 모든 요소들의 새 배열 반환\n3) `indexOf()`: 특정 값의 인덱스 반환 (조건 함수 사용 불가)\n\n`find()`는 조건을 만족하는 요소가 없으면 `undefined`를 반환합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T07:08:34.000Z"
    },
    {
      "id": 692,
      "subject_id": 1,
      "question": "다음 중 Typed Array에서 사용할 수 없는 메서드들과 그 이유로 올바른 것은?\n\n```javascript\nconst myArr = new Int32Array(5);\n\n// 다음 중 어떤 메서드들이 사용 불가능한가?\n// A: myArr.push(10);\n// B: myArr.fill(100);\n// C: myArr.splice(1, 2);\n// D: myArr.find(x => x > 50);\n```",
      "option_a": "A, C만 불가능 - 고정 길이 특성 때문",
      "option_b": "A, B, C 모두 불가능 - Typed Array 전용 메서드만 사용 가능",
      "option_c": "A, C, D 불가능 - 숫자 타입만 지원하기 때문",
      "option_d": "모두 사용 가능 - 표준 배열과 동일한 메서드 지원",
      "correct_answer": "A",
      "explanation": "Typed Array는 고정 길이(fixed-length) 특성을 가지므로, 배열의 크기를 변경하는 메서드들은 사용할 수 없습니다:\n\n1. 사용 불가능한 메서드들:\n\n1) `push()`, `pop()`: 배열 끝에 요소 추가/제거\n2) `shift()`, `unshift()`: 배열 앞에 요소 추가/제거\n3) `splice()`: 요소 삭제/삽입으로 배열 크기 변경\n4) `concat()`: 새로운 배열 생성 (크기 변경)\n\n2. 사용 가능한 메서드들:\n\n1) `fill()`: 기존 요소 값만 변경\n2) `find()`, `some()`, `filter()`: 검색/필터링 (크기 변경 없음)\n3) `forEach()`, `map()`: 순회/변환\n4) `slice()`: 새 배열 생성하지만 원본 크기 유지\n\n이는 Typed Array가 메모리 효율성과 성능을 위해 고정된 메모리 구조를 사용하기 때문입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T07:11:01.000Z"
    },
    {
      "id": 693,
      "subject_id": 1,
      "question": "JavaScript에서 함수가 실행되는 순서에 대한 설명으로 올바른 것은?\n\n```javascript\nfunction myFirst() {\n    console.log(\"Hello\");\n}\nfunction mySecond() {\n    console.log(\"Goodbye\");\n}\nmyFirst();\nmySecond();\n```",
      "option_a": "함수가 정의된 순서대로 실행된다",
      "option_b": "함수가 호출된 순서대로 실행된다",
      "option_c": "알파벳 순서대로 실행된다",
      "option_d": "임의의 순서로 실행된다",
      "correct_answer": "B",
      "explanation": "JavaScript 함수는 정의된 순서가 아니라 호출된 순서대로 실행됩니다. 위 코드에서는 `myFirst()`가 먼저 호출되어 \"Hello\"가 출력되고, 그 다음 `mySecond()`가 호출되어 \"Goodbye\"가 출력됩니다. 함수 정의 순서는 실행 순서와 무관합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T07:14:38.000Z"
    },
    {
      "id": 694,
      "subject_id": 1,
      "question": "콜백(Callback) 함수에 대한 설명으로 올바른 것은?",
      "option_a": "함수 내부에서 자동으로 생성되는 함수",
      "option_b": "다른 함수의 인자(argument)로 전달되는 함수",
      "option_c": "반복문에서만 사용할 수 있는 함수",
      "option_d": "먼저 정의된 함수를 나중에 호출하는 기법",
      "correct_answer": "B",
      "explanation": "콜백 함수는 다른 함수의 인자로 전달되는 함수입니다. 이 기법을 통해 한 함수가 다른 함수를 호출할 수 있게 되어, 더 유연하고 재사용 가능한 코드를 작성할 수 있습니다. \"콜백(callback)\"이라는 이름도 \"다시 호출한다\"는 의미에서 나왔습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T07:15:14.000Z"
    },
    {
      "id": 695,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 코드는?\n\n```javascript\nfunction myDisplayer(result) {\n    console.log(\"결과: \" + result);\n}\n\nfunction myCalculator(num1, num2, ________) {\n    let sum = num1 + num2;\n    ________(sum);\n}\n\nmyCalculator(5, 5, myDisplayer);\n```",
      "option_a": "`callback`, `callback`",
      "option_b": "`myCallback`, `myCallback`",
      "option_c": "`func`, `func`",
      "option_d": "`display`, `display`",
      "correct_answer": "A",
      "explanation": "콜백 함수를 매개변수로 받을 때는 일반적으로 `callback`이라는 이름을 사용합니다. 첫 번째 빈칸은 매개변수 이름이고, 두 번째 빈칸은 그 매개변수를 호출하는 부분입니다. `myCalculator(5, 5, myDisplayer)`에서 `myDisplayer` 함수가 `callback` 매개변수로 전달되어, 계산 결과인 `sum`을 인자로 받아 실행됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T07:18:26.000Z"
    },
    {
      "id": 696,
      "subject_id": 1,
      "question": "다음 코드에서 함수를 콜백으로 전달할 때 잘못된 방법은?\n\n```javascript\nfunction myDisplayer(some) {\n    document.getElementById(\"demo\").innerHTML = some;\n}\n\nfunction myCalculator(num1, num2, myCallback) {\n    let sum = num1 + num2;\n    myCallback(sum);\n}\n```",
      "option_a": "myCalculator(5, 5, myDisplayer);",
      "option_b": "myCalculator(5, 5, myDisplayer());",
      "option_c": "myCalculator(5, 5, function(x) { console.log(x); });",
      "option_d": "myCalculator(5, 5, (x) => console.log(x));",
      "correct_answer": "B",
      "explanation": "함수를 콜백으로 전달할 때는 함수 이름만 써야 하고, 괄호를 붙이면 안 됩니다. `myDisplayer()`는 함수를 즉시 실행하여 그 결과값을 전달하는 것이고, `myDisplayer`는 함수 자체를 전달하는 것입니다. 콜백으로는 함수 자체를 전달해야 나중에 적절한 시점에 호출할 수 있습니다. 3번과 4번은 익명함수와 화살표 함수를 사용한 올바른 방법들입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T07:19:41.000Z"
    },
    {
      "id": 697,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst myNumbers = [4, 1, -20, -7, 5, 9, -6];\n\nfunction removeNeg(numbers, callback) {\n    const myArray = [];\n    for (const x of numbers) {\n        if (callback(x)) {\n            myArray.push(x);\n        }\n    }\n    return myArray;\n}\n\nconst result = removeNeg(myNumbers, (x) => x >= 0);\nconsole.log(result);\n```",
      "option_a": "[4, 1, 5, 9]",
      "option_b": "[-20, -7, -6]",
      "option_c": "[4, 1, -20, -7, 5, 9, -6]",
      "option_d": "[]",
      "correct_answer": "A",
      "explanation": "이 코드는 배열에서 조건에 맞는 요소만 필터링하는 함수입니다.\n\n1) `removeNeg` 함수는 배열과 콜백 함수를 받습니다\n2) 콜백 함수 `(x) => x >= 0`는 각 요소가 0보다 크거나 같은지 검사합니다\n3) `for` 루프에서 각 요소를 콜백 함수에 전달하여 `true`가 반환되면 `myArray`에 추가합니다\n4) 원본 배열 `[4, 1, -20, -7, 5, 9, -6]`에서 0 이상인 요소는 `4, 1, 5, 9`입니다\n\n이런 패턴은 JavaScript의 `Array.filter()` 메서드와 같은 원리로 동작하며, 콜백 함수를 활용한 함수형 프로그래밍의 좋은 예시입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T07:21:23.000Z"
    },
    {
      "id": 698,
      "subject_id": 1,
      "question": "비동기(Asynchronous) 함수에 대한 설명으로 올바른 것은?",
      "option_a": "다른 함수와 순차적으로 실행되는 함수",
      "option_b": "다른 함수와 병렬로 실행되는 함수",
      "option_c": "한 번만 실행할 수 있는 함수",
      "option_d": "반환값이 없는 함수",
      "correct_answer": "B",
      "explanation": "비동기 함수는 다른 함수와 병렬(parallel)로 실행되는 함수입니다. 일반적인 함수는 순차적으로 실행되지만, 비동기 함수는 다른 작업이 진행되는 동안 백그라운드에서 실행되어 전체 프로그램의 흐름을 막지 않습니다. JavaScript의 `setTimeout()`이 대표적인 비동기 함수의 예입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T07:23:18.000Z"
    },
    {
      "id": 699,
      "subject_id": 1,
      "question": "다음 코드가 3초 후에 실행되기 위해 빈칸에 들어갈 올바른 값은?\n\n```javascript\nsetTimeout(myFunction, ______);\n\nfunction myFunction() {\n    document.getElementById(\"demo\").innerHTML = \"I love You !!\";\n}\n```",
      "option_a": "3",
      "option_b": "30",
      "option_c": "300",
      "option_d": "3000",
      "correct_answer": "D",
      "explanation": "`setTimeout()` 함수의 두 번째 매개변수는 밀리초(milliseconds) 단위입니다. 1초는 1000밀리초이므로, 3초는 3000밀리초입니다. 따라서 3초 후에 함수를 실행하려면 `3000`을 입력해야 합니다. 이는 JavaScript에서 시간을 다룰 때 항상 밀리초 단위를 사용하는 중요한 규칙입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T07:24:32.000Z"
    },
    {
      "id": 700,
      "subject_id": 1,
      "question": "다음 코드에서 `setTimeout` 함수에 콜백을 전달하는 잘못된 방법은?\n\n```javascript\nfunction myFunction() {\n    console.log(\"Hello World!\");\n}\n```",
      "option_a": "setTimeout(myFunction, 2000);",
      "option_b": "setTimeout(myFunction(), 2000);",
      "option_c": "setTimeout(function() { myFunction(); }, 2000);",
      "option_d": "setTimeout(() => myFunction(), 2000);",
      "correct_answer": "B",
      "explanation": "`setTimeout(myFunction(), 2000)`은 잘못된 방법입니다. `myFunction()`처럼 괄호를 붙이면 함수를 즉시 실행하여 그 결과값을 `setTimeout`에 전달하게 됩니다. 올바른 방법은 `myFunction`처럼 함수 이름만 전달하거나, 익명함수나 화살표 함수로 감싸서 전달하는 것입니다. 콜백으로는 함수 자체를 전달해야 나중에 적절한 시점에 호출할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T07:25:43.000Z"
    },
    {
      "id": 701,
      "subject_id": 1,
      "question": "1초마다 반복해서 현재 시간을 표시하기 위해 빈칸에 들어갈 올바른 함수는?\n\n```javascript\n________(myFunction, 1000);\n\nfunction myFunction() {\n    let d = new Date();\n    document.getElementById(\"demo\").innerHTML = \n        d.getHours() + \":\" + d.getMinutes() + \":\" + d.getSeconds();\n}\n```",
      "option_a": "setTimeout",
      "option_b": "setInterval",
      "option_c": "setRepeat",
      "option_d": "setLoop",
      "correct_answer": "B",
      "explanation": "`setInterval` 함수는 지정된 시간 간격마다 반복해서 함수를 실행합니다. `setTimeout`은 한 번만 실행되지만, `setInterval`은 중단될 때까지 계속 반복 실행됩니다. 위 코드는 매초마다 현재 시간을 업데이트하는 실시간 시계를 만드는 전형적인 `setInterval` 사용 예제입니다. 1000밀리초(1초)마다 `myFunction`이 호출되어 시간이 갱신됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T07:27:10.000Z"
    },
    {
      "id": 702,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 올바른 것은?\n\n```javascript\nconsole.log(\"시작\");\n\nsetTimeout(function() {\n    console.log(\"3초 후 실행\");\n}, 3000);\n\nsetTimeout(function() {\n    console.log(\"1초 후 실행\");\n}, 1000);\n\nconsole.log(\"끝\");\n```",
      "option_a": "시작 → 3초 후 실행 → 1초 후 실행 → 끝",
      "option_b": "시작 → 끝 → 3초 후 실행 → 1초 후 실행",
      "option_c": "시작 → 끝 → 1초 후 실행 → 3초 후 실행",
      "option_d": "시작 → 1초 후 실행 → 3초 후 실행 → 끝",
      "correct_answer": "C",
      "explanation": "이 코드는 JavaScript의 비동기 실행 순서를 보여주는 중요한 예제입니다.\n\n실행 순서:\n\n1) \"시작\" - 즉시 실행\n2) 첫 번째 `setTimeout` - 3초 후 실행되도록 예약 (즉시 반환)\n3) 두 번째 `setTimeout` - 1초 후 실행되도록 예약 (즉시 반환)\n4) \"끝\" - 즉시 실행\n5) 1초 후: \"1초 후 실행\"\n6) 3초 후: \"3초 후 실행\"\n\n`setTimeout`은 비동기 함수이므로 코드의 실행을 멈추지 않고, 백그라운드에서 타이머를 설정한 후 즉시 다음 코드로 넘어갑니다. 따라서 동기 코드(\"시작\", \"끝\")가 먼저 모두 실행되고, 그 후에 설정된 시간에 따라 비동기 콜백들이 실행됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T07:28:32.000Z"
    },
    {
      "id": 703,
      "subject_id": 1,
      "question": "Promise에 대한 설명으로 올바른 것은?",
      "option_a": "함수를 즉시 실행하는 객체",
      "option_b": "생산 코드(Producing code)와 소비 코드(Consuming code)를 연결하는 객체",
      "option_c": "배열의 요소를 순회하는 객체",
      "option_d": "오류를 처리하는 전용 객체",
      "correct_answer": "B",
      "explanation": "Promise는 생산 코드(Producing code)와 소비 코드(Consuming code)를 연결하는 객체입니다. 생산 코드는 시간이 걸릴 수 있는 작업(파일 로딩, 네트워크 요청 등)을 수행하고, 소비 코드는 그 결과를 기다려서 처리합니다. Promise는 이 둘 사이의 다리 역할을 하여 비동기 프로그래밍을 더 깔끔하게 만들어줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T07:35:30.000Z"
    },
    {
      "id": 704,
      "subject_id": 1,
      "question": "Promise 객체가 가질 수 있는 3가지 상태가 아닌 것은?",
      "option_a": "Pending (대기)",
      "option_b": "Fulfilled (이행됨)",
      "option_c": "Rejected (거부됨)",
      "option_d": "Completed (완료됨)",
      "correct_answer": "D",
      "explanation": "Promise 객체는 3가지 상태를 가집니다:\n\n1) Pending (대기): 초기 상태, 아직 완료되지 않음\n2) Fulfilled (이행됨): 작업이 성공적으로 완료됨\n3) Rejected (거부됨): 작업이 실패함\n\n\"Completed\"는 Promise의 공식 상태가 아닙니다. Promise가 Pending 상태에서 시작하여 성공하면 Fulfilled, 실패하면 Rejected 상태로 변경됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T07:36:27.000Z"
    },
    {
      "id": 705,
      "subject_id": 1,
      "question": "다음 Promise 생성 코드에서 빈칸에 들어갈 올바른 매개변수는?\n\n```javascript\nlet myPromise = new Promise(function(______, ______) {\n    let x = 0;\n    if (x == 0) {\n        ______(\"OK\");\n    } else {\n        ______(\"Error\");\n    }\n});\n```",
      "option_a": "`resolve`, `reject`, `resolve`, `reject`",
      "option_b": "`myResolve`, `myReject`, `myResolve`, `myReject`",
      "option_c": "`success`, `failure`, `success`, `failure`",
      "option_d": "`then`, `catch`, `then`, `catch`",
      "correct_answer": "B",
      "explanation": "Promise 생성자 함수는 두 개의 매개변수를 받습니다. 이 매개변수들의 이름은 개발자가 정할 수 있지만, 일반적으로 `myResolve`와 `myReject`라고 명명합니다:\n\n1) `myResolve`: 작업이 성공했을 때 호출하는 함수\n2) `myReject`: 작업이 실패했을 때 호출하는 함수\n\n코드에서 `x == 0`이므로 성공 조건이 만족되어 `myResolve(\"OK\")`가 호출됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T07:48:01.000Z"
    },
    {
      "id": 706,
      "subject_id": 1,
      "question": "다음 Promise 사용 코드에서 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\nmyPromise.______(\n    function(value) { console.log(\"성공: \" + value); },\n    function(error) { console.log(\"실패: \" + error); }\n);\n```",
      "option_a": "done",
      "option_b": "then",
      "option_c": "catch",
      "option_d": "finally",
      "correct_answer": "B",
      "explanation": "`then()` 메서드는 Promise의 결과를 처리하는 핵심 메서드입니다. `then()` 메서드는 두 개의 콜백 함수를 인자로 받습니다:\n\n1) 첫 번째 콜백: Promise가 성공(fulfilled)했을 때 실행\n2) 두 번째 콜백: Promise가 실패(rejected)했을 때 실행\n\n두 번째 콜백은 선택사항이므로 성공 처리만 하고 싶다면 첫 번째 콜백만 전달할 수도 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T07:49:01.000Z"
    },
    {
      "id": 707,
      "subject_id": 1,
      "question": "다음 두 코드의 실행 결과가 동일한지 판단하세요.\n\n코드 A (Callback 방식):\n```javascript\nsetTimeout(function() { \n    document.getElementById(\"demo\").innerHTML = \"I love You !!!\"; \n}, 3000);\n```\n\n코드 B (Promise 방식):\n```javascript\nlet myPromise = new Promise(function(myResolve, myReject) {\n    setTimeout(function() { myResolve(\"I love You !!!\"); }, 3000);\n});\nmyPromise.then(function(value) {\n    document.getElementById(\"demo\").innerHTML = value;\n});\n```",
      "option_a": "동일하다 - 둘 다 3초 후에 같은 텍스트를 화면에 표시한다",
      "option_b": "다르다 - 코드 A가 더 빠르게 실행된다",
      "option_c": "다르다 - 코드 B가 더 빠르게 실행된다",
      "option_d": "다르다 - 표시되는 텍스트가 다르다",
      "correct_answer": "A",
      "explanation": "두 코드는 동일한 결과를 만들어냅니다. 둘 다 3초 후에 \"I love You !!!\"라는 텍스트를 화면에 표시합니다.\n\n차이점은 구현 방식에 있습니다:\n\n1. 코드 A (Callback 방식):\n\n1) `setTimeout`에 직접 콜백 함수를 전달\n2) 간단하지만 복잡한 비동기 작업에서는 \"콜백 지옥\" 문제 발생 가능\n\n2. 코드 B (Promise 방식):\n\n1) Promise 객체를 통해 비동기 작업을 감싸고 `then()`으로 결과 처리\n2) 더 깔끔한 코드 구조, 에러 처리가 용이함\n3) 복잡한 비동기 작업에서 코드 가독성이 향상됨\n\nPromise 방식이 콜백 방식의 현대적인 대안으로 널리 사용되고 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T07:50:51.000Z"
    },
    {
      "id": 708,
      "subject_id": 1,
      "question": "`async` 키워드의 역할에 대한 설명으로 올바른 것은?",
      "option_a": "함수의 실행 속도를 빠르게 만든다",
      "option_b": "함수가 Promise를 반환하도록 만든다",
      "option_c": "함수를 즉시 실행한다",
      "option_d": "함수의 에러를 자동으로 처리한다",
      "correct_answer": "B",
      "explanation": "`async` 키워드는 함수가 Promise를 반환하도록 만드는 역할을 합니다. 일반 함수 앞에 `async`를 붙이면, 그 함수는 자동으로 Promise 객체를 반환하게 됩니다. 예를 들어, `async function myFunction() { return \"Hello\"; }`는 `function myFunction() { return Promise.resolve(\"Hello\"); }`와 동일합니다. 이를 통해 Promise를 더 간단하고 직관적으로 작성할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T07:53:33.000Z"
    },
    {
      "id": 709,
      "subject_id": 1,
      "question": "`await` 키워드에 대한 설명으로 올바른 것은?",
      "option_a": "모든 함수에서 사용할 수 있다",
      "option_b": "Promise가 완료될 때까지 함수 실행을 일시정지시킨다",
      "option_c": "함수의 실행을 완전히 중단시킨다",
      "option_d": "오직 `async` 함수 밖에서만 사용할 수 있다",
      "correct_answer": "B",
      "explanation": "`await` 키워드는 Promise가 완료될 때까지 함수 실행을 일시정지시키는 역할을 합니다. 중요한 점은 `await`는 오직 `async` 함수 내부에서만 사용할 수 있습니다. `await`를 만나면 Promise가 resolve되거나 reject될 때까지 기다렸다가, 결과값을 받아서 다음 코드를 실행합니다. 이를 통해 비동기 코드를 마치 동기 코드처럼 작성할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T07:54:26.000Z"
    },
    {
      "id": 710,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 키워드는?\n\n```javascript\n______ function myDisplay() {\n    let myPromise = new Promise(function(resolve) {\n        resolve(\"I love You !!\");\n    });\n    document.getElementById(\"demo\").innerHTML = ______ myPromise;\n}\n```",
      "option_a": "`async`, `then`",
      "option_b": "`async`, `await`",
      "option_c": "`promise`, `await`",
      "option_d": "`function`, `resolve`",
      "correct_answer": "B",
      "explanation": "첫 번째 빈칸에는 `async`, 두 번째 빈칸에는 `await`가 들어가야 합니다.\n\n1) `async` 키워드는 함수가 Promise를 반환하도록 만들고, 함수 내부에서 `await`를 사용할 수 있게 해줍니다.\n2) `await` 키워드는 Promise가 완료될 때까지 기다렸다가 결과값을 반환합니다.\n\n이 코드는 Promise가 완료되면 \"I love You !!\"라는 값을 받아서 HTML 요소에 직접 할당하는 구조입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T07:56:40.000Z"
    },
    {
      "id": 711,
      "subject_id": 1,
      "question": "다음 두 코드가 동일한 결과를 만드는지 판단하세요.\n\n코드 A:\n```javascript\nasync function myFunction() {\n    return \"Hello\";\n}\nmyFunction().then(function(value) { console.log(value); });\n```\n\n코드 B:\n```javascript\nfunction myFunction() {\n    return Promise.resolve(\"Hello\");\n}\nmyFunction().then(function(value) { console.log(value); });\n```",
      "option_a": "동일하다",
      "option_b": "코드 A가 더 빠르다",
      "option_c": "코드 B가 더 빠르다",
      "option_d": "완전히 다른 결과를 만든다",
      "correct_answer": "A",
      "explanation": "두 코드는 완전히 동일한 결과를 만듭니다.\n\n코드 A에서 `async function myFunction() { return \"Hello\"; }`는 자동으로 `Promise.resolve(\"Hello\")`를 반환합니다.\n\n코드 B에서는 명시적으로 `Promise.resolve(\"Hello\")`를 반환합니다.\n\n따라서 두 함수 모두 같은 Promise 객체를 반환하며, `.then()` 메서드를 통해 \"Hello\"라는 값을 받아 콘솔에 출력합니다. `async` 키워드는 Promise 작성을 더 간편하게 만들어주는 syntactic sugar(문법적 설탕)입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T07:58:15.000Z"
    },
    {
      "id": 712,
      "subject_id": 1,
      "question": "다음 코드의 실행 순서로 올바른 것은?\n\n```javascript\nconsole.log(\"1\");\n\nasync function myDisplay() {\n    console.log(\"2\");\n    let myPromise = new Promise(function(resolve) {\n        setTimeout(function() { \n            console.log(\"3\");\n            resolve(\"완료\"); \n        }, 2000);\n    });\n    console.log(\"4\");\n    let result = await myPromise;\n    console.log(\"5: \" + result);\n}\n\nconsole.log(\"6\");\nmyDisplay();\nconsole.log(\"7\");\n```",
      "option_a": "1 → 6 → 2 → 4 → 7 → 3 → 5: 완료",
      "option_b": "1 → 2 → 4 → 6 → 7 → 3 → 5: 완료",
      "option_c": "1 → 6 → 7 → 2 → 4 → 3 → 5: 완료",
      "option_d": "1 → 2 → 3 → 4 → 5: 완료 → 6 → 7",
      "correct_answer": "A",
      "explanation": "실행 순서를 단계별로 분석하면:\n\n1) \"1\" 출력 - 동기 코드\n2) \"6\" 출력 - 동기 코드\n3) `myDisplay()` 호출 시작\n4) \"2\" 출력 - async 함수 내부 동기 코드\n5) Promise 생성, `setTimeout` 예약 (2초 후 실행)\n6) \"4\" 출력 - Promise 생성 후 동기 코드\n7) `await myPromise` - 여기서 함수 실행이 일시정지\n8) \"7\" 출력 - async 함수가 일시정지되었으므로 메인 스레드 계속 실행\n9) 2초 후: \"3\" 출력 - setTimeout 콜백 실행\n10) Promise resolve됨\n11) \"5: 완료\" 출력 - await가 완료되어 async 함수 재개\n\n`await`는 Promise가 완료될 때까지 해당 함수만 일시정지시키고, 메인 스레드는 계속 다른 코드를 실행합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T08:00:11.000Z"
    },
    {
      "id": 713,
      "subject_id": 1,
      "question": "HTML DOM(Document Object Model)에 대한 설명으로 올바른 것은?",
      "option_a": "HTML 문서의 스타일만 변경할 수 있는 모델",
      "option_b": "웹 페이지가 로드될 때 브라우저가 생성하는 객체의 트리 구조",
      "option_c": "오직 텍스트 내용만 변경할 수 있는 인터페이스",
      "option_d": "HTML 문서를 작성하기 위한 편집 도구",
      "correct_answer": "B",
      "explanation": "HTML DOM은 웹 페이지가 로드될 때 브라우저가 생성하는 객체의 트리 구조입니다. DOM을 통해 JavaScript는 HTML 문서의 모든 요소에 접근하고 변경할 수 있습니다. 이 트리 구조에서 Document가 최상위 객체이고, 그 아래에 html, head, body 등의 요소들이 계층적으로 배치됩니다. DOM을 통해 HTML 요소, 속성, CSS 스타일, 이벤트 등을 모두 조작할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T08:02:20.000Z"
    },
    {
      "id": 714,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\nconst element = document.______(\"demo\");\nelement.innerHTML = \"Hello World!\";\n```\nHTML:\n```html\n <p id=\"demo\">Original text</p>\n```",
      "option_a": "getElementsById",
      "option_b": "getElementById",
      "option_c": "getElementByID",
      "option_d": "findElementById",
      "correct_answer": "B",
      "explanation": "`getElementById`가 정답입니다. 이는 HTML DOM에서 가장 일반적으로 사용되는 메서드로, 특정 id를 가진 요소를 찾는 데 사용됩니다.\n\n주의사항:\n\n1) `getElementById`는 단수형입니다 (Elements가 아닌 Element)\n2) 대소문자를 정확히 써야 합니다 (Id가 아닌 Id)\n3) 이 메서드는 해당 id를 가진 하나의 요소를 반환합니다\n4) id는 HTML 문서에서 고유해야 하므로 하나의 요소만 찾습니다",
      "difficulty": "easy",
      "created_at": "2025-08-08T08:03:54.000Z"
    },
    {
      "id": 715,
      "subject_id": 1,
      "question": "HTML 요소의 내용을 변경하려고 할 때 빈칸에 들어갈 올바른 속성은?\n\n```javascript\ndocument.getElementById(\"demo\").______ = \"새로운 내용입니다!\";\n```",
      "option_a": "content",
      "option_b": "text",
      "option_c": "innerHTML",
      "option_d": "value",
      "correct_answer": "C",
      "explanation": "`innerHTML` 속성이 정답입니다. `innerHTML`은 HTML 요소의 내용을 가져오거나 변경하는 가장 쉬운 방법입니다.\n\n각 옵션의 차이점:\n\n1) `innerHTML`: HTML 태그를 포함한 모든 내용을 다룰 수 있음\n2) `textContent`: 텍스트만 다루고 HTML 태그는 문자열로 처리\n3) `value`: 주로 input, textarea 등의 폼 요소에서 사용\n4) `content`: 표준 DOM 속성이 아님\n\n`innerHTML`을 사용하면 `\"<strong>강조된 텍스트</strong>\"`와 같이 HTML 태그도 함께 삽입할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T08:05:45.000Z"
    },
    {
      "id": 716,
      "subject_id": 1,
      "question": "다음 코드들의 실행 결과로 올바른 것은?\n```javascript\n// 코드 A\nconst elements = document.getElementsByTagName(\"p\");\nconsole.log(\"A: \" + elements.length);\n\n// 코드 B  \nconst elements2 = document.getElementsByClassName(\"intro\");\nconsole.log(\"B: \" + elements2.length);\n```\n\nHTML:\n```html\n<p class=\"intro\">첫 번째 문단</p>\n<p>두 번째 문단</p>\n<p class=\"intro\">세 번째 문단</p>\n<div class=\"intro\">div 요소</div>\n```",
      "option_a": "A: 2, B: 2",
      "option_b": "A: 3, B: 3",
      "option_c": "A: 4, B: 3",
      "option_d": "A: 3, B: 4",
      "correct_answer": "B",
      "explanation": "1. 코드 A 분석:\n\n1) `getElementsByTagName(\"p\")`는 태그 이름이 \"p\"인 모든 요소를 찾습니다\n2) HTML에 `<p>` 태그가 3개 있으므로 `elements.length`는 3입니다\n\n2. 코드 B 분석:\n\n1) `getElementsByClassName(\"intro\")`는 클래스명이 \"intro\"인 모든 요소를 찾습니다\n2) `class=\"intro\"`를 가진 요소는 첫 번째 p, 세 번째 p, div 총 3개입니다\n\n3. 중요한 점:\n\n1) `getElementsByTagName`은 태그 종류에 관계없이 지정된 태그명을 가진 모든 요소를 반환\n2) `getElementsByClassName`은 태그 종류에 관계없이 지정된 클래스를 가진 모든 요소를 반환\n3) 둘 다 배열 형태의 HTMLCollection을 반환합니다",
      "difficulty": "medium",
      "created_at": "2025-08-08T08:15:09.000Z"
    },
    {
      "id": 717,
      "subject_id": 1,
      "question": "다음 코드의 실행 순서와 최종 결과로 올바른 것은?\n\n```javascript\nconsole.log(\"1단계: \" + document.getElementById(\"test\").innerHTML);\n\ndocument.getElementById(\"test\").innerHTML = \"변경된 내용\";\n\nconsole.log(\"2단계: \" + document.getElementById(\"test\").innerHTML);\n\ndocument.getElementById(\"test\").setAttribute(\"class\", \"highlight\");\n\nconsole.log(\"3단계 클래스: \" + document.getElementById(\"test\").className);\n\nconst img = document.getElementById(\"myImg\");\nconsole.log(\"4단계 원본: \" + img.src);\nimg.src = \"new-image.jpg\";\nconsole.log(\"5단계 변경: \" + img.src);\n```\n\nHTML:\n```html\n<p id=\"test\">원본 텍스트</p>\n<img id=\"myImg\" src=\"original.jpg\">\n```",
      "option_a": "1단계: 원본 텍스트 → 2단계: 변경된 내용 → 3단계 클래스: highlight → 4단계 원본: original.jpg → 5단계 변경: new-image.jpg",
      "option_b": "모든 단계에서 원본 값이 그대로 유지됨",
      "option_c": "1단계: 변경된 내용 → 나머지는 오류 발생",
      "option_d": "1단계: 원본 텍스트 → 2단계: 원본 텍스트 → 3단계 클래스: → 4단계 원본: → 5단계 변경: new-image.jpg",
      "correct_answer": "A",
      "explanation": "1. 단계별 실행 과정:\n\n1) 1단계: `innerHTML` 속성으로 원본 내용 \"원본 텍스트\" 출력\n2) 2단계: `innerHTML`을 \"변경된 내용\"으로 변경 후 출력\n3) 3단계: `setAttribute()`로 class 속성을 \"highlight\"로 설정, `className`으로 확인\n4) 4단계: img 요소의 원본 `src` 속성값 \"original.jpg\" 출력\n5) 5단계: `src` 속성을 \"new-image.jpg\"로 변경 후 출력\n\n2. 핵심 학습 포인트:\n\n1) `innerHTML`: 요소의 내용을 실시간으로 변경 가능\n2) `setAttribute()`: 모든 HTML 속성을 동적으로 설정 가능\n3) `className`: 클래스 속성에 접근하는 DOM 속성\n4) 속성 직접 접근: `img.src`처럼 속성에 직접 접근하여 변경 가능\n5) DOM 변경사항은 즉시 브라우저에 반영됩니다\n\n이는 JavaScript가 웹 페이지를 동적으로 만들 수 있는 핵심 기능들입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T08:18:06.000Z"
    },
    {
      "id": 718,
      "subject_id": 1,
      "question": "JavaScript로 HTML 요소의 CSS 스타일을 변경하는 올바른 문법은?",
      "option_a": "document.getElementById(id).css.property = \"value\"",
      "option_b": "document.getElementById(id).style.property = \"value\"",
      "option_c": "document.getElementById(id).setStyle(property, \"value\")",
      "option_d": "document.getElementById(id).changeStyle(\"property\", \"value\")",
      "correct_answer": "B",
      "explanation": "JavaScript에서 HTML 요소의 CSS 스타일을 변경할 때는 `style` 속성을 사용합니다. 문법은 `document.getElementById(id).style.property = \"value\"`입니다. 예를 들어, 글자 색을 빨간색으로 바꾸려면 `element.style.color = \"red\"`와 같이 사용합니다. 이때 CSS 속성명에서 하이픈(-)이 있는 경우 camelCase로 변환해야 합니다(예: `font-size` → `fontSize`).",
      "difficulty": "easy",
      "created_at": "2025-08-08T08:20:59.000Z"
    },
    {
      "id": 719,
      "subject_id": 1,
      "question": "다음 폼 검증 함수에서 빈칸에 들어갈 올바른 코드는?\n\n```javascript\nfunction validateForm() {\n    let x = document.forms[\"myForm\"][\"fname\"].value;\n    if (x == \"\") {\n        alert(\"Name must be filled out\");\n        return ______;\n    }\n}\n```",
      "option_a": "true",
      "option_b": "false",
      "option_c": "null",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "폼 검증에서 **`false`**를 반환하면 폼 제출을 중단시킵니다. 사용자가 필수 필드를 입력하지 않았을 때 경고 메시지를 표시하고 `false`를 반환하여 폼이 서버로 전송되지 않도록 막습니다. 반대로 `true`를 반환하면 폼 제출이 계속 진행됩니다. 이는 `onsubmit=\"return validateForm()\"`에서 반환값에 따라 폼 제출 여부가 결정되는 중요한 메커니즘입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T08:21:57.000Z"
    },
    {
      "id": 720,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 함수는?\n\n```javascript\nfunction myMove() {\n    let id = null;\n    const elem = document.getElementById(\"animate\");\n    let pos = 0;\n    ______(id);\n    id = setInterval(frame, 5);\n    function frame() {\n        if (pos == 350) {\n            ______(id);\n        } else {\n            pos++;\n            elem.style.top = pos + 'px';\n            elem.style.left = pos + 'px';\n        }\n    }\n}\n```",
      "option_a": "`setTimeout`, `clearTimeout`",
      "option_b": "`setInterval`, `clearInterval`",
      "option_c": "`clearInterval`, `clearInterval`",
      "option_d": "`clearTimeout`, `clearTimeout`",
      "correct_answer": "C",
      "explanation": "두 빈칸 모두 **`clearInterval`**이 들어가야 합니다.\n\n1) 첫 번째 빈칸: `clearInterval(id)`로 이전에 실행 중이던 타이머를 정리합니다 (중복 실행 방지)\n2) 두 번째 빈칸: 애니메이션이 완료되었을 때(`pos == 350`) `clearInterval(id)`로 타이머를 중지합니다\n\n`setInterval`은 일정한 간격으로 함수를 반복 실행하는 타이머를 설정하고, `clearInterval`은 그 타이머를 중지시킵니다. 이 코드는 5밀리초마다 `frame` 함수를 실행하여 요소를 한 픽셀씩 이동시키는 애니메이션을 만듭니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T08:23:43.000Z"
    },
    {
      "id": 721,
      "subject_id": 1,
      "question": "다음 코드들의 실행 결과로 올바른 것은?\n\n```javascript\n// 숫자 검증 함수\nlet x = \"abc\";\nif (isNaN(x) || x < 1 || x > 10) {\n    console.log(\"A: Input not valid\");\n} else {\n    console.log(\"A: Input OK\");\n}\n\n// 숫자 검증 함수\nlet y = \"5\";\nif (isNaN(y) || y < 1 || y > 10) {\n    console.log(\"B: Input not valid\");\n} else {\n    console.log(\"B: Input OK\");\n}\n```",
      "option_a": "A: Input not valid, B: Input not valid",
      "option_b": "A: Input OK, B: Input OK",
      "option_c": "A: Input not valid, B: Input OK",
      "option_d": "A: Input OK, B: Input not valid",
      "correct_answer": "C",
      "explanation": "1. 변수 x = \"abc\" 분석:\n\n1) `isNaN(\"abc\")`는 `true` (문자열이므로 숫자가 아님)\n2) 조건 `isNaN(x) || x < 1 || x > 10`에서 첫 번째 조건이 `true`이므로 전체가 `true`\n3) 결과: \"A: Input not valid\"\n\n2. 변수 y = \"5\" 분석:\n\n1) `isNaN(\"5\")`는 `false` (문자열이지만 숫자로 변환 가능)\n2) `\"5\" < 1`은 `false` (JavaScript가 자동으로 숫자 비교)\n3) `\"5\" > 10`은 `false`\n4) 모든 조건이 `false`이므로 전체가 `false`\n5) 결과: \"B: Input OK\"\n\n`isNaN()` 함수는 값이 숫자가 아니면 `true`를 반환하며, JavaScript는 문자열 숫자를 자동으로 숫자로 변환하여 비교합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T08:26:10.000Z"
    },
    {
      "id": 722,
      "subject_id": 1,
      "question": "다음 이벤트 처리 코드의 실행 순서와 최종 결과로 올바른 것은?\n\n```html\n<input type=\"text\" id=\"testInput\" oninput=\"inputHandler()\" onchange=\"changeHandler()\">\n```\n\n```javascript\nlet log = \"\";\nfunction inputHandler() {\n    log += \"INPUT \";\n    console.log(\"Input event fired\");\n}\n\nfunction changeHandler() {\n    log += \"CHANGE \";\n    console.log(\"Change event fired\");\n}\n```\n\n사용자가 입력 필드에 \"Hello\"를 타이핑한 후 다른 곳을 클릭했을 때의 결과는?",
      "option_a": "INPUT만 5번 실행, log = \"INPUT INPUT INPUT INPUT INPUT \"",
      "option_b": "CHANGE만 1번 실행, log = \"CHANGE \"",
      "option_c": "INPUT이 5번, CHANGE가 1번 실행, log = \"INPUT INPUT INPUT INPUT INPUT CHANGE \"",
      "option_d": "CHANGE가 1번, INPUT이 5번 실행, log = \"CHANGE INPUT INPUT INPUT INPUT INPUT \"",
      "correct_answer": "C",
      "explanation": "이벤트 실행 순서:\n\n1. `oninput` 이벤트: 사용자가 키보드로 글자를 입력할 때마다 실시간으로 발생\n\n1) \"H\" 입력 → INPUT 이벤트\n2) \"e\" 입력 → INPUT 이벤트\n3) \"l\" 입력 → INPUT 이벤트\n4) \"l\" 입력 → INPUT 이벤트\n5) \"o\" 입력 → INPUT 이벤트\n6) 총 5번의 INPUT 이벤트 발생\n\n2. `onchange` 이벤트: 입력 필드의 포커스가 벗어날 때 (다른 곳 클릭) 발생\n\n1)사용자가 다른 곳을 클릭 → CHANGE 이벤트 1번 발생\n\n\n최종 결과: `log = \"INPUT INPUT INPUT INPUT INPUT CHANGE \"`\n\n핵심 차이점:\n\n1) `oninput`: 실시간 입력 감지 (타이핑할 때마다)\n2) `onchange`: 값이 변경되고 포커스를 잃을 때만 발생\n\n이는 실시간 검색 기능(`oninput`)과 폼 검증(`onchange`)에서 각각 다르게 활용됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T08:28:59.000Z"
    },
    {
      "id": 723,
      "subject_id": 1,
      "question": "버튼 클릭 시 함수를 실행하기 위해 사용할 올바른 메서드는?\n\n```javascript\ndocument.getElementById(\"myBtn\").________(\"click\", myFunction);\n```",
      "option_a": "onclick",
      "option_b": "addEventListener",
      "option_c": "addEvent",
      "option_d": "clickListener",
      "correct_answer": "B",
      "explanation": "addEventListener는 HTML 요소에 이벤트 핸들러를 연결하는 JavaScript의 표준 메서드입니다. 이 메서드는 기존 이벤트 핸들러를 덮어쓰지 않고, 하나의 요소에 여러 개의 이벤트 핸들러를 추가할 수 있는 장점이 있습니다. 문법은 `element.addEventListener(event, function, useCapture)`입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T08:36:55.000Z"
    },
    {
      "id": 724,
      "subject_id": 1,
      "question": "DOM에서 모든 HTML 요소는 어떤 타입의 노드인가요?",
      "option_a": "텍스트 노드 (Text Node)",
      "option_b": "속성 노드 (Attribute Node)",
      "option_c": "요소 노드 (Element Node)",
      "option_d": "주석 노드 (Comment Node)",
      "correct_answer": "C",
      "explanation": "W3C HTML DOM 표준에 따르면:\n\n1) 전체 문서는 문서 노드(Document Node)\n2) 모든 HTML 요소는 요소 노드(Element Node)\n3) HTML 요소 내부의 텍스트는 텍스트 노드(Text Node)\n4) 모든 HTML 속성은 속성 노드(Attribute Node) - 현재는 deprecated\n5) 모든 주석은 주석 노드(Comment Node)\n\nHTML 태그들(`<div>`, `<p>`, `<h1>` 등)이 바로 요소 노드에 해당합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T08:38:31.000Z"
    },
    {
      "id": 725,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n\n```javascript\n// h1 요소의 텍스트 내용을 가져오는 세 가지 방법\nlet title1 = document.getElementById(\"demo\").innerHTML;\nlet title2 = document.getElementById(\"demo\").firstChild.________;\nlet title3 = document.getElementById(\"demo\").childNodes[0].________;\n```",
      "option_a": "innerHTML",
      "option_b": "textContent",
      "option_c": "nodeValue",
      "option_d": "innerText",
      "correct_answer": "C",
      "explanation": "텍스트 노드의 값을 가져오려면 `nodeValue` 속성을 사용해야 합니다.\n\n1. `innerHTML`: 요소의 HTML 내용을 반환 (요소 노드용)\n\n2. `nodeValue`: 노드의 값을 반환\n1) 요소 노드의 경우: null\n2) 텍스트 노드의 경우: 텍스트 자체\n3) 속성 노드의 경우: 속성 값\n\n3. `firstChild`와 `childNodes[0]`는 첫 번째 자식 노드(텍스트 노드)를 가리키므로, 해당 텍스트 값을 얻으려면 `.nodeValue`를 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T08:40:23.000Z"
    },
    {
      "id": 726,
      "subject_id": 1,
      "question": "이벤트 버블링(Event Bubbling)과 이벤트 캡처링(Event Capturing)에 대한 설명으로 올바른 것은?\n\n```javascript\nelement.addEventListener(\"click\", myFunction, useCapture);\n```",
      "option_a": "버블링: 바깥쪽 요소 → 안쪽 요소, useCapture = true",
      "option_b": "버블링: 안쪽 요소 → 바깥쪽 요소, useCapture = false",
      "option_c": "캡처링: 안쪽 요소 → 바깥쪽 요소, useCapture = true",
      "option_d": "기본값은 캡처링이며, useCapture = false로 버블링으로 변경",
      "correct_answer": "B",
      "explanation": "이벤트 전파(Event Propagation) 방식:\n\n1. 버블링 (Bubbling):\n\n1) 안쪽(자식) 요소 → 바깥쪽(부모) 요소 순으로 이벤트 처리\n2) `useCapture = false` (기본값)\n3) 예: `<p>` 클릭 시 `<p>` → `<div>` 순서로 이벤트 발생\n\n2. 캡처링 (Capturing):\n\n1) 바깥쪽(부모) 요소 → 안쪽(자식) 요소 순으로 이벤트 처리\n2) `useCapture = true`\n3) 예: `<p>` 클릭 시 `<div>` → `<p>` 순서로 이벤트 발생\n\n기본값은 버블링(`false`)입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T08:43:11.000Z"
    },
    {
      "id": 727,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 올바른 것은?\n\n```html\n<div id=\"parent\">\n    <p id=\"child\">Click me!</p>\n</div>\n\n<script>\ndocument.getElementById(\"parent\").addEventListener(\"click\", function() {\n    alert(\"Parent clicked!\");\n}, false);\n\ndocument.getElementById(\"child\").addEventListener(\"click\", function() {\n    alert(\"Child clicked!\");\n}, false);\n</script>\n```\n`<p>` 요소를 클릭했을 때 alert 창이 나타나는 순서는?",
      "option_a": "\"Parent clicked!\" → \"Child clicked!\"",
      "option_b": "\"Child clicked!\" → \"Parent clicked!\"",
      "option_c": "\"Child clicked!\" 만 나타남",
      "option_d": "\"Parent clicked!\" 만 나타남",
      "correct_answer": "B",
      "explanation": "이벤트 버블링 때문입니다:\n\n1. `<p>` 요소를 클릭하면, 클릭 이벤트가 발생합니다.\n2. 두 이벤트 리스너 모두 `useCapture = false`(버블링)으로 설정되어 있습니다.\n3. 버블링에서는 안쪽 요소부터 바깥쪽 요소 순서로 이벤트가 처리됩니다.\n\n실행 순서:\n\n1. `<p>` 요소의 클릭 이벤트 → \"Child clicked!\" 출력\n2. 이벤트가 부모인 `<div>`로 버블링 → \"Parent clicked!\" 출력\n\n만약 이벤트 전파를 중단하려면 `event.stopPropagation()`을 사용할 수 있고, 캡처링을 원한다면 세 번째 매개변수를 `true`로 설정하면 순서가 바뀝니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T08:45:15.000Z"
    },
    {
      "id": 728,
      "subject_id": 1,
      "question": "새로운 HTML 요소를 생성하기 위해 사용하는 메서드는?\n\n```javascript\nconst newElement = document.________(\"p\");\n```",
      "option_a": "createNode",
      "option_b": "createElement",
      "option_c": "makeElement",
      "option_d": "newElement",
      "correct_answer": "B",
      "explanation": "`document.createElement()`는 지정된 HTML 태그의 새로운 요소를 생성하는 JavaScript의 표준 메서드입니다.\n\n사용 단계:\n\n1. `document.createElement(\"tagName\")` - 요소 생성\n2. `document.createTextNode(\"text\")` - 텍스트 노드 생성 (필요시)\n3. `appendChild()` - 텍스트를 요소에 추가\n4. 부모 요소에 새 요소 추가\n\n이 메서드는 DOM 트리에 동적으로 요소를 추가할 때 가장 기본이 되는 메서드입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T08:48:41.000Z"
    },
    {
      "id": 729,
      "subject_id": 1,
      "question": "HTMLCollection에서 요소에 접근하는 올바른 방법은?\n\n```javascript\nconst collection = document.getElementsByTagName(\"p\");\n// 두 번째 p 요소에 접근하려면?\n```",
      "option_a": "collection.get(1)",
      "option_b": "`collection.item(1)` 또는 `collection[1]`",
      "option_c": "collection.second()",
      "option_d": "collection.index(1)",
      "correct_answer": "B",
      "explanation": "HTMLCollection은 배열과 유사한 객체로, 인덱스는 0부터 시작합니다.\n\n접근 방법:\n\n1) `collection[index]` - 배열 스타일 접근 (가장 일반적)\n2) `collection.item(index)` - 메서드를 이용한 접근\n3) `collection.namedItem(id)` - name이나 id로 접근\n\n주의사항:\n\n1) HTMLCollection은 실제 배열이 아니므로 `push()`, `pop()`, `join()` 등의 배열 메서드는 사용할 수 없습니다.\n2) 하지만 `for` 반복문이나 `length` 속성은 사용 가능합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T08:50:55.000Z"
    },
    {
      "id": 730,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\nconst parent = document.getElementById(\"container\");\nconst newChild = document.createElement(\"div\");\nconst existingChild = document.getElementById(\"first\");\n\n// newChild를 existingChild 앞에 삽입하려면?\nparent.________(newChild, existingChild);\n```",
      "option_a": "insertAfter",
      "option_b": "insertBefore",
      "option_c": "addBefore",
      "option_d": "placeBefore",
      "correct_answer": "B",
      "explanation": "`insertBefore()` 메서드는 기존 요소 앞에 새로운 요소를 삽입할 때 사용합니다.\n\n문법: `parentNode.insertBefore(newNode, referenceNode)`\n\nDOM 조작 메서드 비교:\n\n1) `appendChild(newNode)` - 부모의 마지막 자식으로 추가\n2) `insertBefore(newNode, referenceNode)` - 참조 노드 앞에 삽입\n3) `replaceChild(newNode, oldNode)` - 기존 노드를 새 노드로 교체\n4) `removeChild(node)` 또는 `node.remove()` - 노드 제거\n\nJavaScript에는 `insertAfter()` 메서드가 없으므로, 뒤에 삽입하려면 다음 형제 요소를 찾아서 `insertBefore()`를 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T08:53:05.000Z"
    },
    {
      "id": 731,
      "subject_id": 1,
      "question": "HTMLCollection과 NodeList의 차이점에 대한 설명으로 올바른 것은?",
      "option_a": "HTMLCollection은 정적이고, NodeList는 동적이다",
      "option_b": "HTMLCollection은 동적이고, NodeList는 대부분 정적이다",
      "option_c": "둘 다 항상 동적이다",
      "option_d": "둘 다 항상 정적이다",
      "correct_answer": "B",
      "explanation": "동적(Live) vs 정적(Static):\n\n1) 동적: DOM이 변경되면 컬렉션도 자동으로 업데이트\n2) 정적: 생성 시점의 상태를 유지, DOM 변경에 영향받지 않음\n\n예외: `childNodes` 속성으로 얻는 NodeList는 동적입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T08:53:59.000Z"
    },
    {
      "id": 732,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```html\n<div id=\"container\">\n  <p>First</p>\n  <p>Second</p>\n</div>\n\n<script>\nconst container = document.getElementById(\"container\");\nconst htmlCollection = container.getElementsByTagName(\"p\");\nconst nodeList = container.querySelectorAll(\"p\");\n\nconsole.log(\"HTMLCollection length:\", htmlCollection.length);\nconsole.log(\"NodeList length:\", nodeList.length);\n\n// 새로운 p 요소 추가\nconst newP = document.createElement(\"p\");\nnewP.textContent = \"Third\";\ncontainer.appendChild(newP);\n\nconsole.log(\"After adding - HTMLCollection length:\", htmlCollection.length);\nconsole.log(\"After adding - NodeList length:\", nodeList.length);\n</script>\n```",
      "option_a": "HTMLCollection: 2→3, NodeList: 2→3",
      "option_b": "HTMLCollection: 2→3, NodeList: 2→2",
      "option_c": "HTMLCollection: 2→2, NodeList: 2→3",
      "option_d": "HTMLCollection: 2→2, NodeList: 2→2",
      "correct_answer": "B",
      "explanation": "실행 과정 분석:\n\n1. 초기 상태:\n1) HTMLCollection: 2개 (동적이므로 실시간 반영)\n2) NodeList: 2개 (정적이므로 생성 시점 상태 유지)\n\n2. 새 요소 추가 후:\n1) HTMLCollection: 3개 (동적이므로 새로운 `<p>` 요소가 자동으로 포함됨)\n2) NodeList: 2개 (정적이므로 변화 없음)\n\n\n핵심 개념:\n\n1) `getElementsByTagName()`은 Live HTMLCollection 반환 → DOM 변경사항 실시간 반영\n2) `querySelectorAll()`은 Static NodeList 반환 → 생성 시점의 스냅샷 유지\n\n실무 활용:\n\n1) 동적으로 요소가 추가/제거되는 상황에서는 HTMLCollection 사용\n2) 고정된 요소 집합에 대한 작업에는 NodeList가 더 안정적\n3) 성능 상 NodeList가 일반적으로 더 효율적",
      "difficulty": "hard",
      "created_at": "2025-08-08T08:56:45.000Z"
    },
    {
      "id": 733,
      "subject_id": 1,
      "question": "브라우저 창의 내부 너비와 높이를 가져오는 올바른 속성은?\n\n```javascript\nlet width = window.________;\nlet height = window.________;\n```",
      "option_a": "`outerWidth`, `outerHeight`",
      "option_b": "`innerWidth`, `innerHeight`",
      "option_c": "`screenWidth`, `screenHeight`",
      "option_d": "`clientWidth`, `clientHeight`",
      "correct_answer": "B",
      "explanation": "`window.innerWidth`와 `window.innerHeight`는 브라우저 창의 뷰포트(viewport) 크기를 픽셀 단위로 반환합니다.\n\n주요 window 크기 속성들:\n\n• `window.innerWidth/innerHeight`: 브라우저 창의 내부 크기 (툴바, 스크롤바 제외)\n• `window.outerWidth/outerHeight`: 브라우저 창의 전체 크기 (툴바, 메뉴바 포함)\n• `screen.width/height`: 사용자의 전체 화면 크기\n• `screen.availWidth/availHeight`: 사용가능한 화면 크기 (작업표시줄 제외)\n\n실무 활용: 반응형 웹 개발에서 화면 크기에 따라 레이아웃을 조정할 때 주로 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T09:03:12.000Z"
    },
    {
      "id": 734,
      "subject_id": 1,
      "question": "사용자에게 확인/취소를 선택하게 하는 팝업 박스는?\n\n```javascript\nlet result = ________(\"정말 삭제하시겠습니까?\");\nif (result) {\n    // 삭제 실행\n} else {\n    // 취소\n}\n```",
      "option_a": "alert",
      "option_b": "confirm",
      "option_c": "prompt",
      "option_d": "popup",
      "correct_answer": "B",
      "explanation": "`confirm()` 메서드는 사용자에게 확인/취소 선택지를 제공하는 대화상자를 표시합니다.\n\nJavaScript 팝업 박스 3가지:\n\n1. `alert(\"메시지\")`\n\n• 단순 알림 표시\n• 반환값: 없음 (undefined)\n• 사용자는 \"확인\"만 클릭 가능\n\n2. `confirm(\"메시지\")`\n\n• 확인/취소 선택\n• 반환값: 확인 클릭 시 `true`, 취소 클릭 시 `false`\n\n3. `prompt(\"메시지\", \"기본값\")`\n\n• 사용자 입력 받기\n• 반환값: 입력한 문자열 또는 취소 시 `null`\n\n\n실무 활용: 중요한 작업(삭제, 저장 등) 전에 사용자 확인을 받을 때 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T09:05:27.000Z"
    },
    {
      "id": 735,
      "subject_id": 1,
      "question": "현재 페이지의 URL 정보를 다루는 객체와 속성으로 올바른 것은?\n\n```javascript\nconsole.log(\"전체 URL:\", window.location.________);\nconsole.log(\"호스트명:\", window.location.________);\nconsole.log(\"경로:\", window.location.________);\nconsole.log(\"프로토콜:\", window.location.________);\n```",
      "option_a": "`url`, `domain`, `path`, `scheme`",
      "option_b": "`href`, `hostname`, `pathname`, `protocol`",
      "option_c": "`address`, `host`, `route`, `http`",
      "option_d": "`link`, `server`, `directory`, `method`",
      "correct_answer": "B",
      "explanation": "`window.location` 객체는 현재 페이지의 URL 정보를 제공합니다.\n\n주요 location 속성들:\n\n• `location.href`: 전체 URL (https://www.example.com/path/page.html)\n• `location.hostname`: 호스트명 (www.example.com)\n• `location.pathname`: 경로와 파일명 (/path/page.html)\n• `location.protocol`: 프로토콜 (https: 또는 http:)\n• `location.port`: 포트번호 (기본 포트는 빈 문자열)\n• `location.search`: 쿼리 문자열 (?param=value)\n• `location.hash`: 해시 (#section)\n\n실무 활용:\n```javascript\n// 페이지 리디렉션\nlocation.assign(\"https://newpage.com\");\n// 또는\nlocation.href = \"https://newpage.com\";\n```",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:08:23.000Z"
    },
    {
      "id": 736,
      "subject_id": 1,
      "question": "3초 후에 함수를 실행시키고, 실행 전에 취소할 수 있는 코드는?\n\n```javascript\nfunction showMessage() {\n    alert(\"3초가 지났습니다!\");\n}\n\n// 3초 후 실행 설정\nlet timer = ________(showMessage, 3000);\n\n// 실행 취소\n________(timer);\n```",
      "option_a": "`setDelay`, `cancelDelay`",
      "option_b": "`setTimer`, `cancelTimer`",
      "option_c": "`setTimeout`, `clearTimeout`",
      "option_d": "`setInterval`, `clearInterval`",
      "correct_answer": "C",
      "explanation": "JavaScript 타이밍 이벤트:\n\n1. `setTimeout(function, milliseconds)`\n\n• 지정된 시간 후 한 번 함수 실행\n• 반환값: 타이머 ID (숫자)\n\n2. `clearTimeout(timeoutID)`\n\n• setTimeout으로 설정한 타이머 취소\n\n3. `setInterval(function, milliseconds)`\n\n• 지정된 시간마다 함수를 반복 실행\n\n4. `clearInterval(intervalID)`\n\n• setInterval로 설정한 반복 실행 중단\n\n\n실무 예제:\n```javascript\n// 5초 후 자동 로그아웃 알림\nlet logoutTimer = setTimeout(() => {\n    alert(\"자동 로그아웃됩니다.\");\n    logout();\n}, 5000);\n\n// 사용자 활동 감지 시 타이머 재설정\ndocument.addEventListener('click', () => {\n    clearTimeout(logoutTimer);\n    logoutTimer = setTimeout(logout, 5000);\n});\n```",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:10:41.000Z"
    },
    {
      "id": 737,
      "subject_id": 1,
      "question": "다음 쿠키 관련 코드의 실행 결과는?\n\n```javascript\n// 쿠키 설정\ndocument.cookie = \"username=John; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/\";\ndocument.cookie = \"theme=dark; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/\";\n\n// 쿠키 읽기\nconsole.log(document.cookie);\n\n// 쿠키 삭제 (username만)\ndocument.cookie = \"username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/\";\n\n// 다시 쿠키 읽기\nconsole.log(document.cookie);\n```",
      "option_a": "첫 번째: `\"username=John\"`, 두 번째: `\"theme=dark\"`",
      "option_b": "첫 번째: `\"username=John; theme=dark\"`, 두 번째: `\"theme=dark\"`",
      "option_c": "첫 번째: `\"username=John; theme=dark\"`, 두 번째: `\"\"`",
      "option_d": "첫 번째: `\"theme=dark; username=John\"`, 두 번째: `\"theme=dark\"`",
      "correct_answer": "B",
      "explanation": "쿠키 동작 원리:\n\n1. 쿠키 설정: `document.cookie = \"name=value; expires=date; path=/\"`\n\n• 새 쿠키를 추가 (기존 쿠키를 덮어쓰지 않음)\n\n2. 쿠키 읽기: `document.cookie`\n\n• 모든 쿠키를 세미콜론으로 구분된 문자열로 반환\n• 순서는 브라우저에 따라 다를 수 있음\n\n3. 쿠키 삭제: 만료일을 과거로 설정\n```javascript\ndocument.cookie = \"name=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/\";\n```\n\n실무에서 쿠키 관리 함수:\n```javascript\n// 쿠키 설정\nfunction setCookie(name, value, days) {\n    const d = new Date();\n    d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));\n    document.cookie = `${name}=${value}; expires=${d.toUTCString()}; path=/`;\n}\n\n// 쿠키 가져오기\nfunction getCookie(name) {\n    const cookies = document.cookie.split(';');\n    for(let cookie of cookies) {\n        let [key, value] = cookie.trim().split('=');\n        if(key === name) return value;\n    }\n    return null;\n}\n\n// 쿠키 삭제\nfunction deleteCookie(name) {\n    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/`;\n}\n```\n\n주의사항:\n\n• 쿠키는 도메인과 경로별로 관리됩니다\n• HTTPS에서는 `Secure` 속성 사용을 권장합니다\n• 개인정보보호를 위해 중요한 데이터는 쿠키에 저장하지 않습니다",
      "difficulty": "hard",
      "created_at": "2025-08-08T09:14:00.000Z"
    },
    {
      "id": 738,
      "subject_id": 1,
      "question": "Web API에서 'API'는 무엇의 줄임말인가요?",
      "option_a": "Advanced Programming Interface",
      "option_b": "Application Programming Interface",
      "option_c": "Automated Programming Interface",
      "option_d": "Applied Programming Interface",
      "correct_answer": "B",
      "explanation": "API는 Application Programming Interface의 줄임말입니다. 이는 서로 다른 소프트웨어 구성 요소들이 서로 통신할 수 있도록 하는 규칙과 도구들의 집합을 의미합니다. Web API는 웹 환경에서 이러한 인터페이스를 제공하여 브라우저의 기능을 확장하거나 복잡한 기능을 단순화할 수 있게 해줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T09:16:27.000Z"
    },
    {
      "id": 739,
      "subject_id": 1,
      "question": "Geolocation API 사용법에 대한 문제입니다.\n다음 코드에서 빈칸에 들어갈 올바른 메서드는 무엇인가요?\n\n```javascript\nfunction getLocation() {\n  if (navigator.geolocation) {\n    navigator.geolocation.__________(showPosition);\n  } else {\n    console.log(\"Geolocation is not supported by this browser.\");\n  }\n}\n```",
      "option_a": "getPosition()",
      "option_b": "getCurrentPosition()",
      "option_c": "fetchLocation()",
      "option_d": "retrievePosition()",
      "correct_answer": "B",
      "explanation": "`getCurrentPosition()`은 Geolocation API에서 사용자의 현재 위치를 가져오는 메서드입니다. 이 메서드는 첫 번째 매개변수로 성공 시 호출될 콜백 함수를 받고, 선택적으로 두 번째 매개변수로 에러 처리 함수를 받을 수 있습니다. GPS가 있는 스마트폰 등에서 가장 정확한 결과를 제공하며, HTTPS 환경에서만 작동합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:17:29.000Z"
    },
    {
      "id": 740,
      "subject_id": 1,
      "question": "Web Storage API의 차이점에 대한 문제입니다.\nlocalStorage와 sessionStorage의 가장 중요한 차이점은 무엇인가요?",
      "option_a": "localStorage는 문자열만 저장할 수 있고, sessionStorage는 객체도 저장할 수 있다",
      "option_b": "localStorage는 모든 탭에서 공유되고, sessionStorage는 현재 탭에서만 사용된다",
      "option_c": "localStorage는 브라우저를 닫아도 데이터가 유지되고, sessionStorage는 브라우저를 닫으면 데이터가 삭제된다",
      "option_d": "localStorage는 5MB까지, sessionStorage는 10MB까지 저장할 수 있다",
      "correct_answer": "C",
      "explanation": "localStorage와 sessionStorage의 핵심적인 차이점은 데이터 지속성입니다. localStorage에 저장된 데이터는 명시적으로 삭제하지 않는 한 브라우저를 닫아도 계속 유지되어 며칠, 몇 주, 심지어 몇 년 동안도 사용할 수 있습니다. 반면 sessionStorage는 해당 세션(브라우저 탭)이 닫히면 데이터가 자동으로 삭제됩니다. 둘 다 같은 메서드(`setItem()`, `getItem()` 등)를 사용하며 저장 용량도 동일합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:18:20.000Z"
    },
    {
      "id": 741,
      "subject_id": 1,
      "question": "Form Validation API의 validity 속성에 대한 문제입니다.\n다음 HTML과 JavaScript 코드에서 입력값이 150일 때, 어떤 validity 속성이 true가 될까요?\n\n```html\n<input id=\"userInput\" type=\"number\" min=\"100\" max=\"300\" required>\n```\n\n```javascript\nfunction checkInput() {\n  const input = document.getElementById(\"userInput\");\n  const validity = input.validity;\n  // 입력값: 150\n}\n```",
      "option_a": "rangeUnderflow",
      "option_b": "rangeOverflow",
      "option_c": "valid",
      "option_d": "valueMissing",
      "correct_answer": "C",
      "explanation": "입력값 150은 min=\"100\"과 max=\"300\" 사이에 있는 유효한 값이므로 `valid` 속성이 true가 됩니다. `rangeUnderflow`는 값이 min보다 작을 때, `rangeOverflow`는 값이 max보다 클 때 true가 되고, `valueMissing`은 required 필드가 비어있을 때 true가 됩니다. validity 객체의 이러한 속성들을 통해 정확한 유효성 검사를 수행할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T09:19:57.000Z"
    },
    {
      "id": 742,
      "subject_id": 1,
      "question": "Web Workers의 제한사항과 특징에 대한 문제입니다.\nWeb Worker에서 접근할 수 없는 JavaScript 객체는 무엇인가요?",
      "option_a": "console 객체",
      "option_b": "setTimeout 함수",
      "option_c": "document 객체",
      "option_d": "JSON 객체",
      "correct_answer": "C",
      "explanation": "Web Worker는 메인 스레드와 분리된 백그라운드에서 실행되기 때문에 DOM과 관련된 객체들에 접근할 수 없습니다. 특히 `document` 객체, `window` 객체, `parent` 객체에는 접근이 불가능합니다. 이는 Web Worker가 페이지의 성능에 영향을 주지 않고 독립적으로 실행되도록 설계되었기 때문입니다. 대신 `postMessage()` 메서드를 통해 메인 스레드와 안전하게 통신할 수 있습니다. console, setTimeout, JSON 등의 기본 JavaScript 기능들은 사용할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T09:20:48.000Z"
    },
    {
      "id": 743,
      "subject_id": 1,
      "question": "AJAX의 기본 개념에 대한 문제입니다.\nAJAX는 무엇의 줄임말인가요?",
      "option_a": "Advanced JavaScript And XML",
      "option_b": "Asynchronous JavaScript And XML",
      "option_c": "Automated JavaScript And XML",
      "option_d": "Applied JavaScript And XML",
      "correct_answer": "B",
      "explanation": "AJAX는 \"Asynchronous JavaScript And XML\"의 줄임말입니다. 이름에 XML이 포함되어 있지만, 실제로는 XML뿐만 아니라 일반 텍스트나 JSON 형태의 데이터도 전송할 수 있습니다. AJAX의 핵심은 \"비동기(Asynchronous)\"라는 개념으로, 페이지 전체를 새로고침하지 않고도 서버와 데이터를 주고받을 수 있게 해줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T09:22:47.000Z"
    },
    {
      "id": 744,
      "subject_id": 1,
      "question": "XMLHttpRequest 객체 생성에 대한 문제입니다.\n다음 코드에서 빈칸에 들어갈 올바른 코드는 무엇인가요?\n\n```javascript\nfunction loadDoc() {\n  const xhttp = new ___________;\n  xhttp.onload = function() {\n    document.getElementById(\"demo\").innerHTML = this.responseText;\n  }\n  xhttp.open(\"GET\", \"ajax_info.txt\");\n  xhttp.send();\n}\n```",
      "option_a": "XMLRequest()",
      "option_b": "XMLHttpRequest()",
      "option_c": "HttpRequest()",
      "option_d": "AjaxRequest()",
      "correct_answer": "B",
      "explanation": "`XMLHttpRequest()`는 AJAX의 핵심이 되는 객체입니다. 이 객체를 통해 서버와 HTTP 요청을 주고받을 수 있습니다. 모든 최신 브라우저에서 지원되며, 웹페이지가 로드된 후에도 서버에서 데이터를 읽고, 페이지를 다시 로드하지 않고도 웹페이지를 업데이트하고, 백그라운드에서 서버로 데이터를 전송할 수 있게 해줍니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:23:28.000Z"
    },
    {
      "id": 745,
      "subject_id": 1,
      "question": "비동기 처리의 중요성에 대한 문제입니다.\nAJAX 요청에서 `open()` 메서드의 세 번째 매개변수가 `true`인 이유는 무엇인가요?\n\n```javascript\nxhttp.open(\"GET\", \"ajax_test.asp\", true);\n```",
      "option_a": "GET 방식으로 요청하기 위해서",
      "option_b": "보안을 강화하기 위해서",
      "option_c": "비동기적으로 요청을 처리하기 위해서",
      "option_d": "캐시를 사용하기 위해서",
      "correct_answer": "C",
      "explanation": "`open()` 메서드의 세 번째 매개변수는 `async` 파라미터로, `true`는 비동기 요청을 의미합니다. 비동기 요청을 사용하면 JavaScript가 서버 응답을 기다리는 동안 다른 스크립트를 실행할 수 있습니다. 만약 `false`(동기)로 설정하면 서버 응답이 준비될 때까지 JavaScript 실행이 중단되어 애플리케이션이 멈추거나 느려질 수 있습니다. 따라서 서버 요청은 항상 비동기적으로 보내는 것이 권장됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:24:32.000Z"
    },
    {
      "id": 746,
      "subject_id": 1,
      "question": "readyState와 status를 활용한 에러 처리에 대한 문제입니다.\n다음 코드에서 빈칸에 들어갈 올바른 조건문은 무엇인가요?\n\n```javascript\nxhttp.onreadystatechange = function() {\n  if (_______ && _______) {\n    document.getElementById(\"demo\").innerHTML = this.responseText;\n  }\n};\n```",
      "option_a": "this.readyState == 3 && this.status == 404",
      "option_b": "this.readyState == 4 && this.status == 200",
      "option_c": "this.readyState == 2 && this.status == 500",
      "option_d": "this.readyState == 1 && this.status == 300",
      "correct_answer": "B",
      "explanation": "`readyState == 4`는 요청이 완료되고 응답이 준비되었음을 의미하며, `status == 200`은 \"OK\" 상태로 요청이 성공했음을 나타냅니다. `onreadystatechange` 이벤트는 readyState가 변경될 때마다 (1-4) 총 4번 호출되므로, 응답이 완전히 준비된 상태(4)이고 성공적으로 처리된 상태(200)일 때만 내용을 업데이트해야 합니다. 다른 readyState 값들: 0(요청 미초기화), 1(서버 연결 설정됨), 2(요청 수신됨), 3(요청 처리 중)을 의미합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T09:25:37.000Z"
    },
    {
      "id": 747,
      "subject_id": 1,
      "question": "GET과 POST 방식의 차이점과 적절한 사용법에 대한 문제입니다.\n다음 중 POST 방식을 반드시 사용해야 하는 경우가 아닌 것은?",
      "option_a": "서버의 파일이나 데이터베이스를 업데이트할 때",
      "option_b": "대용량 데이터를 서버로 전송할 때",
      "option_c": "단순히 서버에서 정보를 조회할 때",
      "option_d": "사용자 입력 데이터(알 수 없는 문자 포함)를 전송할 때",
      "correct_answer": "C",
      "explanation": "단순히 서버에서 정보를 조회하는 경우에는 GET 방식을 사용하는 것이 적절합니다. GET은 더 간단하고 빠르며, 대부분의 경우에 사용할 수 있습니다. POST를 사용해야 하는 경우는: ① 캐시된 파일이 옵션이 아닌 경우(서버의 파일이나 데이터베이스 업데이트), ② 서버로 대용량 데이터를 전송하는 경우(POST는 크기 제한이 없음), ③ 사용자 입력을 전송하는 경우(알 수 없는 문자가 포함될 수 있어 POST가 더 안전함)입니다. GET은 URL에 정보가 노출되고 길이 제한이 있지만, 단순 조회에는 효율적입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T09:26:13.000Z"
    },
    {
      "id": 748,
      "subject_id": 1,
      "question": "XML 응답 처리의 기본 개념에 대한 문제입니다.\nAJAX로 XML 파일을 가져온 후, XML 데이터에 접근하기 위해 사용하는 속성은 무엇인가요?",
      "option_a": "responseText",
      "option_b": "responseXML",
      "option_c": "responseData",
      "option_d": "responseHTML",
      "correct_answer": "B",
      "explanation": "XML 파일을 처리할 때는 `responseXML` 속성을 사용합니다. 이 속성은 서버 응답을 XML DOM 객체로 반환하여, `getElementsByTagName()` 같은 DOM 메서드를 사용해 XML 요소에 접근할 수 있게 해줍니다. `responseText`는 응답을 문자열로 반환하므로 XML 파싱에는 적합하지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T09:28:28.000Z"
    },
    {
      "id": 749,
      "subject_id": 1,
      "question": "실시간 검색 기능 구현에 대한 문제입니다.\n다음 실시간 검색 기능 코드에서 빈칸에 들어갈 올바른 이벤트는 무엇인가요?\n\n```javascript\n<input type=\"text\" _______=\"showHint(this.value)\">\n\nfunction showHint(str) {\n  if (str.length == 0) {\n    document.getElementById(\"txtHint\").innerHTML = \"\";\n    return;\n  }\n  // AJAX 코드...\n}\n```",
      "option_a": "onclick",
      "option_b": "onchange",
      "option_c": "onkeyup",
      "option_d": "onload",
      "correct_answer": "C",
      "explanation": "실시간 검색 기능에서는 사용자가 키보드를 누를 때마다 즉시 서버에 요청을 보내야 하므로 `onkeyup` 이벤트를 사용합니다. `onclick`은 클릭할 때만, `onchange`는 포커스가 벗어날 때만 실행되어 실시간 효과를 낼 수 없습니다. `onkeyup`을 사용하면 사용자가 타이핑할 때마다 함수가 호출되어 즉시 검색 결과를 보여줄 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:29:39.000Z"
    },
    {
      "id": 750,
      "subject_id": 1,
      "question": "XML 데이터 파싱에 대한 문제입니다.\n다음 코드에서 XML의 ARTIST 요소 값을 가져오는 올바른 방법은?\n\n```javascript\nconst xmlDoc = xhttp.responseXML;\nconst x = xmlDoc.getElementsByTagName(\"CD\");\n// 첫 번째 CD의 ARTIST 값을 가져오려면?\n```",
      "option_a": "x[0].ARTIST.value",
      "option_b": "x[0].getElementsByTagName(\"ARTIST\")[0].nodeValue",
      "option_c": "x[0].getElementsByTagName(\"ARTIST\")[0].childNodes[0].nodeValue",
      "option_d": "x[0].getElementsByTagName(\"ARTIST\").textContent",
      "correct_answer": "C",
      "explanation": "XML에서 요소의 텍스트 값을 가져오려면 `getElementsByTagName(\"ARTIST\")[0].childNodes[0].nodeValue`를 사용해야 합니다. 이는 DOM의 구조 때문입니다: `getElementsByTagName()`으로 요소를 찾고, `[0]`으로 첫 번째 요소를 선택한 후, `childNodes[0]`으로 텍스트 노드에 접근하고, `nodeValue`로 실제 텍스트 값을 가져옵니다. 이는 XML DOM에서 텍스트가 별도의 노드로 저장되기 때문입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:30:46.000Z"
    },
    {
      "id": 751,
      "subject_id": 1,
      "question": "동적 HTML 테이블 생성에 대한 문제입니다.\n다음 코드에서 XML 데이터로 HTML 테이블을 동적으로 생성할 때 빈칸에 들어갈 코드는?\n```javascript\nfunction myFunction(xml) {\n  const xmlDoc = xml.responseXML;\n  const x = xmlDoc.getElementsByTagName(\"CD\");\n  let table = \"<tr><th>Artist</th><th>Title</th></tr>\";\n  \n  for (let i = 0; i < x.length; i++) {\n    table += \"<tr><td>\" +\n    _____________ +\n    \"</td><td>\" +\n    _____________ +\n    \"</td></tr>\";\n  }\n  document.getElementById(\"demo\").innerHTML = table;\n}\n```",
      "option_a": "`x[i].ARTIST`, `x[i].TITLE`",
      "option_b": "`x[i].getElementsByTagName(\"ARTIST\")[0].value`, `x[i].getElementsByTagName(\"TITLE\")[0].value`",
      "option_c": "`x[i].getElementsByTagName(\"ARTIST\")[0].childNodes[0].nodeValue`, `x[i].getElementsByTagName(\"TITLE\")[0].childNodes[0].nodeValue`",
      "option_d": "`x[i].getElementsByTagName(\"ARTIST\").innerHTML`, `x[i].getElementsByTagName(\"TITLE\").innerHTML`",
      "correct_answer": "C",
      "explanation": "XML에서 각 CD 요소의 ARTIST와 TITLE 값을 가져오려면 `getElementsByTagName()`으로 해당 요소를 찾고, `childNodes[0].nodeValue`로 텍스트 값을 추출해야 합니다. 반복문에서 `x[i]`는 각 CD 요소를 나타내므로, 그 안에서 다시 `getElementsByTagName()`을 사용하여 자식 요소들을 찾아야 합니다. 이 방식으로 XML 데이터를 HTML 테이블 형태로 변환할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T09:32:02.000Z"
    },
    {
      "id": 752,
      "subject_id": 1,
      "question": "데이터베이스 연동 및 SQL 인젝션 방지에 대한 문제입니다.\n다음 PHP 코드에서 SQL 인젝션 공격을 방지하기 위해 사용된 기법은 무엇인가요?\n\n```php\n$sql = \"SELECT customerid, companyname FROM customers WHERE customerid = ?\";\n$stmt = $mysqli->prepare($sql);\n$stmt->bind_param(\"s\", $_GET['q']);\n$stmt->execute();\n```",
      "option_a": "SQL 쿼리 암호화",
      "option_b": "Prepared Statement (준비된 문장)",
      "option_c": "데이터베이스 접근 권한 제한",
      "option_d": "입력값 길이 제한",
      "correct_answer": "B",
      "explanation": "이 코드는 Prepared Statement(준비된 문장) 기법을 사용하여 SQL 인젝션을 방지합니다. `prepare()`로 SQL 문을 미리 준비하고, `?` 플레이스홀더를 사용한 후, `bind_param()`으로 실제 값을 안전하게 바인딩합니다. 이 방식은 사용자 입력을 SQL 쿼리와 분리하여 처리하므로, 악의적인 SQL 코드가 삽입되어도 실행되지 않습니다. \"s\"는 문자열 타입을 의미하며, `$_GET['q']` 값이 안전하게 바인딩됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T09:32:58.000Z"
    },
    {
      "id": 753,
      "subject_id": 1,
      "question": "JSON의 기본 개념에 대한 문제입니다.\nJSON은 무엇의 줄임말인가요?",
      "option_a": "Java Standard Object Notation",
      "option_b": "JavaScript Object Notation",
      "option_c": "JavaScript Simple Object Notation",
      "option_d": "Java Syntax Object Notation",
      "correct_answer": "B",
      "explanation": "JSON은 \"JavaScript Object Notation\"의 줄임말입니다. JSON은 데이터를 저장하고 전송하기 위한 텍스트 형식으로, JavaScript 객체 표기법에서 파생되었습니다. 하지만 JSON은 언어 독립적이어서 JavaScript뿐만 아니라 다양한 프로그래밍 언어에서 사용할 수 있습니다. JSON은 \"자기 서술적(self-describing)\"이고 이해하기 쉬운 특징을 가지고 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T09:34:44.000Z"
    },
    {
      "id": 754,
      "subject_id": 1,
      "question": "JSON 문법 규칙에 대한 문제입니다.\n다음 중 유효한 JSON 형식은 무엇인가요?",
      "option_a": "{name: \"John\", age: 30}",
      "option_b": "{\"name\": \"John\", \"age\": 30}",
      "option_c": "{name: 'John', age: 30}",
      "option_d": "{\"name\": John, \"age\": 30}",
      "correct_answer": "B",
      "explanation": "JSON에서는 키(key)와 문자열 값 모두 반드시 쌍따옴표(\")로 감싸야 합니다. 1번과 3번은 키에 쌍따옴표가 없고, 3번은 문자열 값에 작은따옴표를 사용했으므로 틀렸습니다. 4번은 문자열 값에 따옴표가 없어서 틀렸습니다. JavaScript 객체에서는 키에 따옴표가 없어도 되고 문자열에 작은따옴표도 사용할 수 있지만, JSON은 더 엄격한 문법 규칙을 따릅니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:35:16.000Z"
    },
    {
      "id": 755,
      "subject_id": 1,
      "question": "JavaScript 객체 접근 방법에 대한 문제입니다.\n다음 코드에서 빈칸에 들어갈 수 있는 것은? (두 가지 모두 올바른 답을 선택하세요)\n\n```javascript\nconst person = {name: \"John\", age: 30, city: \"New York\"};\nconsole.log(person._____); // \"John\" 출력\nconsole.log(person._____); // \"John\" 출력\n```",
      "option_a": "name, [\"name\"]",
      "option_b": ".name, ['name']",
      "option_c": "->name, [\"name\"]",
      "option_d": "name(), \"name\"",
      "correct_answer": "A",
      "explanation": "JavaScript에서 객체의 속성에 접근하는 방법은 두 가지입니다: 점 표기법(`person.name`)과 대괄호 표기법(`person[\"name\"]`). 점 표기법은 속성 이름이 유효한 식별자일 때 사용하며, 대괄호 표기법은 속성 이름에 공백이나 특수문자가 있거나 변수로 접근할 때 유용합니다. 대괄호 안의 속성 이름은 문자열이므로 따옴표로 감싸야 하며, 작은따옴표와 쌍따옴표 모두 사용 가능합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:36:14.000Z"
    },
    {
      "id": 756,
      "subject_id": 1,
      "question": "JSON과 XML 비교에 대한 문제입니다.\n다음 JSON 데이터와 동일한 정보를 담고 있는 XML은?\n\n```json\n{\"employees\": [\n  {\"firstName\": \"John\", \"lastName\": \"Doe\"},\n  {\"firstName\": \"Anna\", \"lastName\": \"Smith\"}\n]}\n```",
      "option_a": "```xml\n<employees>\n  <firstName>John</firstName><lastName>Doe</lastName>\n  <firstName>Anna</firstName><lastName>Smith</lastName>\n</employees>\n```",
      "option_b": "```xml\n<employees>\n  <employee firstName=\"John\" lastName=\"Doe\"/>\n  <employee firstName=\"Anna\" lastName=\"Smith\"/>\n</employees>\n```",
      "option_c": "```xml\n<employees>\n  <employee>\n    <firstName>John</firstName><lastName>Doe</lastName>\n  </employee>\n  <employee>\n    <firstName>Anna</firstName><lastName>Smith</lastName>\n  </employee>\n</employees>\n```",
      "option_d": "```xml\n<employees>\n  John Doe, Anna Smith\n</employees>\n```",
      "correct_answer": "C",
      "explanation": "JSON의 배열 구조를 XML로 정확히 표현하려면 각 배열 요소를 별도의 XML 요소로 표현해야 합니다. JSON에서 `employees` 배열의 각 객체는 XML에서 `<employee>`요소가 되고, 각 객체의 속성들(`firstName`, `lastName`)은 해당 요소의 자식 요소가 됩니다. 1번은 배열 구조가 없고, 2번은 속성(attribute)으로 표현했으므로 구조가 다르며, 4번은 단순 텍스트로 구조 정보가 손실됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T09:38:46.000Z"
    },
    {
      "id": 757,
      "subject_id": 1,
      "question": "JSON의 장점과 사용법에 대한 문제입니다.\nAJAX 애플리케이션에서 JSON이 XML보다 유리한 이유로 가장 적절하지 않은 것은?",
      "option_a": "JSON은 XML보다 파싱이 쉽다",
      "option_b": "JSON은 JavaScript의 내장 함수로 파싱할 수 있다",
      "option_c": "JSON은 XML보다 데이터 크기가 작다",
      "option_d": "JSON은 XML보다 더 많은 데이터 타입을 지원한다",
      "correct_answer": "D",
      "explanation": "JSON이 XML보다 더 많은 데이터 타입을 지원한다는 것은 틀린 설명입니다. 실제로 JSON은 제한된 데이터 타입만 지원합니다: 문자열, 숫자, 객체, 배열, 불린(true/false), null. 반면 XML은 더 유연한 데이터 표현이 가능합니다. JSON의 실제 장점들은: 1) XML DOM 파서가 필요한 XML과 달리 `JSON.parse()` 같은 표준 JavaScript 함수로 쉽게 파싱 가능, 2) 끝 태그가 없어서 더 간결하고 빠른 읽기/쓰기 가능, 3) 불필요한 태그가 없어 데이터 크기가 작음 등입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T09:39:36.000Z"
    },
    {
      "id": 758,
      "subject_id": 1,
      "question": "JSON에서 사용할 수 있는 데이터 타입이 아닌 것은?",
      "option_a": "string (문자열)",
      "option_b": "number (숫자)",
      "option_c": "function (함수)",
      "option_d": "boolean (불린)",
      "correct_answer": "C",
      "explanation": "JSON은 JavaScript Object Notation의 약자이지만, JavaScript의 모든 데이터 타입을 지원하지는 않습니다. JSON에서 사용할 수 있는 데이터 타입은 다음과 같습니다:\n\n• string (문자열) - 반드시 큰따옴표로 묶어야 함\n• number (숫자) - 정수 또는 소수\n• object (객체) - JSON 객체\n• array (배열)\n• boolean (true/false)\n• null\n\n반면 function, undefined, Date 객체는 JSON에서 직접 지원하지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T09:45:48.000Z"
    },
    {
      "id": 759,
      "subject_id": 1,
      "question": "다음 JSON 문자열 중 올바른 형식은?",
      "option_a": "{'name': 'John', 'age': 30}",
      "option_b": "{\"name\":\"John\", \"age\":30}",
      "option_c": "{name: \"John\", age: 30}",
      "option_d": "{\"name\":\"John\", \"age\":30,}",
      "correct_answer": "B",
      "explanation": "JSON에서는 다음 규칙을 반드시 지켜야 합니다:\n\n• 문자열은 반드시 **큰따옴표(\"\")**를 사용해야 합니다 (작은따옴표 불가)\n• 속성명(키)도 반드시 큰따옴표로 묶어야 합니다\n• 마지막 속성 뒤에 쉼표를 붙이면 안 됩니다\n\n1번은 작은따옴표를 사용했고, 3번은 속성명에 따옴표가 없으며, 4번은 마지막에 불필요한 쉼표가 있어서 모두 잘못된 형식입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T09:47:45.000Z"
    },
    {
      "id": 760,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\nconst jsonString = '{\"name\":\"John\", \"age\":30, \"city\":\"New York\"}';\nconst obj = JSON._______(jsonString);\nconsole.log(obj.name); // \"John\" 출력\n```",
      "option_a": "stringify",
      "option_b": "parse",
      "option_c": "convert",
      "option_d": "decode",
      "correct_answer": "B",
      "explanation": "• `JSON.parse()`: JSON 문자열을 JavaScript 객체로 변환할 때 사용\n• `JSON.stringify()`: JavaScript 객체를 JSON 문자열로 변환할 때 사용\n\n이 코드에서는 JSON 문자열(`jsonString`)을 JavaScript 객체로 변환하여 `obj.name`으로 접근할 수 있게 만들어야 하므로 `JSON.parse()`를 사용해야 합니다.\n\n기억하는 팁: \"parse\"는 \"분석하다\"라는 뜻으로, 문자열을 분석해서 객체로 만든다고 생각하면 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:49:27.000Z"
    },
    {
      "id": 761,
      "subject_id": 1,
      "question": "다음 코드에서 `JSON.parse()`에 reviver 함수를 사용하는 목적은?\n\n```javascript\nconst text = '{\"name\":\"John\", \"birth\":\"1986-12-14\", \"city\":\"New York\"}';\nconst obj = JSON.parse(text, function (key, value) {\n    if (key == \"birth\") {\n        return new Date(value);\n    } else {\n        return value;\n    }\n});\n```",
      "option_a": "JSON 파싱 속도를 향상시키기 위해",
      "option_b": "특정 속성의 값을 원하는 타입으로 변환하기 위해",
      "option_c": "파싱 과정에서 오류를 방지하기 위해",
      "option_d": "JSON 문자열의 형식을 검증하기 위해",
      "correct_answer": "B",
      "explanation": "`JSON.parse()`의 두 번째 매개변수인 reviver 함수는 파싱 과정에서 각 속성값을 변환할 수 있게 해줍니다.\n\n이 예제에서는:\n\n• JSON에서는 Date 객체를 직접 표현할 수 없어서 문자열(\"1986-12-14\")로 저장됩니다\n• reviver 함수를 통해 \"birth\" 속성의 문자열 값을 실제 Date 객체로 변환합니다\n• 다른 속성들은 그대로 반환합니다\n\n이렇게 하면 `obj.birth`는 문자열이 아닌 실제 Date 객체가 되어 날짜 관련 메서드들을 사용할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T09:50:57.000Z"
    },
    {
      "id": 762,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 올바른 것은?\n```javascript\nconst obj = {\n    name: \"John\", \n    age: function() {return 30;}, \n    city: \"New York\",\n    birth: new Date(\"1986-12-14\")\n};\nconst jsonString = JSON.stringify(obj);\nconsole.log(jsonString);\n```",
      "option_a": "`{\"name\":\"John\",\"age\":\"function() {return 30;}\",\"city\":\"New York\",\"birth\":\"1986-12-14T00:00:00.000Z\"}`",
      "option_b": "`{\"name\":\"John\",\"city\":\"New York\",\"birth\":\"1986-12-14T00:00:00.000Z\"}`",
      "option_c": "`{\"name\":\"John\",\"age\":30,\"city\":\"New York\",\"birth\":\"1986-12-14\"}`",
      "option_d": "오류 발생",
      "correct_answer": "B",
      "explanation": "`JSON.stringify()`는 JavaScript 객체를 JSON 문자열로 변환할 때 다음과 같은 규칙을 적용합니다:\n\n1. 함수는 완전히 제거됩니다: `age` 속성의 함수는 키와 값 모두 JSON 문자열에서 사라집니다.\n\n2. Date 객체는 문자열로 변환됩니다: `new Date(\"1986-12-14\")`는 ISO 8601 형식의 문자열 `\"1986-12-14T00:00:00.000Z\"`로 변환됩니다.\n\n3. 일반 속성은 그대로 유지됩니다: `name`과 `city`는 그대로 포함됩니다.\n\n따라서 결과는 `age` 속성이 없고, `birth`가 ISO 날짜 문자열로 변환된 형태가 됩니다.\n\n중요한 점: 함수를 JSON에 포함시키려면 `JSON.stringify()` 호출 전에 `obj.age = obj.age.toString()`처럼 미리 문자열로 변환해야 하지만, 이 경우 나중에 다시 함수로 사용하려면 `eval()`을 써야 하므로 권장되지 않습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T09:53:08.000Z"
    },
    {
      "id": 763,
      "subject_id": 1,
      "question": "JSON과 JavaScript 객체의 차이점에 대한 설명으로 올바른 것은?",
      "option_a": "JSON은 JavaScript 객체와 완전히 동일하다",
      "option_b": "JSON은 문자열 형태이고, JavaScript 객체는 실제 객체이다",
      "option_c": "JSON은 함수를 포함할 수 있지만, JavaScript 객체는 포함할 수 없다",
      "option_d": "JSON과 JavaScript 객체는 모두 문자열 형태이다",
      "correct_answer": "B",
      "explanation": "이것은 JSON을 이해하는 데 매우 중요한 개념입니다.\n\n• JSON: 문자열 형태의 데이터 포맷입니다. 예: `'{\"name\":\"John\", \"age\":30}'`\n• JavaScript 객체: 메모리에 존재하는 실제 객체입니다. 예: `{name:\"John\", age:30}`\n\nJSON은 \"JavaScript Object Notation\"의 약자이지만, JSON 자체는 문자열입니다. 데이터가 JSON 형태일 때만 JSON이라고 부를 수 있습니다. JavaScript 변수로 변환되면 그것은 JavaScript 객체가 됩니다.\n\n흔한 실수: \"JSON 객체\"라고 부르는 것은 잘못된 표현입니다. 정확히는 \"JSON 문자열\" 또는 \"JSON 형태의 데이터\"라고 해야 합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T09:57:29.000Z"
    },
    {
      "id": 764,
      "subject_id": 1,
      "question": "다음 코드의 빈칸에 들어갈 올바른 접근 방법 두 가지는?\n\n```javascript\nconst myJSON = '{\"name\":\"John\", \"age\":30, \"car\":null}';\nconst myObj = JSON.parse(myJSON);\n\n// 방법 1: x = myObj._______;\n// 방법 2: x = myObj_______;\n```",
      "option_a": "`name` / `[name]`",
      "option_b": "`name` / `[\"name\"]`",
      "option_c": "`\"name\"` / `[\"name\"]`",
      "option_d": "`name` / `('name')`",
      "correct_answer": "B",
      "explanation": "JavaScript에서 객체의 속성에 접근하는 방법은 두 가지입니다:\n\n1. 점 표기법 (Dot notation): `myObj.name`\n\n• 속성명을 직접 작성 (따옴표 없음)\n• 간단하고 읽기 쉬움\n\n2. 괄호 표기법 (Bracket notation): `myObj[\"name\"]`\n\n• 속성명을 문자열로 작성 (반드시 따옴표 필요)\n• 동적 속성 접근이나 특수문자가 포함된 속성명에 유용\n\n잘못된 예시들:\n\n• `myObj[name]` → `name`이라는 변수를 찾게 됨\n• `myObj[\"name\"]`에서 `myObj('name')` → 함수 호출 문법으로 오류 발생",
      "difficulty": "easy",
      "created_at": "2025-08-08T09:59:30.000Z"
    },
    {
      "id": 765,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과는?\n\n```javascript\nconst myJSON = '{\"name\":\"John\", \"age\":30, \"car\":null}';\nconst myObj = JSON.parse(myJSON);\nlet text = \"\";\nfor (const x in myObj) {\n    text += x + \", \";\n}\nconsole.log(text);\n```",
      "option_a": "John, 30, null,",
      "option_b": "name, age, car,",
      "option_c": "\"name\", \"age\", \"car\",",
      "option_d": "John, 30,",
      "correct_answer": "B",
      "explanation": "`for...in` 루프는 객체의 **속성명(키)**을 순회합니다.\n\n코드 분석:\n\n• `myObj`는 `{name:\"John\", age:30, car:null}` 객체\n• `for (const x in myObj)`에서 `x`는 각 속성명을 나타냄\n• 첫 번째 반복: `x = \"name\"` → `text = \"name, \"`\n• 두 번째 반복: `x = \"age\"` → `text = \"name, age, \"`\n• 세 번째 반복: `x = \"car\"` → `text = \"name, age, car, \"`\n\n속성값을 얻으려면:\n```javascript\nfor (const x in myObj) {\n    text += myObj[x] + \", \";  // 괄호 표기법 사용\n}\n// 결과: \"John, 30, null,\"\n```\n\n핵심 포인트: `for...in`에서는 반드시 괄호 표기법(`myObj[x]`)을 사용해야 속성값에 접근할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T10:01:47.000Z"
    },
    {
      "id": 766,
      "subject_id": 1,
      "question": "다음 코드에서 `myObj.cars[1]`의 값은?\n\n```javascript\nconst myJSON = '{\"name\":\"John\", \"age\":30, \"cars\":[\"Ford\", \"BMW\", \"Fiat\"]}';\nconst myObj = JSON.parse(myJSON);\n```",
      "option_a": "Ford",
      "option_b": "BMW",
      "option_c": "Fiat",
      "option_d": "undefined",
      "correct_answer": "B",
      "explanation": "이 문제는 JSON 내부의 배열과 배열 인덱스 개념을 다룹니다.\n\nJSON 구조 분석:\n```javascript\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"cars\": [\"Ford\", \"BMW\", \"Fiat\"]  // 배열\n}\n```\n배열 인덱스 이해:\n\n• 배열의 인덱스는 0부터 시작\n• `cars[0]` = `\"Ford\"`\n• `cars[1]` = `\"BMW\"` ← 정답\n• `cars[2]` = `\"Fiat\"`\n\n접근 순서:\n\n1. `myObj.cars` → 배열 `[\"Ford\", \"BMW\", \"Fiat\"]`에 접근\n2. `[1]` → 배열의 두 번째 요소(인덱스 1)에 접근\n3. 결과: `\"BMW\"`\n\n실제 사용 예시: JSON에서 객체 안에 배열이 포함된 형태는 매우 흔합니다. 예를 들어, 사용자의 취미 목록, 주문 상품 목록 등에서 자주 볼 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T10:03:53.000Z"
    },
    {
      "id": 767,
      "subject_id": 1,
      "question": "다음 두 코드의 실행 결과를 비교했을 때 올바른 설명은?\n\n코드 A:\n```javascript\nconst myJSON = '{\"name\":\"John\", \"age\":30, \"cars\":[\"Ford\", \"BMW\", \"Fiat\"]}';\nconst myObj = JSON.parse(myJSON);\nlet text = \"\";\nfor (let i in myObj.cars) {\n    text += myObj.cars[i] + \" \";\n}\n```\n\n코드 B:\n```javascript\nconst myJSON = '{\"name\":\"John\", \"age\":30, \"cars\":[\"Ford\", \"BMW\", \"Fiat\"]}';\nconst myObj = JSON.parse(myJSON);\nlet text = \"\";\nfor (let i = 0; i < myObj.cars.length; i++) {\n    text += myObj.cars[i] + \" \";\n}\n```",
      "option_a": "코드 A만 올바르게 작동한다",
      "option_b": "코드 B만 올바르게 작동한다",
      "option_c": "둘 다 같은 결과를 출력하지만, 코드 B가 더 명확하다",
      "option_d": "둘 다 다른 결과를 출력한다",
      "correct_answer": "C",
      "explanation": "이 문제는 배열 순회의 두 가지 방법을 비교합니다.\n\n코드 A 분석 (`for...in` 루프):\n\n• `for (let i in myObj.cars)`에서 `i`는 배열의 인덱스(문자열)\n• `i = \"0\"`, `\"1\"`, `\"2\"` 순으로 순회\n• `myObj.cars[i]`로 각 요소에 접근\n• 결과: `\"Ford BMW Fiat \"`\n\n코드 B 분석 (전통적인 `for` 루프):\n\n• `for (let i = 0; i < myObj.cars.length; i++)`에서 `i`는 숫자\n• `i = 0, 1, 2` 순으로 순회\n• `myObj.cars[i]`로 각 요소에 접근\n• 결과: `\"Ford BMW Fiat \"`\n\n왜 코드 B가 더 명확한가?\n\n• 배열 순회 시 전통적인 `for` 루프가 의도를 더 명확하게 표현\n• 숫자 인덱스를 직접 사용하여 배열 특성에 더 적합\n• 대부분의 개발자들이 선호하는 방식\n\n현대적 대안:\n```javascript\n// ES6+ 방법들\nmyObj.cars.forEach(car => text += car + \" \");\n// 또는\nfor (const car of myObj.cars) {\n    text += car + \" \";\n}\n```",
      "difficulty": "hard",
      "created_at": "2025-08-08T10:07:12.000Z"
    },
    {
      "id": 768,
      "subject_id": 1,
      "question": "서버에서 받은 JSON 데이터를 JavaScript 객체로 변환할 때 사용하는 메서드는?",
      "option_a": "JSON.stringify()",
      "option_b": "JSON.parse()",
      "option_c": "JSON.convert()",
      "option_d": "JSON.decode()",
      "correct_answer": "B",
      "explanation": "웹 개발에서 가장 기본적인 JSON 처리 패턴입니다.\n\n데이터 흐름:\n\n• 서버 → 클라이언트: JSON 문자열 → `JSON.parse()` → JavaScript 객체\n• 클라이언트 → 서버: JavaScript 객체 → `JSON.stringify()` → JSON 문자열\n\n실제 사용 예시:\n```javascript\n// 서버에서 받은 JSON 문자열\nconst jsonFromServer = '{\"name\":\"John\", \"age\":31}';\n\n// JavaScript 객체로 변환\nconst userObj = JSON.parse(jsonFromServer);\nconsole.log(userObj.name); // \"John\"\n```\n\n왜 parse인가?\n\"Parse\"는 \"분석하다\"라는 뜻으로, 문자열을 분석해서 데이터 구조로 만든다는 의미입니다. 서버에서 받은 데이터는 항상 문자열이므로, 이를 JavaScript에서 사용할 수 있는 객체로 변환하려면 `JSON.parse()`가 필요합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T10:11:46.000Z"
    },
    {
      "id": 769,
      "subject_id": 1,
      "question": "다음 코드에서 서버로 데이터를 전송하기 위해 빈칸에 들어갈 메서드는?\n\n```javascript\nconst myObj = {name: \"John\", age: 31, city: \"New York\"};\nconst myJSON = JSON._______(myObj);\nwindow.location = \"demo.php?x=\" + myJSON;\n```",
      "option_a": "parse",
      "option_b": "stringify",
      "option_c": "encode",
      "option_d": "convert",
      "correct_answer": "B",
      "explanation": "클라이언트에서 서버로 데이터를 보낼 때의 필수 과정입니다.\n\n전송 과정:\n\n1. JavaScript 객체 생성: `{name: \"John\", age: 31, city: \"New York\"}`\n2. JSON 문자열로 변환: `JSON.stringify()` 사용\n3. URL 파라미터로 전송: `\"?x=\" + myJSON`\n\nstringify의 결과:\n```javascript\nconst myObj = {name: \"John\", age: 31, city: \"New York\"};\nconst myJSON = JSON.stringify(myObj);\nconsole.log(myJSON); \n// 출력: '{\"name\":\"John\",\"age\":31,\"city\":\"New York\"}'\n```\n\n왜 stringify가 필요한가?\n\n• 웹에서 데이터 전송은 문자열로만 가능\n• JavaScript 객체는 그대로 전송할 수 없음\n• `JSON.stringify()`로 객체를 문자열로 \"직렬화(serialization)\" 필요\n\n실제 URL 예시: `demo.php?x={\"name\":\"John\",\"age\":31,\"city\":\"New York\"}`",
      "difficulty": "easy",
      "created_at": "2025-08-08T10:13:49.000Z"
    },
    {
      "id": 770,
      "subject_id": 1,
      "question": "XMLHttpRequest를 사용하여 서버에서 JSON 데이터를 가져오는 코드입니다. 빈칸에 들어갈 올바른 코드는?\n\n```javascript\nconst xmlhttp = new XMLHttpRequest();\nxmlhttp.onload = function() {\n    const myObj = JSON.parse(_______);\n    document.getElementById(\"demo\").innerHTML = myObj.name;\n};\nxmlhttp.open(\"GET\", \"data.json\");\nxmlhttp.send();\n```",
      "option_a": "xmlhttp.responseText",
      "option_b": "this.responseText",
      "option_c": "xmlhttp.response",
      "option_d": "this.response",
      "correct_answer": "B",
      "explanation": "AJAX 통신에서 서버 응답을 처리하는 핵심 패턴입니다.\n\nXMLHttpRequest 응답 처리:\n\n• `onload` 함수는 서버 응답이 완료됐을 때 실행\n• `this`는 `xmlhttp` 객체를 가리킴\n• `responseText`는 서버에서 받은 문자열 형태의 응답\n\n다른 옵션들과의 차이:\n\n1. `xmlhttp.responseText` ✅ (동일하게 작동하지만 this 사용이 일반적)\n2. `this.responseText` ✅ (정답 - 가장 일반적인 패턴)\n3. `xmlhttp.response` ❌ (JSON 파싱이 안 된 상태)\n4. `this.response` ❌ (JSON 파싱이 안 된 상태)\n\n전체 동작 과정:\n\n1. `xmlhttp.send()` → 서버에 요청 전송\n2. 서버가 JSON 문자열로 응답\n3. `onload`함수 실행\n4. `this.responseText`로 응답 문자열 가져오기\n5. `JSON.parse()`로 JavaScript 객체 변환\n6. 객체의 속성 사용\n\n현대적 대안 (Fetch API):\n```javascript\nfetch(\"data.json\")\n  .then(response => response.json())\n  .then(data => console.log(data.name));\n```",
      "difficulty": "medium",
      "created_at": "2025-08-08T10:16:12.000Z"
    },
    {
      "id": 771,
      "subject_id": 1,
      "question": "서버에서 배열 형태의 JSON을 받았을 때의 처리 방법으로 올바른 것은?\n\n```javascript\n// 서버 응답: '[\"Ford\", \"BMW\", \"Fiat\"]'\nconst xmlhttp = new XMLHttpRequest();\nxmlhttp.onload = function() {\n    const myArr = JSON.parse(this.responseText);\n    document.getElementById(\"demo\").innerHTML = _______;\n};\n```",
      "option_a": "myArr.name",
      "option_b": "myArr[0]",
      "option_c": "myArr.length",
      "option_d": "myArr.first",
      "correct_answer": "B",
      "explanation": "JSON 배열과 JSON 객체의 처리 방식 차이를 이해하는 중요한 문제입니다.\n\nJSON 데이터 타입별 처리:\n\n객체인 경우:\n```javascript\n// 서버 응답: '{\"name\":\"John\", \"age\":30}'\nconst myObj = JSON.parse(responseText);\nconsole.log(myObj.name); // \"John\" - 속성명으로 접근\n```\n\n배열인 경우:\n```javascript\n// 서버 응답: '[\"Ford\", \"BMW\", \"Fiat\"]'\nconst myArr = JSON.parse(responseText);\nconsole.log(myArr[0]); // \"Ford\" - 인덱스로 접근\nconsole.log(myArr.length); // 3 - 배열 길이\n```\n\n각 옵션 분석:\n\n1. `myArr.name` ❌ - 배열에는 name 속성이 없음\n2. `myArr[0]` ✅ - 첫 번째 요소 \"Ford\"를 반환\n3. `myArr.length` ⚠️ - 배열 길이(3)를 반환하지만, 요소 값은 아님\n4. `myArr.first` ❌ - JavaScript 배열에는 first 속성이 없음\n\n실제 활용 예시:\n```javascript\n// 모든 요소 출력\nfor (let i = 0; i < myArr.length; i++) {\n    console.log(myArr[i]);\n}\n\n// 또는 forEach 사용\nmyArr.forEach(car => console.log(car));\n```",
      "difficulty": "medium",
      "created_at": "2025-08-08T10:18:15.000Z"
    },
    {
      "id": 772,
      "subject_id": 1,
      "question": "다음은 POST 방식으로 JSON 데이터를 서버에 전송하는 코드입니다. 빈칸에 들어갈 올바른 조합은?\n\n```javascript\nconst dbParam = JSON.stringify({\"limit\":10});\nconst xmlhttp = new XMLHttpRequest();\nxmlhttp.onload = function() {\n    const myObj = JSON.parse(this.responseText);\n    // 응답 처리 코드\n};\nxmlhttp.open(\"POST\", \"server.php\");\nxmlhttp.setRequestHeader(\"Content-type\", \"_______\");\nxmlhttp.send(\"_______\");\n```",
      "option_a": "`\"application/json\"` / `dbParam`",
      "option_b": "`\"application/x-www-form-urlencoded\"` / `\"x=\" + dbParam`",
      "option_c": "`\"text/plain\"` / `dbParam`",
      "option_d": "`\"multipart/form-data\"` / `\"data=\" + dbParam`",
      "correct_answer": "B",
      "explanation": "POST 방식은 AJAX 통신에서 가장 복잡하지만 실무에서 자주 사용되는 패턴입니다.\n\nPOST vs GET 비교:\n\nGET 방식 (URL 파라미터):\n```javascript\nxmlhttp.open(\"GET\", \"server.php?x=\" + dbParam);\nxmlhttp.send(); // 빈 send()\n```\n\nPOST 방식 (요청 본문에 데이터):\n```javascript\nxmlhttp.open(\"POST\", \"server.php\");\nxmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\nxmlhttp.send(\"x=\" + dbParam); // 데이터를 send()에 포함\n```\n\nContent-Type 헤더의 중요성:\n\n• `application/x-www-form-urlencoded`: HTML 폼과 같은 형태\n• 서버에서 `$_POST[\"x\"]`로 데이터 접근 가능\n• 데이터 형태: `\"x=\" + dbParam` → `\"x={\"limit\":10}\"`\n\n다른 옵션들이 틀린 이유:\n\n• `application/json` + `dbParam`: 서버에서 `$_POST`로 접근 불가\n• `text/plain`: 일반 텍스트로 전송, 서버 처리 어려움\n• `multipart/form-data`: 파일 업로드용, 여기서는 부적절\n\n서버 측 PHP 처리:\n```php\n// GET: $_GET[\"x\"]\n// POST: $_POST[\"x\"]\n$obj = json_decode($_POST[\"x\"], false);\necho \"Limit: \" . $obj->limit; // 10\n```\n\n실제 전송되는 데이터:\n\n• 요청 헤더: `Content-Type: application/x-www-form-urlencoded`\n• 요청 본문: `x={\"limit\":10}`\n\n왜 POST를 사용하는가?\n\n• 보안: URL에 데이터가 노출되지 않음\n• 용량: 큰 데이터도 전송 가능 (GET은 URL 길이 제한)\n• 의미: 서버 상태를 변경하는 작업에 적합",
      "difficulty": "hard",
      "created_at": "2025-08-08T10:22:39.000Z"
    },
    {
      "id": 773,
      "subject_id": 1,
      "question": "JSON 데이터로 HTML 테이블을 생성하는 코드입니다. 빈칸에 들어갈 올바른 HTML 태그는?\n\n```javascript\nconst myObj = JSON.parse(this.responseText);\nlet text = \"<table border='1'>\";\nfor (let x in myObj) {\n    text += \"_______\" + myObj[x].name + \"_______\";\n}\ntext += \"</table>\";\ndocument.getElementById(\"demo\").innerHTML = text;\n```",
      "option_a": "`<td>` / `</td>`",
      "option_b": "`<tr><td>` / `</td></tr>`",
      "option_c": "`<th>` / `</th>`",
      "option_d": "`<tr>` / `</tr>`",
      "correct_answer": "B",
      "explanation": "HTML 테이블 구조를 이해하는 기본 문제입니다.\n\nHTML 테이블의 기본 구조:\n\n• `<table>`: 테이블 전체를 감싸는 태그\n• `<tr>`: 테이블 행(Table Row)\n• `<td>`: 테이블 데이터 셀(Table Data)\n• `<th>`: 테이블 헤더 셀(Table Header)\n\n올바른 중첩 구조:\n```html\n<table border='1'>\n  <tr><td>Alfreds Futterkiste</td></tr>\n  <tr><td>Ana Trujillo Emparedados</td></tr>\n  <tr><td>Antonio Moreno Taqueria</td></tr>\n</table>\n```\n\n각 옵션 분석:\n\n1. `<td></td>` - 셀만 있고 행이 없어서 잘못된 구조\n2. `<tr><td></td></tr>` ✅ - 올바른 테이블 구조\n3. `<th></th>` - 헤더용이므로 데이터 표시에는 부적절\n4. `<tr></tr>` - 행만 있고 셀이 없어서 데이터가 표시되지 않음\n\n실제 결과: 각 JSON 객체의 name 속성이 테이블의 각 행에 하나씩 표시됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T12:47:00.000Z"
    },
    {
      "id": 774,
      "subject_id": 1,
      "question": "JSON 데이터로 드롭다운 목록(select)을 생성하는 코드입니다. 빈칸에 들어갈 올바른 HTML 태그는?\n\n```javascript\nconst myObj = JSON.parse(this.responseText);\nlet text = \"<select>\";\nfor (let x in myObj) {\n    text += \"_______\" + myObj[x].name + \"_______\";\n}\ntext += \"</select>\";\n```",
      "option_a": "`<li>` / `</li>`",
      "option_b": "`<item>` / `</item>`",
      "option_c": "`<option>` / `</option>`",
      "option_d": "`<choice>` / `</choice>`",
      "correct_answer": "C",
      "explanation": "HTML 드롭다운 목록의 구조를 이해하는 문제입니다.\n\nHTML Select 요소의 구조:\n```html\n<select>\n  <option>첫 번째 선택지</option>\n  <option>두 번째 선택지</option>\n  <option>세 번째 선택지</option>\n</select>\n```\n\n각 태그의 용도:\n\n• `<select>`: 드롭다운 목록 전체를 만드는 컨테이너\n• `<option>`: 각각의 선택 가능한 항목\n• `<li>`: 순서 없는 목록(`<ul>`)에서 사용하는 항목\n• `<item>`, `<choice>`: 존재하지 않는 HTML 태그\n\n실제 생성되는 결과:\n```html\n<select>\n  <option>Alfreds Futterkiste</option>\n  <option>Ana Trujillo Emparedados y helados</option>\n  <option>Antonio Moreno Taqueria</option>\n  ...\n</select>\n```\n\n활용 예시: 서버에서 받은 고객 목록, 제품 목록, 카테고리 목록 등을 드롭다운으로 표시할 때 이 패턴을 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T12:49:34.000Z"
    },
    {
      "id": 775,
      "subject_id": 1,
      "question": "동적 테이블 생성에서 드롭다운 변경 시 실행되는 함수입니다. 빈칸에 들어갈 올바른 코드는?\n\n```javascript\nfunction change_myselect(sel) {\n    const dbParam = JSON.stringify({table: _______, limit: 20});\n    const xmlhttp = new XMLHttpRequest();\n    xmlhttp.onload = function() {\n        const myObj = JSON.parse(this.responseText);\n        // 테이블 생성 코드...\n    };\n    xmlhttp.open(\"POST\", \"server.php\");\n    xmlhttp.send(\"x=\" + dbParam);\n}\n```",
      "option_a": "\"customers\"",
      "option_b": "sel",
      "option_c": "this.value",
      "option_d": "document.getElementById(\"myselect\").value",
      "correct_answer": "B",
      "explanation": "함수 매개변수와 동적 데이터 처리의 핵심 개념입니다.\n\n함수 호출 과정:\n'''html\n<select onchange=\"change_myselect(this.value)\">\n  <option value=\"customers\">Customers</option>\n  <option value=\"products\">Products</option>\n  <option value=\"suppliers\">Suppliers</option>\n</select>\n```\n\n단계별 동작:\n\n1. 사용자가 드롭다운에서 \"products\" 선택\n2. `onchange=\"change_myselect(this.value)\"` 실행\n3. `this.value`는 \"products\"\n4. `change_myselect(\"products\")` 함수 호출\n5. 매개변수 `sel`에 \"products\" 저장\n\n각 옵션 분석:\n\n1. `\"customers\"` - 항상 고정값, 동적 선택 반영 안 됨\n2. `sel` ✅ - 매개변수로 전달받은 선택된 값 사용\n3. `this.value` - 함수 내부에서 `this`는 다른 객체를 가리킴\n4. `document.getElementById(\"myselect\").value` - 작동하지만 불필요하게 복잡\n\n결과적으로 생성되는 JSON:\n```javascript\n// \"products\" 선택 시\n{\"table\": \"products\", \"limit\": 20}\n\n// \"suppliers\" 선택 시  \n{\"table\": \"suppliers\", \"limit\": 20}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-08T12:52:42.000Z"
    },
    {
      "id": 776,
      "subject_id": 1,
      "question": "JSONP의 특징에 대한 설명으로 올바른 것은?",
      "option_a": "XMLHttpRequest 객체를 사용하여 데이터를 요청한다",
      "option_b": "`<script>` 태그를 사용하여 cross-domain 문제를 해결한다",
      "option_c": "JSON 데이터를 직접 반환한다",
      "option_d": "서버와 클라이언트 간 동기 통신을 수행한다",
      "correct_answer": "B",
      "explanation": "JSONP(JSON with Padding)의 핵심 개념과 동작 원리를 이해하는 문제입니다.\n\nJSONP의 등장 배경:\n\n• Cross-Domain Policy: 웹 브라우저의 보안 정책으로 다른 도메인으로의 AJAX 요청 제한\n• 문제 상황: `XMLHttpRequest`로는 다른 도메인의 데이터를 가져올 수 없음\n\nJSONP의 해결 방법:\n```html\n<!-- 일반적인 script 태그는 cross-domain 제한이 없음 -->\n<script src=\"https://other-domain.com/api/data.js\"></script>\n```\n\nJSONP 동작 과정:\n\n1. 클라이언트: `<script>` 태그 동적 생성\n2. 서버: JSON 데이터를 함수 호출 형태로 반환\n3. 결과: 함수가 실행되어 데이터 처리\n\n서버 응답 예시:\n```php\n// 일반 JSON (JSONP 아님)\n{\"name\":\"John\", \"age\":30}\n\n// JSONP 방식\nmyFunc({\"name\":\"John\", \"age\":30});\n```\n\n각 옵션 분석:\n\n1. XMLHttpRequest 사용 ❌ - JSONP는 `<script>` 태그 사용\n2. `<script>` 태그로 cross-domain 해결 ✅ - JSONP의 핵심\n3. JSON 데이터 직접 반환 ❌ - 함수 호출 형태로 반환\n4. 동기 통신 ❌ - 비동기적으로 동작",
      "difficulty": "medium",
      "created_at": "2025-08-08T12:55:03.000Z"
    },
    {
      "id": 777,
      "subject_id": 1,
      "question": "다음 JSONP 구현에서 동적으로 script 태그를 생성하는 코드입니다. 빈칸에 들어갈 올바른 조합은?\n\n```javascript\nfunction clickButton() {\n    let s = document._______(\"script\");\n    s._______ = \"demo_jsonp.php?callback=myDisplayFunction\";\n    document.body._______(s);\n}\n\nfunction myDisplayFunction(myObj) {\n    document.getElementById(\"demo\").innerHTML = myObj.name;\n}\n```",
      "option_a": "`createElement` / `src` / `appendChild`",
      "option_b": "`createNode` / `href` / `addChild`",
      "option_c": "`makeElement` / `url` / `insertChild`",
      "option_d": "`newElement` / `source` / `appendNode`",
      "correct_answer": "A",
      "explanation": "DOM 조작을 통한 동적 JSONP 구현의 핵심 패턴입니다.\n\n동적 Script 태그 생성 과정:\n\n1단계: 요소 생성\n```javascript\nlet s = document.createElement(\"script\");\n// <script></script> 태그 생성\n```\n\n2단계: 속성 설정\n```javascript\ns.src = \"demo_jsonp.php?callback=myDisplayFunction\";\n// <script src=\"demo_jsonp.php?callback=myDisplayFunction\"></script>\n```\n\n3단계: DOM에 추가\n```javascript\ndocument.body.appendChild(s);\n// HTML 문서의 body에 script 태그 삽입\n```\n\n전체 동작 흐름:\n\n1. 버튼 클릭 → `clickButton()` 실행\n2. Script 태그 동적 생성 및 DOM 추가\n3. 브라우저가 `demo_jsonp.php?callback=myDisplayFunction` 요청\n4. 서버가 `myDisplayFunction({...})` 형태로 응답\n5. 함수가 자동 실행되어 데이터 처리\n\n서버 응답 예시:\n```php\n// PHP 파일 (demo_jsonp.php)\n$callback = $_GET['callback']; // \"myDisplayFunction\"\n$data = '{\"name\":\"John\", \"age\":30}';\necho $callback . \"(\" . $data . \");\";\n// 결과: myDisplayFunction({\"name\":\"John\", \"age\":30});\n```\n\n다른 옵션들이 틀린 이유:\n\n• `createNode`, `makeElement`, `newElement`: 존재하지 않는 메서드\n• `href`: 링크용 속성, script에는 `src` 사용\n• `addChild`, `insertChild`, `appendNode`: 존재하지 않는 메서드\n\n현대적 대안:\n```javascript\n// Fetch API with CORS\nfetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data));\n```\n\nJSONP는 과거 cross-domain 문제 해결을 위한 방법이었지만, 현재는 CORS(Cross-Origin Resource Sharing)가 더 안전하고 표준적인 해결책입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T12:59:12.000Z"
    },
    {
      "id": 778,
      "subject_id": 1,
      "question": "ID가 \"myButton\"인 HTML 요소를 찾는 JavaScript 코드는?",
      "option_a": "document.findById(\"myButton\")",
      "option_b": "document.getElementById(\"myButton\")",
      "option_c": "document.selectById(\"myButton\")",
      "option_d": "document.queryById(\"myButton\")",
      "correct_answer": "B",
      "explanation": "DOM에서 ID로 요소를 찾는 가장 기본적인 JavaScript 메서드입니다.\n\n기본 DOM 선택 메서드들:\n```javascript\n// ID로 선택 (하나의 요소 반환)\ndocument.getElementById(\"myButton\")\n\n// 태그명으로 선택 (HTMLCollection 반환)\ndocument.getElementsByTagName(\"p\")\n\n// 클래스명으로 선택 (HTMLCollection 반환)\ndocument.getElementsByClassName(\"intro\")\n\n// CSS 선택자로 선택 (첫 번째 요소만 반환)\ndocument.querySelector(\"#myButton\")\n\n// CSS 선택자로 선택 (모든 일치 요소 반환)\ndocument.querySelectorAll(\"p.intro\")\n```\n\n각 옵션 분석:\n\n1. `findById` - 존재하지 않는 메서드\n2. `getElementById` ✅ - 표준 DOM 메서드\n3. `selectById` - 존재하지 않는 메서드\n4. `queryById` - 존재하지 않는 메서드\n\njQuery와의 비교:\n\n• `jQuery`: `$(\"#myButton\")` - 간단하고 직관적\n• JavaScript: `document.getElementById(\"myButton\")` - 조금 더 길지만 표준\n\n실제 사용 예시:\n```javascript\nconst button = document.getElementById(\"myButton\");\nbutton.innerHTML = \"Click Me!\";\nbutton.style.color = \"red\";\n```",
      "difficulty": "easy",
      "created_at": "2025-08-08T13:05:26.000Z"
    },
    {
      "id": 779,
      "subject_id": 1,
      "question": "다음 jQuery 코드와 같은 기능을 하는 JavaScript 코드는?\n\n```javascript\n// jQuery\nmyElements = $(\"p\");\n\n// JavaScript\nmyElements = document.______(\"p\");\n```",
      "option_a": "getElementsByTag",
      "option_b": "getElementsByTagName",
      "option_c": "getElementByTag",
      "option_d": "selectByTagName",
      "correct_answer": "B",
      "explanation": "태그명으로 요소를 선택하는 JavaScript의 표준 메서드입니다.\n\n태그명 선택 비교:\n\njQuery 방식:\n```javascript\nvar myElements = $(\"p\");  // 모든 <p> 태그 선택\nconsole.log(myElements.length);  // 요소 개수\nconsole.log(myElements[0].innerHTML);  // 첫 번째 요소 내용\n```\n\nJavaScript 방식:\n```javascript\nvar myElements = document.getElementsByTagName(\"p\");\nconsole.log(myElements.length);  // 요소 개수\nconsole.log(myElements[0].innerHTML);  // 첫 번째 요소 내용\n```\n\n반환값의 특징:\n\n• jQuery: jQuery 객체 반환 (jQuery 메서드 사용 가능)\n• JavaScript: HTMLCollection 반환 (배열과 유사하지만 배열은 아님)\n\nHTMLCollection 특성:\n```javascript\nconst paragraphs = document.getElementsByTagName(\"p\");\nconsole.log(paragraphs.length);  // 길이 확인\nconsole.log(paragraphs[0]);  // 인덱스로 접근\n// paragraphs.forEach()  // ❌ 작동하지 않음 (배열이 아니므로)\n\n// 배열로 변환하려면:\nconst paragraphArray = Array.from(paragraphs);\nparagraphArray.forEach(p => console.log(p.innerHTML));  // ✅ 작동\n```\n\n현대적 대안:\n```javascript\n// querySelectorAll 사용 (NodeList 반환, forEach 사용 가능)\nconst paragraphs = document.querySelectorAll(\"p\");\nparagraphs.forEach(p => console.log(p.innerHTML));\n```",
      "difficulty": "easy",
      "created_at": "2025-08-08T13:08:54.000Z"
    },
    {
      "id": 780,
      "subject_id": 1,
      "question": "클래스명이 \"intro\"인 모든 요소를 선택하는 코드입니다. 빈칸에 들어갈 올바른 조합은?\n\n```javascript\n// jQuery\nmyElements = _______(\".intro\");\n\n// JavaScript  \nmyElements = document._______(\"intro\");\n```",
      "option_a": "`$` / `getElementsByClassName`",
      "option_b": "`jQuery` / `getElementsByClass`",
      "option_c": "`$` / `getElementByClassName`",
      "option_d": "`find` / `getElementsByClassName`",
      "correct_answer": "A",
      "explanation": "jQuery의 $ 함수와 JavaScript의 getElementsByClassName 메서드를 사용한 클래스 선택입니다.\n\n클래스 선택 방법 비교:\n\njQuery 방식:\n```javascript\n// $ 기호 사용 (jQuery의 핵심 함수)\nvar myElements = $(\".intro\");  // 점(.) 포함\n\n// jQuery의 다른 표기법 (동일한 결과)\nvar myElements = jQuery(\".intro\");  // $ 대신 jQuery 사용 가능\n```\n\nJavaScript 방식:\n```javascript\n// 클래스명만 사용 (점 없음)\nvar myElements = document.getElementsByClassName(\"intro\");\n```\n\n실제 사용 예시:\n```javascript\n// jQuery\n$(\".intro\").hide();  // 모든 .intro 요소 숨기기\n$(\".intro\").css(\"color\", \"red\");  // 색상 변경\n\n// JavaScript\nconst elements = document.getElementsByClassName(\"intro\");\nfor (let i = 0; i < elements.length; i++) {\n    elements[i].style.display = \"none\";  // 숨기기\n    elements[i].style.color = \"red\";  // 색상 변경\n}\n```\n\n참고사항:\n\n• jQuery는 CSS 선택자 문법을 그대로 사용\n• JavaScript의 `getElementsByClassName`은 클래스명만 입력",
      "difficulty": "medium",
      "created_at": "2025-08-08T13:11:19.000Z"
    },
    {
      "id": 781,
      "subject_id": 1,
      "question": "다음 코드는 특정 태그와 클래스를 동시에 만족하는 요소를 찾습니다. 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\n// jQuery\nmyElements = $(\"p.intro\");\n\n// JavaScript\nmyElements = document._______(\"p.intro\");\n```",
      "option_a": "getElementsBySelector",
      "option_b": "querySelectorAll",
      "option_c": "getElementsByTagAndClass",
      "option_d": "selectElements",
      "correct_answer": "B",
      "explanation": "CSS 선택자를 사용하여 복합 조건으로 요소를 선택하는 현대적인 JavaScript 메서드입니다.\n\nCSS 선택자 활용:\n\n선택자 패턴:\n```javascript\n\"p.intro\"     // <p> 태그이면서 class=\"intro\"인 요소\n\"div#main\"    // <div> 태그이면서 id=\"main\"인 요소\n\".intro p\"    // class=\"intro\" 안에 있는 모든 <p> 태그\n\"p, div\"      // 모든 <p> 태그와 모든 <div> 태그\n```\n\nquerySelector vs querySelectorAll:\n```javascript\n// 첫 번째 일치하는 요소만 반환\nconst firstElement = document.querySelector(\"p.intro\");\n\n// 모든 일치하는 요소들을 NodeList로 반환\nconst allElements = document.querySelectorAll(\"p.intro\");\n```\n\njQuery와의 비교:\n```javascript\n// jQuery (항상 모든 일치 요소 반환)\n$(\"p.intro\")  // jQuery 객체\n\n// JavaScript\ndocument.querySelector(\"p.intro\")     // 첫 번째 요소만\ndocument.querySelectorAll(\"p.intro\")  // 모든 요소들\n```\n\nNodeList vs HTMLCollection:\n```javascript\n// querySelectorAll → NodeList (forEach 사용 가능)\nconst nodeList = document.querySelectorAll(\"p.intro\");\nnodeList.forEach(element => {\n    console.log(element.innerHTML);  // ✅ 작동\n});\n\n// getElementsByClassName → HTMLCollection (forEach 불가)\nconst htmlCollection = document.getElementsByClassName(\"intro\");\n// htmlCollection.forEach()  // ❌ 오류 발생\n```\n\n실용적 활용:\n```javascript\n// 복잡한 선택자도 가능\ndocument.querySelectorAll(\"div.container > p.intro:first-child\");\ndocument.querySelectorAll(\"input[type='text']:not([disabled])\");\ndocument.querySelectorAll(\"li:nth-child(odd)\");\n```",
      "difficulty": "medium",
      "created_at": "2025-08-08T13:13:55.000Z"
    },
    {
      "id": 782,
      "subject_id": 1,
      "question": "jQuery와 JavaScript로 같은 작업을 수행하는 코드입니다. 빈칸에 들어갈 올바른 조합은?\n\n```javascript\n// jQuery\n$(document).ready(function() {\n    var myElements = _______(\"p\");\n    _______(\"demo\").text(\"First paragraph: \" + myElements[0].innerHTML);\n});\n\n// JavaScript\nconst myElements = document.getElementsByTagName(\"p\");\ndocument.getElementById(\"demo\")._______ = \"First paragraph: \" + myElements[0].innerHTML;\n```",
      "option_a": "`$` / `$` / `innerHTML`",
      "option_b": "`$` / `$(\"#\")` / `textContent`",
      "option_c": "`$` / `$(\"#\")` / `innerHTML`",
      "option_d": "`jQuery` / `$` / `textContent`",
      "correct_answer": "C",
      "explanation": "jQuery와 JavaScript의 요소 선택과 내용 설정 방법을 비교하는 종합 문제입니다.\n\n코드 분석:\n\njQuery 부분:\n```javascript\n$(document).ready(function() {\n    // $(\"p\") - 모든 p 태그 선택\n    var myElements = $(\"p\");\n    \n    // $(\"#demo\") - ID가 demo인 요소 선택\n    // .text() - 텍스트 내용 설정\n    $(\"#demo\").text(\"First paragraph: \" + myElements[0].innerHTML);\n});\n```\n\nJavaScript 부분:\n```javascript\n// getElementsByTagName으로 p 태그들 선택\nconst myElements = document.getElementsByTagName(\"p\");\n\n// getElementById로 demo 요소 선택, innerHTML로 내용 설정\ndocument.getElementById(\"demo\").innerHTML = \"First paragraph: \" + myElements[0].innerHTML;\n```\n\n텍스트 설정 방법:\n```javascript\n// jQuery\n$(\"#demo\").text(\"텍스트만\");     // HTML 태그 무시\n$(\"#demo\").html(\"<b>HTML</b>\");  // HTML 태그 해석\n\n// JavaScript  \nelement.textContent = \"텍스트만\";    // HTML 태그 무시\nelement.innerHTML = \"<b>HTML</b>\";   // HTML 태그 해석\n```\n\n현대적 JavaScript 대안:\n```javascript\n// DOMContentLoaded 이벤트 사용\ndocument.addEventListener('DOMContentLoaded', function() {\n    const myElements = document.querySelectorAll(\"p\");\n    document.getElementById(\"demo\").innerHTML = \n        \"First paragraph: \" + myElements[0].innerHTML;\n});\n```\n\njQuery의 장점과 JavaScript의 발전:\n\n• jQuery 시대: 브라우저 호환성 문제 해결, 간단한 문법\n• 현재: 표준 JavaScript 기능 향상, jQuery 의존도 감소\n• 선택 기준: 프로젝트 규모, 팀 선호도, 레거시 코드 고려",
      "difficulty": "hard",
      "created_at": "2025-08-08T13:16:41.000Z"
    },
    {
      "id": 783,
      "subject_id": 1,
      "question": "jQuery가 만들어진 목적으로 가장 적절한 것은?",
      "option_a": "새로운 프로그래밍 언어를 만들기 위해",
      "option_b": "브라우저 호환성 문제를 해결하고 HTML DOM 조작을 단순화하기 위해",
      "option_c": "서버 개발을 위한 백엔드 프레임워크를 만들기 위해",
      "option_d": "데이터베이스 관리를 위해",
      "correct_answer": "B",
      "explanation": "jQuery는 2006년 John Resig에 의해 만들어졌으며, 브라우저 간의 호환성 문제를 해결하고 HTML DOM 조작, 이벤트 처리, 애니메이션, Ajax를 단순화하기 위해 개발되었습니다. 10년 이상 가장 인기 있는 JavaScript 라이브러리였지만, 현재는 순수 JavaScript로도 대부분의 기능을 구현할 수 있게 되었습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T13:19:38.000Z"
    },
    {
      "id": 784,
      "subject_id": 1,
      "question": "HTML 요소의 텍스트 내용을 설정하는 코드에서 빈칸에 들어갈 올바른 메서드는?\n\njQuery: `myElement.text(\"Hello World!\");`\n\nJavaScript: `myElement._______ = \"Hello World!\";`",
      "option_a": "innerHTML",
      "option_b": "textContent",
      "option_c": "value",
      "option_d": "innerText",
      "correct_answer": "B",
      "explanation": "jQuery의 `.text()` 메서드와 동일한 기능을 하는 순수 JavaScript 메서드는 `textContent`입니다. `innerHTML`은 HTML 태그를 포함한 내용을 다룰 때 사용하고, `textContent`는 순수 텍스트만을 다룹니다. `innerText`도 텍스트를 다루지만 `textContent`가 표준이며 더 일반적으로 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T13:21:56.000Z"
    },
    {
      "id": 785,
      "subject_id": 1,
      "question": "다음 jQuery 코드와 동일한 기능을 하는 JavaScript 코드는?\n\n```javascript\n// jQuery\n$(\"#demo\").hide();\n```",
      "option_a": "document.getElementById(\"demo\").style.visibility = \"hidden\";",
      "option_b": "document.getElementById(\"demo\").style.display = \"none\";",
      "option_c": "document.getElementById(\"demo\").style.opacity = \"0\";",
      "option_d": "document.getElementById(\"demo\").remove();",
      "correct_answer": "B",
      "explanation": "jQuery의 `.hide()` 메서드는 요소의 `display` 속성을 `\"none\"`으로 설정하여 요소를 완전히 숨깁니다. `visibility: hidden`은 요소가 보이지 않지만 공간은 차지하고, `opacity: 0`은 투명하게 만들지만 여전히 공간을 차지합니다. `remove()`는 요소를 DOM에서 완전히 제거하는 것이므로 다른 기능입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T13:23:11.000Z"
    },
    {
      "id": 786,
      "subject_id": 1,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 조합은?\n\n```javascript\n// HTML 요소의 내용 가져오기\n// jQuery\nvar content = $(\"#myDiv\").____();\n\n// JavaScript  \nvar content = document.getElementById(\"myDiv\")._____;\n```",
      "option_a": "text, textContent",
      "option_b": "html, innerHTML",
      "option_c": "css, style",
      "option_d": "show, display",
      "correct_answer": "B",
      "explanation": "jQuery의 `.html()` 메서드는 HTML 태그를 포함한 요소의 내용을 가져오거나 설정합니다. 이와 동일한 기능을 하는 순수 JavaScript 속성은 `innerHTML`입니다. 둘 다 HTML 마크업을 그대로 처리할 수 있어서 `<p>Hello</p>`와 같은 태그가 포함된 내용을 다룰 때 사용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T13:38:38.000Z"
    },
    {
      "id": 787,
      "subject_id": 1,
      "question": "다음 코드의 실행 결과로 옳은 것은?\n\n```html\n<div id=\"parent\">\n  <p id=\"child\">Hello World</p>\n</div>\n\n<script>\n// jQuery\nvar parentName = $(\"#child\").parent().prop(\"nodeName\");\ndocument.getElementById(\"result\").innerHTML = parentName;\n</script>\n```",
      "option_a": "\"parent\"",
      "option_b": "\"child\"",
      "option_c": "\"DIV\"",
      "option_d": "\"P\"",
      "correct_answer": "C",
      "explanation": "이 코드는 id가 \"child\"인 요소(`<p>` 태그)의 부모 요소를 찾아서 그 노드명을 가져옵니다.\n\n• `$(\"#child\")`는 `<p id=\"child\">` 요소를 선택\n• `.parent()`는 그 부모 요소인 `<div id=\"parent\">`를 선택\n• `.prop(\"nodeName\")`은 해당 요소의 노드명을 가져옴\n• HTML에서 노드명은 항상 대문자로 반환되므로 \"DIV\"가 결과입니다.\n\n순수 JavaScript로는 `document.getElementById(\"child\").parentNode.nodeName`과 동일한 기능입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T13:40:58.000Z"
    },
    {
      "id": 788,
      "subject_id": 1,
      "question": "JavaScript에서 차트를 만들 수 있는 그래픽 라이브러리로 올바른 것은?",
      "option_a": "React, Vue, Angular",
      "option_b": "Plotly.js, Chart.js, Google Chart",
      "option_c": "Express, Node.js, MongoDB",
      "option_d": "Bootstrap, Tailwind, Materialize",
      "correct_answer": "B",
      "explanation": "PDF에서 소개된 주요 JavaScript 그래픽 라이브러리는 Plotly.js, Chart.js, Google Chart입니다. 이들은 모두 다양한 종류의 차트와 그래프를 만들 수 있는 전문 라이브러리입니다. 1번은 프론트엔드 프레임워크, 3번은 백엔드 기술, 4번은 CSS 프레임워크입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T13:43:26.000Z"
    },
    {
      "id": 789,
      "subject_id": 1,
      "question": "Plotly.js에서 파이 차트를 만들기 위한 코드에서 빈칸에 들어갈 올바른 속성은?\n\n```javascript\nconst data = [{\n    _____: xArray,\n    _____: yArray,\n    type: \"pie\"\n}];\n```",
      "option_a": "x, y",
      "option_b": "labels, values",
      "option_c": "name, data",
      "option_d": "categories, series",
      "correct_answer": "B",
      "explanation": "Plotly.js에서 파이 차트를 만들 때는 `labels`와 `values` 속성을 사용합니다. `labels`는 각 조각의 이름을, `values`는 각 조각의 값을 나타냅니다. 바 차트나 라인 차트에서는 `x`와 `y`를 사용하지만, 파이 차트는 다른 구조를 가집니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T13:44:36.000Z"
    },
    {
      "id": 790,
      "subject_id": 1,
      "question": "다음 Plotly.js 코드에서 수평 바 차트를 만들기 위해 빈칸에 들어갈 값은?\n\n```javascript\nconst data = [{\n    x: [55, 49, 44, 24, 15],\n    y: [\"Italy\", \"France\", \"Spain\", \"USA\", \"Argentina\"],\n    type: \"bar\",\n    orientation: \"_____\"\n}];\n```",
      "option_a": "\"vertical\"",
      "option_b": "\"horizontal\"",
      "option_c": "\"h\"",
      "option_d": "\"sideways\"",
      "correct_answer": "C",
      "explanation": "Plotly.js에서 수평 바 차트를 만들려면 `orientation` 속성을 `\"h\"`로 설정합니다. 수직 바 차트는 `\"v\"`를 사용합니다. 이때 x축에는 값(숫자), y축에는 카테고리(라벨)가 들어갑니다. \"horizontal\"이나 \"sideways\"는 Plotly.js에서 사용하지 않는 값입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T13:45:33.000Z"
    },
    {
      "id": 791,
      "subject_id": 1,
      "question": "HTML Canvas에서 산점도(scatter plot)를 그릴 때 사용되는 메서드 조합으로 올바른 것은?\n\n```javascript\nctx.beginPath();\nctx.______(x, y, 2, 3, 0, 0, Math.PI * 2);\nctx.______();\n```",
      "option_a": "circle, draw",
      "option_b": "ellipse, fill",
      "option_c": "arc, stroke",
      "option_d": "round, paint",
      "correct_answer": "B",
      "explanation": "HTML Canvas에서 산점도의 점들을 그릴 때는 `ellipse()` 메서드로 타원형(원형 포함)을 그리고, `fill()` 메서드로 색을 채웁니다. `ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle)` 형태로 사용하며, 여기서 `Math.PI * 2`는 완전한 원을 의미합니다. `arc()`도 원을 그릴 수 있지만 매개변수가 다릅니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T13:46:35.000Z"
    },
    {
      "id": 792,
      "subject_id": 1,
      "question": "다음 Plotly.js 코드에서 도넛 차트와 일반 파이 차트의 차이점은 무엇인가?\n\n```javascript\n// 일반 파이 차트\nconst data1 = [{\n    labels: xArray,\n    values: yArray,\n    type: \"pie\"\n}];\n\n// 도넛 차트  \nconst data2 = [{\n    labels: xArray,\n    values: yArray,\n    hole: .4,\n    type: \"pie\"\n}];\n```",
      "option_a": "type 속성이 \"donut\"으로 다름",
      "option_b": "hole 속성의 유무가 다름",
      "option_c": "labels와 values의 순서가 다름",
      "option_d": "layout 설정이 다름",
      "correct_answer": "B",
      "explanation": "Plotly.js에서 도넛 차트는 일반 파이 차트에 `hole` 속성을 추가하여 만듭니다. `hole` 속성의 값은 0과 1 사이의 소수로, 차트 중앙의 구멍 크기를 나타냅니다. 예제에서 `.4`는 차트 반지름의 40% 크기만큼 가운데에 구멍을 뚫는다는 의미입니다. type은 여전히 \"pie\"를 사용하며, \"donut\"이라는 별도 타입은 없습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T13:47:47.000Z"
    },
    {
      "id": 793,
      "subject_id": 1,
      "question": "Chart.js를 사용하기 위해 필요한 기본 HTML 요소는 무엇인가?",
      "option_a": "`<div>` 요소",
      "option_b": "`<canvas>` 요소",
      "option_c": "`<svg>` 요소",
      "option_d": "`<chart>` 요소",
      "correct_answer": "B",
      "explanation": "Chart.js는 HTML5의 `<canvas>` 요소를 사용하여 차트를 그립니다. Canvas는 JavaScript를 통해 그래픽을 그릴 수 있는 HTML5 요소입니다. `<canvas>` 요소는 반드시 고유한 `id` 속성을 가져야 하며, Chart.js에서 이 id를 통해 차트를 렌더링할 위치를 지정합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T13:51:57.000Z"
    },
    {
      "id": 794,
      "subject_id": 1,
      "question": "Chart.js에서 기본 차트 생성 문법의 빈칸에 들어갈 올바른 내용은?\n\n```javascript\nconst myChart = new Chart(\"myChart\", {\n    _____: \"bar\",\n    _____: {},\n    _____: {}\n});\n```",
      "option_a": "chart, info, settings",
      "option_b": "type, data, options",
      "option_c": "kind, values, config",
      "option_d": "style, content, properties",
      "correct_answer": "B",
      "explanation": "Chart.js의 기본 생성자는 `new Chart(id, config)` 형태입니다. config 객체는 세 가지 주요 속성을 가집니다:\n\n• `type`: 차트의 종류 (bar, line, pie, scatter 등)\n• `data`: 차트에 표시할 데이터\n• `options`: 차트의 다양한 설정 옵션 (제목, 축 설정, 범례 등)",
      "difficulty": "easy",
      "created_at": "2025-08-08T13:52:59.000Z"
    },
    {
      "id": 795,
      "subject_id": 1,
      "question": "Chart.js에서 수평 바 차트를 만들기 위해 type 속성에 들어갈 값은?\n\n```javascript\nnew Chart(\"myChart\", {\n    type: \"_____\",\n    data: {\n        labels: [\"Italy\", \"France\", \"Spain\"],\n        datasets: [{\n            data: [55, 49, 44]\n        }]\n    }\n});\n```",
      "option_a": "\"bar\"",
      "option_b": "\"horizontal\"",
      "option_c": "\"horizontalBar\"",
      "option_d": "\"barHorizontal\"",
      "correct_answer": "C",
      "explanation": "Chart.js에서 수직 바 차트는 `type: \"bar\"`를 사용하고, 수평 바 차트는 `type: \"horizontalBar\"`를 사용합니다. 이는 Chart.js v2.x 버전의 문법입니다. v3.x 이후에서는 `type: \"bar\"`에 `indexAxis: 'y'` 옵션을 추가하는 방식으로 변경되었지만, 문서의 예시는 v2.x 기준입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T13:53:55.000Z"
    },
    {
      "id": 796,
      "subject_id": 1,
      "question": "Chart.js에서 산점도(scatter plot)를 만들 때 데이터 형식으로 올바른 것은?",
      "option_a": "data: [50, 60, 70, 80]",
      "option_b": "data: [{x:50, y:7}, {x:60, y:8}, {x:70, y:8}]",
      "option_c": "data: [[50,7], [60,8], [70,8]]",
      "option_d": "data: {x: [50,60,70], y: [7,8,8]}",
      "correct_answer": "B",
      "explanation": "산점도에서는 각 점이 x, y 좌표를 모두 가져야 하므로, 데이터를 `{x: value, y: value}` 형태의 객체 배열로 제공해야 합니다. 이 형식을 통해 Chart.js는 각 점을 정확한 x, y 위치에 배치할 수 있습니다. 다른 차트 타입들은 보통 일차원 배열이나 labels와 data를 분리하여 사용하지만, 산점도는 이 특별한 형식을 요구합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T13:54:41.000Z"
    },
    {
      "id": 797,
      "subject_id": 1,
      "question": "다음 Chart.js 코드에서 라인 차트를 산점도처럼 보이게 만들기 위해 변경해야 할 속성은?\n\n```javascript\nnew Chart(\"myChart\", {\n    type: \"line\",\n    data: {\n        labels: xValues,\n        datasets: [{\n            backgroundColor: \"rgba(0,0,255,1.0)\",\n            borderColor: \"rgba(0,0,255,0.1)\",\n            data: yValues\n        }]\n    }\n});\n```",
      "option_a": "backgroundColor를 \"rgba(0,0,0,0)\"으로 변경",
      "option_b": "borderColor를 \"rgba(0,0,0,0)\"으로 변경",
      "option_c": "type을 \"scatter\"로 변경",
      "option_d": "lineTension을 0으로 설정",
      "correct_answer": "B",
      "explanation": "라인 차트에서 선을 제거하여 점만 보이게 하려면 `borderColor`를 투명하게 만들어야 합니다. `borderColor`는 선의 색상을 담당하므로, 이를 `\"rgba(0,0,0,0)\"` (완전 투명)으로 설정하면 선이 보이지 않고 점들만 남게 되어 산점도와 같은 모양이 됩니다. `backgroundColor`는 점의 색상을 담당하므로 이를 투명하게 하면 점이 보이지 않게 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T13:55:42.000Z"
    },
    {
      "id": 823,
      "subject_id": 8,
      "question": "HTML의 정식 명칭은 무엇인가?",
      "option_a": "High Technology Markup Language",
      "option_b": "Hyper Text Markup Language",
      "option_c": "Home Tool Markup Language",
      "option_d": "Hyper Transfer Markup Language",
      "correct_answer": "B",
      "explanation": "HTML은 \"Hyper Text Markup Language\"의 줄임말입니다. 웹 페이지를 만들기 위한 표준 마크업 언어로, 웹 페이지의 구조를 기술하고 브라우저에게 콘텐츠를 어떻게 표시할지 알려주는 역할을 합니다. \"Hyper Text\"는 링크를 통해 다른 문서로 이동할 수 있는 텍스트를 의미하고, \"Markup\"은 태그를 사용해 문서의 구조를 표시하는 방식을 뜻합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:01:00.000Z"
    },
    {
      "id": 824,
      "subject_id": 8,
      "question": "다음 HTML 문서 구조에서 빈칸에 들어갈 올바른 태그는?\n\n```html\n<!DOCTYPE html>\n<html>\n<_____>\n<title>Page Title</title>\n</_____>\n<body>\n<h1>My First Heading</h1>\n<p>My first paragraph.</p>\n</body>\n</html>\n```",
      "option_a": "header",
      "option_b": "head",
      "option_c": "top",
      "option_d": "meta",
      "correct_answer": "B",
      "explanation": "`<head>` 태그는 HTML 문서의 메타 정보를 담는 영역입니다. 이 안에는 페이지 제목(`<title>`), 문자 인코딩, CSS 스타일, JavaScript 등이 들어갑니다. `<head>` 영역의 내용은 브라우저 화면에 직접 표시되지 않지만, 브라우저 탭에 표시될 제목이나 검색 엔진 최적화에 중요한 정보들이 포함됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:02:01.000Z"
    },
    {
      "id": 825,
      "subject_id": 8,
      "question": "HTML 요소의 구조에 대한 설명으로 올바른 것은?\n\n```html\n<h1>My First Heading</h1>\n```",
      "option_a": "시작 태그만 있으면 된다",
      "option_b": "시작 태그, 내용, 종료 태그로 구성된다",
      "option_c": "종료 태그가 항상 필요하다",
      "option_d": "내용 없이 태그만 있어도 된다",
      "correct_answer": "B",
      "explanation": "HTML 요소는 기본적으로 \"시작 태그 + 내용 + 종료 태그\"로 구성됩니다. 예시에서 `<h1>`은 시작 태그, \"My First Heading\"은 내용, `</h1>`은 종료 태그입니다. 단, `<br>`, `<img>`, `<input>` 같은 빈 요소(empty elements)들은 내용이 없고 종료 태그도 없습니다. 이러한 요소들은 스스로 닫히는 태그입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T14:03:14.000Z"
    },
    {
      "id": 826,
      "subject_id": 8,
      "question": "다음 중 브라우저 화면에 실제로 표시되는 내용이 들어가는 영역은?\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<title>Page Title</title>\n</head>\n<_____>\n<h1>My First Heading</h1>\n<p>My first paragraph.</p>\n</_____>\n</html>\n```",
      "option_a": "html",
      "option_b": "head",
      "option_c": "body",
      "option_d": "title",
      "correct_answer": "C",
      "explanation": "`<body>` 태그는 사용자가 웹 페이지에서 실제로 볼 수 있는 모든 내용을 담는 컨테이너입니다. 제목, 문단, 이미지, 링크, 표, 목록 등 모든 가시적인 콘텐츠가 `<body>` 안에 들어갑니다. 반면 `<head>` 영역의 내용은 화면에 표시되지 않고, `<title>`의 내용만 브라우저 탭이나 제목 표시줄에 나타납니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T14:04:13.000Z"
    },
    {
      "id": 827,
      "subject_id": 8,
      "question": "다음 HTML 코드에서 브라우저가 수행하는 역할에 대한 설명으로 가장 적절한 것은?\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<title>My Website</title>\n</head>\n<body>\n<h1>Welcome</h1>\n<p>This is my first website.</p>\n</body>\n</html>\n```",
      "option_a": "HTML 태그들을 그대로 화면에 표시한다",
      "option_b": "HTML 태그들을 해석해서 구조화된 콘텐츠로 표시한다",
      "option_c": "HTML 코드를 다른 언어로 번역한다",
      "option_d": "HTML 파일을 서버에 저장한다",
      "correct_answer": "B",
      "explanation": "웹 브라우저(Chrome, Firefox, Safari 등)의 핵심 역할은 HTML 문서를 읽고 올바르게 표시하는 것입니다. 브라우저는 HTML 태그 자체를 화면에 보여주지 않고, 대신 태그들을 해석해서 문서의 구조를 파악합니다. 예를 들어 `<h1>` 태그를 만나면 큰 제목으로, `<p>` 태그를 만나면 문단으로 표시합니다. 이렇게 브라우저는 HTML 태그를 \"어떻게 표시할지 결정하는 지시사항\"으로 사용합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T14:05:23.000Z"
    },
    {
      "id": 828,
      "subject_id": 8,
      "question": "HTML에서 제목(heading)을 나타내는 태그 중 가장 중요한 제목을 표시하는 태그는?",
      "option_a": "`<h6>`",
      "option_b": "`<h1>`",
      "option_c": "`<title>`",
      "option_d": "`<header>`",
      "correct_answer": "B",
      "explanation": "HTML에서는 `<h1>`부터 `<h6>`까지 6단계의 제목 태그가 있습니다. `<h1>`이 가장 중요하고 큰 제목을 나타내며, 숫자가 커질수록 중요도가 낮아집니다. `<h6>`가 가장 작고 덜 중요한 제목입니다. `<title>`은 브라우저 탭에 표시되는 문서 제목이고, `<header>`는 HTML5의 시맨틱 태그로 다른 용도입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:07:44.000Z"
    },
    {
      "id": 829,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 태그는?\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n<_____>This is a paragraph.</_____>\n<_____>This is another paragraph.</_____>\n</body>\n</html>\n```",
      "option_a": "div",
      "option_b": "span",
      "option_c": "p",
      "option_d": "text",
      "correct_answer": "C",
      "explanation": "HTML에서 문단(paragraph)을 나타내는 태그는 `<p>`입니다. 각 `<p>` 태그는 하나의 문단을 의미하며, 브라우저는 자동으로 문단 앞뒤에 여백을 추가합니다. `<div>`는 블록 컨테이너, `<span>`은 인라인 컨테이너, `<text>`는 존재하지 않는 태그입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:09:01.000Z"
    },
    {
      "id": 830,
      "subject_id": 8,
      "question": "HTML 링크를 만들 때 사용하는 태그와 링크 주소를 지정하는 속성의 올바른 조합은?\n\n```html\n<_____ _____=\"https://www.example.com\">Click here</_____ >\n```",
      "option_a": "`<link>`, `url`",
      "option_b": "`<a>`, `href`",
      "option_c": "`<url>`, `link`",
      "option_d": "`<a>`, `src`",
      "correct_answer": "B",
      "explanation": "HTML에서 링크를 만들 때는 `<a>` 태그를 사용하고, 링크 주소는 `href` 속성에 지정합니다. `href`는 \"hypertext reference\"의 줄임말입니다. `<link>` 태그는 외부 리소스(CSS 파일 등)를 연결할 때 사용하고, `src` 속성은 주로 이미지나 스크립트 파일의 경로를 지정할 때 사용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T14:10:19.000Z"
    },
    {
      "id": 831,
      "subject_id": 8,
      "question": "다음 이미지 태그에서 각 속성의 역할로 올바른 것은?\n\n```html\n<img src=\"photo.jpg\" alt=\"My Photo\" width=\"200\" height=\"150\">\n```",
      "option_a": "src: 이미지 크기, alt: 이미지 색상, width/height: 이미지 위치",
      "option_b": "src: 이미지 파일 경로, alt: 대체 텍스트, width/height: 이미지 크기",
      "option_c": "src: 이미지 제목, alt: 이미지 설명, width/height: 이미지 품질",
      "option_d": "src: 이미지 타입, alt: 이미지 링크, width/height: 이미지 해상도",
      "correct_answer": "B",
      "explanation": "• `src` (source): 표시할 이미지 파일의 경로나 URL을 지정\n• `alt` (alternative): 이미지를 불러올 수 없을 때 대신 표시되는 대체 텍스트 (접근성을 위해 중요)\n• `width`와 `height`: 이미지의 너비와 높이를 픽셀 단위로 지정\n\n이 속성들은 웹 접근성과 페이지 로딩 최적화에 중요한 역할을 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T14:11:35.000Z"
    },
    {
      "id": 832,
      "subject_id": 8,
      "question": "다음 HTML 코드의 실행 결과에서 제목들의 크기 순서로 올바른 것은?\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n<h3>제목 A</h3>\n<h1>제목 B</h1>\n<h5>제목 C</h5>\n<h2>제목 D</h2>\n</body>\n</html>\n```",
      "option_a": "A > B > C > D (코드 순서대로)",
      "option_b": "B > D > A > C (h1이 가장 크고, h5가 가장 작음)",
      "option_c": "C > A > D > B (h5가 가장 크고, h1이 가장 작음)",
      "option_d": "모든 제목이 같은 크기",
      "correct_answer": "B",
      "explanation": "HTML 제목 태그는 코드에 나타나는 순서와 관계없이 태그 번호에 따라 크기가 결정됩니다. 크기 순서는 다음과 같습니다:\n\n• `<h1>` (가장 큼) > `<h2>` > `<h3>` > `<h4>` > `<h5>` > `<h6>` (가장 작음)\n\n따라서 실제 화면에서는:\n\n• 제목 B (`<h1>`): 가장 큼\n• 제목 D (`<h2>`): 두 번째로 큼\n• 제목 A (`<h3>`): 세 번째로 큼\n• 제목 C (`<h5>`): 가장 작음\n\n이는 문서의 계층 구조를 나타내는 중요한 개념입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T14:13:23.000Z"
    },
    {
      "id": 833,
      "subject_id": 8,
      "question": "다음 중 빈 요소(empty element)의 특징으로 올바른 것은?",
      "option_a": "반드시 끝 태그를 가져야 한다",
      "option_b": "내용과 끝 태그가 없다",
      "option_c": "시작 태그가 없다",
      "option_d": "대소문자를 구분한다",
      "correct_answer": "B",
      "explanation": "빈 요소(empty element)는 내용이 없는 HTML 요소로, 끝 태그가 필요하지 않습니다. 대표적인 예가 줄 바꿈을 만드는 `<br>` 태그입니다. `<p>This is a <br> paragraph with a line break.</p>`처럼 사용되며, `<br></br>`로 쓰지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:17:15.000Z"
    },
    {
      "id": 834,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 태그는 무엇인가요?\n\n```html\n<!DOCTYPE html>\n<____>\n<body>\n<h1>My First Heading</h1>\n<p>My first paragraph.</p>\n</body>\n</____>\n```",
      "option_a": "head",
      "option_b": "html",
      "option_c": "title",
      "option_d": "document",
      "correct_answer": "B",
      "explanation": "`<html>` 태그는 HTML 문서의 루트 요소(root element)로, 전체 HTML 문서를 정의합니다. 모든 다른 HTML 요소들은 `<html>` 요소 안에 중첩되어야 합니다. 이 예제에서는 `<html>` 태그 안에 `<body>` 요소가 있고, 그 안에 다시 `<h1>`과 `<p>` 요소가 중첩된 구조입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T14:18:14.000Z"
    },
    {
      "id": 836,
      "subject_id": 8,
      "question": "다음 코드의 실행 결과와 관련된 설명으로 가장 적절한 것은?\n\n```html\n<html>\n<body>\n<p>This is a paragraph\n<p>This is a paragraph\n</body>\n</html>\n```",
      "option_a": "오류가 발생하여 화면에 아무것도 표시되지 않는다",
      "option_b": "첫 번째 단락만 표시되고 두 번째는 무시된다",
      "option_c": "올바르게 표시되지만 예상치 못한 결과가 발생할 수 있으므로 권장되지 않는다",
      "option_d": "HTML 표준에 따라 반드시 끝 태그를 추가해야 한다",
      "correct_answer": "C",
      "explanation": "끝 태그를 생략한 `<p>` 요소들은 대부분의 브라우저에서 올바르게 표시됩니다. 브라우저가 자동으로 누락된 끝 태그를 추정하여 처리하기 때문입니다. 하지만 이런 방식에 의존하면 예상치 못한 결과나 오류가 발생할 수 있습니다. 따라서 항상 끝 태그를 명시적으로 작성하는 것이 좋은 관습입니다. ",
      "difficulty": "hard",
      "created_at": "2025-08-08T14:20:02.000Z"
    },
    {
      "id": 837,
      "subject_id": 8,
      "question": "HTML 속성(attributes)에 대한 설명으로 올바른 것은?",
      "option_a": "속성은 HTML 요소의 끝 태그에 작성한다",
      "option_b": "속성은 항상 시작 태그에 작성하며, 요소에 추가 정보를 제공한다",
      "option_c": "속성은 HTML 문서의 맨 위에만 작성할 수 있다",
      "option_d": "속성은 모든 HTML 요소에 필수로 포함되어야 한다",
      "correct_answer": "B",
      "explanation": "HTML 속성은 항상 시작 태그에 작성되며, HTML 요소에 대한 추가 정보를 제공합니다. 예를 들어 `<a href=\"링크주소\">` 에서 `href`는 속성이고, 이는 링크가 어디로 이동할지에 대한 정보를 제공합니다. 속성은 선택사항이므로 모든 요소에 필수는 아니며, 끝 태그나 문서 상단에 작성하지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:27:11.000Z"
    },
    {
      "id": 838,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n\n```html\n<a ______=\"https://www.google.com\">구글로 이동</a>\n```",
      "option_a": "src",
      "option_b": "href",
      "option_c": "alt",
      "option_d": "width",
      "correct_answer": "B",
      "explanation": "`<a>` 태그는 하이퍼링크를 만드는 태그이고, `href` 속성은 링크가 이동할 URL을 지정합니다. `src`는 이미지 파일 경로, `alt`는 이미지 대체 텍스트, `width`는 너비를 지정하는 속성으로 링크 태그와는 관련이 없습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:28:05.000Z"
    },
    {
      "id": 839,
      "subject_id": 8,
      "question": "다음 이미지 태그에서 잘못된 부분은?\n\n```html\n<img href=\"photo.jpg\" width=\"300\" height=\"200\" alt=\"사진\">\n```",
      "option_a": "width 속성이 잘못되었다",
      "option_b": "height 속성이 잘못되었다",
      "option_c": "alt 속성이 잘못되었다",
      "option_d": "href 속성이 잘못되었다",
      "correct_answer": "D",
      "explanation": "`<img>` 태그에서 이미지 파일의 경로를 지정하는 속성은 `src`입니다. `href`는 `<a>` 태그에서 사용하는 속성으로, 링크 주소를 지정할 때 사용합니다. 올바른 코드는 `<img src=\"photo.jpg\" width=\"300\" height=\"200\" alt=\"사진\">`입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T14:29:34.000Z"
    },
    {
      "id": 840,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 속성들을 올바른 순서대로 나열한 것은?\n\n```html\n<img ①______=\"girl.jpg\" ②______=\"여자 사진\" ③______=\"400\" ④______=\"500\">\n```",
      "option_a": "src, alt, width, height",
      "option_b": "href, title, width, height",
      "option_c": "src, title, height, width",
      "option_d": "alt, src, width, height",
      "correct_answer": "A",
      "explanation": "① `src`: 이미지 파일의 경로를 지정\n② `alt`: 이미지가 로드되지 않을 때 표시되는 대체 텍스트 (접근성을 위해 필수)\n③ `width`: 이미지의 너비를 픽셀 단위로 지정\n④ `height`: 이미지의 높이를 픽셀 단위로 지정\n\n`title`은 마우스를 올렸을 때 툴팁으로 표시되는 속성이고, `href`는 링크 태그에서 사용하는 속성입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T14:32:21.000Z"
    },
    {
      "id": 841,
      "subject_id": 8,
      "question": "다음 HTML 코드들 중에서 가장 좋은 관례(best practice) 를 따르고 있는 것은?",
      "option_a": "`<p STYLE=\"COLOR:RED;\">텍스트</p>`",
      "option_b": "`<p style=color:red;>텍스트</p>`",
      "option_c": "`<p style=\"color:red;\">텍스트</p>`",
      "option_d": "`<p Style='Color:Red;'>텍스트</p>`",
      "correct_answer": "C",
      "explanation": "HTML에서 권장되는 좋은 관례는 다음과 같습니다:\n\n1. 속성명은 소문자 사용: `STYLE` ❌ → `style` ✅\n2. 속성값은 따옴표로 감싸기: `color:red;` ❌ → `\"color:red;\"` ✅\n3. 일관성 있는 따옴표 사용: 일반적으로 큰따옴표(`\"`)를 사용\n\n선택지 분석:\n\n1번: 속성명이 대문자 (❌)\n2번: 속성값에 따옴표가 없음 (❌)\n3번: 모든 관례를 올바르게 준수 (✅)\n4번: 속성명과 속성값이 대소문자가 섞여있고 일관성 없음 (❌)\n\nW3C에서는 더 엄격한 문서 타입(XHTML 등)에서는 소문자 속성명과 따옴표 사용을 필수로 요구하므로, 이런 관례를 따르는 것이 좋습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T14:34:23.000Z"
    },
    {
      "id": 842,
      "subject_id": 8,
      "question": "HTML에서 제목(heading)을 나타내는 태그에 대한 설명으로 올바른 것은?",
      "option_a": "`<h1>`부터 `<h10>`까지 총 10개의 제목 태그가 있다",
      "option_b": "`<h1>`부터 `<h6>`까지 총 6개의 제목 태그가 있으며, `<h1>`이 가장 중요한 제목이다",
      "option_c": "`<h6>`가 가장 중요한 제목이고, `<h1>`이 가장 덜 중요한 제목이다",
      "option_d": "제목 태그는 `<title>` 하나만 존재한다",
      "correct_answer": "B",
      "explanation": "HTML에서는 `<h1>`부터 `<h6>`까지 총 6개의 제목 태그를 제공합니다. `<h1>`은 가장 중요하고 큰 제목을 나타내며, 숫자가 커질수록 중요도가 낮아집니다. 즉, `<h1> > <h2> > <h3> > <h4> > <h5> > <h6>` 순서로 중요도가 결정됩니다. `<title>` 태그는 브라우저 탭에 표시되는 문서 제목으로, 페이지 내 제목과는 다른 용도입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:38:34.000Z"
    },
    {
      "id": 843,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 태그는?\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  ______주요 뉴스______\n  ______경제 뉴스______\n    ______증시 동향______\n    ______환율 정보______\n  ______스포츠 뉴스______\n    ______축구______\n    ______야구______\n</body>\n</html>\n```\n문서 구조를 고려할 때, \"주요 뉴스\", \"경제 뉴스\", \"증시 동향\"에 들어갈 태그 조합은?",
      "option_a": "`<h1>`, `<h1>`, `<h1>`",
      "option_b": "`<h1>`, `<h2>`, `<h3>`",
      "option_c": "`<h1>`, `<h3>`, `<h2>`",
      "option_d": "`<h2>`, `<h1>`, `<h3>`",
      "correct_answer": "B",
      "explanation": "HTML 제목 태그는 문서의 계층 구조를 나타내야 합니다:\n\n• \"주요 뉴스\": 전체 페이지의 대제목 → `<h1>`\n• \"경제 뉴스\": 주요 카테고리 → `<h2>`\n• \"증시 동향\": 경제 뉴스의 하위 항목 → `<h3>`\n\n올바른 제목 구조는 단계적으로 내려가야 하며(`h1 → h2 → h3`), 검색엔진과 사용자가 문서 구조를 쉽게 이해할 수 있도록 도와줍니다. `<h1>`은 페이지당 하나만 사용하는 것이 좋은 관례입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T14:40:31.000Z"
    },
    {
      "id": 844,
      "subject_id": 8,
      "question": "다음 코드에서 가장 적절하지 않은 부분은?\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  <h1>웹사이트 제목</h1>\n  <h3>중요한 공지사항</h3>\n  <p>공지사항 내용입니다.</p>\n  <h2 style=\"font-size:10px;\">작은 제목</h2>\n  <h4>일반 정보</h4>\n  <p>일반 정보 내용입니다.</p>\n</body>\n</html>\n```",
      "option_a": "`<h1>` 다음에 바로 `<h3>`가 나온 것",
      "option_b": "`<h2>`에 `style=\"font-size:10px;\"`를 사용한 것",
      "option_c": "`<h4>` 태그를 사용한 것",
      "option_d": "1번과 2번 모두",
      "correct_answer": "D",
      "explanation": "이 코드에는 두 가지 주요 문제점이 있습니다:\n\n1. 제목 계층 구조 위반: \n`<h1>` 다음에 `<h2>`를 건너뛰고 바로 `<h3>`를 사용했습니다. 올바른 제목 구조는 순차적이어야 합니다 (`h1 → h2 → h3 → ...`). 이는 검색엔진 최적화(SEO)와 접근성에 좋지 않습니다.\n\n2. 잘못된 제목 사용법:\n`<h2>`를 작은 크기로 만들기 위해 `font-size:10px`를 사용했습니다. 문서에서 언급했듯이 \"제목을 텍스트를 크게 하거나 굵게 만들기 위해 사용하면 안 됩니다.\" 제목은 의미적 중요도에 따라 선택해야 하고, 크기 조절이 필요하다면 적절한 제목 태그를 선택한 후 CSS로 스타일링해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T14:43:06.000Z"
    },
    {
      "id": 845,
      "subject_id": 8,
      "question": "HTML에서 문단(paragraph)을 나타내는 태그는?",
      "option_a": "`<paragraph>`",
      "option_b": "`<p>`",
      "option_c": "`<para>`",
      "option_d": "`<text>`",
      "correct_answer": "B",
      "explanation": "HTML에서 문단을 정의할 때는 `<p>` 태그를 사용합니다. `<p>` 태그는 \"paragraph\"의 줄임말로, 하나의 문단을 나타내며 브라우저는 자동으로 문단 앞뒤에 여백(margin)을 추가합니다. 각 `<p>` 태그는 새로운 줄에서 시작되어 블록 형태로 표시됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:47:01.000Z"
    },
    {
      "id": 846,
      "subject_id": 8,
      "question": "다음 코드의 실행 결과는?\n\n```html\n<p>첫 번째    줄입니다.</p>\n<p>두 번째\n\n\n줄입니다.</p>\n```",
      "option_a": "공백과 줄바꿈이 모두 그대로 표시된다",
      "option_b": "공백과 줄바꿈이 모두 무시되고 한 칸 공백으로만 표시된다",
      "option_c": "공백은 그대로 표시되지만 줄바꿈은 무시된다",
      "option_d": "줄바꿈은 그대로 표시되지만 공백은 무시된다",
      "correct_answer": "B",
      "explanation": "HTML에서는 브라우저가 자동으로 여러 개의 공백과 줄바꿈을 하나의 공백으로 변환합니다. 따라서 소스 코드에서 여러 개의 공백이나 Enter로 줄을 바꾼 것은 모두 무시되고, 결과적으로 \"첫 번째 줄입니다.\"와 \"두 번째 줄입니다.\"가 각각 한 줄씩 깔끔하게 표시됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:48:07.000Z"
    },
    {
      "id": 847,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 태그는?\n\n```html\n<p>첫 번째 문단입니다.</p>\n______\n<p>구분선 아래 문단입니다.</p>\n<p>이것은______새 줄에서 시작하는______같은 문단 안의 텍스트입니다.</p>\n```",
      "option_a": "`<hr>`, `<br>`, `<br>`",
      "option_b": "`<line>`, `<break>`, `<break>`",
      "option_c": "`<hr>`, `<newline>`, `<newline>`",
      "option_d": "`<break>`, `<br>`, `<br>`",
      "correct_answer": "A",
      "explanation": "• 첫 번째 빈칸: `<hr>` 태그는 수평선(horizontal rule)을 그어서 내용을 구분할 때 사용합니다.\n• 두 번째, 세 번째 빈칸: `<br>` 태그는 줄바꿈(line break)을 만들 때 사용합니다. 새로운 문단을 만들지 않고도 같은 문단 내에서 줄을 바꿀 수 있습니다.\n\n`<hr>`와 `<br>` 모두 빈 태그(empty tag)로, 닫는 태그가 없습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T14:49:58.000Z"
    },
    {
      "id": 848,
      "subject_id": 8,
      "question": "시나 코드처럼 공백과 줄바꿈을 그대로 유지하려면 어떤 태그를 사용해야 할까요?\n\n```html\n<______>\n  function hello() {\n    console.log(\"Hello World!\");\n  }\n</______>\n```",
      "option_a": "`<p>`",
      "option_b": "`<pre>`",
      "option_c": "`<code>`",
      "option_d": "`<text>`",
      "correct_answer": "B",
      "explanation": "`<pre>` 태그는 \"preformatted text\"의 줄임말로, 미리 서식이 지정된 텍스트를 의미합니다. 이 태그 안의 내용은:\n\n• 공백과 줄바꿈이 소스 코드 그대로 유지됩니다\n• 보통 고정폭 글꼴(Courier 등)로 표시됩니다\n• 코드, 시, ASCII 아트 등을 표시할 때 유용합니다\n\n일반적인 `<p>` 태그와는 달리, `<pre>` 태그는 여러 공백과 줄바꿈을 모두 보존합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T14:51:12.000Z"
    },
    {
      "id": 849,
      "subject_id": 8,
      "question": "다음 코드들 중에서 가장 적절한 것은?\n\n```html\n<!-- 선택지 1 -->\n<p>공지사항</p>\n<hr>\n<p>오늘은<br>좋은 날입니다.</p>\n\n<!-- 선택지 2 -->\n<p>공지사항\n\n오늘은\n\n\n좋은 날입니다.</p>\n\n<!-- 선택지 3 -->\n<pre>공지사항\n오늘은\n좋은 날입니다.</pre>\n\n<!-- 선택지 4 -->\n<p>공지사항</p>\n<p>오늘은 좋은 날입니다.</p>\n```\n\n\"공지사항\"과 \"오늘은 좋은 날입니다.\"를 구분하여 표시하되, 의미적으로 올바른 구조는?",
      "option_a": "선택지 1",
      "option_b": "선택지 2",
      "option_c": "선택지 3",
      "option_d": "선택지 4",
      "correct_answer": "D",
      "explanation": "각 선택지를 분석해보면:\n\n선택지 1: `<hr>` 태그는 주제의 변화나 섹션 구분에 사용하는 것이 적절하므로, 단순히 두 문장을 구분하는 용도로는 과도합니다.\n\n선택지 2: HTML은 여러 공백과 줄바꿈을 무시하므로 \"공지사항 오늘은 좋은 날입니다.\"로 한 줄에 표시됩니다.\n\n선택지 3: `<pre>` 태그는 코드나 시처럼 정확한 서식이 중요한 경우에 사용하는 것이 적절합니다. 일반 문장에는 부적절합니다.\n\n선택지 4: 각각 독립적인 의미를 가진 문장이므로 별도의 `<p>` 태그로 구분하는 것이 의미적으로 가장 올바릅니다. 브라우저가 자동으로 문단 간 적절한 간격을 만들어 줍니다.\n\nHTML의 기본 원칙은 의미에 맞는 태그 사용이므로, 두 개의 독립적인 문장은 두 개의 문단으로 처리하는 것이 가장 적절합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T14:52:58.000Z"
    },
    {
      "id": 850,
      "subject_id": 8,
      "question": "HTML에서 요소에 스타일을 적용하기 위해 사용하는 속성은?",
      "option_a": "css",
      "option_b": "design",
      "option_c": "style",
      "option_d": "format",
      "correct_answer": "C",
      "explanation": "HTML에서 요소에 색상, 폰트, 크기 등의 스타일을 적용할 때는 `style` 속성을 사용합니다. `style` 속성의 기본 문법은 `<태그명 style=\"속성:값;\">`입니다. 예를 들어, `<p style=\"color:red;\">빨간 텍스트</p>`처럼 사용할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:58:16.000Z"
    },
    {
      "id": 851,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n\n```html\n<p style=\"______:blue;\">파란색 텍스트입니다.</p>\n```",
      "option_a": "text-color",
      "option_b": "color",
      "option_c": "font-color",
      "option_d": "text",
      "correct_answer": "B",
      "explanation": "HTML에서 텍스트의 색상을 변경할 때는 CSS의 `color` 속성을 사용합니다. `color` 속성은 요소의 텍스트 색상을 정의하며, 색상명(blue, red 등), 16진수 코드(`#0000FF`), RGB 값 등으로 지정할 수 있습니다. `text-color`나 `font-color`는 존재하지 않는 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T14:59:25.000Z"
    },
    {
      "id": 852,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성들은?\n\n```html\n<body style=\"①______:lightblue;\">\n  <h1 style=\"②______:arial;\">제목</h1>\n  <p style=\"③______:150%;\">본문 텍스트</p>\n</body>\n```",
      "option_a": "color, font-family, font-size",
      "option_b": "background-color, font-family, font-size",
      "option_c": "text-color, font-name, text-size",
      "option_d": "background, font, size",
      "correct_answer": "B",
      "explanation": "①번: `background-color`는 요소의 배경색을 설정하는 CSS 속성입니다.\n②번: `font-family`는 텍스트에 사용할 글꼴을 지정하는 속성입니다. (예: arial, verdana, courier 등)\n③번: `font-size`는 텍스트의 크기를 설정하는 속성입니다. 픽셀(px), 퍼센트(%), em 등의 단위를 사용할 수 있습니다.\n\n선택지 3번과 4번의 속성들은 실제로 존재하지 않는 CSS 속성들입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T15:01:25.000Z"
    },
    {
      "id": 853,
      "subject_id": 8,
      "question": "다음 코드의 실행 결과로 올바른 것은?\n\n```html\n<h1 style=\"text-align:center; color:red;\">중앙 제목</h1>\n<p style=\"text-align:center;\">중앙 문단</p>\n```",
      "option_a": "제목과 문단 모두 왼쪽 정렬되고, 제목만 빨간색으로 표시",
      "option_b": "제목과 문단 모두 중앙 정렬되고, 제목만 빨간색으로 표시",
      "option_c": "제목만 중앙 정렬되고, 문단은 왼쪽 정렬, 둘 다 빨간색으로 표시",
      "option_d": "제목과 문단 모두 중앙 정렬되고, 둘 다 빨간색으로 표시",
      "correct_answer": "B",
      "explanation": "• `text-align:center`는 텍스트를 수평으로 중앙 정렬합니다.\n• `color:red`는 텍스트 색상을 빨간색으로 만듭니다.\n• 각 요소는 독립적으로 스타일이 적용되므로:\n`<h1>` 태그: 중앙 정렬 + 빨간색 텍스트\n`<p>` 태그: 중앙 정렬 + 기본 색상(보통 검은색)\n\n한 요소에 여러 CSS 속성을 적용할 때는 세미콜론(;)으로 구분합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T15:03:21.000Z"
    },
    {
      "id": 854,
      "subject_id": 8,
      "question": "다음 코드에서 스타일 적용 우선순위가 가장 높은 요소는?\n```html\n<body style=\"background-color:yellow;\">\n  <div style=\"background-color:blue;\">\n    <p style=\"color:red; font-size:20px;\">\n      이 텍스트는 <span style=\"color:green;\">초록색</span>과 빨간색입니다.\n    </p>\n  </div>\n</body>\n```\n`<span>` 요소의 최종 스타일은?",
      "option_a": "배경색: 노란색, 글자색: 빨간색, 크기: 20px",
      "option_b": "배경색: 파란색, 글자색: 초록색, 크기: 20px",
      "option_c": "배경색: 투명, 글자색: 초록색, 크기: 20px",
      "option_d": "배경색: 노란색, 글자색: 초록색, 크기: 기본크기",
      "correct_answer": "C",
      "explanation": "CSS에서는 더 구체적이고 가까운 요소의 스타일이 우선순위가 높습니다.\n\n각 속성별 분석:\n\n배경색(background-color):\n\n• `<body>`: yellow\n• `<div>`: blue\n• `<span>`: 지정되지 않음 → 투명(기본값)\n\n글자색(color):\n\n• `<p>`: red\n• `<span>`: green → green 적용 (직접 지정된 스타일이 상속된 스타일보다 우선)\n\n글자크기(font-size):\n\n• `<p>`: 20px\n• `<span>`: 지정되지 않음 → 부모로부터 상속받아 20px\n\n따라서 `<span>` 요소는 배경색이 투명하고, 글자색은 초록색, 크기는 부모에서 상속받은 20px가 됩니다. 하지만 문제에서는 크기에 대한 명시적 언급이 없으므로 가장 정확한 답은 3번입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T15:05:18.000Z"
    },
    {
      "id": 855,
      "subject_id": 8,
      "question": "HTML에서 텍스트를 굵게 표시하는 태그는?",
      "option_a": "`<bold>`",
      "option_b": "`<b>`",
      "option_c": "`<thick>`",
      "option_d": "`<heavy>`",
      "correct_answer": "B",
      "explanation": "HTML에서 텍스트를 굵게 표시할 때는 `<b>` 태그를 사용합니다. `<b>` 태그는 \"bold\"의 줄임말로, 단순히 텍스트를 굵게 표시하는 시각적 효과를 제공합니다. 사용법은 `<b>굵은 텍스트</b>`와 같습니다. `<bold>`, `<thick>`, `<heavy>` 태그는 HTML에 존재하지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T15:11:40.000Z"
    },
    {
      "id": 856,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 태그는?\n\n```html\n<p>이 텍스트는 ______기울어진 텍스트______ 입니다.</p>\n```",
      "option_a": "`<italic>`, `</italic>`",
      "option_b": "`<i>`, `</i>`",
      "option_c": "`<slant>`, `</slant>`",
      "option_d": "`<tilt>`, `</tilt>`",
      "correct_answer": "B",
      "explanation": "HTML에서 텍스트를 기울임체(이탤릭)로 표시할 때는 `<i>` 태그를 사용합니다. `<i>` 태그는 \"italic\"의 줄임말로, 텍스트를 기울어지게 표시합니다. 올바른 사용법은 `<i>기울어진 텍스트</i>`입니다. 모든 HTML 태그는 여는 태그와 닫는 태그가 쌍을 이루어야 합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T15:12:45.000Z"
    },
    {
      "id": 857,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 태그들은?\n\n```html\n<p>화학식: H______2______O</p>\n```",
      "option_a": "`<sub>`, `</sub>`",
      "option_b": "`<down>`, `</down>`",
      "option_c": "`<lower>`, `</lower>`",
      "option_d": "`<below>`, `</below>`",
      "correct_answer": "A",
      "explanation": "`<sub>` 태그는 아래첨자(subscript)를 만들 때 사용합니다. 화학식에서 H₂O의 '2'처럼 기준선 아래에 작고 표시됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T15:16:36.000Z"
    },
    {
      "id": 858,
      "subject_id": 8,
      "question": "다음 코드의 실행 결과에서 텍스트 표시 방식으로 올바른 것은?\n\n```html\n<p>내가 좋아하는 색상은 <del>파란색</del> <ins>빨간색</ins>입니다.</p>\n```",
      "option_a": "\"파란색\"은 굵게, \"빨간색\"은 기울임체로 표시",
      "option_b": "\"파란색\"은 취소선, \"빨간색\"은 밑줄로 표시",
      "option_c": "\"파란색\"은 작은 글씨, \"빨간색\"은 큰 글씨로 표시",
      "option_d": "\"파란색\"은 하이라이트, \"빨간색\"은 일반 텍스트로 표시",
      "correct_answer": "B",
      "explanation": "• `<del>` 태그는 \"deleted\"의 줄임말로, 문서에서 삭제된 텍스트를 나타냅니다. 브라우저는 이를 보통 **취소선(strikethrough)**으로 표시합니다.\n• `<ins>` 태그는 \"inserted\"의 줄임말로, 문서에 새로 추가된 텍스트를 나타냅니다. 브라우저는 이를 보통 **밑줄(underline)**로 표시합니다.\n\n이 태그들은 문서 편집 과정에서 수정 사항을 표시할 때 유용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T15:18:07.000Z"
    },
    {
      "id": 859,
      "subject_id": 8,
      "question": "다음 코드에서 의미적으로 가장 적절한 조합은?\n\n```html\n<!-- 상황: 웹페이지에서 중요한 경고 메시지와 기술 용어를 표시 -->\n\n<p>______시스템 오류______가 발생했습니다. ______localhost______ 서버를 확인하세요.</p>\n```\n\n\"시스템 오류\"는 사용자에게 매우 중요한 정보이고, \"localhost\"는 기술 용어입니다.",
      "option_a": "`<b>`, `</b>`, `<i>`, `</i>`",
      "option_b": "`<strong>`, `</strong>`, `<i>`, `</i>`",
      "option_c": "`<b>`, `</b>`, `<em>`, `</em>`",
      "option_d": "`<strong>`, `</strong>`, `<em>`, `</em>`",
      "correct_answer": "B",
      "explanation": "HTML에서는 단순한 시각적 효과보다 의미적(semantic) 마크업이 중요합니다:\n\n`<strong>` vs `<b>`:\n\n• `<strong>`: 내용이 매우 중요함을 의미 (스크린 리더가 강조해서 읽음)\n• `<b>`: 단순히 굵게 표시하는 시각적 효과만\n\n`<i>` vs `<em>`:\n\n• `<i>`: 기술 용어, 외국어, 생각 등 다른 톤의 텍스트 (localhost 같은 기술 용어에 적합)\n• `<em>`: 강조된 텍스트 (스크린 리더가 강세를 주어 읽음)\n\n문제 상황 분석:\n\n\"시스템 오류\": 사용자에게 중요한 정보 → `<strong>` 적합\n\"localhost\": 기술 용어 → `<i>` 적합\n\n따라서 접근성과 의미를 고려할 때 `<strong>`과 `<i>`의 조합이 가장 적절합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T15:21:06.000Z"
    },
    {
      "id": 860,
      "subject_id": 8,
      "question": "HTML에서 긴 인용문을 표시할 때 사용하는 태그는?",
      "option_a": "`<quote>`",
      "option_b": "`<blockquote>`",
      "option_c": "`<longquote>`",
      "option_d": "`<citation>`",
      "correct_answer": "B",
      "explanation": "HTML에서 다른 소스로부터 인용한 긴 텍스트 섹션을 정의할 때는 `<blockquote>` 태그를 사용합니다. 브라우저는 일반적으로 `<blockquote>` 요소를 들여쓰기하여 표시합니다. 이 태그는 여러 줄에 걸친 긴 인용문에 적합하며, 단순한 `<quote>` 태그나 `<longquote>` 태그는 존재하지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T15:25:52.000Z"
    },
    {
      "id": 861,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 태그는?\n\n```html\n<p>그는 말했다: ______\"오늘은 좋은 날이다\"______ 라고 했다.</p>\n```",
      "option_a": "`<shortquote>`, `</shortquote>`",
      "option_b": "`<q>`, `</q>`",
      "option_c": "`<quote>`, `</quote>`",
      "option_d": "`<cite>`, `</cite>`",
      "correct_answer": "B",
      "explanation": "HTML에서 짧은 인용문을 정의할 때는 `<q>` 태그를 사용합니다. 브라우저는 일반적으로 `<q>` 요소 주위에 자동으로 따옴표를 삽입합니다. `<q>` 태그는 문장 내에서 사용되는 짧은 인용구에 적합하며, `<shortquote>`나 `<quote>` 태그는 HTML에 존재하지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T15:27:08.000Z"
    },
    {
      "id": 862,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 태그와 속성은?\n\n```html\n<p>______title=\"World Health Organization\"______WHO______는 1948년에 설립되었다.</p>\n```",
      "option_a": "`<abbr`, `>`, `</abbr>`",
      "option_b": "`<acronym`, `>`, `</acronym>`",
      "option_c": "`<short`, `>`, `</short>`",
      "option_d": "`<abbreviation`, `>`, `</abbreviation>`",
      "correct_answer": "A",
      "explanation": "HTML에서 약어나 줄임말을 정의할 때는 <abbr> 태그를 사용합니다. \"WHO\"와 같은 약어나 \"Dr.\", \"Mr.\" 같은 줄임말에 사용됩니다. `title` 속성을 함께 사용하면 마우스를 올렸을 때 전체 명칭을 툴팁으로 표시할 수 있어 사용자에게 유용한 정보를 제공합니다. 이는 브라우저, 번역 시스템, 검색 엔진에도 유용한 정보를 제공합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T15:30:10.000Z"
    },
    {
      "id": 863,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 태그들은?\n\n```html\n<p>______모나리자______는 레오나르도 다 빈치의 작품이다.</p>\n<______>\n작성자: 홍길동<br>\n이메일: hong@example.com<br>\n전화: 010-1234-5678\n</______>\n```\n\n",
      "option_a": "`<cite>`, `</cite>`, `<contact>`, `</contact>`",
      "option_b": "`<cite>`, `</cite>`, `<address>`, `</address>`",
      "option_c": "`<title>`, `</title>`, `<contact>`, `</contact>`",
      "option_d": "`<work>`, `</work>`, `<address>`, `</address>`",
      "correct_answer": "B",
      "explanation": "• `<cite>` 태그는 창작물의 제목(책, 시, 노래, 영화, 그림, 조각품 등)을 정의할 때 사용합니다. 주의할 점은 사람의 이름이 아닌 작품의 제목에만 사용한다는 것입니다.\n\n• `<address>` 태그는 문서나 기사의 작성자/소유자의 연락처 정보를 정의합니다. 이메일 주소, URL, 실제 주소, 전화번호, 소셜 미디어 계정 등이 포함될 수 있습니다. 브라우저는 일반적으로 이 요소를 기울임체로 표시하고 앞뒤로 줄바꿈을 추가합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T15:32:16.000Z"
    },
    {
      "id": 864,
      "subject_id": 8,
      "question": "다음 상황에서 가장 적절한 태그 조합은?\n\n```html\n<!-- 상황: 블로그 글에서 유명한 소설의 한 구절을 길게 인용하고, 출처를 명시하려고 함 -->\n\n<p>셰익스피어의 유명한 작품에서 이런 구절이 있습니다:</p>\n\n①______\nTo be or not to be, that is the question:\nWhether 'tis nobler in the mind to suffer\nThe slings and arrows of outrageous fortune...\n②______\n\n<p>- ③______햄릿③______ 中에서</p>\n```",
      "option_a": "`<q>`, `</q>`, `<cite>`, `</cite>`",
      "option_b": "`<blockquote>`, `</blockquote>`, `<cite>`, `</cite>`",
      "option_c": "`<blockquote>`, `</blockquote>`, `<address>`, `</address>`",
      "option_d": "`<q>`, `</q>`, `<abbr>`, `</abbr>`",
      "correct_answer": "B",
      "explanation": "이 문제는 인용문의 길이와 성격에 따른 적절한 태그 선택을 묻고 있습니다:\n\n①②번 분석:\n\n• 여러 줄에 걸친 긴 인용문이므로 `<blockquote>`가 적절합니다\n• `<q>` 태그는 문장 내의 짧은 인용구에 사용하므로 부적절합니다\n\n③번 분석:\n\n• \"햄릿\"은 셰익스피어의 작품 제목이므로 `<cite>` 태그가 적절합니다\n• `<address>`는 연락처 정보용이므로 부적절합니다\n• `<abbr>`는 줄임말/약어용이므로 부적절합니다\n\n올바른 사용 구분:\n\n• `<blockquote>`: 긴 인용문 (여러 줄, 별도 단락)\n• `<q>`: 짧은 인용문 (문장 내 삽입)\n• `<cite>`: 창작물의 제목\n• `<address>`: 연락처 정보\n• `<abbr>`: 약어/줄임말\n\n따라서 긴 인용문을 위한 `<blockquote>`와 작품 제목을 위한 `<cite>`의 조합이 가장 의미적으로 올바릅니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T15:35:41.000Z"
    },
    {
      "id": 865,
      "subject_id": 8,
      "question": "HTML에서 주석을 작성하는 올바른 문법은?",
      "option_a": "`<comment>주석 내용</comment>`",
      "option_b": "`<!-- 주석 내용 -->`",
      "option_c": "`<-- 주석 내용 -->`",
      "option_d": "`/* 주석 내용 */`",
      "correct_answer": "B",
      "explanation": "HTML에서 주석을 작성할 때는 `<!-- 주석 내용 -->`의 문법을 사용합니다.\n\n• 시작 부분에는 `<!--`를 사용하며, 여기서 주목할 점은 `<` 다음에 느낌표(!)가 온다는 것입니다.\n• 끝 부분에는 `-->`를 사용하며, 여기서는 느낌표가 없습니다.\n• HTML 주석은 브라우저에 표시되지 않지만, HTML 소스 코드를 문서화하고 설명하는 데 도움이 됩니다.\n• 선택지 4번의 `/* */`는 CSS나 JavaScript에서 사용하는 주석 문법입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T15:39:30.000Z"
    },
    {
      "id": 866,
      "subject_id": 8,
      "question": "다음 코드의 실행 결과는?\n\n```html\n<p>첫 번째 문단입니다.</p>\n<!-- <p>두 번째 문단입니다.</p> -->\n<p>세 번째 문단입니다.</p>\n```",
      "option_a": "세 개의 문단이 모두 표시된다",
      "option_b": "첫 번째와 세 번째 문단만 표시된다",
      "option_c": "첫 번째 문단만 표시된다",
      "option_d": "아무것도 표시되지 않는다",
      "correct_answer": "B",
      "explanation": "HTML 주석으로 감싸진 내용은 브라우저에 표시되지 않습니다. 따라서:\n\n• `<p>첫 번째 문단입니다.</p>` → 표시됨\n• `<!-- <p>두 번째 문단입니다.</p> -->` → 표시되지 않음 (주석 처리됨)\n• `<p>세 번째 문단입니다.</p>` → 표시됨\n\n주석은 콘텐츠를 임시로 숨기는 데 매우 유용합니다. 개발 과정에서 특정 부분을 잠시 제거해보고 싶거나, 나중에 사용할 코드를 보관해두고 싶을 때 주석을 활용할 수 있습니다. 또한 HTML 디버깅 시에 코드 한 줄씩 주석 처리하여 오류를 찾는 용도로도 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T15:40:42.000Z"
    },
    {
      "id": 867,
      "subject_id": 8,
      "question": "다음 코드에서 브라우저에 실제로 표시되는 텍스트는?\n\n```html\n<p>이것은 <!-- 정말 --> 좋은 <!-- 아주 멋진 --> 예시입니다.</p>\n<!--\n<h1>제목입니다</h1>\n<p>이 문단은 여러 줄에 걸쳐\n작성되었습니다.</p>\n-->\n<p>마지막 문단입니다.</p>\n```",
      "option_a": "\"이것은 정말 좋은 아주 멋진 예시입니다. 제목입니다 이 문단은 여러 줄에 걸쳐 작성되었습니다. 마지막 문단입니다.\"",
      "option_b": "\"이것은 좋은 예시입니다. 마지막 문단입니다.\"",
      "option_c": "\"이것은 정말 좋은 아주 멋진 예시입니다. 마지막 문단입니다.\"",
      "option_d": "\"이것은 좋은 예시입니다. 제목입니다 이 문단은 여러 줄에 걸쳐 작성되었습니다. 마지막 문단입니다.\"",
      "correct_answer": "B",
      "explanation": "1. 인라인 주석 (문장 중간에 삽입):\n```html\n<p>이것은 <!-- 정말 --> 좋은 <!-- 아주 멋진 --> 예시입니다.</p>\n```\n• \"정말\"과 \"아주 멋진\" 부분이 주석으로 처리되어 표시되지 않습니다.\n• 실제 표시: \"이것은 좋은 예시입니다.\"\n\n2. 블록 주석 (여러 줄 주석):\n```html\n<!--\n<h1>제목입니다</h1>\n<p>이 문단은 여러 줄에 걸쳐\n작성되었습니다.</p>\n-->\n```\n• `<!--`와 `-->` 사이의 모든 내용이 숨겨집니다.\n• 여러 HTML 요소를 한 번에 주석 처리할 수 있습니다.\n\n3. 일반 요소:\n```html\n<p>마지막 문단입니다.</p>\n```\n• 주석이 아니므로 정상적으로 표시됩니다.\n\n최종 결과: \"이것은 좋은 예시입니다.\"와 \"마지막 문단입니다.\"만 브라우저에 표시됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T15:42:50.000Z"
    },
    {
      "id": 868,
      "subject_id": 8,
      "question": "HTML에서 텍스트 색상을 빨간색으로 설정하는 올바른 방법은?",
      "option_a": "`<p style=\"text-color:red;\">텍스트</p>`",
      "option_b": "`<p style=\"color:red;\">텍스트</p>`",
      "option_c": "`<p style=\"font-color:red;\">텍스트</p>`",
      "option_d": "`<p style=\"red-color:true;\">텍스트</p>`",
      "correct_answer": "B",
      "explanation": "HTML에서 텍스트의 색상을 설정할 때는 CSS의 `color` 속성을 사용합니다.\n\n• `color` 속성은 요소의 텍스트 색상을 정의합니다\n• 값으로는 색상 이름(red, blue 등), HEX 코드(`#ff0000`), RGB 값(rgb(255,0,0)) 등을 사용할 수 있습니다\n• `text-color`, `font-color` 등은 존재하지 않는 속성입니다\n• HTML은 140가지 표준 색상 이름을 지원합니다",
      "difficulty": "easy",
      "created_at": "2025-08-08T15:46:54.000Z"
    },
    {
      "id": 869,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n\n```html\n<h1 style=\"______:DodgerBlue;\">제목</h1>\n<p style=\"______:Tomato;\">이것은 문단입니다.</p>\n```",
      "option_a": "`color`, `background-color`",
      "option_b": "`background-color`, `color`",
      "option_c": "`text-color`, `bg-color`",
      "option_d": "`font-color`, `back-color`",
      "correct_answer": "B",
      "explanation": "• 첫 번째 빈칸: `background-color` 속성은 요소의 배경색을 설정합니다. 제목(`<h1>`)의 배경을 DodgerBlue(하늘색)로 설정하는 것입니다.\n• 두 번째 빈칸: `color` 속성은 텍스트 색상을 설정합니다. 문단(`<p>`)의 글자색을 Tomato(토마토색, 빨간색 계열)로 설정하는 것입니다.\n\n이 두 속성은 HTML/CSS에서 가장 기본적이고 자주 사용되는 색상 관련 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-08T15:48:16.000Z"
    },
    {
      "id": 870,
      "subject_id": 8,
      "question": "RGB 색상 값에 대한 설명으로 올바른 것은?\n\n```html\n<div style=\"background-color:rgb(255, 0, 0);\">빨간색</div>\n<div style=\"background-color:rgb(0, 255, 0);\">초록색</div>\n<div style=\"background-color:rgb(0, 0, 255);\">파란색</div>\n```",
      "option_a": "각 값은 0부터 100까지의 범위를 가진다",
      "option_b": "각 값은 0부터 255까지의 범위를 가지며, 총 16,777,216가지 색상 조합이 가능하다",
      "option_c": "첫 번째 값은 투명도를 나타낸다",
      "option_d": "RGB는 Red, Green, Black의 줄임말이다",
      "correct_answer": "B",
      "explanation": "RGB 색상 시스템에 대한 핵심 정보입니다:\n\nRGB 기본 개념:\n\n• RGB는 Red(빨강), Green(초록), Blue(파랑)의 줄임말입니다\n• 각 색상 성분은 0부터 255까지의 값을 가집니다 (총 256개 값)\n• 공식: `rgb(red, green, blue)`\n\n색상 조합 계산:\n\n• 가능한 색상 조합: 256 × 256 × 256 = 16,777,216가지\n\n예시 분석:\n\n• `rgb(255, 0, 0)`: 빨강 최대, 초록/파랑 0 → 순수한 빨간색\n• `rgb(0, 255, 0)`: 초록 최대, 빨강/파랑 0 → 순수한 초록색\n• `rgb(0, 0, 255)`: 파랑 최대, 빨강/초록 0 → 순수한 파란색\n\n특별한 경우:\n\n• 검은색: `rgb(0, 0, 0)` (모든 값이 0)\n• 흰색: `rgb(255, 255, 255)` (모든 값이 최대)",
      "difficulty": "medium",
      "created_at": "2025-08-08T15:49:56.000Z"
    },
    {
      "id": 871,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 HEX 색상 값은?\n\n```html\n<p style=\"color:______;\">빨간색 텍스트</p>\n<p style=\"color:______;\">파란색 텍스트</p>\n<p style=\"color:______;\">흰색 텍스트</p>\n```",
      "option_a": "`#ff0000`, `#0000ff`, `#ffffff`",
      "option_b": "`#red`, `#blue`, `#white`",
      "option_c": "`#255000`, `#000255`, `#255255255`",
      "option_d": "`ff0000`, `0000ff`, `ffffff`",
      "correct_answer": "A",
      "explanation": "HEX(16진수) 색상 값의 올바른 사용법입니다:\n\nHEX 색상 형식:\n\n• 형식: `#RRGGBB`\n• `#` 기호로 시작 (필수)\n• RR(빨강), GG(초록), BB(파랑) 각각 00~FF (16진수)\n\n각 색상 분석:\n\n• 빨간색 `#ff0000`:\nRR=FF (빨강 최대), GG=00 (초록 없음), BB=00 (파랑 없음)\n\n• 파란색 `#0000ff`:\nRR=00 (빨강 없음), GG=00 (초록 없음), BB=FF (파랑 최대)\n\n• 흰색 `#ffffff`:\n모든 색상 성분이 최대값 (FF)\n\n16진수와 10진수 대응:\n\n• 00 (16진수) = 0 (10진수)\n• FF (16진수) = 255 (10진수)\n\n따라서 `#ff0000`은 `rgb(255, 0, 0)`과 동일한 색상입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T15:52:43.000Z"
    },
    {
      "id": 872,
      "subject_id": 8,
      "question": "다음 RGBA와 HSLA 색상에 대한 설명 중 올바른 것은?\n\n```html\n<div style=\"background-color:rgba(255, 99, 71, 0.5);\">반투명 토마토색</div>\n<div style=\"background-color:hsla(120, 100%, 50%, 0.8);\">반투명 초록색</div>\n```",
      "option_a": "RGBA의 네 번째 값은 색상의 밝기를 나타내며, 0이 가장 밝고 1이 가장 어둡다",
      "option_b": "HSLA에서 첫 번째 값 120은 색상환에서 초록색을 나타내며, 네 번째 값 0.8은 80% 불투명도를 의미한다",
      "option_c": "두 색상 모두 완전히 투명하여 보이지 않는다",
      "option_d": "RGBA와 HSLA는 각각 3개의 매개변수만 가질 수 있다",
      "correct_answer": "B",
      "explanation": "RGBA와 HSLA의 Alpha 채널(투명도)에 대한 고급 개념입니다:\n\nRGBA 분석 (`rgba(255, 99, 71, 0.5)`):\n\n• 첫 3개 값: RGB 색상 (토마토색)\n• 네 번째 값 `0.5`: Alpha 채널 = 50% 투명도 (50% 불투명)\n\nHSLA 분석 (`hsla(120, 100%, 50%, 0.8)`):\n\n• `120`: Hue(색조) = 색상환에서 120도 = 초록색 위치\n0도 = 빨강, 120도 = 초록, 240도 = 파랑\n\n• `100%`: Saturation(채도) = 순수한 색상 (회색 섞임 없음)\n\n• `50%`: Lightness(명도) = 중간 밝기 (0%=검정, 100%=흰색)\n\n• `0.8`: Alpha = 80% 불투명도 (20% 투명)\n\nAlpha 채널 이해:\n\n• 범위: 0.0 (완전 투명) ~ 1.0 (완전 불투명)\n• `0.5` = 50% 불투명 = 뒤의 내용이 50% 비쳐 보임\n• `0.8` = 80% 불투명 = 거의 불투명하지만 약간 투명\n\n따라서 두 색상 모두 반투명 상태로 표시되며, 뒤의 배경이 일부 비쳐 보입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-08T15:54:42.000Z"
    },
    {
      "id": 873,
      "subject_id": 8,
      "question": "CSS는 무엇의 줄임말이며, 주요 목적은 무엇인가요?",
      "option_a": "Computer Style Sheets - 컴퓨터 스타일 관리",
      "option_b": "Cascading Style Sheets - 웹페이지 레이아웃 포맷팅",
      "option_c": "Creative Style System - 창의적 디자인 시스템",
      "option_d": "Color Style Specification - 색상 스타일 지정",
      "correct_answer": "B",
      "explanation": "CSS는 \"Cascading Style Sheets\"의 줄임말입니다.\n\n• **Cascading(계단식)**이라는 의미는 부모 요소에 적용된 스타일이 자식 요소들에게도 자동으로 적용된다는 뜻입니다\n\n• CSS의 주요 목적은 웹페이지의 레이아웃을 포맷팅하는 것입니다\n\n• 색상, 폰트, 텍스트 크기, 요소 간의 간격, 위치, 배경 등을 제어할 수 있습니다\n\n• 한 번에 여러 웹페이지의 레이아웃을 제어할 수 있어서 많은 작업을 절약해줍니다",
      "difficulty": "easy",
      "created_at": "2025-08-08T15:58:45.000Z"
    },
    {
      "id": 874,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n\n```html\n<h1 ______=\"color:blue;\">파란색 제목</h1>\n<p ______=\"color:red;\">빨간색 문단</p>\n```",
      "option_a": "class",
      "option_b": "style",
      "option_c": "css",
      "option_d": "design",
      "correct_answer": "B",
      "explanation": "인라인 CSS를 적용할 때는 `style` 속성을 사용합니다.\n\n• 인라인 CSS는 개별 HTML 요소에 고유한 스타일을 적용하는 방법입니다\n\n• `style` 속성 안에 CSS 속성과 값을 `속성:값;` 형태로 작성합니다\n\n• 예시: `style=\"color:blue;\"` (텍스트를 파란색으로)\n\n• 여러 속성을 적용할 때는 세미콜론(;)으로 구분합니다: `style=\"color:blue; font-size:20px;\"`",
      "difficulty": "easy",
      "created_at": "2025-08-08T16:00:31.000Z"
    },
    {
      "id": 875,
      "subject_id": 8,
      "question": "HTML 문서에 CSS를 적용하는 방법은 3가지입니다. 다음 중 올바른 조합은?",
      "option_a": "Inline, Internal, External",
      "option_b": "Direct, Embedded, Linked",
      "option_c": "Simple, Complex, Advanced",
      "option_d": "Local, Global, Universal",
      "correct_answer": "A",
      "explanation": "CSS를 HTML에 적용하는 3가지 방법입니다:\n\n1. Inline CSS (인라인)\n\n• HTML 요소의 `style` 속성 사용\n• 예: `<h1 style=\"color:blue;\">제목</h1>`\n• 개별 요소에만 적용\n\n2. Internal CSS (내부)\n\n• `<head>` 섹션 내의 `<style>` 요소 사용\n• 해당 HTML 페이지 전체에 적용\n• 예: `<style>h1 {color: blue;}</style>`\n\n3. External CSS (외부)\n\n• 별도의 CSS 파일(.css)을 만들고 `<link>` 요소로 연결\n• 여러 웹페이지에서 공유 가능\n• 예: `<link rel=\"stylesheet\" href=\"styles.css\">`\n\n가장 일반적이고 권장되는 방법은 External CSS입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-08T16:02:08.000Z"
    },
    {
      "id": 876,
      "subject_id": 8,
      "question": "다음 Internal CSS 코드에서 빈칸에 들어갈 올바른 태그들은?\n\n```html\n<!DOCTYPE html>\n<html>\n<______>\n<______>\nbody {background-color: powderblue;}\nh1 {color: blue;}\np {color: red;}\n</______>\n</______>\n<body>\n<h1>제목</h1>\n<p>문단</p>\n</body>\n</html>\n```",
      "option_a": "`<head>`, `<css>`, `</css>`, `</head>`",
      "option_b": "`<head>`, `<style>`, `</style>`, `</head>`",
      "option_c": "`<header>`, `<style>`, `</style>`, `</header>`",
      "option_d": "`<head>`, `<design>`, `</design>`, `</head>`",
      "correct_answer": "B",
      "explanation": "Internal CSS의 올바른 구조입니다:\n\n구조 분석:\n\n• `<head>`: HTML 문서의 메타데이터 섹션\n• `<style>`: 내부 CSS를 정의하는 태그\n\nCSS 규칙 해석:\n\n• `body {background-color: powderblue;}`: 페이지 전체 배경을 연한 파란색으로\n• `h1 {color: blue;}`: 모든 `<h1>` 태그의 텍스트를 파란색으로\n• `p {color: red;}`: 모든 `<p>` 태그의 텍스트를 빨간색으로\n\n장점:\n\n• 한 페이지의 모든 동일한 요소에 일괄 적용\n• 인라인 CSS보다 관리가 쉬움\n• 해당 페이지에서만 유효",
      "difficulty": "medium",
      "created_at": "2025-08-08T16:04:21.000Z"
    },
    {
      "id": 877,
      "subject_id": 8,
      "question": "다음 CSS 속성들과 그 역할에 대한 설명 중 올바른 것은?\n\n```css\np {\n  border: 2px solid blue;\n  padding: 20px;\n  margin: 30px;\n  font-family: Arial;\n  font-size: 150%;\n}\n```",
      "option_a": "padding은 테두리 바깥쪽 공간, margin은 테두리 안쪽 공간이다",
      "option_b": "border는 요소 주변의 테두리, padding은 텍스트와 테두리 사이 공간, margin은 테두리 바깥쪽 공간이다",
      "option_c": "font-family는 글자 크기, font-size는 글꼴 종류를 설정한다",
      "option_d": "모든 속성이 텍스트 스타일링에만 관련되어 있다",
      "correct_answer": "B",
      "explanation": "CSS 박스 모델과 폰트 속성의 정확한 이해가 필요한 문제입니다:\n\n박스 모델 구조 (안쪽부터 바깥쪽으로):\n\n1. Content (내용): 실제 텍스트나 이미지\n2. Padding: 내용과 테두리 사이의 안쪽 여백 (`padding: 20px`)\n3. Border: 요소의 테두리 (`border: 2px solid blue` = 2픽셀 두께의 파란색 실선)\n4. Margin: 테두리 바깥쪽 여백, 다른 요소와의 간격 (`margin: 30px`)\n\n폰트 속성:\n\n• `font-family: Arial`: 글꼴 종류 설정 (Arial 폰트 사용)\n• `font-size: 150%`: 글자 크기 설정 (기본 크기의 150%)",
      "difficulty": "hard",
      "created_at": "2025-08-08T16:06:17.000Z"
    },
    {
      "id": 878,
      "subject_id": 8,
      "question": "HTML에서 하이퍼링크를 만들 때 사용하는 태그와 가장 중요한 속성은?",
      "option_a": "`<link>` 태그와 `url` 속성",
      "option_b": "`<a>` 태그와 `href` 속성",
      "option_c": "`<hyperlink>` 태그와 `destination` 속성",
      "option_d": "`<url>` 태그와 `link` 속성",
      "correct_answer": "B",
      "explanation": "HTML에서 하이퍼링크(하이퍼텍스트 링크)를 만들 때는 `<a>` 태그를 사용합니다.\n\n• `<a>` 태그는 \"anchor\"의 줄임말입니다\n• 가장 중요한 속성은 `href`(hypertext reference)로, 링크의 목적지를 지정합니다\n• 기본 문법: `<a href=\"URL\">링크 텍스트</a>`\n• 링크 텍스트는 사용자에게 보이는 부분이고, 이를 클릭하면 href에 지정된 주소로 이동합니다\n• 링크는 텍스트뿐만 아니라 이미지나 다른 HTML 요소도 될 수 있습니다",
      "difficulty": "easy",
      "created_at": "2025-08-09T06:56:10.000Z"
    },
    {
      "id": 879,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성과 값은?\n\n```html\n<a ______=\"https://www.google.com\" ______=\"_blank\">구글로 이동</a>\n```",
      "option_a": "`href`, `target`",
      "option_b": "`link`, `window`",
      "option_c": "`url`, `open`",
      "option_d": "`destination`, `new`",
      "correct_answer": "A",
      "explanation": "이 코드는 새 창에서 구글로 이동하는 링크를 만드는 예시입니다:\n\n첫 번째 빈칸 `href`:\n\n• 링크의 목적지 URL을 지정하는 필수 속성\n• `href=\"https://www.google.com\"`으로 구글 홈페이지를 지정\n\n두 번째 빈칸 `target`:\n\n• 링크된 문서를 어디서 열지 지정하는 속성\n• `target=\"_blank\"`: 새 창이나 새 탭에서 열기\n• `target=\"_self\"`: 현재 창에서 열기 (기본값)\n\n기본 링크 표시:\n\n• 방문하지 않은 링크: 파란색 + 밑줄\n• 방문한 링크: 보라색 + 밑줄\n• 활성화된 링크: 빨간색 + 밑줄",
      "difficulty": "easy",
      "created_at": "2025-08-09T06:58:01.000Z"
    },
    {
      "id": 880,
      "subject_id": 8,
      "question": "절대 URL과 상대 URL에 대한 설명으로 올바른 것은?\n\n```html\n<!-- 예시 A -->\n<a href=\"https://www.example.com/page.html\">외부 사이트</a>\n\n<!-- 예시 B -->\n<a href=\"about.html\">회사 소개</a>\n<a href=\"/images/photo.jpg\">사진</a>\n```",
      "option_a": "예시 A는 상대 URL, 예시 B는 절대 URL이다",
      "option_b": "예시 A는 절대 URL, 예시 B는 상대 URL이다",
      "option_c": "모두 절대 URL이다",
      "option_d": "모두 상대 URL이다",
      "correct_answer": "B",
      "explanation": "URL 유형을 구분하는 중요한 개념입니다:\n\n절대 URL (Absolute URL):\n\n• 완전한 웹 주소를 포함 (`https://www.example.com/page.html`)\n• 프로토콜(https://) + 도메인(www.example.com) + 경로(/page.html)\n• 외부 웹사이트로 링크할 때 사용\n• 어떤 페이지에서든 동일하게 작동\n\n상대 URL (Relative URL):\n\n• 현재 웹사이트 내의 파일 경로만 지정\n• `about.html`: 현재 폴더의 파일\n• `/images/photo.jpg`: 웹사이트 루트부터의 경로\n• 같은 웹사이트 내의 페이지 간 이동에 사용\n• 현재 페이지의 위치에 따라 상대적으로 해석됨\n\n장점:\n\n• 절대 URL: 명확하고 외부 링크에 필수\n• 상대 URL: 사이트 구조 변경 시 유연하고 관리가 쉬움",
      "difficulty": "medium",
      "created_at": "2025-08-09T06:59:34.000Z"
    },
    {
      "id": 881,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 내용은?\n\n```html\n<!-- 이미지를 링크로 만들기 -->\n<a href=\"home.html\">\n  <______ src=\"logo.png\" alt=\"홈으로\" style=\"width:100px;\">\n</a>\n\n<!-- 이메일 링크 만들기 -->\n<a href=\"______:contact@company.com\">문의하기</a>\n```",
      "option_a": "`<img>`, `email`",
      "option_b": "`<img>`, `mailto`",
      "option_c": "`<image>`, `mail`",
      "option_d": "`<picture>`, `mailto`",
      "correct_answer": "B",
      "explanation": "이미지 링크와 이메일 링크를 만드는 방법입니다:\n\n이미지를 링크로 만들기:\n\n• `<img>` 태그를 `<a>` 태그 안에 넣으면 됩니다\n• 이미지를 클릭하면 링크가 작동합니다\n• `alt` 속성으로 접근성을 고려한 대체 텍스트 제공\n• `style`로 이미지 크기 조절 가능\n\n이메일 링크:\n\n• `mailto`: 스키마를 사용합니다\n• `href=\"mailto:contact@company.com\"`\n• 클릭하면 사용자의 기본 이메일 프로그램이 열립니다\n• 새 이메일 작성 화면에서 받는 사람 주소가 자동으로 입력됩니다\n\n추가 활용:\n\n• `mailto:email@example.com?subject=문의사항&body=안녕하세요`: 제목과 본문까지 미리 설정 가능",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:01:35.000Z"
    },
    {
      "id": 882,
      "subject_id": 8,
      "question": "페이지 내 북마크(책갈피) 기능을 구현하는 올바른 방법은?\n\n```html\n<!-- 북마크 생성 -->\n<h2 ①______=\"chapter3\">3장: HTML 링크</h2>\n\n<!-- 북마크로 이동하는 링크 -->\n<a ②______=\"③______chapter3\">3장으로 이동</a>\n\n<!-- 다른 페이지의 북마크로 이동 -->\n<a href=\"tutorial.html④______chapter3\">튜토리얼 3장으로</a>\n```",
      "option_a": "①`id` ②`href` ③`#` ④`#`",
      "option_b": "①`name` ②`link` ③`@` ④`@`",
      "option_c": "①`bookmark` ②`href` ③`&` ④`&`",
      "option_d": "①`anchor` ②`target` ③`#` ④`#`",
      "correct_answer": "A",
      "explanation": " HTML 북마크(책갈피) 시스템의 완전한 구현 방법입니다:\n\n① 북마크 생성 (`id` 속성):\n\n• `<h2 id=\"chapter3\">3장: HTML 링크</h2>`\n• `id` 속성으로 페이지 내 특정 위치에 고유한 식별자 부여\n• 이 위치가 북마크의 목적지가 됩니다\n\n② 북마크 링크 (`href` 속성):\n\n• `<a href=\"#chapter3\">3장으로 이동</a>`\n• `href` 속성을 사용하여 링크 생성\n\n③ 해시 기호 (`#`):\n\n• `#chapter3`에서 `#`은 같은 페이지 내의 id를 참조한다는 의미\n• 클릭하면 해당 id 위치로 자동 스크롤\n\n④ 다른 페이지의 북마크:\n\n• `href=\"tutorial.html#chapter3\"`\n• 파일명 + `#` + id값으로 다른 페이지의 특정 위치로 이동\n\n실제 동작:\n\n• 긴 웹페이지에서 특정 섹션으로 빠르게 이동\n• 목차나 네비게이션 메뉴에서 자주 사용\n• 페이지가 해당 위치로 부드럽게 스크롤됨",
      "difficulty": "hard",
      "created_at": "2025-08-09T07:04:26.000Z"
    },
    {
      "id": 883,
      "subject_id": 8,
      "question": "HTML에서 이미지를 웹 페이지에 삽입하기 위해 사용하는 태그는 무엇인가요?\n\n```html\n<_____ src=\"photo.jpg\" alt=\"사진\">\n```",
      "option_a": "`<image>`",
      "option_b": "`<img>`",
      "option_c": "`<picture>`",
      "option_d": "`<photo>`",
      "correct_answer": "B",
      "explanation": "HTML에서 이미지를 삽입할 때는 `<img>` 태그를 사용합니다. 이 태그는 self-closing 태그로, 닫는 태그가 필요하지 않습니다. `src` 속성으로 이미지 경로를 지정하고, `alt`속성으로 대체 텍스트를 제공합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:07:38.000Z"
    },
    {
      "id": 884,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은 무엇인가요?\n\n```html\n<img src=\"logo.png\" _____=\"회사 로고\">\n```\n이 속성은 이미지가 로드되지 않거나 시각 장애인을 위한 스크린 리더에서 사용됩니다.",
      "option_a": "title",
      "option_b": "name",
      "option_c": "alt",
      "option_d": "text",
      "correct_answer": "C",
      "explanation": "`alt` 속성은 이미지의 대체 텍스트를 제공하는 필수 속성입니다. 이미지가 로드되지 않을 때 표시되며, 시각 장애인이 사용하는 스크린 리더에서 이미지의 내용을 음성으로 읽어줍니다. 접근성을 위해 반드시 포함해야 하는 중요한 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:09:49.000Z"
    },
    {
      "id": 885,
      "subject_id": 8,
      "question": "이미지의 크기를 지정하는 방법으로 가장 권장되는 방식은 무엇인가요?\n\n```html\n<!-- 방법 A -->\n<img src=\"photo.jpg\" alt=\"사진\" width=\"300\" height=\"200\">\n\n<!-- 방법 B -->\n<img src=\"photo.jpg\" alt=\"사진\" style=\"width:300px;height:200px;\">\n```",
      "option_a": "방법 A만 사용",
      "option_b": "방법 B만 사용 (권장)",
      "option_c": "둘 다 동일하게 좋음",
      "option_d": "둘 다 사용하지 않는 것이 좋음",
      "correct_answer": "B",
      "explanation": "`style` 속성을 사용하는 방법 B가 권장됩니다. 이는 CSS 스타일시트가 이미지 크기를 변경하는 것을 방지하기 때문입니다. `width`와 `height` 속성도 유효하지만, 외부 CSS에 의해 덮어씌워질 수 있어 일관성이 떨어질 수 있습니다. `style` 속성은 인라인 스타일로 더 높은 우선순위를 가집니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:10:49.000Z"
    },
    {
      "id": 886,
      "subject_id": 8,
      "question": "다음 이미지 맵 코드에서 빈칸에 들어갈 올바른 값은 무엇인가요?\n\n```html\n<img src=\"workplace.jpg\" alt=\"작업공간\" usemap=\"#workmap\">\n<map _____=\"workmap\">\n  <area shape=\"rect\" coords=\"34,44,270,350\" alt=\"컴퓨터\" href=\"computer.htm\">\n</map>\n```",
      "option_a": "id",
      "option_b": "name",
      "option_c": "class",
      "option_d": "value",
      "correct_answer": "B",
      "explanation": "`<map>` 태그에는 `name` 속성을 사용해야 합니다. 이 속성의 값은 `<img>` 태그의 `usemap` 속성에서 참조하는 값과 일치해야 합니다. `usemap=\"#workmap\"`에서 `#`뒤의 값인 \"workmap\"이 `<map>` 태그의 `name` 속성값과 같아야 이미지와 맵이 연결됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:12:06.000Z"
    },
    {
      "id": 887,
      "subject_id": 8,
      "question": "다음 코드에서 원형 클릭 영역을 정의할 때 좌표의 의미를 올바르게 설명한 것은?\n\n```html\n<area shape=\"circle\" coords=\"337,300,44\" href=\"coffee.htm\">\n```",
      "option_a": "(337,300)은 원의 중심, 44는 지름",
      "option_b": "(337,300)은 원의 중심, 44는 반지름",
      "option_c": "(337,300)은 원의 시작점, 44는 반지름",
      "option_d": "(337,300)은 원의 끝점, 44는 지름",
      "correct_answer": "B",
      "explanation": "`shape=\"circle\"`에서 좌표는 세 개의 값으로 구성됩니다. 첫 번째와 두 번째 값(337,300)은 원의 중심점의 x, y 좌표를 나타내며, 세 번째 값(44)은 원의 반지름을 픽셀 단위로 나타냅니다. 따라서 이 예제는 (337,300)을 중심으로 하고 반지름이 44픽셀인 원형 클릭 영역을 생성합니다. 지름이 아닌 반지름임에 주의해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T07:12:47.000Z"
    },
    {
      "id": 888,
      "subject_id": 8,
      "question": "HTML 요소에 배경 이미지를 추가하기 위해 사용하는 CSS 속성은 무엇인가요?\n\n```html\n<div style=\"_____: url('background.jpg');\">\n  내용\n</div>\n```",
      "option_a": "background-src",
      "option_b": "background-image",
      "option_c": "image-background",
      "option_d": "bg-image",
      "correct_answer": "B",
      "explanation": "HTML 요소에 배경 이미지를 설정할 때는 `background-image` CSS 속성을 사용합니다. 이 속성의 값으로는 `url('이미지경로')`를 사용하여 이미지 파일의 경로를 지정합니다. `style` 속성을 통해 인라인으로 설정하거나, CSS 파일이나 `<style>` 태그 내에서 설정할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:14:39.000Z"
    },
    {
      "id": 889,
      "subject_id": 8,
      "question": "배경 이미지가 요소보다 작을 때 이미지의 반복을 방지하려면 어떤 속성을 사용해야 할까요?\n\n```css\nbody {\n  background-image: url('small-image.jpg');\n  _____: no-repeat;\n}\n```",
      "option_a": "background-repeat",
      "option_b": "image-repeat",
      "option_c": "repeat-background",
      "option_d": "background-loop",
      "correct_answer": "A",
      "explanation": "`background-repeat` 속성은 배경 이미지의 반복 방식을 제어합니다. 기본값은 `repeat`으로, 이미지가 요소를 채울 때까지 가로와 세로로 반복됩니다. `no-repeat` 값을 사용하면 이미지가 한 번만 표시되고 반복되지 않습니다. 다른 값으로는 `repeat-x`(가로만 반복), `repeat-y`(세로만 반복) 등이 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:15:41.000Z"
    },
    {
      "id": 890,
      "subject_id": 8,
      "question": "배경 이미지가 요소 전체를 덮도록 하면서 원본 비율을 유지하려면 다음 중 어떤 속성값을 사용해야 할까요?\n\n```css\nbody {\n  background-image: url('bg.jpg');\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-size: _____;\n}\n```",
      "option_a": "100% 100%",
      "option_b": "cover",
      "option_c": "contain",
      "option_d": "stretch",
      "correct_answer": "B",
      "explanation": "`background-size: cover`는 배경 이미지가 요소 전체를 덮도록 하면서 이미지의 원본 비율(가로세로 비율)을 유지합니다. 이미지가 요소보다 크거나 작아도 비율을 유지하며 전체 영역을 채웁니다. 반면 `100% 100%`는 이미지를 늘려서 요소에 맞추므로 비율이 왜곡될 수 있습니다. `contain`은 이미지 전체가 보이도록 하지만 요소를 완전히 덮지 못할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:16:46.000Z"
    },
    {
      "id": 891,
      "subject_id": 8,
      "question": "`<picture>` 요소를 사용할 때 반드시 마지막 자식 요소로 포함해야 하는 태그는 무엇인가요?\n```html\n<picture>\n  <source media=\"(min-width: 650px)\" srcset=\"large.jpg\">\n  <source media=\"(min-width: 465px)\" srcset=\"medium.jpg\">\n  <_____ src=\"small.jpg\" alt=\"이미지\">\n</picture>\n```",
      "option_a": "`<image>`",
      "option_b": "`<img>`",
      "option_c": "`<default>`",
      "option_d": "`<fallback>`",
      "correct_answer": "B",
      "explanation": "`<picture>` 요소는 반드시 `<img>` 태그를 마지막 자식 요소로 포함해야 합니다. 이는 두 가지 중요한 역할을 합니다: 1) `<picture>` 요소를 지원하지 않는 구형 브라우저에서의 fallback 역할, 2) 모든 `<source>` 조건에 맞지 않을 때의 기본 이미지 역할. `<img>` 태그가 없으면 일부 브라우저에서 이미지가 표시되지 않을 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:17:49.000Z"
    },
    {
      "id": 892,
      "subject_id": 8,
      "question": "다음 `<picture>` 요소 코드에서 화면 너비가 500px일 때 어떤 이미지가 표시될까요?\n\n```html\n<picture>\n  <source media=\"(min-width: 650px)\" srcset=\"desktop.jpg\">\n  <source media=\"(min-width: 465px)\" srcset=\"tablet.jpg\">\n  <img src=\"mobile.jpg\" alt=\"반응형 이미지\">\n</picture>\n```",
      "option_a": "desktop.jpg",
      "option_b": "tablet.jpg",
      "option_c": "mobile.jpg",
      "option_d": "이미지가 표시되지 않음",
      "correct_answer": "B",
      "explanation": "`<picture>` 요소는 위에서부터 순서대로 조건을 확인하여 첫 번째로 일치하는 `<source>`를 선택합니다. 화면 너비가 500px인 경우:\n\n• 첫 번째 조건: `(min-width: 650px)` → 500px < 650px이므로 false\n• 두 번째 조건: `(min-width: 465px)` → 500px ≥ 465px이므로 true\n\n따라서 `tablet.jpg`가 선택됩니다. 브라우저는 조건에 맞는 첫 번째 `<source>`를 찾으면 나머지는 무시하므로, 세 번째 `<img>` 태그는 확인하지 않습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T07:19:14.000Z"
    },
    {
      "id": 893,
      "subject_id": 8,
      "question": "Favicon이 브라우저에서 표시되는 위치는 어디인가요?",
      "option_a": "페이지 하단의 푸터 영역",
      "option_b": "브라우저 탭의 페이지 제목 옆",
      "option_c": "웹 페이지의 헤더 영역",
      "option_d": "브라우저 주소창 안쪽",
      "correct_answer": "B",
      "explanation": "Favicon은 브라우저 탭에서 페이지 제목 왼쪽에 표시되는 작은 아이콘입니다. 사용자가 여러 탭을 열어놓았을 때 웹사이트를 쉽게 구분할 수 있도록 도와주는 역할을 합니다. 일반적으로 16x16 픽셀 크기의 작은 이미지로, 웹사이트의 브랜드나 로고를 간단히 표현합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:20:34.000Z"
    },
    {
      "id": 894,
      "subject_id": 8,
      "question": "HTML에서 favicon을 추가하기 위해 사용하는 태그는 무엇인가요?\n```html\n<head>\n  <title>내 웹사이트</title>\n  <_____ rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n</head>\n```",
      "option_a": "`<icon>`",
      "option_b": "`<favicon>`",
      "option_c": "`<link>`",
      "option_d": "`<meta>`",
      "correct_answer": "C",
      "explanation": "Favicon을 추가할 때는 `<link>` 태그를 사용합니다. `<link>` 태그는 HTML 문서와 외부 리소스를 연결하는 역할을 하며, `rel=\"icon\"` 속성을 통해 해당 링크가 favicon임을 나타냅니다. 이 태그는 반드시 `<head>` 섹션 내에 위치해야 하며, 일반적으로 `<title>` 태그 다음에 배치합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:21:30.000Z"
    },
    {
      "id": 895,
      "subject_id": 8,
      "question": "다음 코드에서 favicon 설정을 위해 빈칸에 들어갈 올바른 속성값은 무엇인가요?\n\n```html\n<link rel=\"_____\" type=\"image/x-icon\" href=\"/images/favicon.ico\">\n```",
      "option_a": "favicon",
      "option_b": "icon",
      "option_c": "image",
      "option_d": "shortcut icon",
      "correct_answer": "B",
      "explanation": "`rel` 속성에는 `icon`을 사용합니다. 과거에는 `shortcut icon`이 사용되기도 했지만, 현재는 HTML5 표준에 따라 `icon`만 사용하는 것이 권장됩니다. `rel` 속성은 현재 문서와 링크된 리소스 간의 관계(relationship)를 나타내며, `icon`은 해당 리소스가 사이트의 아이콘임을 의미합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:24:59.000Z"
    },
    {
      "id": 896,
      "subject_id": 8,
      "question": "Favicon 이미지를 만들 때 권장되는 특징은 무엇인가요?",
      "option_a": "복잡하고 세밀한 디자인",
      "option_b": "어두운 색상 위주의 디자인",
      "option_c": "단순하고 대비가 높은 디자인",
      "option_d": "큰 크기의 상세한 이미지",
      "correct_answer": "C",
      "explanation": "Favicon은 매우 작은 크기(보통 16x16 픽셀)로 표시되기 때문에 단순하고 대비가 높은 디자인이 권장됩니다. 복잡한 디자인은 작은 크기에서 알아보기 어렵고, 낮은 대비는 시인성을 떨어뜨립니다. 따라서 간단한 모양과 선명한 색상 대비를 사용하여 작은 크기에서도 쉽게 인식할 수 있도록 디자인해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:25:48.000Z"
    },
    {
      "id": 897,
      "subject_id": 8,
      "question": "다음 코드에서 favicon이 올바르게 표시되지 않을 가능성이 가장 높은 이유는 무엇인가요?\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"/images/favicon.ico\">\n  <title>My Website</title>\n</head>\n<body>\n  <h1>Welcome!</h1>\n</body>\n</html>\n```",
      "option_a": "`<link>` 태그가 `<title>` 태그보다 앞에 위치했기 때문",
      "option_b": "`type` 속성이 잘못 설정되었기 때문",
      "option_c": "`href` 경로가 절대경로로 설정되었기 때문",
      "option_d": "`<body>` 태그 안에 favicon 관련 내용이 없기 때문",
      "correct_answer": "A",
      "explanation": "기술적으로는 `<link>` 태그가 `<title>` 태그보다 앞에 있어도 동작하지만, 일부 브라우저에서는 favicon이 제대로 로드되지 않을 수 있습니다. 가장 안전하고 권장되는 방법은 `<title>` 태그 다음에 `<link>` 태그를 배치하는 것입니다. 이는 브라우저가 페이지 제목을 먼저 읽고 나서 favicon을 로드하도록 하여 더 일관된 동작을 보장합니다. 나머지 옵션들은 모두 올바르게 설정되어 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T07:26:52.000Z"
    },
    {
      "id": 898,
      "subject_id": 8,
      "question": "HTML에서 웹 페이지의 제목을 설정하기 위해 사용하는 태그는 무엇인가요?\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <_____>내 웹사이트</_____ >\n</head>\n<body>\n  페이지 내용\n</body>\n</html>\n```",
      "option_a": "`<header>`",
      "option_b": "`<title>`",
      "option_c": "`<h1>`",
      "option_d": "`<name>`",
      "correct_answer": "B",
      "explanation": "HTML에서 웹 페이지의 제목을 설정할 때는 `<title>` 태그를 사용합니다. 이 태그는 반드시 `<head>` 섹션 내에 위치해야 하며, 브라우저 탭에 표시되는 제목을 정의합니다. `<h1>`은 페이지 내용의 제목이고, `<header>`는 페이지의 헤더 섹션을 나타내는 태그로 `<title>`과는 다른 용도입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:28:45.000Z"
    },
    {
      "id": 899,
      "subject_id": 8,
      "question": "`<title>` 태그가 위치해야 하는 HTML 섹션은 어디인가요?\n```html\n<!DOCTYPE html>\n<html>\n<_____>\n  <title>웹 페이지 제목</title>\n</_____ >\n<body>\n  내용\n</body>\n</html>\n```",
      "option_a": "`<body>`",
      "option_b": "`<html>`",
      "option_c": "`<head>`",
      "option_d": "`<header>`",
      "correct_answer": "C",
      "explanation": "`<title>` 태그는 반드시 `<head>` 섹션 내에 위치해야 합니다. `<head>` 섹션은 브라우저에게 페이지에 대한 메타 정보를 제공하는 곳으로, 실제 화면에는 표시되지 않지만 브라우저가 페이지를 처리하는 데 필요한 정보들을 담고 있습니다. `<title>`은 이러한 메타 정보 중 하나로, 브라우저 탭과 검색 결과에 표시됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:29:40.000Z"
    },
    {
      "id": 900,
      "subject_id": 8,
      "question": "페이지 제목이 표시되는 위치로 올바르지 않은 것은 무엇인가요?",
      "option_a": "브라우저의 제목 표시줄(탭)",
      "option_b": "즐겨찾기에 추가할 때의 제목",
      "option_c": "검색 엔진 결과 페이지의 제목",
      "option_d": "웹 페이지 본문의 상단 제목",
      "correct_answer": "D",
      "explanation": "`<title>` 태그로 설정한 페이지 제목은 웹 페이지 본문에는 표시되지 않습니다. 이 제목은 브라우저 탭, 즐겨찾기 제목, 검색 엔진 결과에서만 표시됩니다. 웹 페이지 본문에 보이는 제목은 `<h1>`, `<h2>` 등의 헤딩 태그를 사용해야 합니다. `<title>`은 브라우저와 검색 엔진을 위한 메타데이터 역할을 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:30:28.000Z"
    },
    {
      "id": 901,
      "subject_id": 8,
      "question": "다음 중 SEO(검색 엔진 최적화)에서 `<title>` 태그의 중요성을 가장 잘 설명한 것은?",
      "option_a": "웹 페이지의 로딩 속도를 빠르게 한다",
      "option_b": "검색 엔진이 페이지 순서를 결정할 때 사용한다",
      "option_c": "웹 페이지의 디자인을 개선한다",
      "option_d": "브라우저 호환성을 높인다",
      "correct_answer": "B",
      "explanation": "`<title>` 태그는 SEO에서 매우 중요한 역할을 합니다. 검색 엔진 알고리즘은 페이지 제목을 분석하여 검색 결과의 순서를 결정할 때 중요한 요소로 사용합니다. 제목이 검색어와 관련성이 높고 의미있게 작성되면 검색 결과에서 더 높은 순위에 노출될 가능성이 높아집니다. 따라서 페이지 내용을 정확하고 의미있게 설명하는 제목을 작성하는 것이 중요합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:31:12.000Z"
    },
    {
      "id": 902,
      "subject_id": 8,
      "question": "다음 제목들 중 SEO와 사용자 경험 측면에서 가장 적절한 것은 무엇인가요?\n\n온라인 쇼핑몰의 신발 카테고리 페이지라고 가정했을 때:",
      "option_a": "`<title>페이지</title>`",
      "option_b": "`<title>신발</title>`",
      "option_c": "`<title>남성 운동화, 여성 구두, 아동 신발 | ABC 쇼핑몰</title>`",
      "option_d": "`<title>신발 신발 신발 운동화 구두 샌들 부츠 슬리퍼 로퍼</title>`",
      "correct_answer": "C",
      "explanation": "좋은 페이지 제목은 다음 조건을 만족해야 합니다: 1) 페이지 내용을 정확히 설명, 2) 적절한 길이 유지, 3) 브랜드명 포함, 4) 키워드 과다 사용 피하기.\n\n• 1번은 너무 단순하고 의미가 없음\n• 2번은 너무 짧고 구체적이지 않음\n• 4번은 키워드를 과도하게 반복하여 검색 엔진에서 스팸으로 간주될 수 있음\n• 3번은 구체적인 카테고리 정보와 브랜드명을 포함하여 사용자와 검색 엔진 모두에게 유용한 정보를 제공함",
      "difficulty": "hard",
      "created_at": "2025-08-09T07:32:48.000Z"
    },
    {
      "id": 903,
      "subject_id": 8,
      "question": "HTML에서 테이블을 생성하기 위해 사용하는 기본 태그는 무엇인가요?\n```html\n<_____ >\n  <tr>\n    <td>데이터</td>\n  </tr>\n</_____ >\n```",
      "option_a": "`<table>`",
      "option_b": "`<tab>`",
      "option_c": "`<grid>`",
      "option_d": "`<data>`",
      "correct_answer": "A",
      "explanation": "HTML에서 테이블을 만들 때는 `<table>` 태그를 사용합니다. 이 태그는 테이블의 시작과 끝을 나타내며, 모든 테이블 관련 요소들(`<tr>`, `<td>`, `<th>` 등)을 감싸는 컨테이너 역할을 합니다. `<table>` 태그 안에 행과 열을 정의하여 데이터를 구조화된 형태로 표현할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:34:31.000Z"
    },
    {
      "id": 904,
      "subject_id": 8,
      "question": "테이블에서 하나의 행(가로줄)을 정의하는 태그는 무엇인가요?\n```html\n<table>\n  <_____ >\n    <td>이름</td>\n    <td>나이</td>\n  </_____ >\n</table>\n```",
      "option_a": "`<td>`",
      "option_b": "`<tr>`",
      "option_c": "`<th>`",
      "option_d": "`<row>`",
      "correct_answer": "B",
      "explanation": "`<tr>` 태그는 테이블의 행(table row)을 정의합니다. 'tr'은 'table row'의 줄임말입니다. 하나의 `<tr>` 태그 안에는 여러 개의 `<td>`(데이터 셀) 또는 `<th>`(헤더 셀) 태그가 들어가서 그 행의 각 열을 구성합니다. 테이블에서 가로로 늘어선 데이터들은 모두 하나의 `<tr>` 태그로 묶여집니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:35:27.000Z"
    },
    {
      "id": 905,
      "subject_id": 8,
      "question": "다음 코드에서 테이블의 데이터 셀을 정의하는 빈칸에 들어갈 태그는?\n```html\n<table>\n  <tr>\n    <th>이름</th>\n    <th>점수</th>\n  </tr>\n  <tr>\n    <_____ >김철수</_____ >\n    <_____ >95</_____ >\n  </tr>\n</table>\n```",
      "option_a": "`<tc>`",
      "option_b": "`<td>`",
      "option_c": "`<th>`",
      "option_d": "`<data>`",
      "correct_answer": "B",
      "explanation": "`<td>` 태그는 테이블의 일반 데이터 셀을 정의합니다. 'td'는 'table data'의 줄임말입니다. `<th>` 태그는 헤더 셀에 사용되므로, 일반적인 데이터를 표시할 때는 `<td>`를 사용해야 합니다. `<td>` 태그 안에는 텍스트뿐만 아니라 이미지, 링크, 리스트, 심지어 다른 테이블까지 포함할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:36:14.000Z"
    },
    {
      "id": 906,
      "subject_id": 8,
      "question": "테이블의 헤더 셀과 일반 데이터 셀의 기본 스타일 차이점은 무엇인가요?\n\n```html\n<table>\n  <tr>\n    <th>제목</th>  <!-- 헤더 셀 -->\n  </tr>\n  <tr>\n    <td>내용</td>  <!-- 데이터 셀 -->\n  </tr>\n</table>\n```",
      "option_a": "헤더 셀은 이탤릭체, 데이터 셀은 일반체",
      "option_b": "헤더 셀은 굵은체와 가운데 정렬, 데이터 셀은 일반체와 왼쪽 정렬",
      "option_c": "헤더 셀은 밑줄, 데이터 셀은 일반체",
      "option_d": "둘 다 동일한 스타일",
      "correct_answer": "B",
      "explanation": "`<th>` 태그로 정의된 헤더 셀은 기본적으로 굵은체(bold)와 가운데 정렬(center align)로 표시됩니다. 반면 `<td>` 태그로 정의된 일반 데이터 셀은 일반체(normal weight)와 왼쪽 정렬(left align)로 표시됩니다. 이러한 기본 스타일은 CSS를 사용하여 변경할 수 있지만, 브라우저의 기본 설정에서는 헤더와 데이터를 시각적으로 구분하여 표시합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:37:05.000Z"
    },
    {
      "id": 907,
      "subject_id": 8,
      "question": "다음 테이블 코드에서 잘못된 부분은 무엇인가요?\n\n```html\n<table>\n  <tr>\n    <th>이름</th>\n    <th>나이</th>\n    <th>직업</th>\n  </tr>\n  <tr>\n    <td>홍길동</td>\n    <td>25</td>\n  </tr>\n  <tr>\n    <td>김영희</td>\n    <td>30</td>\n    <td>개발자</td>\n    <td>서울</td>\n  </tr>\n</table>\n```",
      "option_a": "`<th>` 태그가 첫 번째 행에 있음",
      "option_b": "두 번째 행의 셀 개수가 헤더보다 적음",
      "option_c": "세 번째 행의 셀 개수가 헤더보다 많음",
      "option_d": "2번과 3번 모두 문제가 됨",
      "correct_answer": "D",
      "explanation": "테이블에서는 일반적으로 모든 행의 셀 개수가 동일해야 합니다. 이 코드에서는 다음과 같은 문제가 있습니다:\n\n• 헤더 행: 3개 셀 (이름, 나이, 직업)\n• 두 번째 행: 2개 셀 (홍길동, 25) - 직업 셀이 빠짐\n• 세 번째 행: 4개 셀 (김영희, 30, 개발자, 서울) - 서울 셀이 추가됨\n\n셀 개수가 일치하지 않으면 테이블 레이아웃이 깨질 수 있습니다. 모든 행의 셀 개수를 동일하게 맞추거나, 필요시 `colspan`이나 `rowspan` 속성을 사용하여 셀을 병합해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T07:38:02.000Z"
    },
    {
      "id": 908,
      "subject_id": 8,
      "question": "HTML 테이블에 테두리를 추가하기 위해 사용하는 CSS 속성은 무엇인가요?\n\n```css\ntable, th, td {\n  _____: 1px solid black;\n}\n```",
      "option_a": "border",
      "option_b": "outline",
      "option_c": "frame",
      "option_d": "edge",
      "correct_answer": "A",
      "explanation": "HTML 테이블에 테두리를 추가할 때는 CSS의 `border` 속성을 사용합니다. `border` 속성은 테두리의 두께, 스타일, 색상을 한 번에 지정할 수 있습니다. 예를 들어 `border: 1px solid black`은 1픽셀 두께의 검정색 실선 테두리를 의미합니다. 테이블의 경우 `table`, `th`, `td` 요소 모두에 적용해야 완전한 테두리를 만들 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:40:14.000Z"
    },
    {
      "id": 909,
      "subject_id": 8,
      "question": "테이블에서 이중 테두리를 하나의 테두리로 합치기 위해 사용하는 CSS 속성은?\n\n```css\ntable, th, td {\n  border: 1px solid black;\n  _____: collapse;\n}\n```",
      "option_a": "border-merge",
      "option_b": "border-collapse",
      "option_c": "border-combine",
      "option_d": "border-join",
      "correct_answer": "B",
      "explanation": "`border-collapse: collapse` 속성은 테이블의 인접한 셀들 사이의 이중 테두리를 하나로 합쳐줍니다. 기본적으로 테이블의 각 셀은 개별적인 테두리를 가지므로, 인접한 셀들 사이에는 두 개의 테두리가 나란히 표시됩니다. `collapse` 값을 사용하면 이러한 이중 테두리가 하나의 깔끔한 테두리로 합쳐져서 더 전문적인 테이블 모양을 만들 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:40:56.000Z"
    },
    {
      "id": 910,
      "subject_id": 8,
      "question": "테이블 테두리에 둥근 모서리를 만들기 위해 사용하는 CSS 속성은?\n\n```css\nth, td {\n  border: 1px solid black;\n  _____: 10px;\n}\n```",
      "option_a": "border-curve",
      "option_b": "border-round",
      "option_c": "border-radius",
      "option_d": "border-corner",
      "correct_answer": "C",
      "explanation": "`border-radius` 속성은 요소의 모서리를 둥글게 만드는 CSS 속성입니다. 값이 클수록 더 둥근 모서리가 됩니다. 테이블에서 사용할 때 주의할 점은, 테이블 전체에 적용하면 테이블 외곽 테두리도 둥글어지고, `th, td`에만 적용하면 각 셀의 모서리만 둥글어진다는 것입니다. 디자인에 따라 적절히 선택하여 사용할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:41:36.000Z"
    },
    {
      "id": 911,
      "subject_id": 8,
      "question": "다음 중 CSS `border-style` 속성의 유효한 값이 아닌 것은?\n\n```css\nth, td {\n  border-style: _____;\n}\n```",
      "option_a": "dotted",
      "option_b": "dashed",
      "option_c": "wavy",
      "option_d": "solid",
      "correct_answer": "C",
      "explanation": "`border-style` 속성에서 `wavy`는 유효하지 않은 값입니다. 유효한 값들은 `dotted`(점선), `dashed`(대시선), `solid`(실선), `double`(이중선), `groove`(홈), `ridge`(융기), `inset`(오목), `outset`(볼록), `none`(없음), `hidden`(숨김) 등입니다. `wavy`(물결 모양)는 CSS border-style에서 지원하지 않는 값이므로, 물결 모양의 테두리가 필요하다면 다른 방법(예: 이미지나 SVG)을 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:43:03.000Z"
    },
    {
      "id": 912,
      "subject_id": 8,
      "question": "다음 코드의 결과로 테이블이 어떻게 보일까요?\n\n```css\ntable, th, td {\n  border: 1px solid white;\n  border-collapse: collapse;\n}\nth, td {\n  background-color: #96D4D4;\n}\n```",
      "option_a": "검정색 테두리가 있는 파란색 테이블",
      "option_b": "테두리가 보이지 않는 것처럼 보이는 파란색 테이블",
      "option_c": "흰색 배경에 파란색 테두리가 있는 테이블",
      "option_d": "테두리가 완전히 없는 파란색 테이블",
      "correct_answer": "B",
      "explanation": "이 코드는 \"보이지 않는 테두리\" 효과를 만듭니다. 테두리 색상을 흰색(`white`)으로 설정하고, 셀의 배경색을 청록색(`#96D4D4`)으로 설정했습니다. 문서의 배경색이 일반적으로 흰색이므로, 흰색 테두리는 배경과 같은 색이 되어 시각적으로 보이지 않습니다. 하지만 실제로는 테두리가 존재하므로 셀들 사이에 흰색 선이 있어서 셀들이 분리되어 보입니다. 이는 깔끔한 테이블 디자인을 만드는 기법 중 하나입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T07:44:06.000Z"
    },
    {
      "id": 913,
      "subject_id": 8,
      "question": "HTML 테이블의 크기를 조절하기 위해 사용하는 속성은 무엇인가요?\n\n```html\n<table _____ =\"width:100%\">\n  <tr>\n    <td>내용</td>\n  </tr>\n</table>\n```",
      "option_a": "size",
      "option_b": "style",
      "option_c": "width",
      "option_d": "dimension",
      "correct_answer": "B",
      "explanation": "HTML에서 테이블의 크기를 조절할 때는 `style` 속성을 사용합니다. `style` 속성 안에 CSS 속성인 `width`나 `height`를 지정하여 테이블의 너비와 높이를 설정할 수 있습니다. 예를 들어 `style=\"width:100%\"`는 테이블의 너비를 부모 요소의 100%로 설정한다는 의미입니다. 이는 인라인 CSS 방식으로 테이블에 직접 스타일을 적용하는 방법입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:51:35.000Z"
    },
    {
      "id": 914,
      "subject_id": 8,
      "question": "테이블의 너비를 부모 요소의 전체 너비와 같게 만들려면 어떤 값을 사용해야 할까요?\n\n```html\n<table style=\"width:_____\">\n  <tr>\n    <th>제목</th>\n  </tr>\n</table>\n```",
      "option_a": "full",
      "option_b": "100%",
      "option_c": "auto",
      "option_d": "max",
      "correct_answer": "B",
      "explanation": "`width:100%`는 테이블의 너비를 부모 요소의 100%로 설정합니다. 퍼센트(%) 단위는 상대적인 크기를 나타내며, 부모 요소(일반적으로 `<body>`)의 크기에 비례하여 크기가 결정됩니다. 따라서 브라우저 창의 크기가 변해도 테이블은 항상 부모 요소의 전체 너비를 차지하게 됩니다. 이는 반응형 웹 디자인에서 자주 사용되는 방법입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T07:52:18.000Z"
    },
    {
      "id": 915,
      "subject_id": 8,
      "question": "특정 열(컬럼)의 너비를 설정하려면 어떤 태그에 style 속성을 추가해야 할까요?\n\n```html\n<table style=\"width:100%\">\n  <tr>\n    <_____ style=\"width:70%\">이름</_____ >\n    <th>나이</th>\n  </tr>\n</table>\n```",
      "option_a": "`<table>`에만",
      "option_b": "`<tr>`에만",
      "option_c": "`<th>` 또는 `<td>`에",
      "option_d": "`<col>`에만",
      "correct_answer": "C",
      "explanation": "특정 열의 너비를 설정하려면 해당 열의 `<th>`(헤더 셀) 또는 `<td>`(데이터 셀)에 `style` 속성을 추가해야 합니다. 일반적으로 첫 번째 행의 셀에 너비를 설정하면 해당 열 전체에 적용됩니다. 예를 들어 첫 번째 열의 `<th>`에 `style=\"width:70%\"`를 설정하면, 그 열의 모든 셀이 테이블 전체 너비의 70%를 차지하게 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:53:39.000Z"
    },
    {
      "id": 916,
      "subject_id": 8,
      "question": "테이블의 특정 행(row)의 높이를 200픽셀로 설정하는 올바른 코드는?\n\n```html\n<table>\n  <tr>\n    <th>제목</th>\n  </tr>\n  <_____ style=\"_____:200px\">\n    <td>내용</td>\n  </_____ >\n</table>\n```",
      "option_a": "`tr`, `width`, `tr`",
      "option_b": "`tr`, `height`, `tr`",
      "option_c": "`td`, `width`, `td`",
      "option_d": "`td`, `height`, `td`",
      "correct_answer": "B",
      "explanation": "특정 행의 높이를 설정하려면 `<tr>` 태그에 `style=\"height:200px\"`를 추가해야 합니다. `<tr>`은 테이블의 행을 나타내므로, 이 태그에 높이를 설정하면 해당 행 전체의 높이가 조절됩니다. `height` 속성은 세로 크기를 조절하는 CSS 속성이고, `200px`은 200픽셀이라는 절대적인 크기를 의미합니다. 개별 셀(`<td>`)에 높이를 설정할 수도 있지만, 행 전체의 높이를 통일하려면 `<tr>`에 설정하는 것이 좋습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T07:58:24.000Z"
    },
    {
      "id": 917,
      "subject_id": 8,
      "question": "다음 테이블 코드에서 각 열의 실제 너비는 어떻게 될까요?\n\n```html\n<table style=\"width:600px\">\n  <tr>\n    <th style=\"width:50%\">이름</th>\n    <th style=\"width:30%\">나이</th>\n    <th>직업</th>\n  </tr>\n</table>\n```",
      "option_a": "이름: 300px, 나이: 180px, 직업: 120px",
      "option_b": "이름: 50px, 나이: 30px, 직업: 나머지 공간",
      "option_c": "이름: 300px, 나이: 180px, 직업: 나머지 공간",
      "option_d": "모든 열이 동일한 크기",
      "correct_answer": "A",
      "explanation": "테이블의 전체 너비가 600px로 설정되어 있고, 각 열의 너비가 퍼센트로 지정되어 있습니다:\n\n• 이름 열: 50% = 600px × 0.5 = 300px\n• 나이 열: 30% = 600px × 0.3 = 180px\n• 직업 열: 너비 미지정 = 남은 공간 = 600px - 300px - 180px = 120px\n\n퍼센트는 부모 요소(여기서는 테이블)의 크기에 대한 상대적 비율이므로, 절대값인 픽셀로 계산됩니다. 너비가 지정되지 않은 마지막 열은 자동으로 남은 공간을 차지하게 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T07:59:22.000Z"
    },
    {
      "id": 918,
      "subject_id": 8,
      "question": "테이블에서 헤더 셀을 정의하기 위해 사용하는 태그는 무엇인가요?\n```html\n<table>\n  <tr>\n    <_____ >이름</_____ >\n    <_____ >나이</_____ >\n  </tr>\n  <tr>\n    <td>홍길동</td>\n    <td>25</td>\n  </tr>\n</table>\n```",
      "option_a": "`<header>`",
      "option_b": "`<th>`",
      "option_c": "`<td>`",
      "option_d": "`<head>`",
      "correct_answer": "B",
      "explanation": "테이블의 헤더 셀은 `<th>` 태그로 정의합니다. 'th'는 'table header'의 줄임말입니다. `<th>` 태그로 정의된 헤더 셀은 기본적으로 굵은 글씨체와 가운데 정렬로 표시되어 일반 데이터 셀(`<td>`)과 시각적으로 구분됩니다. 헤더는 각 열이나 행이 무엇을 나타내는지 설명하는 역할을 하므로 테이블의 가독성을 높이는 중요한 요소입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:01:56.000Z"
    },
    {
      "id": 919,
      "subject_id": 8,
      "question": "테이블 셀 내부의 여백(padding)을 설정하기 위해 사용하는 CSS 속성은?\n\n```css\nth, td {\n  _____: 15px;\n}\n```",
      "option_a": "margin",
      "option_b": "spacing",
      "option_c": "padding",
      "option_d": "gap",
      "correct_answer": "C",
      "explanation": "테이블 셀 내부의 여백은 `padding` 속성으로 설정합니다. Padding은 셀의 테두리와 내용 사이의 공간을 의미합니다. 기본값은 0이므로 내용이 셀의 테두리에 바짝 붙어 보입니다. `padding: 15px`를 설정하면 셀 내용 주위에 15픽셀의 여백이 생겨서 테이블이 더 읽기 쉬워집니다. `margin`은 요소 외부의 여백을 의미하므로 다른 용도입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:02:41.000Z"
    },
    {
      "id": 920,
      "subject_id": 8,
      "question": "테이블 헤더의 텍스트 정렬을 왼쪽으로 변경하는 CSS 코드는?\n\n```css\nth {\n  _____: left;\n}\n```",
      "option_a": "align",
      "option_b": "text-align",
      "option_c": "position",
      "option_d": "float",
      "correct_answer": "B",
      "explanation": "텍스트의 정렬은 `text-align` 속성으로 제어합니다. 테이블 헤더(`<th>`)는 기본적으로 가운데 정렬(`center`)되어 있지만, `text-align: left`를 사용하면 왼쪽 정렬로 변경할 수 있습니다. 이 속성의 다른 값으로는 `right`(오른쪽 정렬), `justify`(양쪽 정렬) 등이 있습니다. 테이블의 디자인에 따라 적절한 정렬 방식을 선택할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:03:42.000Z"
    },
    {
      "id": 921,
      "subject_id": 8,
      "question": "여러 열에 걸쳐 있는 헤더를 만들기 위해 사용하는 속성은?\n\n```html\n<table>\n  <tr>\n    <th _____ =\"2\">이름</th>\n    <th>나이</th>\n  </tr>\n  <tr>\n    <td>성</td>\n    <td>이름</td>\n    <td>25</td>\n  </tr>\n</table>\n```",
      "option_a": "rowspan",
      "option_b": "colspan",
      "option_c": "span",
      "option_d": "merge",
      "correct_answer": "B",
      "explanation": "`colspan` 속성은 셀이 여러 열에 걸쳐 확장되도록 합니다. 'colspan'은 'column span'의 줄임말입니다. `colspan=\"2\"`는 해당 셀이 2개의 열을 차지한다는 의미입니다. 이 예제에서 \"이름\" 헤더가 \"성\"과 \"이름\" 두 열을 모두 포괄하는 상위 카테고리 역할을 합니다. `rowspan`은 여러 행에 걸쳐 확장할 때 사용하는 속성으로 다른 용도입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:04:41.000Z"
    },
    {
      "id": 922,
      "subject_id": 8,
      "question": "다음 코드에서 테이블의 셀 간격(cell spacing)과 셀 내부 여백(cell padding)을 설명한 것으로 올바른 것은?\n\n```css\ntable {\n  border-spacing: 10px;\n}\nth, td {\n  padding: 20px;\n}\n```",
      "option_a": "셀 간격 10px, 셀 내부 여백 20px",
      "option_b": "셀 간격 20px, 셀 내부 여백 10px",
      "option_c": "모든 여백이 10px로 동일함",
      "option_d": "모든 여백이 20px로 동일함",
      "correct_answer": "A",
      "explanation": "이 코드는 두 가지 서로 다른 여백을 설정합니다:\n\n• `border-spacing: 10px`: 테이블의 각 셀 사이의 간격을 10픽셀로 설정합니다. 이는 셀과 셀 사이의 빈 공간을 의미합니다.\n• `padding: 20px`: 각 셀 내부에서 테두리와 내용 사이의 여백을 20픽셀로 설정합니다.\n\n따라서 셀들 사이에는 10픽셀의 간격이 있고, 각 셀 내부에서는 내용 주위에 20픽셀의 여백이 있게 됩니다. 이 두 속성은 서로 다른 영역에 영향을 주므로 독립적으로 설정할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T08:05:35.000Z"
    },
    {
      "id": 923,
      "subject_id": 8,
      "question": "테이블에서 하나의 셀이 여러 열에 걸쳐 표시되도록 하는 속성은?\n\n```html\n<table>\n  <tr>\n    <th _____ =\"2\">이름</th>\n    <th>나이</th>\n  </tr>\n  <tr>\n    <td>홍</td>\n    <td>길동</td>\n    <td>25</td>\n  </tr>\n</table>\n```",
      "option_a": "rowspan",
      "option_b": "colspan",
      "option_c": "cellspan",
      "option_d": "multispan",
      "correct_answer": "B",
      "explanation": "`colspan` 속성은 테이블 셀이 여러 열(column)에 걸쳐 표시되도록 합니다. `colspan=\"2\"`는 해당 셀이 2개의 열을 차지한다는 의미입니다. 이 예제에서 \"이름\" 헤더가 \"홍\"과 \"길동\" 두 열을 포괄하는 상위 제목 역할을 합니다. `rowspan`은 여러 행에 걸쳐 표시할 때 사용하는 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:07:27.000Z"
    },
    {
      "id": 924,
      "subject_id": 8,
      "question": "테이블의 짝수 번째 행에 배경색을 적용하여 줄무늬 효과를 만드는 CSS 선택자는?\n\n```css\n_____ {\n  background-color: #D6EEEE;\n}\n```",
      "option_a": "tr:nth-child(2n)",
      "option_b": "tr:nth-child(even)",
      "option_c": "tr:even",
      "option_d": "tr:second-child",
      "correct_answer": "B",
      "explanation": "`tr:nth-child(even)` 선택자는 테이블의 짝수 번째 행(2, 4, 6번째 등)을 선택합니다. 이를 통해 테이블에 줄무늬(zebra stripe) 효과를 만들 수 있어 가독성이 향상됩니다. `nth-child(odd)`를 사용하면 홀수 번째 행(1, 3, 5번째 등)을 선택할 수 있습니다. 이는 CSS의 가상 선택자(pseudo-selector) 기능입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:08:18.000Z"
    },
    {
      "id": 925,
      "subject_id": 8,
      "question": "테이블의 특정 열들에 스타일을 적용하기 위해 사용하는 태그 조합은?\n\n```html\n<table>\n  <_____ >\n    <_____ span=\"2\" style=\"background-color: pink\">\n  </_____ >\n  <tr>\n    <td>월</td>\n    <td>화</td>\n    <td>수</td>\n  </tr>\n</table>\n```",
      "option_a": "`<colgroup>`, `<column>`",
      "option_b": "`<colgroup>`, `<col>`",
      "option_c": "`<columngroup>`, `<col>`",
      "option_d": "`<columns>`, `<col>`",
      "correct_answer": "B",
      "explanation": "`<colgroup>`과 `<col>` 태그를 조합하여 테이블의 특정 열들에 스타일을 적용할 수 있습니다. `<colgroup>`은 열 그룹의 컨테이너 역할을 하고, `<col>` 태그로 각 열 또는 열 그룹의 스타일을 정의합니다. `span=\"2\"`는 2개의 열에 적용한다는 의미입니다. 이 방법을 사용하면 각 셀에 개별적으로 스타일을 적용하지 않고도 열 단위로 일괄 스타일링할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:09:35.000Z"
    },
    {
      "id": 926,
      "subject_id": 8,
      "question": "테이블 행에 마우스를 올렸을 때 배경색이 변하는 호버 효과를 만드는 CSS는?\n\n```css\n_____ {\n  background-color: #D6EEEE;\n}\n```",
      "option_a": "tr:hover",
      "option_b": "tr:mouse-over",
      "option_c": "tr:active",
      "option_d": "tr:focus",
      "correct_answer": "A",
      "explanation": "`:hover` 가상 선택자는 사용자가 마우스를 요소 위에 올렸을 때 스타일을 적용합니다. `tr:hover`는 테이블 행에 마우스를 올렸을 때만 배경색이 변하도록 하여 사용자가 현재 보고 있는 행을 쉽게 식별할 수 있게 해줍니다. 이는 특히 많은 데이터가 있는 테이블에서 유용한 UX 기능입니다. `:active`는 클릭 중일 때, `:focus`는 키보드 포커스를 받았을 때 적용되는 선택자입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:10:39.000Z"
    },
    {
      "id": 927,
      "subject_id": 8,
      "question": "다음 코드에서 실제로 화면에 표시되는 열의 개수는?\n\n```html\n<table>\n  <colgroup>\n    <col span=\"2\" style=\"background-color: pink\">\n    <col span=\"3\" style=\"visibility: collapse\">\n    <col span=\"1\" style=\"background-color: yellow\">\n  </colgroup>\n  <tr>\n    <td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td>\n  </tr>\n</table>\n```",
      "option_a": "6개",
      "option_b": "3개",
      "option_c": "4개",
      "option_d": "2개",
      "correct_answer": "B",
      "explanation": "이 테이블은 원래 6개의 열을 가지고 있지만, `<colgroup>` 설정에 의해 다음과 같이 처리됩니다:\n\n• 첫 번째 `<col>`: span=\"2\" → 1,2번째 열 (분홍색 배경, 표시됨)\n• 두 번째 `<col>`: span=\"3\", visibility: collapse → 3,4,5번째 열 (숨겨짐)\n• 세 번째 `<col>`: span=\"1\" → 6번째 열 (노란색 배경, 표시됨)\n\n`visibility: collapse`는 해당 열들을 완전히 숨기므로, 실제로는 1,2,6번째 열만 표시되어 총 3개의 열이 화면에 보입니다. 이는 테이블의 특정 열을 동적으로 숨기거나 보이게 할 때 유용한 기능입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T08:11:46.000Z"
    },
    {
      "id": 928,
      "subject_id": 8,
      "question": "순서가 없는 목록(불릿 포인트가 있는 목록)을 만들기 위해 사용하는 HTML 태그는?\n```html\n<_____ >\n  <li>커피</li>\n  <li>차</li>\n  <li>우유</li>\n</_____ >\n```",
      "option_a": "`<ol>`",
      "option_b": "`<ul>`",
      "option_c": "`<list>`",
      "option_d": "`<dl>`",
      "correct_answer": "B",
      "explanation": "순서가 없는 목록(unordered list)을 만들 때는 `<ul>` 태그를 사용합니다. 'ul'은 'unordered list'의 줄임말입니다. 이 태그 안의 각 항목은 `<li>` 태그로 정의하며, 기본적으로 작은 검은 원(bullet) 모양의 마커가 표시됩니다. `<ol>`은 순서가 있는 목록, `<dl>`은 설명 목록을 만들 때 사용하는 태그입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:13:50.000Z"
    },
    {
      "id": 929,
      "subject_id": 8,
      "question": "순서가 있는 목록에서 각 항목 앞에 표시되는 기본 마커는 무엇인가요?\n\n```html\n<ol>\n  <li>첫 번째 항목</li>\n  <li>두 번째 항목</li>\n  <li>세 번째 항목</li>\n</ol>\n```",
      "option_a": "불릿 포인트 (●)",
      "option_b": "숫자 (1, 2, 3...)",
      "option_c": "대문자 (A, B, C...)",
      "option_d": "하이픈 (-)",
      "correct_answer": "B",
      "explanation": "순서가 있는 목록(`<ol>`)의 기본 마커는 숫자(1, 2, 3...)입니다. 이는 목록의 순서와 순위를 명확하게 나타내기 때문입니다. `type` 속성을 사용하면 다른 형태의 마커로 변경할 수 있습니다. 예를 들어 `type=\"A\"`는 대문자, `type=\"I\"`는 로마 숫자 등으로 표시할 수 있지만, 기본값은 아라비아 숫자입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:14:44.000Z"
    },
    {
      "id": 930,
      "subject_id": 8,
      "question": "순서가 없는 목록의 마커를 정사각형으로 변경하려면 어떤 CSS 속성과 값을 사용해야 할까요?\n\n```html\n<ul style=\"_____: _____;\">\n  <li>항목 1</li>\n  <li>항목 2</li>\n</ul>\n```",
      "option_a": "`list-style-type`, `square`",
      "option_b": "`marker-type`, `square`",
      "option_c": "`bullet-style`, `square`",
      "option_d": "`list-marker`, `square`",
      "correct_answer": "A",
      "explanation": "목록의 마커 스타일을 변경할 때는 `list-style-type` CSS 속성을 사용합니다. 사용 가능한 값으로는 `disc`(기본 원형), `circle`(빈 원형), `square`(정사각형), `none`(마커 없음) 등이 있습니다. `list-style-type: square`를 사용하면 기본 원형 불릿 대신 정사각형 마커가 표시됩니다. 이는 디자인에 따라 목록의 시각적 스타일을 다양하게 변경할 수 있게 해줍니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:16:06.000Z"
    },
    {
      "id": 931,
      "subject_id": 8,
      "question": "설명 목록(description list)에서 용어를 정의하는 태그와 설명을 작성하는 태그는?\n\n```html\n<dl>\n  <_____ >커피</_____ >\n  <_____ >검은색 뜨거운 음료</_____ >\n</dl>\n```",
      "option_a": "`<term>`, `<desc>`",
      "option_b": "`<dt>`, `<dd>`",
      "option_c": "`<name>`, `<definition>`",
      "option_d": "`<title>`, `<detail>`",
      "correct_answer": "B",
      "explanation": "설명 목록에서는 `<dt>` 태그로 용어(term)를 정의하고, `<dd>` 태그로 해당 용어에 대한 설명(description)을 작성합니다. 'dt'는 'description term', 'dd'는 'description definition'의 줄임말입니다. 이 구조는 용어사전, 정의 목록, Q&A 형태의 콘텐츠를 만들 때 매우 유용합니다. 하나의 `<dt>` 다음에 여러 개의 `<dd>`가 올 수도 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:17:13.000Z"
    },
    {
      "id": 932,
      "subject_id": 8,
      "question": "블록 레벨 요소(block-level element)의 특징으로 올바른 것은?\n\n```html\n<p>첫 번째 단락</p>\n<p>두 번째 단락</p>\n```",
      "option_a": "항상 새로운 줄에서 시작하고 전체 너비를 차지한다",
      "option_b": "인라인으로 배치되고 필요한 만큼의 너비만 차지한다",
      "option_c": "다른 요소 안에만 배치할 수 있다",
      "option_d": "텍스트만 포함할 수 있다",
      "correct_answer": "A",
      "explanation": "블록 레벨 요소는 항상 새로운 줄에서 시작하며, 사용 가능한 전체 너비를 차지합니다(왼쪽과 오른쪽으로 최대한 확장). 브라우저는 블록 레벨 요소 앞뒤에 자동으로 여백(margin)을 추가합니다. `<p>`, `<div>`, `<h1>~<h6>` 등이 대표적인 블록 레벨 요소입니다. 이로 인해 각 단락이 수직으로 쌓여서 표시됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:19:23.000Z"
    },
    {
      "id": 933,
      "subject_id": 8,
      "question": "인라인 요소(inline element)로 텍스트 일부분을 마킹할 때 주로 사용하는 태그는?\n```html\n<p>내 어머니는 <_____ style=\"color:blue;\">파란</_____ > 눈을 가지고 있다.</p>\n```",
      "option_a": "`<div>`",
      "option_b": "`<p>`",
      "option_c": "`<span>`",
      "option_d": "`<section>`",
      "correct_answer": "C",
      "explanation": "`<span>` 태그는 텍스트의 일부분이나 문서의 일부를 마킹하는 데 사용되는 인라인 컨테이너입니다. 새로운 줄에서 시작하지 않으며, 필요한 만큼의 너비만 차지합니다. CSS와 함께 사용하여 텍스트의 특정 부분에 스타일을 적용할 때 매우 유용합니다. `<div>`는 블록 레벨 요소이므로 텍스트 중간에 사용하면 줄바꿈이 발생합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:20:12.000Z"
    },
    {
      "id": 934,
      "subject_id": 8,
      "question": "다음 중 블록 레벨 요소가 아닌 것은?",
      "option_a": "`<div>`",
      "option_b": "`<h1>`",
      "option_c": "`<img>`",
      "option_d": "`<p>`",
      "correct_answer": "C",
      "explanation": "`<img>` 태그는 인라인 요소입니다. 이미지는 텍스트 흐름 안에서 다른 인라인 요소들과 함께 배치되며, 새로운 줄에서 시작하지 않습니다. 반면 `<div>`, `<h1>`, `<p>`는 모두 블록 레벨 요소로서 항상 새로운 줄에서 시작하고 전체 너비를 차지합니다. `<img>`는 `<span>`, `<a>`, `<strong>` 등과 같은 인라인 요소 그룹에 속합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:21:20.000Z"
    },
    {
      "id": 935,
      "subject_id": 8,
      "question": "HTML에서 다른 요소들을 감싸는 컨테이너로 자주 사용되는 범용 블록 레벨 요소는?\n```html\n<_____ style=\"background-color:black;color:white;padding:20px;\">\n  <h2>제목</h2>\n  <p>내용</p>\n</_____ >\n```",
      "option_a": "`<container>`",
      "option_b": "`<div>`",
      "option_c": "`<wrapper>`",
      "option_d": "`<box>`",
      "correct_answer": "B",
      "explanation": "`<div>` 태그는 HTML에서 가장 자주 사용되는 범용 블록 레벨 컨테이너입니다. 특별한 의미를 가지지 않지만, 다른 HTML 요소들을 그룹화하고 CSS로 스타일을 적용하는 데 사용됩니다. `style`, `class`, `id` 속성과 함께 사용하여 콘텐츠 블록을 스타일링할 수 있습니다. 레이아웃 구성, 섹션 나누기, 스타일 적용 등 다양한 용도로 활용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:22:10.000Z"
    },
    {
      "id": 936,
      "subject_id": 8,
      "question": "다음 코드의 실행 결과로 올바른 설명은?\n\n```html\n<p>이것은 단락입니다.\n  <div style=\"display:inline;\">인라인으로 표시된 div</div>\n  계속되는 텍스트입니다.\n</p>\n<span style=\"display:block;\">블록으로 표시된 span</span>\n<span>일반 span</span>\n```",
      "option_a": "모든 요소가 한 줄에 표시됨",
      "option_b": "div는 새 줄에서 시작하고, 두 span은 한 줄에 표시됨",
      "option_c": "첫 번째 줄에는 단락과 div가, 두 번째 줄에는 첫 번째 span이, 세 번째 줄에는 두 번째 span이 표시됨",
      "option_d": "CSS display 속성이 적용되지 않음",
      "correct_answer": "C",
      "explanation": "CSS의 `display` 속성은 요소의 기본 표시 방식을 변경할 수 있습니다:\n\n• `<p>` 내부의 `<div style=\"display:inline;\">`는 인라인으로 표시되어 텍스트 흐름을 끊지 않습니다. 따라서 \"이것은 단락입니다. 인라인으로 표시된 div 계속되는 텍스트입니다.\"가 한 줄에 표시됩니다.\n• `<span style=\"display:block;\">`는 블록 요소처럼 동작하여 새로운 줄에서 시작합니다.\n• 마지막 `<span>`은 일반 인라인 요소이지만, 앞의 블록 span 다음 줄에서 시작합니다.\n\n이는 CSS가 HTML 요소의 기본 표시 특성을 어떻게 변경할 수 있는지 보여주는 중요한 예시입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T08:24:05.000Z"
    },
    {
      "id": 937,
      "subject_id": 8,
      "question": "`<div>` 요소의 기본 특성으로 올바른 것은?\n\n```html\n<p>첫 번째 단락</p>\n<div>Div 요소</div>\n<p>두 번째 단락</p>\n```",
      "option_a": "인라인 요소로 텍스트와 같은 줄에 표시된다",
      "option_b": "블록 요소로 새로운 줄에서 시작하고 전체 너비를 차지한다",
      "option_c": "특정 의미를 가지는 시맨틱 요소이다",
      "option_d": "텍스트만 포함할 수 있다",
      "correct_answer": "B",
      "explanation": "`<div>` 요소는 기본적으로 블록 레벨 요소입니다. 이는 항상 새로운 줄에서 시작하고, 사용 가능한 전체 너비를 차지하며, 앞뒤로 줄바꿈이 발생한다는 의미입니다. `<div>`는 특별한 의미를 가지지 않는 범용 컨테이너로, 다른 HTML 요소들을 그룹화하고 스타일을 적용하는 데 주로 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:25:52.000Z"
    },
    {
      "id": 938,
      "subject_id": 8,
      "question": "`<div>` 요소를 중앙 정렬하기 위해 사용하는 CSS 속성과 값은?\n\n```css\ndiv {\n  width: 300px;\n  _____: _____;\n}\n```",
      "option_a": "`text-align`, `center`",
      "option_b": "`margin`, `auto`",
      "option_c": "`position`, `center`",
      "option_d": "`align`, `middle`",
      "correct_answer": "B",
      "explanation": "`<div>` 요소를 수평 중앙 정렬하려면 `margin: auto`를 사용합니다. 이는 좌우 마진을 자동으로 계산하여 요소를 중앙에 배치합니다. 단, 이 방법이 작동하려면 요소의 너비가 100%가 아닌 고정값이나 상대값으로 설정되어 있어야 합니다. `text-align: center`는 요소 내부의 텍스트를 중앙 정렬할 때 사용하는 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:26:56.000Z"
    },
    {
      "id": 939,
      "subject_id": 8,
      "question": "여러 개의 `<div>` 요소를 가로로 나란히 배치하는 방법이 아닌 것은?",
      "option_a": "`float: left` 사용",
      "option_b": "`display: inline-block` 사용",
      "option_c": "`display: flex` 사용 (부모 요소에)",
      "option_d": "`display: block` 사용",
      "correct_answer": "D",
      "explanation": "`display: block`은 `<div>`의 기본값으로, 요소들을 세로로 쌓아 배치합니다. 가로 배치를 위한 방법들은:\n\n• Float: `float: left`로 요소들을 왼쪽으로 떠 있게 함\n• Inline-block: `display: inline-block`으로 블록 요소의 특성을 유지하면서 인라인처럼 배치\n• Flex: 부모 요소에 `display: flex`를 적용하여 자식 요소들을 유연하게 배치\n• Grid: `display: grid`와 `grid-template-columns`로 격자 레이아웃 생성",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:28:31.000Z"
    },
    {
      "id": 940,
      "subject_id": 8,
      "question": "Flexbox를 사용하여 `<div>` 요소들을 가로로 배치할 때 올바른 코드는?\n\n```html\n<div class=\"container\">\n  <div>항목 1</div>\n  <div>항목 2</div>\n  <div>항목 3</div>\n</div>\n```\n\n```css\n.container {\n  _____: _____;\n}\n.container > div {\n  width: 33%;\n}\n```",
      "option_a": "`display`, `block`",
      "option_b": "`display`, `flex`",
      "option_c": "`flex-direction`, `row`",
      "option_d": "`justify-content`, `center`",
      "correct_answer": "B",
      "explanation": "Flexbox 레이아웃을 사용하려면 부모 요소(컨테이너)에 `display: flex`를 설정해야 합니다. 이렇게 하면 자식 요소들이 자동으로 가로로 배치됩니다. `flex-direction: row`는 기본값이므로 생략 가능하고, `justify-content: center`는 정렬 방식을 조정하는 속성이지만 Flexbox를 활성화하는 것은 아닙니다. Flex 컨테이너가 되면 자식 요소들의 너비를 유연하게 조절할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:29:57.000Z"
    },
    {
      "id": 941,
      "subject_id": 8,
      "question": "다음 CSS Grid 코드에서 3개의 `<div>` 요소가 어떻게 배치될까요?\n\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: 25% 50% 25%;\n}\n```\n\n```html\n<div class=\"grid-container\">\n  <div>첫 번째</div>\n  <div>두 번째</div>\n  <div>세 번째</div>\n</div>\n```",
      "option_a": "모든 div가 동일한 너비로 가로 배치",
      "option_b": "첫 번째 25%, 두 번째 50%, 세 번째 25% 너비로 가로 배치",
      "option_c": "첫 번째와 세 번째는 작게, 두 번째는 크게 세로 배치",
      "option_d": "3행 1열로 세로 배치",
      "correct_answer": "B",
      "explanation": "CSS Grid의 `grid-template-columns: 25% 50% 25%`는 3개의 열을 정의하며, 각각의 너비를 지정합니다:\n\n• 첫 번째 열: 전체 너비의 25%\n• 두 번째 열: 전체 너비의 50%\n• 세 번째 열: 전체 너비의 25%\n\nGrid는 자식 요소들을 정의된 열의 순서대로 배치하므로, 세 개의 `<div>` 요소가 각각 25%, 50%, 25%의 너비를 가지며 가로로 나란히 배치됩니다. Grid는 Flexbox와 달리 명확한 행과 열의 구조를 제공하여 더 정밀한 레이아웃 제어가 가능합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T08:31:21.000Z"
    },
    {
      "id": 942,
      "subject_id": 8,
      "question": "HTML에서 클래스를 지정하기 위해 사용하는 속성은?\n\n```html\n<div _____ =\"container\">\n  <h1>제목</h1>\n</div>\n```",
      "option_a": "id",
      "option_b": "class",
      "option_c": "name",
      "option_d": "style",
      "correct_answer": "B",
      "explanation": "HTML에서 요소에 클래스를 지정할 때는 `class` 속성을 사용합니다. 클래스는 여러 요소에 같은 스타일을 적용하거나 JavaScript로 특정 요소들을 선택할 때 사용됩니다. 하나의 클래스는 여러 요소에서 공유할 수 있어서 일관된 스타일링이 가능합니다. `id`는 고유 식별자, `name`은 폼 요소에서 사용, `style`은 인라인 스타일링에 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:33:04.000Z"
    },
    {
      "id": 943,
      "subject_id": 8,
      "question": "CSS에서 클래스를 선택할 때 사용하는 기호는?\n\n```css\n_____ city {\n  background-color: blue;\n  color: white;\n}\n```",
      "option_a": "#",
      "option_b": ".",
      "option_c": "*",
      "option_d": "&",
      "correct_answer": "B",
      "explanation": "CSS에서 클래스를 선택할 때는 마침표(`.`) 기호를 클래스명 앞에 붙입니다. 예를 들어 `class=\"city\"`로 지정된 요소들을 선택하려면 `.city`로 작성합니다. 이는 CSS의 클래스 선택자(class selector) 문법입니다. `#`은 ID 선택자, `*`은 전체 선택자, `&`는 일반적으로 CSS에서 사용되지 않는 기호입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:34:25.000Z"
    },
    {
      "id": 944,
      "subject_id": 8,
      "question": "하나의 HTML 요소에 여러 개의 클래스를 적용하는 올바른 방법은?\n\n```html\n<div _____ >\n  내용\n</div>\n```",
      "option_a": "class=\"main city\"",
      "option_b": "class=\"main\" class=\"city\"",
      "option_c": "class=\"main,city\"",
      "option_d": "class=\"main+city\"",
      "correct_answer": "A",
      "explanation": "하나의 요소에 여러 클래스를 적용할 때는 `class` 속성 값에 공백으로 구분하여 클래스명들을 나열합니다. `class=\"main city\"`처럼 작성하면 해당 요소는 `main` 클래스와 `city` 클래스 모두의 스타일을 적용받습니다. 동일한 속성에 대해 여러 클래스에서 다른 값을 지정한 경우, CSS 우선순위 규칙에 따라 적용됩니다. 속성을 두 번 쓰거나 쉼표, 플러스 기호로 구분하는 것은 올바르지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:35:21.000Z"
    },
    {
      "id": 945,
      "subject_id": 8,
      "question": "다음 코드에서 \"important\" 클래스가 적용되는 요소는 몇 개인가요?\n\n```html\n<h1>제목 <span class=\"important\">중요</span></h1>\n<p class=\"important\">중요한 단락입니다.</p>\n<div class=\"container important\">\n  <span class=\"note\">일반 노트</span>\n</div>\n```",
      "option_a": "1개",
      "option_b": "2개",
      "option_c": "3개",
      "option_d": "4개",
      "correct_answer": "C",
      "explanation": "\"important\" 클래스가 적용된 요소는 총 3개입니다:\n\n1. `<span class=\"important\">` - 첫 번째 요소\n2. `<p class=\"important\">` - 두 번째 요소\n3. `<div class=\"container important\">` - 세 번째 요소 (여러 클래스 중 하나)\n\n마지막 `<span class=\"note\">`는 \"note\" 클래스만 가지고 있으므로 \"important\" 클래스에 해당하지 않습니다. 클래스명은 대소문자를 구분하므로 정확히 일치하는 경우만 계산해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:36:48.000Z"
    },
    {
      "id": 946,
      "subject_id": 8,
      "question": "다음 JavaScript 코드의 실행 결과는?\n\n```html\n<div class=\"city\">London</div>\n<p class=\"city\">Paris</p>\n<span class=\"country\">France</span>\n<h2 class=\"city\">Tokyo</h2>\n```\n\n```javascript\nfunction hideElements() {\n  var elements = document.getElementsByClassName(\"_____\");\n  for (var i = 0; i < elements.length; i++) {\n    elements[i].style.display = \"none\";\n  }\n}\n```\n\n위 함수에서 빈칸에 \"city\"를 넣고 실행하면 화면에 보이는 요소는?",
      "option_a": "모든 요소가 숨겨짐",
      "option_b": "`<span class=\"country\">France</span>`만 보임",
      "option_c": "`<div class=\"city\">London</div>`만 보임",
      "option_d": "아무것도 변하지 않음",
      "correct_answer": "B",
      "explanation": "`getElementsByClassName(\"city\")`는 클래스명이 \"city\"인 모든 요소를 반환합니다. 이 경우:\n\n• `<div class=\"city\">London</div>` - 숨겨짐\n• `<p class=\"city\">Paris</p>` - 숨겨짐\n• `<h2 class=\"city\">Tokyo</h2>` - 숨겨짐\n\n`<span class=\"country\">France</span>`는 \"city\" 클래스가 아닌 \"country\" 클래스를 가지고 있으므로 선택되지 않아서 화면에 그대로 보입니다. `getElementsByClassName()` 메서드는 지정된 클래스명과 정확히 일치하는 요소들만 선택하며, `style.display = \"none\"`으로 요소들을 숨깁니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T08:38:31.000Z"
    },
    {
      "id": 947,
      "subject_id": 8,
      "question": "CSS에서 ID를 선택할 때 사용하는 기호는?\n\n```css\n_____ myHeader {\n  background-color: lightblue;\n  color: black;\n}\n```\n\n```html\n<h1 id=\"myHeader\">제목</h1>\n```",
      "option_a": ".",
      "option_b": "#",
      "option_c": "*",
      "option_d": "@",
      "correct_answer": "B",
      "explanation": "CSS에서 ID를 선택할 때는 해시 기호(`#`)를 ID명 앞에 붙입니다. 예를 들어 `id=\"myHeader\"`로 지정된 요소를 선택하려면 `#myHeader`로 작성합니다. 이는 CSS의 ID 선택자(ID selector) 문법입니다. `.`은 클래스 선택자, `*`은 전체 선택자에 사용되며, `@`는 CSS에서 미디어 쿼리나 키프레임 등에 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:48:15.000Z"
    },
    {
      "id": 948,
      "subject_id": 8,
      "question": "HTML 문서에서 ID의 가장 중요한 특징은?\n\n```html\n<div id=\"header\">헤더</div>\n<div id=\"header\">또 다른 헤더</div>  <!-- 이것이 문제가 되는 이유는? -->\n```",
      "option_a": "ID는 여러 요소에서 공유할 수 있다",
      "option_b": "ID는 문서 내에서 고유해야 한다",
      "option_c": "ID는 대소문자를 구분하지 않는다",
      "option_d": "ID는 숫자로 시작할 수 있다",
      "correct_answer": "B",
      "explanation": "ID의 가장 중요한 특징은 HTML 문서 내에서 고유(unique)해야 한다는 것입니다. 같은 ID를 가진 요소가 두 개 이상 있으면 안 됩니다. 이는 JavaScript에서 `getElementById()` 메서드가 하나의 요소만 반환하도록 설계되었고, CSS에서도 고유한 요소를 대상으로 스타일을 적용하기 위함입니다. 반면 클래스(`class`)는 여러 요소에서 공유할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:49:33.000Z"
    },
    {
      "id": 949,
      "subject_id": 8,
      "question": "class와 id의 차이점으로 올바른 것은?\n\n```html\n<h1 id=\"mainTitle\" class=\"heading\">메인 제목</h1>\n<h2 class=\"heading\">부제목 1</h2>\n<h2 class=\"heading\">부제목 2</h2>\n```",
      "option_a": "class는 여러 요소에 사용 가능, id는 문서당 하나만 사용 가능",
      "option_b": "class는 CSS에서만 사용, id는 JavaScript에서만 사용",
      "option_c": "class는 대소문자 구분, id는 대소문자 구분 안 함",
      "option_d": "class와 id는 완전히 동일한 기능",
      "correct_answer": "A",
      "explanation": "class와 id의 주요 차이점은 사용 범위입니다:\n\n• class: 여러 요소에서 동일한 클래스명을 공유할 수 있습니다. 예제에서 `class=\"heading\"`이 여러 요소에 사용된 것처럼 말입니다.\n• id: 문서 내에서 고유해야 하므로 한 번만 사용할 수 있습니다. 예제에서 `id=\"mainTitle\"`은 오직 하나의 요소에만 적용됩니다.\n\n둘 다 CSS와 JavaScript에서 모두 사용할 수 있으며, 둘 다 대소문자를 구분합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:50:28.000Z"
    },
    {
      "id": 950,
      "subject_id": 8,
      "question": "HTML 북마크를 만들어 페이지 내 특정 섹션으로 이동하는 올바른 코드는?\n\n```html\n<!-- 목적지 설정 -->\n<h2 _____ =\"chapter4\">4장: 고급 기능</h2>\n\n<!-- 링크 설정 -->\n<a _____ =\"_____\">4장으로 이동</a>\n```",
      "option_a": "`name`, `href`, `chapter4`",
      "option_b": "`id`, `href`, `#chapter4`",
      "option_c": "`class`, `link`, `chapter4`",
      "option_d": "`id`, `src`, `#chapter4`",
      "correct_answer": "B",
      "explanation": "HTML 북마크를 만들려면:\n\n1. 목적지에 `id` 속성으로 고유한 식별자를 지정: `<h2 id=\"chapter4\">`\n2. 링크에서 `href` 속성에 `#`과 함께 해당 ID를 지정: `<a href=\"#chapter4\">`\n\n`#` 기호는 같은 페이지 내의 ID를 참조한다는 의미입니다. 클릭하면 브라우저가 자동으로 해당 ID를 가진 요소의 위치로 스크롤합니다. 다른 페이지의 특정 섹션으로 이동하려면 `href=\"페이지명.html#chapter4\"`처럼 사용할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:52:32.000Z"
    },
    {
      "id": 951,
      "subject_id": 8,
      "question": "다음 JavaScript 코드의 실행 결과는?\n\n```html\n<h1 id=\"title\">원래 제목</h1>\n<p id=\"content\">원래 내용</p>\n<button onclick=\"changeContent()\">변경</button>\n```\n```javascript\nfunction changeContent() {\n  document.getElementById(\"_____\").innerHTML = \"새로운 제목\";\n  document.getElementById(\"content\").style.color = \"red\";\n}\n```\n빈칸에 \"title\"을 넣었을 때의 결과는?",
      "option_a": "제목만 변경되고 내용은 그대로",
      "option_b": "내용 색깔만 빨간색으로 변경",
      "option_c": "제목이 \"새로운 제목\"으로 변경되고, 내용 글자색이 빨간색으로 변경",
      "option_d": "아무것도 변하지 않음",
      "correct_answer": "C",
      "explanation": "JavaScript의 `getElementById()` 메서드는 지정된 ID를 가진 요소를 선택하여 조작할 수 있게 해줍니다:\n\n1. `document.getElementById(\"title\").innerHTML = \"새로운 제목\"`: ID가 \"title\"인 요소(h1)의 내용을 \"새로운 제목\"으로 변경\n2. `document.getElementById(\"content\").style.color = \"red\"`: ID가 \"content\"인 요소(p)의 글자색을 빨간색으로 변경\n\n따라서 버튼을 클릭하면 두 가지 변화가 모두 일어납니다. `innerHTML`은 요소의 내용을 변경하고, `style` 속성을 통해 CSS 스타일을 동적으로 변경할 수 있습니다. 이는 웹 페이지의 동적인 상호작용을 만드는 핵심 기법입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T08:54:02.000Z"
    },
    {
      "id": 952,
      "subject_id": 8,
      "question": "웹 페이지 안에 다른 웹 페이지를 삽입하기 위해 사용하는 HTML 태그는?\n```html\n<_____ src=\"https://www.example.com\" title=\"예제 페이지\">\n</_____ >\n```",
      "option_a": "`<frame>`",
      "option_b": "`<iframe>`",
      "option_c": "`<embed>`",
      "option_d": "`<include>`",
      "correct_answer": "B",
      "explanation": "웹 페이지 내에 다른 웹 페이지를 삽입할 때는 `<iframe>` 태그를 사용합니다. 'iframe'은 'inline frame'의 줄임말로, 현재 HTML 문서 내에 다른 문서를 인라인으로 삽입하는 역할을 합니다. 유튜브 동영상 삽입, 지도 삽입, 다른 웹사이트 콘텐츠 표시 등에 자주 사용됩니다. `<frame>`은 구식 태그이고, `<embed>`는 플러그인 콘텐츠용입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:55:55.000Z"
    },
    {
      "id": 953,
      "subject_id": 8,
      "question": "iframe에서 표시할 웹 페이지의 URL을 지정하는 속성은?\n\n```html\n<iframe _____ =\"https://www.w3schools.com\" title=\"W3Schools\">\n</iframe>\n```",
      "option_a": "url",
      "option_b": "src",
      "option_c": "href",
      "option_d": "link",
      "correct_answer": "B",
      "explanation": "iframe에서 표시할 웹 페이지의 URL을 지정할 때는 `src` 속성을 사용합니다. 'src'는 'source'의 줄임말로, 삽입할 문서의 출처를 나타냅니다. 이는 `<img>` 태그의 `src` 속성과 같은 개념입니다. `href`는 링크(`<a>`) 태그에서 사용하는 속성이고, `url`이나 `link`는 iframe에서 사용하지 않는 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T08:56:57.000Z"
    },
    {
      "id": 954,
      "subject_id": 8,
      "question": "iframe의 크기를 설정하는 방법으로 올바르지 않은 것은?",
      "option_a": "`<iframe src=\"page.html\" height=\"300\" width=\"400\">`",
      "option_b": "`<iframe src=\"page.html\" style=\"height:300px;width:400px;\">`",
      "option_c": "`<iframe src=\"page.html\" size=\"300x400\">`",
      "option_d": "`<iframe src=\"page.html\" style=\"height:50%;width:80%;\">`",
      "correct_answer": "C",
      "explanation": "iframe의 크기는 다음 방법들로 설정할 수 있습니다:\n\n• HTML 속성: `height`와 `width` 속성 사용 (기본 단위는 픽셀)\n• CSS 스타일: `style` 속성으로 `height`와 `width` 설정 (픽셀, 퍼센트 등 다양한 단위 가능)\n\n하지만 `size=\"300x400\"`같은 속성은 존재하지 않습니다. 이는 잘못된 문법입니다. iframe의 크기는 반드시 `height`와 `width`를 각각 지정해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:58:12.000Z"
    },
    {
      "id": 955,
      "subject_id": 8,
      "question": "iframe의 테두리를 제거하고 빨간색 테두리로 변경하려면?\n\n```html\n<!-- 테두리 제거 -->\n<iframe src=\"page.html\" style=\"_____\" title=\"예제\">\n</iframe>\n\n<!-- 빨간색 테두리 -->\n<iframe src=\"page.html\" style=\"_____\" title=\"예제\">\n</iframe>\n```",
      "option_a": "`border:none;`, `border:2px solid red;`",
      "option_b": "`border:hidden;`, `border:red;`",
      "option_c": "`no-border:true;`, `border-color:red;`",
      "option_d": "`border:remove;`, `border:red-line;`",
      "correct_answer": "A",
      "explanation": "iframe의 테두리를 제어하려면 CSS의 `border` 속성을 사용합니다:\n\n• 테두리 제거: `border:none;` 또는 `border:0;`\n• 빨간색 테두리: `border:2px solid red;` (두께, 스타일, 색상 순으로 지정)\n\n기본적으로 iframe에는 테두리가 있으므로, 깔끔한 디자인을 위해 `border:none;`을 자주 사용합니다. 테두리 스타일링은 일반적인 CSS border 속성과 동일하게 적용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T08:59:58.000Z"
    },
    {
      "id": 956,
      "subject_id": 8,
      "question": "다음 코드에서 링크를 클릭했을 때의 결과는?\n\n```html\n<iframe src=\"about.html\" name=\"contentFrame\" width=\"500\" height=\"300\" title=\"콘텐츠\">\n</iframe>\n\n<p><a href=\"https://www.google.com\" target=\"contentFrame\">구글로 이동</a></p>\n<p><a href=\"contact.html\" target=\"contentFrame\">연락처 페이지</a></p>\n<p><a href=\"https://www.naver.com\" target=\"_blank\">네이버로 이동</a></p>\n```",
      "option_a": "모든 링크가 새 창에서 열림",
      "option_b": "첫 번째와 두 번째 링크는 iframe 내에서, 세 번째 링크는 새 창에서 열림",
      "option_c": "모든 링크가 iframe 내에서 열림",
      "option_d": "모든 링크가 현재 페이지에서 열림",
      "correct_answer": "B",
      "explanation": "링크의 `target` 속성이 어떻게 작동하는지 분석해보면:\n\n1. 구글 링크: `target=\"contentFrame\"` → iframe의 `name=\"contentFrame\"`과 일치하므로 iframe 내에서 열림\n2. 연락처 링크: `target=\"contentFrame\"` → 마찬가지로 iframe 내에서 열림\n3. 네이버 링크: `target=\"_blank\"` → 새 창(또는 새 탭)에서 열림\n\n`target` 속성에 iframe의 `name` 값을 지정하면 해당 iframe을 대상으로 페이지가 로드됩니다. 이는 iframe을 콘텐츠 표시 영역으로 사용하는 프레임 기반 네비게이션에서 유용한 기법입니다. `_blank`는 항상 새 창에서 열리는 특수한 target 값입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T09:01:30.000Z"
    },
    {
      "id": 957,
      "subject_id": 8,
      "question": "HTML에서 JavaScript 코드를 삽입하기 위해 사용하는 태그는?\n```html\n<_____ >\ndocument.getElementById(\"demo\").innerHTML = \"Hello!\";\n</_____ >\n```",
      "option_a": "`<js>`",
      "option_b": "`<javascript>`",
      "option_c": "`<script>`",
      "option_d": "`<code>`",
      "correct_answer": "C",
      "explanation": "HTML에서 JavaScript 코드를 삽입할 때는 `<script>` 태그를 사용합니다. 이 태그 안에 JavaScript 코드를 직접 작성하거나, `src` 속성을 사용하여 외부 JavaScript 파일을 연결할 수 있습니다. `<script>` 태그는 클라이언트 사이드 스크립트를 정의하는 표준 HTML 태그입니다. JavaScript는 웹 페이지를 동적이고 상호작용적으로 만드는 데 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:03:12.000Z"
    },
    {
      "id": 958,
      "subject_id": 8,
      "question": "JavaScript에서 HTML 요소를 선택하는 가장 일반적인 메서드는?\n\n```javascript\n_____ .getElementById(\"myElement\").innerHTML = \"새로운 내용\";\n```",
      "option_a": "window",
      "option_b": "document",
      "option_c": "element",
      "option_d": "html",
      "correct_answer": "B",
      "explanation": "JavaScript에서 HTML 요소를 선택할 때는 `document.getElementById()` 메서드를 가장 많이 사용합니다. `document`는 현재 웹 페이지의 DOM(Document Object Model)을 나타내는 객체입니다. `getElementById()` 메서드는 지정된 ID를 가진 요소를 찾아 반환하므로, 해당 요소의 내용이나 스타일을 변경할 수 있습니다. 이는 HTML과 JavaScript를 연결하는 핵심적인 방법입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:04:00.000Z"
    },
    {
      "id": 959,
      "subject_id": 8,
      "question": "다음 JavaScript 코드의 실행 결과는?\n\n```html\n<p id=\"text\">원래 텍스트</p>\n<script>\ndocument.getElementById(\"text\").innerHTML = \"Hello JavaScript!\";\ndocument.getElementById(\"text\").style.color = \"red\";\n</script>\n```",
      "option_a": "텍스트가 \"Hello JavaScript!\"로 변경됨",
      "option_b": "텍스트 색깔만 빨간색으로 변경됨",
      "option_c": "텍스트가 \"Hello JavaScript!\"로 변경되고 빨간색으로 표시됨",
      "option_d": "아무것도 변하지 않음",
      "correct_answer": "C",
      "explanation": "이 코드는 두 가지 작업을 순차적으로 수행합니다:\n\n1. `innerHTML = \"Hello JavaScript!\"`: ID가 \"text\"인 요소의 내용을 \"Hello JavaScript!\"로 변경\n2. `style.color = \"red\"`: 같은 요소의 글자색을 빨간색으로 변경\n\nJavaScript는 위에서 아래로 순차적으로 실행되므로, 두 변경사항이 모두 적용됩니다. `innerHTML`은 요소의 내용을 변경하고, `style` 속성을 통해 CSS 스타일을 동적으로 조작할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:04:58.000Z"
    },
    {
      "id": 960,
      "subject_id": 8,
      "question": "JavaScript가 비활성화된 브라우저에서 대체 콘텐츠를 표시하기 위해 사용하는 태그는?\n```html\n<script>\ndocument.getElementById(\"demo\").innerHTML = \"JavaScript가 작동합니다!\";\n</script>\n<_____ >죄송합니다. JavaScript를 지원하지 않습니다!</_____ >\n```",
      "option_a": "`<nojs>`",
      "option_b": "`<noscript>`",
      "option_c": "`<alternative>`",
      "option_d": "`<fallback>`",
      "correct_answer": "B",
      "explanation": "`<noscript>` 태그는 사용자의 브라우저에서 JavaScript가 비활성화되어 있거나 지원하지 않을 때 표시될 대체 콘텐츠를 정의합니다. 이는 웹 접근성을 향상시키는 중요한 요소로, 모든 사용자가 웹사이트의 기본 기능에 접근할 수 있도록 보장합니다. JavaScript에 의존적인 기능이 있을 때는 항상 `<noscript>` 태그로 대체 방안을 제공하는 것이 좋은 관례입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:05:43.000Z"
    },
    {
      "id": 961,
      "subject_id": 8,
      "question": "다음 코드에서 버튼을 클릭했을 때의 결과는?\n\n```html\n<img id=\"myImage\" src=\"day.jpg\" alt=\"낮 이미지\">\n<p id=\"status\" style=\"font-size: 16px;\">현재: 낮</p>\n<button onclick=\"changeImage()\">이미지 변경</button>\n\n<script>\nfunction changeImage() {\n  document.getElementById(\"myImage\")._____ = \"night.jpg\";\n  document.getElementById(\"status\").innerHTML = \"현재: 밤\";\n  document.getElementById(\"status\").style._____ = \"20px\";\n}\n</script>\n```\n빈칸에 `src`와 `fontSize`가 들어갈 때의 결과는?",
      "option_a": "이미지만 변경됨",
      "option_b": "텍스트만 변경됨",
      "option_c": "이미지가 night.jpg로 변경되고, 텍스트가 \"현재: 밤\"으로 변경되며, 글자 크기가 20px로 커짐",
      "option_d": "오류 발생으로 아무것도 변하지 않음",
      "correct_answer": "C",
      "explanation": "이 JavaScript 함수는 세 가지 작업을 수행합니다:\n\n1. `document.getElementById(\"myImage\").src = \"night.jpg\"`: 이미지의 `src` 속성을 변경하여 다른 이미지 파일로 교체\n2. `document.getElementById(\"status\").innerHTML = \"현재: 밤\"`: 텍스트 내용을 변경\n3. `document.getElementById(\"status\").style.fontSize = \"20px\"`: 글자 크기를 16px에서 20px로 변경\n\nJavaScript에서는 HTML 속성(`src`, `alt` 등)과 CSS 스타일(`fontSize`, `color` 등)을 모두 동적으로 변경할 수 있습니다. 이는 사용자 상호작용에 따라 웹 페이지의 모양과 내용을 실시간으로 바꾸는 핵심 기능입니다. 버튼 클릭 시 `onclick` 이벤트가 발생하여 함수가 실행됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T09:07:23.000Z"
    },
    {
      "id": 962,
      "subject_id": 8,
      "question": "현재 페이지와 같은 폴더에 있는 이미지를 참조하는 올바른 방법은?\n\n```html\n<img src=\"_____ \" alt=\"사진\">\n```\n현재 폴더에 \"photo.jpg\" 파일이 있을 때:",
      "option_a": "/photo.jpg",
      "option_b": "photo.jpg",
      "option_c": "../photo.jpg",
      "option_d": "./images/photo.jpg",
      "correct_answer": "B",
      "explanation": "현재 페이지와 같은 폴더에 있는 파일을 참조할 때는 파일명만 작성하면 됩니다. `photo.jpg`처럼 경로 없이 파일명만 사용하는 것이 가장 간단한 상대 경로입니다. `/photo.jpg`는 웹사이트 루트 폴더의 파일을 의미하고, `../photo.jpg`는 한 단계 위 폴더의 파일을 의미하며, `./images/photo.jpg`는 현재 폴더의 images 하위 폴더 안의 파일을 의미합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:09:30.000Z"
    },
    {
      "id": 963,
      "subject_id": 8,
      "question": "절대 경로(Absolute File Path)의 예시로 올바른 것은?\n\n```html\n<img src=\"_____ \" alt=\"이미지\">\n```",
      "option_a": "images/picture.jpg",
      "option_b": "../picture.jpg",
      "option_c": "https://www.example.com/images/picture.jpg",
      "option_d": "/images/picture.jpg",
      "correct_answer": "C",
      "explanation": "절대 경로는 파일의 완전한 URL을 포함하는 경로입니다. `https://www.example.com/images/picture.jpg`처럼 프로토콜(https)과 도메인명이 포함된 전체 주소가 절대 경로입니다. 나머지는 모두 상대 경로입니다:\n\n• `images/picture.jpg`: 현재 폴더의 하위 폴더\n• `../picture.jpg`: 한 단계 위 폴더\n• `/images/picture.jpg`: 웹사이트 루트부터 시작하는 상대 경로",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:10:32.000Z"
    },
    {
      "id": 964,
      "subject_id": 8,
      "question": "다음 중 \"현재 폴더의 images 하위 폴더에 있는 파일\"을 참조하는 올바른 상대 경로는?\n\n```html\n<img src=\"_____ \" alt=\"그림\">\n```",
      "option_a": "/images/logo.png",
      "option_b": "images/logo.png",
      "option_c": "../images/logo.png",
      "option_d": "./logo.png/images",
      "correct_answer": "B",
      "explanation": "현재 폴더의 하위 폴더에 있는 파일을 참조할 때는 `폴더명/파일명` 형식을 사용합니다. `images/logo.png`는 현재 위치에서 images 폴더 안의 logo.png 파일을 의미합니다.\n\n• `/images/logo.png`는 웹사이트 루트의 images 폴더를 의미\n• `../images/logo.png`는 한 단계 위 폴더의 images 폴더를 의미\n• `./logo.png/images`는 잘못된 문법",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:11:36.000Z"
    },
    {
      "id": 965,
      "subject_id": 8,
      "question": "한 단계 위 폴더에 있는 파일을 참조할 때 사용하는 기호는?\n\n```html\n<link rel=\"stylesheet\" href=\"_____ /css/style.css\">\n```",
      "option_a": "/",
      "option_b": "./",
      "option_c": "../",
      "option_d": "~/",
      "correct_answer": "C",
      "explanation": "상위 폴더(한 단계 위 폴더)로 이동할 때는 `../`를 사용합니다. 점 두 개(`..`)는 \"부모 디렉토리\"를 의미하는 표준 표기법입니다.\n\n• `/`: 웹사이트의 루트(최상위) 폴더\n• `./`: 현재 폴더 (생략 가능)\n• `~/`: Unix/Linux 시스템의 홈 디렉토리 (웹에서는 사용하지 않음)\n\n여러 단계 위로 올라가려면 `../../`처럼 반복 사용할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:12:51.000Z"
    },
    {
      "id": 966,
      "subject_id": 8,
      "question": "다음 폴더 구조에서 \"page.html\"에 있는 이미지 태그가 \"logo.png\"를 올바르게 참조하는 코드는?\n\nwebsite/\n├── index.html\n├── images/\n│   └── logo.png\n└── pages/\n    └── page.html\n\n현재 \"pages/page.html\" 파일에서 \"images/logo.png\"를 참조하려면:",
      "option_a": "`<img src=\"images/logo.png\">`",
      "option_b": "`<img src=\"/images/logo.png\">`",
      "option_c": "`<img src=\"../images/logo.png\">`",
      "option_d": "`<img src=\"./images/logo.png\">`",
      "correct_answer": "C",
      "explanation": "현재 위치는 `pages/page.html`이고, 목표 파일은 `images/logo.png`입니다.\n\n폴더 구조를 분석하면:\n\n• `page.html`은 `pages` 폴더 안에 있음\n• `logo.png`는 `images` 폴더 안에 있음\n• `pages`와 `images` 폴더는 같은 레벨(둘 다 website 폴더의 직계 자식)\n\n따라서 `pages` 폴더에서 한 단계 위(`website`)로 올라간 다음, `images` 폴더로 들어가야 합니다.\n경로: `../images/logo.png`\n\n• `../`: pages에서 website로 한 단계 위로\n• `images/`: website에서 images 폴더로\n• `logo.png`: 목표 파일\n\n옵션 2번(`/images/logo.png`)도 작동하지만, 이는 절대 경로 방식으로 웹사이트 루트부터 시작하는 방법입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T09:14:59.000Z"
    },
    {
      "id": 967,
      "subject_id": 8,
      "question": "HTML 문서에서 반드시 포함되어야 하는 필수 태그는?\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <_____ >웹사이트 제목</_____ >\n</head>\n<body>\n  내용\n</body>\n</html>\n```",
      "option_a": "`<meta>`",
      "option_b": "`<title>`",
      "option_c": "`<style>`",
      "option_d": "`<link>`",
      "correct_answer": "B",
      "explanation": "HTML 문서에서 `<title>` 태그는 반드시 포함되어야 하는 필수 요소입니다. 브라우저 탭에 표시되는 제목을 정의하며, SEO(검색 엔진 최적화)에도 매우 중요한 역할을 합니다. 검색 엔진은 페이지 제목을 사용하여 검색 결과의 순서를 결정하므로, 의미 있고 정확한 제목을 작성하는 것이 중요합니다. 다른 태그들은 선택적으로 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:17:14.000Z"
    },
    {
      "id": 968,
      "subject_id": 8,
      "question": "외부 CSS 파일을 HTML 문서에 연결할 때 사용하는 태그는?\n```html\n<head>\n  <_____ rel=\"stylesheet\" href=\"style.css\">\n</head>\n```",
      "option_a": "`<style>`",
      "option_b": "`<link>`",
      "option_c": "`<meta>`",
      "option_d": "`<css>`",
      "correct_answer": "B",
      "explanation": "외부 CSS 파일을 HTML 문서에 연결할 때는 `<link>` 태그를 사용합니다. `rel=\"stylesheet\"` 속성으로 연결하는 파일이 스타일시트임을 명시하고, `href` 속성으로 CSS 파일의 경로를 지정합니다. `<style>` 태그는 HTML 문서 내부에 직접 CSS를 작성할 때 사용하며, <link> 태그는 외부 리소스를 연결하는 용도입니다. 이 방법으로 CSS를 분리하면 여러 HTML 파일에서 재사용할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:18:02.000Z"
    },
    {
      "id": 969,
      "subject_id": 8,
      "question": "반응형 웹사이트를 위해 모든 웹 페이지에 포함해야 하는 meta 태그는?\n\n```html\n<meta name=\"_____\" content=\"width=device-width, initial-scale=1.0\">\n```",
      "option_a": "description",
      "option_b": "keywords",
      "option_c": "viewport",
      "option_d": "author",
      "correct_answer": "C",
      "explanation": "`<meta name=\"viewport\">` 태그는 반응형 웹사이트를 만들기 위해 반드시 포함해야 하는 태그입니다. 이 태그는 브라우저에게 페이지의 크기와 확대/축소를 어떻게 제어할지 지시합니다. `width=device-width`는 페이지 너비를 기기의 화면 너비에 맞추고, `initial-scale=1.0`은 페이지가 처음 로드될 때의 초기 확대/축소 비율을 설정합니다. 이 태그가 없으면 모바일에서 웹사이트가 제대로 표시되지 않을 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:19:05.000Z"
    },
    {
      "id": 970,
      "subject_id": 8,
      "question": "다음 meta 태그들의 용도가 올바르게 설명된 것은?\n\n```html\n<meta charset=\"UTF-8\">\n<meta name=\"description\" content=\"HTML 학습 사이트\">\n<meta name=\"keywords\" content=\"HTML, CSS, JavaScript\">\n```",
      "option_a": "문자 인코딩, 페이지 설명, 검색 키워드",
      "option_b": "폰트 설정, 제목, 언어 설정",
      "option_c": "색상 설정, 저자 정보, 페이지 크기",
      "option_d": "스타일 정보, 링크, 스크립트",
      "correct_answer": "A",
      "explanation": "각 meta 태그의 용도는 다음과 같습니다:\n\n• `<meta charset=\"UTF-8\">`: 문서의 문자 인코딩을 UTF-8로 설정 (한글 등 다국어 지원)\n• `<meta name=\"description\">`: 검색 엔진과 SNS에서 표시될 페이지 설명\n• `<meta name=\"keywords\">`: 검색 엔진이 페이지 내용을 파악하는 데 도움이 되는 키워드\n\n이러한 메타데이터는 페이지에 직접 표시되지 않지만, 브라우저와 검색 엔진이 페이지를 올바르게 처리하고 검색 결과에 적절히 표시하는 데 중요한 역할을 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:20:02.000Z"
    },
    {
      "id": 971,
      "subject_id": 8,
      "question": "다음 HTML 문서에서 `<base>` 태그가 설정된 상태에서 이미지와 링크가 실제로 참조하는 경로는?\n\n```html\n<head>\n  <base href=\"https://www.example.com/docs/\" target=\"_blank\">\n</head>\n<body>\n  <img src=\"images/logo.png\" alt=\"로고\">\n  <a href=\"tutorial.html\">튜토리얼</a>\n</body>\n```",
      "option_a": "이미지: `images/logo.png`, 링크: `tutorial.html`",
      "option_b": "이미지: `https://www.example.com/docs/images/logo.png`, 링크: `https://www.example.com/docs/tutorial.html`",
      "option_c": "이미지: `https://www.example.com/images/logo.png`, 링크: `https://www.example.com/tutorial.html`",
      "option_d": "이미지와 링크 모두 오류 발생",
      "correct_answer": "B",
      "explanation": "`<base>` 태그는 페이지 내 모든 상대 경로의 기준점을 설정합니다. `href=\"https://www.example.com/docs/\"`로 설정되어 있으므로:\n\n• 이미지 경로: `images/logo.png` → `https://www.example.com/docs/` + `images/logo.png` = `https://www.example.com/docs/images/logo.png`\n• 링크 경로: `tutorial.html` → `https://www.example.com/docs/` + `tutorial.html` = `https://www.example.com/docs/tutorial.html`\n\n또한 `target=\"_blank\"`가 설정되어 있으므로 링크는 새 창에서 열립니다. `<base>` 태그는 문서당 하나만 사용할 수 있으며, 모든 상대 경로에 영향을 주므로 신중하게 사용해야 합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T09:22:29.000Z"
    },
    {
      "id": 972,
      "subject_id": 8,
      "question": "웹페이지의 상단 부분을 정의하는 HTML 시맨틱 요소는 무엇인가요?",
      "option_a": "`<top>`",
      "option_b": "`<header>`",
      "option_c": "`<head>`",
      "option_d": "`<title>`",
      "correct_answer": "B",
      "explanation": "`<header>` 요소는 문서나 섹션의 상단 부분(헤더)를 정의하는 HTML5의 시맨틱 요소입니다. 일반적으로 제목, 로고, 내비게이션 메뉴 등이 포함됩니다. `<head>`는 문서의 메타데이터를 담는 요소이고, `<top>`이나 `<title>`은 헤더를 나타내는 요소가 아닙니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:24:09.000Z"
    },
    {
      "id": 973,
      "subject_id": 8,
      "question": "다음 중 독립적이고 자체 완결적인 콘텐츠를 정의하는 시맨틱 요소는?",
      "option_a": "`<section>`",
      "option_b": "`<aside>`",
      "option_c": "`<article>`",
      "option_d": "`<div>`",
      "correct_answer": "C",
      "explanation": "`<article>` 요소는 독립적이고 자체 완결적인 콘텐츠를 정의합니다. 블로그 포스트, 뉴스 기사, 포럼 글 등이 대표적인 예입니다. `<section>`은 문서의 한 구역을 나타내고, `<aside>`는 사이드바 같은 부가 콘텐츠, `<div>`는 일반적인 컨테이너 요소입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:25:02.000Z"
    },
    {
      "id": 974,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 요소는?\n```html\n<______>\n  <a href=\"#home\">홈</a>\n  <a href=\"#about\">소개</a>\n  <a href=\"#contact\">연락처</a>\n</______>\n```",
      "option_a": "`<menu>`",
      "option_b": "`<nav>`",
      "option_c": "`<links>`",
      "option_d": "`<navigation>`",
      "correct_answer": "B",
      "explanation": "`<nav>` 요소는 내비게이션 링크들의 집합을 정의하는 시맨틱 요소입니다. 주 메뉴, 페이지네이션 등에 사용됩니다. 코드에서 보듯이 여러 링크들을 묶어서 내비게이션을 만들 때 사용하는 적절한 요소입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:25:57.000Z"
    },
    {
      "id": 975,
      "subject_id": 8,
      "question": "CSS를 이용한 다단 레이아웃 기법 중 가장 최신의 방법은 무엇인가요?",
      "option_a": "CSS Float",
      "option_b": "CSS Framework",
      "option_c": "CSS Flexbox",
      "option_d": "CSS Grid",
      "correct_answer": "D",
      "explanation": "CSS Grid는 행과 열을 기반으로 한 2차원 레이아웃 시스템으로, 가장 최신의 레이아웃 기법입니다. Float는 원래 레이아웃을 위한 것이 아니었고, Flexbox는 1차원 레이아웃에 특화되어 있습니다. CSS Grid는 복잡한 레이아웃을 플로트나 포지셔닝 없이도 쉽게 만들 수 있게 해줍니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:26:36.000Z"
    },
    {
      "id": 976,
      "subject_id": 8,
      "question": "반응형 웹사이트를 만들기 위해 모든 웹페이지에 추가해야 하는 메타 태그는 무엇인가요?",
      "option_a": "`<meta name=\"description\" content=\"responsive website\">`",
      "option_b": "`<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">`",
      "option_c": "`<meta name=\"responsive\" content=\"true\">`",
      "option_d": "`<meta name=\"mobile\" content=\"width=100%\">`",
      "correct_answer": "B",
      "explanation": "반응형 웹사이트를 만들기 위해서는 `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">` 태그를 반드시 추가해야 합니다. 이 태그는 브라우저에게 페이지의 크기와 스케일링을 어떻게 제어할지 지시합니다. `width=device-width`는 페이지의 너비를 기기의 화면 너비에 맞추고, `initial-scale=1.0`은 초기 확대/축소 비율을 1배로 설정합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:30:10.000Z"
    },
    {
      "id": 977,
      "subject_id": 8,
      "question": "다음 CSS 코드에서 이미지를 반응형으로 만들기 위해 빈칸에 들어갈 올바른 속성은?\n\n```html\n<img src=\"photo.jpg\" style=\"______:100%;\">\n```",
      "option_a": "height",
      "option_b": "width",
      "option_c": "size",
      "option_d": "scale",
      "correct_answer": "B",
      "explanation": "`width: 100%`를 사용하면 이미지가 부모 컨테이너의 너비에 맞춰 반응형으로 크기가 조절됩니다. 화면 크기가 변해도 이미지가 자동으로 확대되거나 축소되어 브라우저 창에 맞게 표시됩니다. 하지만 이 방법은 이미지가 원본 크기보다 커질 수 있다는 단점이 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:30:48.000Z"
    },
    {
      "id": 978,
      "subject_id": 8,
      "question": "이미지가 원본 크기보다 커지지 않으면서 반응형으로 동작하게 하려면 어떤 속성을 사용해야 하나요?\n\n```html\n<img src=\"photo.jpg\" style=\"______:100%;height:auto;\">\n```",
      "option_a": "width",
      "option_b": "min-width",
      "option_c": "max-width",
      "option_d": "responsive-width",
      "correct_answer": "C",
      "explanation": "`max-width: 100%`를 사용하면 이미지가 필요에 따라 축소되지만, 절대 원본 크기보다 커지지 않습니다. 이는 `width: 100%`보다 더 나은 해결책입니다. 화면이 이미지보다 작으면 이미지가 축소되고, 화면이 이미지보다 크면 이미지는 원본 크기를 유지합니다. `height: auto`와 함께 사용하면 이미지의 비율이 유지됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:37:48.000Z"
    },
    {
      "id": 979,
      "subject_id": 8,
      "question": "브라우저 창 크기에 따라 다른 이미지를 보여주기 위해 사용하는 HTML 요소는 무엇인가요?\n```html\n<______>\n  <source srcset=\"small.jpg\" media=\"(max-width: 600px)\">\n  <source srcset=\"large.jpg\">\n  <img src=\"default.jpg\" alt=\"responsive image\">\n</______>\n```",
      "option_a": "`<images>`",
      "option_b": "`<picture>`",
      "option_c": "`<responsive>`",
      "option_d": "`<media>`",
      "correct_answer": "B",
      "explanation": "`<picture>` 요소는 브라우저 창 크기에 따라 다른 이미지를 표시할 수 있게 해주는 HTML5 요소입니다. `<source>` 태그의 `media` 속성을 통해 조건을 설정하고, 해당 조건에 맞는 이미지를 `srcset`으로 지정합니다. 예시에서는 600px 이하일 때는 small.jpg를, 그보다 클 때는 large.jpg를 보여줍니다. 마지막 `<img>` 태그는 폴백용입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:38:47.000Z"
    },
    {
      "id": 980,
      "subject_id": 8,
      "question": "다음 미디어 쿼리 코드에서 빈칸에 들어갈 올바른 내용을 순서대로 나열한 것은?\n\n```css\n.left, .right {\n  float: left;\n  width: ______; /* 기본 너비 */\n}\n.main {\n  float: left;\n  width: ______; /* 기본 너비 */\n}\n\n@media screen and (______: 800px) {\n  .left, .main, .right {\n    width: ______; /* 작은 화면에서의 너비 */\n  }\n}\n```",
      "option_a": "20%, 60%, min-width, 50%",
      "option_b": "30%, 40%, max-height, 100%",
      "option_c": "20%, 60%, max-width, 100%",
      "option_d": "25%, 50%, min-height, 80%",
      "correct_answer": "C",
      "explanation": "이 코드는 반응형 3단 레이아웃을 구현하는 전형적인 패턴입니다:\n\n• `.left, .right { width: 20%; }`: 좌우 사이드바가 각각 20%씩 차지\n• `.main { width: 60%; }`: 메인 콘텐츠가 60% 차지 (20% + 60% + 20% = 100%)\n• `@media screen and (max-width: 800px)`: 화면 너비가 800px 이하일 때 적용\n• `width: 100%`: 작은 화면에서는 모든 요소가 100% 너비를 가져 세로로 쌓임\n\n이렇게 하면 큰 화면에서는 가로 3단 레이아웃이, 작은 화면에서는 세로 스택 레이아웃이 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T09:41:12.000Z"
    },
    {
      "id": 981,
      "subject_id": 8,
      "question": "사용자가 키보드로 입력하는 내용을 표시할 때 사용하는 HTML 요소는 무엇인가요?\n```html\n<p>문서를 저장하려면 <______>Ctrl + S</______>를 누르세요</p>\n```",
      "option_a": "`<key>`",
      "option_b": "`<kbd>`",
      "option_c": "`<input>`",
      "option_d": "`<keyboard>`",
      "correct_answer": "B",
      "explanation": "`<kbd>` 요소는 키보드 입력을 정의하는 데 사용됩니다. 브라우저에서 기본적으로 고정폭 폰트로 표시되며, 사용자에게 어떤 키를 눌러야 하는지 명확하게 보여줍니다. 예를 들어 \"Ctrl + S\", \"Enter\", \"Alt + Tab\" 같은 키보드 조합을 표시할 때 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:43:02.000Z"
    },
    {
      "id": 982,
      "subject_id": 8,
      "question": "컴퓨터 프로그램의 출력 결과를 표시하는 HTML 요소는 무엇인가요?\n```html\n<p>컴퓨터에서 보낸 메시지:</p>\n<______>파일을 찾을 수 없습니다.</______>\n```",
      "option_a": "`<output>`",
      "option_b": "`<result>`",
      "option_c": "`<samp>`",
      "option_d": "`<display>`",
      "correct_answer": "C",
      "explanation": "`<samp>` 요소는 컴퓨터 프로그램의 샘플 출력을 정의하는 데 사용됩니다. 터미널이나 콘솔에서 출력되는 메시지, 에러 메시지, 프로그램 실행 결과 등을 표시할 때 사용하며, 브라우저에서 고정폭 폰트로 표시됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:43:48.000Z"
    },
    {
      "id": 983,
      "subject_id": 8,
      "question": "다음 코드에서 줄바꿈과 공백을 그대로 유지하려면 `<code>` 요소를 어떤 요소로 감싸야 하나요?\n```html\n<______>\n<code>\nx = 5;\ny = 6;\nz = x + y;\n</code>\n</______>\n```",
      "option_a": "`<preserve>`",
      "option_b": "`<pre>`",
      "option_c": "`<format>`",
      "option_d": "`<whitespace>`",
      "correct_answer": "B",
      "explanation": "`<code>` 요소는 기본적으로 추가적인 공백과 줄바꿈을 보존하지 않습니다. 코드의 포맷을 그대로 유지하려면 `<pre>` 요소로 감싸야 합니다. `<pre>` 요소는 preformatted text를 의미하며, 텍스트 안의 공백, 탭, 줄바꿈을 모두 그대로 표시합니다. 이는 코드 블록을 표시할 때 매우 유용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:44:40.000Z"
    },
    {
      "id": 984,
      "subject_id": 8,
      "question": "다음 중 독립적이고 자체 완결적인 콘텐츠를 정의하는 시맨틱 요소는 무엇인가요?\n```html\n<______>\n  <h2>블로그 포스트 제목</h2>\n  <p>이 글은 독립적으로 배포될 수 있는 완전한 내용입니다.</p>\n</______>\n```",
      "option_a": "`<section>`",
      "option_b": "`<article>`",
      "option_c": "`<div>`",
      "option_d": "`<content>`",
      "correct_answer": "B",
      "explanation": "`<article>` 요소는 독립적이고 자체 완결적인 콘텐츠를 정의합니다. 블로그 포스트, 뉴스 기사, 포럼 글, 제품 카드 등과 같이 그 자체로 의미가 완전하고 다른 곳에 독립적으로 배포할 수 있는 콘텐츠에 사용합니다. `<section>`은 문서의 한 구역을 나타내지만 반드시 독립적일 필요는 없습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:45:30.000Z"
    },
    {
      "id": 985,
      "subject_id": 8,
      "question": "HTML 문서의 첫 번째 줄에 반드시 선언해야 하는 것은 무엇인가요?\n```html\n______\n<html>\n<head>\n  <title>웹페이지</title>\n</head>\n<body>\n  <h1>안녕하세요</h1>\n</body>\n</html>\n```",
      "option_a": "`<html lang=\"ko\">`",
      "option_b": "`<!DOCTYPE html>`",
      "option_c": "`<meta charset=\"UTF-8\">`",
      "option_d": "`<!-- HTML 문서 -->`",
      "correct_answer": "B",
      "explanation": "HTML 문서의 첫 번째 줄에는 반드시 `<!DOCTYPE html>`을 선언해야 합니다. 이는 브라우저에게 이 문서가 HTML5 형식임을 알려주는 문서 타입 선언입니다. DOCTYPE 선언이 없으면 브라우저가 호환 모드(quirks mode)로 작동하여 예상치 못한 렌더링 문제가 발생할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:54:39.000Z"
    },
    {
      "id": 986,
      "subject_id": 8,
      "question": "다음 중 올바른 HTML 코딩 스타일은 무엇인가요?",
      "option_a": "`<P CLASS=\"MAIN\">텍스트</P>`",
      "option_b": "`<p class=\"main\">텍스트</p>`",
      "option_c": "`<P class=main>텍스트</P>`",
      "option_d": "`<p Class=\"Main\">텍스트</p>`",
      "correct_answer": "B",
      "explanation": "HTML에서는 요소명과 속성명을 모두 소문자로 작성하는 것이 권장됩니다. 또한 속성값은 항상 따옴표로 감싸야 합니다. 소문자 사용은 코드를 더 깔끔하게 보이게 하고, 개발자들 사이의 일반적인 관례이며, 타이핑하기도 더 쉽습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T09:55:20.000Z"
    },
    {
      "id": 987,
      "subject_id": 8,
      "question": "이미지 태그에서 반드시 포함해야 하는 속성들을 모두 포함한 올바른 예시는?\n\n```html\n<img ______>\n```",
      "option_a": "src=\"image.jpg\"",
      "option_b": "src=\"image.jpg\" alt=\"설명\"",
      "option_c": "src=\"image.jpg\" alt=\"설명\" style=\"width:100px;height:100px\"",
      "option_d": "src=\"image.jpg\" width=\"100\" height=\"100\"",
      "correct_answer": "C",
      "explanation": "이미지 태그에는 반드시 `src` (이미지 경로), `alt` (대체 텍스트), 그리고 `width`와 `height` (크기)를 지정해야 합니다. `alt` 속성은 접근성을 위해 필수이며, 크기 지정은 이미지 로딩 전에 브라우저가 공간을 미리 확보하여 깜빡임을 방지합니다. `style` 속성이나 별도의 `width`, `height` 속성 모두 사용 가능하지만, 3번이 모든 필수 요소를 포함한 완전한 예시입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:56:40.000Z"
    },
    {
      "id": 988,
      "subject_id": 8,
      "question": "반응형 웹페이지를 위해 HTML 문서의 `<head>` 섹션에 포함해야 하는 메타 태그는?\n```html\n<head>\n  <meta charset=\"UTF-8\">\n  <title>페이지 제목</title>\n  ______\n</head>\n```",
      "option_a": "`<meta name=\"responsive\" content=\"true\">`",
      "option_b": "`<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">`",
      "option_c": "`<meta name=\"mobile\" content=\"optimized\">`",
      "option_d": "`<meta name=\"screen\" content=\"mobile,desktop\">`",
      "correct_answer": "B",
      "explanation": "반응형 웹사이트를 만들기 위해서는 viewport 메타 태그가 필수입니다. `width=device-width`는 페이지 너비를 기기의 화면 너비에 맞추고, `initial-scale=1.0`은 초기 확대/축소 비율을 1배로 설정합니다. 이 태그가 없으면 모바일 기기에서 데스크톱용 레이아웃이 축소되어 표시되어 사용자 경험이 매우 나빠집니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T09:58:11.000Z"
    },
    {
      "id": 989,
      "subject_id": 8,
      "question": "다음 HTML 문서 구조에서 빈칸에 들어갈 올바른 내용들을 순서대로 나열한 것은?\n\n```html\n______ \n<html ______>\n<head>\n  ______ \n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  ______\n  <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n  <h1>웹사이트</h1>\n  <p>내용</p>\n</body>\n</html>\n```",
      "option_a": "`<!DOCTYPE html>`, `lang=\"ko\"`, `<meta charset=\"UTF-8\">`, `<title>페이지 제목</title>`",
      "option_b": "`<html>`, `charset=\"UTF-8\"`, `<meta lang=\"ko\">`, `<title>제목</title>`",
      "option_c": "`<!DOCTYPE>`, `language=\"korean\"`, `<charset=\"UTF-8\">`, `<title>제목</title>`",
      "option_d": "`<!html>`, `lang=\"korean\"`, `<meta charset=\"ko\">`, `<name>제목</name>`",
      "correct_answer": "A",
      "explanation": "올바른 HTML5 문서 구조는 다음과 같습니다:\n\n• `<!DOCTYPE html>`: HTML5 문서 타입 선언 (첫 번째 줄)\n• `lang=\"ko\"`: HTML 요소의 언어 속성 (SEO와 접근성을 위해 중요)\n• `<meta charset=\"UTF-8\">`: 문자 인코딩 선언 (가능한 한 빨리 선언)\n• `<title>페이지 제목</title>`: 필수 요소로, SEO와 브라우저 탭에 표시\n\n이 순서와 문법을 정확히 지키는 것이 표준적인 HTML 작성법이며, 검색엔진 최적화와 접근성, 브라우저 호환성을 보장합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T10:00:06.000Z"
    },
    {
      "id": 990,
      "subject_id": 8,
      "question": "HTML에서 \"작다\" 기호(<)를 텍스트로 표시하려면 어떻게 써야 하나요?\n```html\n<p>5 ______ 10입니다.</p>\n```",
      "option_a": "`<`",
      "option_b": "`&lt;`",
      "option_c": "`&less;`",
      "option_d": "`&#less;`",
      "correct_answer": "B",
      "explanation": "HTML에서 `<` 기호는 태그의 시작을 의미하는 예약된 문자입니다. 따라서 이 기호를 텍스트로 표시하려면 HTML 엔티티인 `&lt;`를 사용해야 합니다. 직접 <를 사용하면 브라우저가 이것을 HTML 태그로 인식하여 올바르게 표시되지 않을 수 있습니다. `&lt;`에서 'lt'는 'less than'의 줄임말입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:02:11.000Z"
    },
    {
      "id": 991,
      "subject_id": 8,
      "question": "줄바꿈되지 않는 공백(non-breaking space)을 만들 때 사용하는 HTML 엔티티는?\n```html\n<p>§ 10______ 조항</p>\n```",
      "option_a": "`&space;`",
      "option_b": "`&nbsp;`",
      "option_c": "`&nospace;`",
      "option_d": "`&#space;`",
      "correct_answer": "B",
      "explanation": "`&nbsp;`는 non-breaking space를 의미하는 HTML 엔티티입니다. 일반 공백과 달리 이 공백은 줄바꿈 지점이 되지 않아서, 두 단어가 항상 함께 붙어있게 됩니다. 예를 들어 \"§ 10\"에서 숫자와 기호가 서로 다른 줄로 나뉘지 않게 하려면 `&nbsp;`를 사용합니다. 또한 브라우저가 연속된 공백을 하나로 축약하는 것을 방지할 때도 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:03:05.000Z"
    },
    {
      "id": 992,
      "subject_id": 8,
      "question": "다음 HTML 코드에서 빈칸에 들어갈 올바른 엔티티는?\n\n```html\n<p>HTML 태그는 ______tagname______ 형식입니다.</p>\n```\n결과: HTML 태그는 <tagname> 형식입니다.",
      "option_a": "`&lt;`, `&gt;`",
      "option_b": "`&less;`, `&greater;`",
      "option_c": "`&#60;`, `&#62;`",
      "option_d": "1번과 3번 모두 정답",
      "correct_answer": "D",
      "explanation": "HTML에서 `<`와 `>` 기호를 텍스트로 표시하는 방법은 두 가지입니다:\n\n• 엔티티 이름 사용: `&lt;` (less than), `&gt;` (greater than)\n• 엔티티 번호 사용: `&#60;`, `&#62;`\n\n두 방법 모두 동일한 결과를 만들어냅니다. 엔티티 이름은 기억하기 쉽고, 엔티티 번호는 더 짧게 표현할 수 있다는 장점이 있습니다. 실제 개발에서는 엔티티 이름이 더 널리 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:04:50.000Z"
    },
    {
      "id": 993,
      "subject_id": 8,
      "question": "유로화 기호(€)를 표시하는 방법으로 잘못된 것은?\n```html\n<p>가격: 50______ </p>\n```",
      "option_a": "`&euro;`",
      "option_b": "`&#8364;`",
      "option_c": "`&#x20AC;`",
      "option_d": "`&EUR;`",
      "correct_answer": "D",
      "explanation": "유로화 기호(€)를 HTML에서 표시하는 올바른 방법은 세 가지입니다:\n\n• `&euro;` (엔티티 이름)\n• `&#8364;` (10진수 엔티티 번호)\n• `&#x20AC;` (16진수 엔티티 번호, x 접두사 사용)\n\n`&EUR;`은 존재하지 않는 엔티티 이름입니다. HTML 엔티티 이름은 대소문자를 구분하며, 정확한 이름을 사용해야 합니다. 잘못된 엔티티를 사용하면 브라우저에서 그대로 텍스트로 표시됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:05:46.000Z"
    },
    {
      "id": 994,
      "subject_id": 8,
      "question": "다음 HTML 코드의 실행 결과로 올바른 것은?\n```html\n<p>&copy; 2025 &amp; &#8482;</p>\n<p>&quot;Hello&quot; &rarr; &hearts;</p>\n<p>10&nbsp;&nbsp;&nbsp;spaces</p>\n```",
      "option_a": "```html\n© 2025 & ™\n\"Hello\" → ♥\n10   spaces\n```",
      "option_b": "```html\n&copy; 2025 &amp; &#8482;\n&quot;Hello&quot; &rarr; &hearts;\n10   spaces\n```",
      "option_c": "```html\n© 2025 & ™\n\"Hello\" → ♥\n10 spaces\n```",
      "option_d": "```html\n© 2025 &\nHello →\n10spaces\n```",
      "correct_answer": "A",
      "explanation": "각 엔티티의 의미와 실행 결과는 다음과 같습니다:\n\n• `&copy;` = © (저작권 기호)\n• `&amp;` = & (앰퍼샌드)\n• `&#8482;` = ™ (상표 기호)\n• `&quot;` = \" (큰따옴표)\n• `&rarr;` = → (오른쪽 화살표)\n• `&hearts;` = ♥ (하트 기호)\n• `&nbsp;` = 줄바꿈되지 않는 공백\n\n세 번째 줄의 `&nbsp;&nbsp;&nbsp;`는 3개의 줄바꿈되지 않는 공백을 만들어 \"10   spaces\"로 표시됩니다. 일반 공백과 달리 `&nbsp;`는 브라우저가 축약하지 않으므로 모든 공백이 유지됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T10:07:26.000Z"
    },
    {
      "id": 995,
      "subject_id": 8,
      "question": "HTML에서 이모지를 올바르게 표시하기 위해 반드시 필요한 메타 태그는?\n```html\n<head>\n  <title>이모지 페이지</title>\n  ______\n</head>\n```",
      "option_a": "`<meta charset=\"ASCII\">`",
      "option_b": "`<meta charset=\"UTF-8\">`",
      "option_c": "`<meta charset=\"ISO-8859-1\">`",
      "option_d": "`<meta charset=\"EMOJI\">`",
      "correct_answer": "B",
      "explanation": "이모지는 UTF-8 문자 집합에 속하는 문자들입니다. HTML에서 이모지를 올바르게 표시하려면 `<meta charset=\"UTF-8\">`을 선언해야 합니다. UTF-8은 전 세계의 거의 모든 문자와 기호를 포함하는 유니코드 문자 집합입니다. 이 선언이 없으면 브라우저가 이모지를 제대로 인식하지 못할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:10:19.000Z"
    },
    {
      "id": 996,
      "subject_id": 8,
      "question": "이모지의 본질적 특성에 대한 설명으로 올바른 것은?",
      "option_a": "이모지는 이미지 파일이다",
      "option_b": "이모지는 아이콘 파일이다",
      "option_c": "이모지는 UTF-8 문자 집합의 문자이다",
      "option_d": "이모지는 별도의 플러그인이 필요하다",
      "correct_answer": "C",
      "explanation": "이모지는 이미지나 아이콘이 아닌 UTF-8(유니코드) 문자 집합의 문자입니다. 겉보기에는 이미지처럼 보이지만, 실제로는 'A', 'B', 'C'와 같은 일반 문자와 동일한 성격을 가진 문자입니다. 따라서 이모지는 일반 텍스트처럼 복사, 붙여넣기, 크기 조절이 가능하며, 별도의 이미지 파일이나 플러그인 없이도 사용할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:10:51.000Z"
    },
    {
      "id": 997,
      "subject_id": 8,
      "question": "HTML에서 이모지를 엔티티 번호로 표시할 때 사용하는 올바른 형식은?\n```html\n<p>행복한 얼굴: ______</p>\n```",
      "option_a": "`#128512`",
      "option_b": "`&128512;`",
      "option_c": "`&#128512;`",
      "option_d": "`&emoji128512;`",
      "correct_answer": "C",
      "explanation": "HTML에서 이모지를 엔티티 번호로 표시할 때는 `&#번호;` 형식을 사용합니다. `&#`로 시작하고 `;`(세미콜론)으로 끝내야 합니다. 이 형식은 브라우저에게 \"이것은 문자의 유니코드 번호입니다\"라고 알려주는 역할을 합니다. 예를 들어 `&#128512;`는 😀 이모지를 표시합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:11:48.000Z"
    },
    {
      "id": 998,
      "subject_id": 8,
      "question": "다음 코드에서 이모지의 크기를 48px로 만들기 위해 빈칸에 들어갈 CSS 속성은?\n\n```html\n<p style=\"______:48px\">\n  &#128512; &#128516; &#128525;\n</p>\n```",
      "option_a": "emoji-size",
      "option_b": "size",
      "option_c": "font-size",
      "option_d": "icon-size",
      "correct_answer": "C",
      "explanation": "이모지는 텍스트 문자이므로 크기를 조절할 때 `font-size` 속성을 사용합니다. 이미지가 아닌 문자이기 때문에 `width`나 `height` 같은 이미지 속성이 아닌 폰트 관련 속성을 사용해야 합니다. `font-size`를 사용하면 이모지의 크기를 자유롭게 조절할 수 있으며, 다른 텍스트와 함께 일관된 스타일링이 가능합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:12:41.000Z"
    },
    {
      "id": 999,
      "subject_id": 8,
      "question": "다음 HTML 코드의 실행 결과로 올바른 것은?\n\n```html\n<!DOCTYPE html>\n<html>\n<meta charset=\"UTF-8\">\n<body>\n  <p>&#65; &#66; &#67;</p>\n  <p>&#128512; &#128516;</p>\n  <p style=\"font-size:24px\">&#128525; &#128151;</p>\n</body>\n</html>\n```",
      "option_a": "A B C\n😀 😄\n😍 💗 (24px 크기)",
      "option_b": "&#65; &#66; &#67;\n&#128512; &#128516;\n&#128525; &#128151;",
      "option_c": "65 66 67\n128512 128516\n128525 128151",
      "option_d": "A B C\n😀 😄\n😍 💗 (모두 같은 크기)",
      "correct_answer": "A",
      "explanation": "각 엔티티 번호는 다음과 같이 변환됩니다:\n\n• `&#65;` = A, `&#66;` = B, `&#67;` = C (기본 알파벳 문자)\n• `&#128512;` = 😀 (웃는 얼굴), `&#128516;` = 😄 (활짝 웃는 얼굴)\n• `&#128525;` = 😍 (하트 눈), `&#128151;` = 💗 (뛰는 하트)\n\n`<meta charset=\"UTF-8\">`이 선언되어 있어 모든 UTF-8 문자가 올바르게 표시됩니다. 세 번째 줄의 이모지들은 `font-size:24px` 스타일이 적용되어 다른 것들보다 크게 표시됩니다. 이모지는 문자이므로 CSS의 폰트 관련 속성들이 모두 적용됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T10:14:19.000Z"
    },
    {
      "id": 1000,
      "subject_id": 8,
      "question": "HTML5에서 권장되는 문자 인코딩을 올바르게 선언하는 방법은?\n```html\n<head>\n  <title>웹페이지</title>\n  ______\n</head>\n```",
      "option_a": "`<meta charset=\"ASCII\">`",
      "option_b": "`<meta charset=\"UTF-8\">`",
      "option_c": "`<meta charset=\"ISO-8859-1\">`",
      "option_d": "`<meta charset=\"Windows-1252\">`",
      "correct_answer": "B",
      "explanation": "HTML5에서는 UTF-8 문자 인코딩 사용을 강력히 권장합니다. UTF-8은 전 세계의 거의 모든 문자와 기호를 포함할 수 있어 다국어 웹사이트에 이상적입니다. `<meta charset=\"UTF-8\">`로 선언하며, 이는 ASCII보다 훨씬 포괄적이고 현대적인 웹 표준에 부합합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:16:06.000Z"
    },
    {
      "id": 1001,
      "subject_id": 8,
      "question": "URL의 구성 요소 중 웹사이트의 보안 연결을 나타내는 scheme은?\n______://www.example.com/page.html",
      "option_a": "http",
      "option_b": "https",
      "option_c": "ftp",
      "option_d": "file",
      "correct_answer": "B",
      "explanation": "`https`는 Secure HyperText Transfer Protocol의 줄임말로, 암호화된 보안 웹페이지를 나타냅니다. `http`는 일반적인 웹페이지지만 암호화되지 않고, `ftp`는 파일 전송용, `file`은 로컬 파일용입니다. 온라인 쇼핑이나 로그인 페이지 등 보안이 중요한 사이트에서는 반드시 `https`를 사용해야 합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:17:01.000Z"
    },
    {
      "id": 1002,
      "subject_id": 8,
      "question": "URL에서 공백 문자가 인코딩되는 올바른 방법은?\n`https://example.com/search?q=hello world`\n위 URL에서 \"hello world\" 사이의 공백은 어떻게 인코딩되어야 하나요?",
      "option_a": "`hello world` (그대로)",
      "option_b": "`hello+world` 또는 `hello%20world`",
      "option_c": "`hello_world`",
      "option_d": "`hello-world`",
      "correct_answer": "B",
      "explanation": "URL에는 공백이 포함될 수 없으므로 URL 인코딩이 필요합니다. 공백은 일반적으로 `+` 기호나 `%20`으로 인코딩됩니다. 따라서 \"hello world\"는 \"hello+world\" 또는 \"hello%20world\"가 됩니다. `%20`은 공백 문자의 16진수 ASCII 값을 나타냅니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:18:23.000Z"
    },
    {
      "id": 1003,
      "subject_id": 8,
      "question": "XHTML에서 빈 요소(empty element)의 올바른 작성법은?\n\n```html\n줄바꿈: ______\n수평선: ______\n이미지: ______\n```",
      "option_a": "`<br>`, `<hr>`, `<img src=\"pic.jpg\">`",
      "option_b": "`<br />`, `<hr />`, `<img src=\"pic.jpg\" />`",
      "option_c": "`<br></br>`, `<hr></hr>`, `<img src=\"pic.jpg\"></img>`",
      "option_d": "`<BR>`, `<HR>`, `<IMG SRC=\"pic.jpg\">`",
      "correct_answer": "B",
      "explanation": "XHTML에서는 빈 요소도 반드시 닫혀야 하며, 자체 닫는 태그(`/>`)를 사용합니다. 또한 모든 요소명은 소문자로 작성해야 합니다. HTML에서는 `<br>`, `<hr>` 등이 허용되지만, XHTML의 엄격한 XML 규칙에 따라 `<br />`, `<hr />`, `<img src=\"pic.jpg\" />`와 같이 작성해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:20:01.000Z"
    },
    {
      "id": 1004,
      "subject_id": 8,
      "question": "다음 XHTML 코드에서 잘못된 부분들을 모두 찾아 수정한 올바른 코드는?\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>페이지 제목</title>\n</head>\n<body>\n  <P CLASS=\"main\">텍스트</P>\n  <br>\n  <img src=\"image.jpg\" alt=\"이미지\">\n  <input type=\"checkbox\" checked>\n</body>\n</html>\n```",
      "option_a": "DOCTYPE과 html 태그만 수정하면 됨",
      "option_b": "P 태그와 br 태그만 수정하면 됨",
      "option_c": "모든 태그에 수정이 필요함",
      "option_d": "이미 올바른 XHTML 코드임",
      "correct_answer": "C",
      "explanation": "이 코드는 여러 XHTML 규칙을 위반하고 있습니다:\n\n문제점들:\n\n• DOCTYPE이 XHTML 형식이 아님\n• `<html>` 태그에 `xmlns` 속성 누락\n• `<P CLASS=\"main\">`: 요소명과 속성명이 대문자 (소문자여야 함)\n• `<br>`: 빈 요소가 닫히지 않음 (`<br />`이어야 함)\n• `<img>`: 빈 요소가 닫히지 않음 (`<img ... />`이어야 함)\n• `checked`: 속성값이 생략됨 (`checked=\"checked\"`이어야 함)\n\n올바른 XHTML 코드:\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \n\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n  <title>페이지 제목</title>\n</head>\n<body>\n  <p class=\"main\">텍스트</p>\n  <br />\n  <img src=\"image.jpg\" alt=\"이미지\" />\n  <input type=\"checkbox\" checked=\"checked\" />\n</body>\n</html>\n```",
      "difficulty": "hard",
      "created_at": "2025-08-09T10:21:48.000Z"
    },
    {
      "id": 1005,
      "subject_id": 8,
      "question": "HTML 폼에서 사용자 입력을 서버로 전송하기 위해 반드시 필요한 속성은?\n\n```html\n<form action=\"/submit.php\">\n  <input type=\"text\" id=\"username\" ______=\"username\">\n  <input type=\"submit\" value=\"전송\">\n</form>\n```",
      "option_a": "id",
      "option_b": "value",
      "option_c": "name",
      "option_d": "class",
      "correct_answer": "C",
      "explanation": "HTML 폼에서 입력 필드의 데이터가 서버로 전송되려면 반드시 `name` 속성이 있어야 합니다. `name` 속성이 없으면 해당 입력 필드의 값은 전송되지 않습니다. 서버에서는 이 `name` 값을 키로 사용하여 전송된 데이터를 식별합니다. `id`는 접근성과 JavaScript용이고, `value`는 초기값이며, `class`는 스타일링용입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:24:09.000Z"
    },
    {
      "id": 1006,
      "subject_id": 8,
      "question": "라디오 버튼과 체크박스의 차이점으로 올바른 설명은?\n\n```html\n<!-- 라디오 버튼 -->\n<input type=\"radio\" name=\"color\" value=\"red\"> 빨강\n<input type=\"radio\" name=\"color\" value=\"blue\"> 파랑\n\n<!-- 체크박스 -->\n<input type=\"checkbox\" name=\"hobby\" value=\"reading\"> 독서\n<input type=\"checkbox\" name=\"hobby\" value=\"music\"> 음악\n```",
      "option_a": "라디오 버튼은 여러 개 선택 가능, 체크박스는 하나만 선택 가능",
      "option_b": "라디오 버튼은 하나만 선택 가능, 체크박스는 여러 개 선택 가능",
      "option_c": "둘 다 하나만 선택 가능",
      "option_d": "둘 다 여러 개 선택 가능",
      "correct_answer": "B",
      "explanation": "라디오 버튼(`type=\"radio\"`)은 같은 `name` 속성을 가진 그룹에서 하나만 선택할 수 있습니다. 체크박스(`type=\"checkbox\"`)는 0개 이상 여러 개를 선택할 수 있습니다. 라디오 버튼은 \"둘 중 하나\"와 같은 배타적 선택에 사용하고, 체크박스는 \"관심사 여러 개 선택\"과 같은 다중 선택에 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:25:01.000Z"
    },
    {
      "id": 1007,
      "subject_id": 8,
      "question": "폼 데이터 전송 방식에서 GET과 POST의 올바른 설명은?\n\n```html\n<form action=\"/search.php\" method=\"______\">\n  <input type=\"text\" name=\"query\" value=\"HTML 학습\">\n  <input type=\"submit\" value=\"검색\">\n</form>\n```\n위 검색 폼에 적합한 method와 그 이유는?",
      "option_a": "GET - 검색 결과를 북마크할 수 있고, URL에 검색어가 표시됨",
      "option_b": "POST - 보안이 더 좋고, 검색어가 URL에 숨겨짐",
      "option_c": "GET - 데이터 크기 제한이 없어서 긴 검색어도 가능",
      "option_d": "POST - 검색 속도가 더 빠름",
      "correct_answer": "A",
      "explanation": "검색 폼에는 일반적으로 GET 방식을 사용합니다. GET의 장점:\n\n• URL에 검색어가 포함되어 검색 결과를 북마크/공유 가능\n• 민감하지 않은 데이터(검색어)에 적합\n• 브라우저 뒤로가기/앞으로가기 기능이 정상 작동\n\nPOST는 로그인, 회원가입 등 민감한 정보나 큰 데이터를 전송할 때 사용합니다. POST는 URL에 데이터가 노출되지 않지만, 검색 결과를 북마크할 수 없다는 단점이 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:26:09.000Z"
    },
    {
      "id": 1008,
      "subject_id": 8,
      "question": "다음 드롭다운 목록에서 빈칸에 들어갈 올바른 요소는?\n\n```html\n<label for=\"cars\">자동차 선택:</label>\n<______ id=\"cars\" name=\"cars\">\n  <______ value=\"hyundai\">현대</______ >\n  <______ value=\"kia\" selected>기아</______ >\n  <______ value=\"samsung\">삼성</______ >\n</______ >\n```",
      "option_a": "`<dropdown>`, `<item>`",
      "option_b": "`<select>`, `<option>`",
      "option_c": "`<list>`, `<choice>`",
      "option_d": "`<menu>`, `<option>`",
      "correct_answer": "B",
      "explanation": "드롭다운 목록을 만들 때는 `<select>` 요소를 사용하고, 각 선택 항목은 `<option>` 요소로 정의합니다.\n\n• `<select>`: 드롭다운 목록의 컨테이너\n• `<option>`: 선택 가능한 각 항목\n• `selected` 속성: 기본 선택 항목 지정\n• `value` 속성: 서버로 전송될 실제 값\n\n이 예시에서는 \"기아\"가 기본 선택된 상태로 표시되고, 사용자가 다른 옵션을 선택하면 해당 `value` 값이 서버로 전송됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:27:38.000Z"
    },
    {
      "id": 1009,
      "subject_id": 8,
      "question": "다음 폼 코드에서 접근성과 사용성을 높이기 위해 빈칸에 들어가야 할 올바른 속성들은?\n\n```html\n<form action=\"/contact.php\" method=\"post\">\n  <fieldset>\n    <legend>연락처 정보</legend>\n    \n    <label ______=\"email\">이메일:</label>\n    <input type=\"email\" ______=\"email\" name=\"email\" required>\n    \n    <label ______=\"message\">메시지:</label>\n    <textarea ______=\"message\" name=\"message\" rows=\"5\" cols=\"30\"></textarea>\n    \n    <input type=\"submit\" value=\"전송\">\n  </fieldset>\n</form>\n```",
      "option_a": "`for`, `id`, `for`, `id`",
      "option_b": "`id`, `for`, `id`, `for`",
      "option_c": "`name`, `name`, `name`, `name`",
      "option_d": "`target`, `src`, `target`, `src`",
      "correct_answer": "A",
      "explanation": "접근성과 사용성을 위해 `<label>`과 `<input>` 요소를 올바르게 연결해야 합니다:\n\n올바른 연결 방법:\n\n• `<label for=\"email\">`: label의 `for` 속성\n• `<input id=\"email\">`: input의 `id` 속성\n• 같은 값으로 설정하여 서로 연결\n\n장점:\n\n1. 접근성: 스크린 리더가 레이블을 읽어줌\n2. 사용성: 레이블 텍스트를 클릭해도 입력 필드가 포커스됨\n3. 표준 준수: HTML 표준에 맞는 올바른 구조\n\n추가 요소들:\n\n• `<fieldset>`: 관련된 폼 요소들을 그룹화\n• `<legend>`: fieldset의 제목/설명\n• `required`: 필수 입력 필드 지정\n\n이런 구조는 시각 장애인 사용자와 일반 사용자 모두에게 더 나은 경험을 제공합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T10:30:00.000Z"
    },
    {
      "id": 1010,
      "subject_id": 8,
      "question": "HTML에서 사용자가 텍스트를 입력할 수 있는 가장 기본적인 input 타입은 무엇인가요?",
      "option_a": "`<input type=\"string\">`",
      "option_b": "`<input type=\"text\">`",
      "option_c": "`<input type=\"input\">`",
      "option_d": "`<input type=\"field\">`",
      "correct_answer": "B",
      "explanation": "HTML에서 가장 기본적인 텍스트 입력 필드는 `<input type=\"text\">`입니다. 실제로 type 속성을 생략하면 기본값이 \"text\"로 설정됩니다. 이는 한 줄짜리 텍스트 입력을 위해 사용되며, 이름, 주소 등의 일반적인 텍스트 정보를 입력받을 때 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:31:53.000Z"
    },
    {
      "id": 1011,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 input 타입은?\n\n```html\n<form>\n  <label for=\"pwd\">비밀번호:</label>\n  <input type=\"______\" id=\"pwd\" name=\"pwd\">\n</form>\n```",
      "option_a": "text",
      "option_b": "password",
      "option_c": "hidden",
      "option_d": "secure",
      "correct_answer": "B",
      "explanation": "비밀번호 입력 필드는 `type=\"password\"`를 사용합니다. 이 타입을 사용하면 입력되는 문자가 별표(*)나 점(•)으로 마스킹되어 화면에 표시되므로 보안상 안전합니다. 일반적인 text 타입을 사용하면 입력한 비밀번호가 그대로 보여지게 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:32:34.000Z"
    },
    {
      "id": 1013,
      "subject_id": 8,
      "question": "다음 코드에서 빈칸에 들어갈 속성들로 올바른 것은?\n\n```html\n<form>\n  <label for=\"quantity\">수량 (1~10 사이):</label>\n  <input type=\"number\" id=\"quantity\" name=\"quantity\" \n         ____=\"1\" ____=\"10\" ____=\"30\">\n</form>\n```",
      "option_a": "min, max, value",
      "option_b": "minimum, maximum, default",
      "option_c": "start, end, initial",
      "option_d": "from, to, set",
      "correct_answer": "A",
      "explanation": "숫자 입력 필드(`type=\"number\"`)에서 범위를 제한할 때는 `min`과 `max` 속성을 사용합니다. `min=\"1\"`은 최소값을 1로, `max=\"10\"`은 최대값을 10으로 설정합니다. `value=\"30\"`은 기본값을 30으로 설정하는데, 이는 max 값보다 크므로 실제로는 유효하지 않은 값입니다. 이러한 속성들은 number, range, date 관련 input 타입들에서 사용할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:34:42.000Z"
    },
    {
      "id": 1014,
      "subject_id": 8,
      "question": "다음 코드의 실행 결과로 올바른 설명은?\n\n```html\n<form action=\"/submit.php\" method=\"post\">\n  <input type=\"text\" name=\"username\" value=\"john\" readonly>\n  <input type=\"text\" name=\"email\" value=\"test@test.com\" disabled>\n  <input type=\"hidden\" name=\"userId\" value=\"12345\">\n  <input type=\"submit\" value=\"전송\">\n</form>\n```",
      "option_a": "username, email, userId 모두 서버로 전송됨",
      "option_b": "username, userId만 서버로 전송됨 (email은 전송 안됨)",
      "option_c": "userId만 서버로 전송됨",
      "option_d": "username, email만 서버로 전송됨 (userId는 전송 안됨)",
      "correct_answer": "B",
      "explanation": "이 문제는 readonly, disabled, hidden 속성의 차이점을 이해하는 것이 핵심입니다.\n\n• readonly 속성: 사용자가 값을 수정할 수 없지만, 폼 전송 시 값이 서버로 전송됩니다. 따라서 username=\"john\"이 전송됩니다.\n• disabled 속성: 입력 필드가 비활성화되고, 폼 전송 시 값이 서버로 전송되지 않습니다. 따라서 email 값은 전송되지 않습니다.\n• hidden 속성: 사용자에게는 보이지 않지만 값이 서버로 전송됩니다. 따라서 userId=\"12345\"가 전송됩니다.\n\n결과적으로 username과 userId만 서버로 전송되고, disabled된 email은 전송되지 않습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T10:35:51.000Z"
    },
    {
      "id": 1015,
      "subject_id": 8,
      "question": "HTML Canvas 요소의 역할에 대한 설명으로 올바른 것은?",
      "option_a": "Canvas 자체가 그래픽을 그려준다",
      "option_b": "Canvas는 그래픽을 위한 컨테이너일 뿐, 실제 그리기는 JavaScript가 담당한다",
      "option_c": "Canvas는 정적인 이미지만 표시할 수 있다",
      "option_d": "Canvas는 CSS로만 제어할 수 있다",
      "correct_answer": "B",
      "explanation": "HTML `<canvas>` 요소는 그래픽을 그리기 위한 컨테이너(container) 역할만 합니다. Canvas 자체는 빈 직사각형 영역일 뿐이고, 실제로 선, 도형, 텍스트 등을 그리는 작업은 JavaScript를 통해 수행됩니다. Canvas는 동적인 그래픽 생성이 가능하며, JavaScript의 다양한 메서드(moveTo, lineTo, arc 등)를 사용해 복잡한 그래픽도 만들 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:37:32.000Z"
    },
    {
      "id": 1016,
      "subject_id": 8,
      "question": "다음 Canvas 코드에서 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\nvar c = document.getElementById(\"myCanvas\");\nvar ctx = c.getContext(\"2d\");\nctx.beginPath();\nctx.arc(95, 50, 40, 0, 2 * Math.PI);\nctx.______();\n```",
      "option_a": "draw",
      "option_b": "stroke",
      "option_c": "paint",
      "option_d": "render",
      "correct_answer": "B",
      "explanation": "Canvas에서 원을 그리는 과정은 다음과 같습니다:\n\n1. `beginPath()`: 새로운 경로 시작\n2. `arc(x, y, radius, startAngle, endAngle)`: 원의 경로 정의\n3. `stroke()`: 경로를 실제로 그리기 (선으로 표시)\n\n`stroke()` 메서드는 정의된 경로를 선으로 그려주는 역할을 합니다. 만약 원을 채우고 싶다면 `fill()` 메서드를 사용하면 됩니다. 이 예제에서는 원의 테두리만 그리는 것이므로 `stroke()`가 정답입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:38:41.000Z"
    },
    {
      "id": 1017,
      "subject_id": 8,
      "question": "SVG에서 원을 그리는 올바른 코드는?",
      "option_a": "`<circle cx=\"50\" cy=\"50\" radius=\"40\" stroke=\"green\" fill=\"yellow\" />`",
      "option_b": "`<circle x=\"50\" y=\"50\" r=\"40\" stroke=\"green\" fill=\"yellow\" />`",
      "option_c": "`<circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"green\" fill=\"yellow\" />`",
      "option_d": "`<circle centerX=\"50\" centerY=\"50\" r=\"40\" stroke=\"green\" fill=\"yellow\" />`",
      "correct_answer": "C",
      "explanation": "SVG에서 원(`<circle>`) 요소의 올바른 속성들은 다음과 같습니다:\n\n• `cx`: 원의 중심점 x 좌표 (center x)\n• `cy`: 원의 중심점 y 좌표 (center y)\n• `r`: 원의 반지름 (radius)\n• `stroke`: 테두리 색상\n• `fill`: 채우기 색상\n\n1번의 `radius=\"40\"`은 잘못된 속성명이고(올바른 것은 `r=\"40\"`), 2번의 `x`, `y`는 사각형에서 사용하는 속성입니다. 4번의 `centerX`, `centerY`는 존재하지 않는 속성명입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:40:09.000Z"
    },
    {
      "id": 1018,
      "subject_id": 8,
      "question": "다음 중 Canvas와 SVG의 차이점에 대한 설명으로 틀린 것은?",
      "option_a": "Canvas는 픽셀 기반으로 렌더링되고, SVG는 벡터 기반이다",
      "option_b": "SVG는 해상도에 독립적이지만, Canvas는 해상도에 의존적이다",
      "option_c": "Canvas는 이벤트 핸들러를 지원하지만, SVG는 지원하지 않는다",
      "option_d": "SVG는 각 도형이 객체로 기억되지만, Canvas는 그린 후 잊혀진다",
      "correct_answer": "C",
      "explanation": "3번 설명이 틀렸습니다. 실제로는 정반대입니다:\n\n• SVG: 각 요소가 DOM 객체로 존재하므로 이벤트 핸들러 지원 가능 (클릭, 마우스오버 등)\n• Canvas: 픽셀 기반으로 그려진 후 개별 요소에 대한 이벤트 핸들러 지원 불가\n\n나머지 설명들은 모두 올바릅니다:\n\n1. Canvas는 비트맵(픽셀) 기반, SVG는 벡터 기반\n2. SVG는 확대/축소해도 품질 손실 없음, Canvas는 픽셀이 늘어남\n3. SVG는 각 도형을 기억해서 수정 가능, Canvas는 전체를 다시 그려야 함",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:41:04.000Z"
    },
    {
      "id": 1019,
      "subject_id": 8,
      "question": "다음 SVG 코드의 실행 결과를 예측해보세요:\n\n```html\n<svg width=\"300\" height=\"200\">\n  <defs>\n    <linearGradient id=\"grad1\">\n      <stop offset=\"0%\" stop-color=\"red\" />\n      <stop offset=\"100%\" stop-color=\"blue\" />\n    </linearGradient>\n  </defs>\n  <rect x=\"50\" y=\"50\" width=\"100\" height=\"80\" \n        fill=\"url(#grad1)\" stroke=\"black\" stroke-width=\"2\" />\n</svg>\n```",
      "option_a": "빨간색 사각형이 검은 테두리와 함께 표시된다",
      "option_b": "파란색 사각형이 검은 테두리와 함께 표시된다",
      "option_c": "빨간색에서 파란색으로 변하는 그라데이션 사각형이 검은 테두리와 함께 표시된다",
      "option_d": "아무것도 표시되지 않는다",
      "correct_answer": "C",
      "explanation": "이 코드는 SVG의 선형 그라데이션(Linear Gradient) 기능을 사용합니다:\n\n1. `<defs>` 섹션: 재사용 가능한 정의들을 담는 영역\n2. `<linearGradient id=\"grad1\">`: \"grad1\"이라는 ID로 선형 그라데이션 정의\n3. `<stop>` 요소들:\n• `offset=\"0%\"`: 시작점(0%)에서 빨간색\n• `offset=\"100%\"`: 끝점(100%)에서 파란색\n4. `<rect>` 요소:\n• `fill=\"url(#grad1)\"`: 정의된 그라데이션으로 채우기\n• `stroke=\"black\" stroke-width=\"2\"`: 검은색 테두리, 두께 2px\n\n결과적으로 왼쪽은 빨간색, 오른쪽은 파란색이고, 중간은 부드럽게 변하는 그라데이션 효과가 적용된 사각형이 검은 테두리와 함께 표시됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T10:42:50.000Z"
    },
    {
      "id": 1020,
      "subject_id": 8,
      "question": "HTML에서 지원하는 표준 비디오 포맷이 아닌 것은?",
      "option_a": "MP4",
      "option_b": "WebM",
      "option_c": "Ogg",
      "option_d": "AVI",
      "correct_answer": "D",
      "explanation": "HTML 표준에서 공식적으로 지원하는 비디오 포맷은 MP4, WebM, Ogg 세 가지입니다. AVI는 Microsoft에서 개발한 포맷으로 비디오 카메라나 TV 하드웨어에서 많이 사용되지만, 웹 브라우저에서는 지원하지 않습니다. 따라서 웹 개발 시에는 브라우저 호환성을 위해 HTML 표준 포맷을 사용하는 것이 중요합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:45:59.000Z"
    },
    {
      "id": 1021,
      "subject_id": 8,
      "question": "다음 HTML 비디오 코드에서 빈칸에 들어갈 올바른 속성은?\n\n```html\n<video width=\"320\" height=\"240\" ______>\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n  <source src=\"movie.ogg\" type=\"video/ogg\">\n</video>\n```",
      "option_a": "buttons",
      "option_b": "controls",
      "option_c": "player",
      "option_d": "interface",
      "correct_answer": "B",
      "explanation": "`controls` 속성은 비디오 플레이어에 재생, 일시정지, 볼륨 조절 등의 컨트롤 버튼들을 표시해줍니다. 이 속성이 없으면 사용자가 비디오를 제어할 수 있는 방법이 없어집니다. `controls` 속성은 단독으로 사용하는 불린(boolean) 속성이므로 `controls=\"true\"` 같은 값 지정 없이 속성명만 써주면 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:46:51.000Z"
    },
    {
      "id": 1022,
      "subject_id": 8,
      "question": "다음 오디오 코드에서 설명으로 올바른 것은?\n\n```html\n<audio controls autoplay muted>\n  <source src=\"music.mp3\" type=\"audio/mpeg\">\n  <source src=\"music.ogg\" type=\"audio/ogg\">\n  Your browser does not support the audio element.\n</audio>\n```",
      "option_a": "페이지 로드 시 자동으로 소리와 함께 재생된다",
      "option_b": "페이지 로드 시 자동으로 음소거 상태로 재생된다",
      "option_c": "사용자가 재생 버튼을 눌러야만 재생된다",
      "option_d": "오디오가 전혀 재생되지 않는다",
      "correct_answer": "B",
      "explanation": "이 코드에는 세 가지 중요한 속성이 있습니다:\n\n• `controls`: 재생/일시정지, 볼륨 등의 컨트롤 버튼 표시\n• `autoplay`: 페이지 로드 시 자동 재생\n• `muted`: 음소거 상태로 재생\n\n현대 브라우저(특히 Chrome 계열)는 사용자 경험을 위해 음성이 있는 자동재생을 차단합니다. 하지만 `muted` 속성이 있으면 음소거 상태로 자동재생이 허용됩니다. 따라서 페이지가 로드되면 오디오가 자동으로 재생되지만 소리는 들리지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:47:57.000Z"
    },
    {
      "id": 1023,
      "subject_id": 8,
      "question": "YouTube 비디오를 HTML에 삽입할 때 사용하는 요소와 속성의 올바른 조합은?",
      "option_a": "`<video src=\"https://youtube.com/...\"></video>`",
      "option_b": "`<embed src=\"https://youtube.com/...\"></embed>`",
      "option_c": "`<iframe src=\"https://www.youtube.com/embed/...\"></iframe>`",
      "option_d": "`<object data=\"https://youtube.com/...\"></object>`",
      "correct_answer": "C",
      "explanation": "YouTube 비디오를 웹페이지에 삽입하는 표준 방법은 `<iframe>` 요소를 사용하는 것입니다. YouTube는 동영상을 임베드(embed)하기 위한 전용 URL 형식을 제공합니다: `https://www.youtube.com/embed/비디오ID`\n\n올바른 사용 예시:\n```html\n<iframe width=\"420\" height=\"315\" \n        src=\"https://www.youtube.com/embed/tgbNymZ7vqY\">\n</iframe>\n```\n다른 요소들(`<video>`, `<embed>`, `<object>`)은 YouTube 동영상 삽입에 적합하지 않습니다. `<iframe>`을 사용하면 YouTube의 플레이어와 모든 기능을 그대로 사용할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:49:18.000Z"
    },
    {
      "id": 1024,
      "subject_id": 8,
      "question": "다음 `<source>` 요소에 대한 설명 중 올바른 것은?\n\n```html\n<video controls>\n  <source src=\"movie.webm\" type=\"video/webm\">\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n  <source src=\"movie.ogg\" type=\"video/ogg\">\n  Your browser does not support the video tag.\n</source>\n```",
      "option_a": "세 개의 비디오가 동시에 재생된다",
      "option_b": "브라우저가 지원하는 첫 번째 포맷을 선택해서 재생한다",
      "option_c": "가장 화질이 좋은 포맷을 자동으로 선택한다",
      "option_d": "사용자가 원하는 포맷을 선택할 수 있는 메뉴가 표시된다",
      "correct_answer": "B",
      "explanation": "`<source>` 요소는 브라우저 호환성을 위한 대안(fallback) 메커니즘을 제공합니다. 브라우저는 위에서부터 순서대로 각 `<source>`를 확인하여 지원 가능한 첫 번째 포맷을 찾으면 그것을 사용하고 나머지는 무시합니다.\n\n이 예제에서는:\n\n1. WebM을 지원하는 브라우저 → WebM 파일 재생\n2. WebM 미지원, MP4 지원 → MP4 파일 재생\n3. WebM, MP4 모두 미지원, Ogg 지원 → Ogg 파일 재생\n4. 모든 포맷 미지원 → \"Your browser does not support...\" 텍스트 표시\n\n참고: 코드에 오타가 있습니다. 마지막 줄은 `</video>`여야 하는데 `</source>`로 되어 있습니다. `<source>`는 자체 닫힘 태그입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T10:50:34.000Z"
    },
    {
      "id": 1025,
      "subject_id": 8,
      "question": "HTML5 Web Storage에서 localStorage와 sessionStorage의 가장 큰 차이점은 무엇인가요?",
      "option_a": "localStorage는 5MB, sessionStorage는 1MB까지 저장 가능",
      "option_b": "localStorage는 브라우저를 닫아도 데이터 유지, sessionStorage는 탭을 닫으면 데이터 삭제",
      "option_c": "localStorage는 문자열만, sessionStorage는 객체도 저장 가능",
      "option_d": "localStorage는 모든 도메인에서 접근 가능, sessionStorage는 같은 도메인에서만 접근 가능",
      "correct_answer": "B",
      "explanation": "localStorage와 sessionStorage의 핵심적인 차이는 데이터 지속성입니다:\n\n• localStorage: 명시적으로 삭제하지 않는 한 브라우저를 닫아도 데이터가 영구 보존됩니다\n• sessionStorage: 브라우저 탭을 닫으면 데이터가 자동으로 삭제됩니다\n\n둘 다 같은 용량 제한(최소 5MB), 같은 데이터 타입(문자열), 같은 접근 범위(동일 도메인)를 가집니다. 사용자 설정이나 장기간 보관할 데이터는 localStorage를, 임시 세션 데이터는 sessionStorage를 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:54:13.000Z"
    },
    {
      "id": 1026,
      "subject_id": 8,
      "question": "다음 Web Storage 코드에서 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\n// 데이터 저장\nlocalStorage.____(\"username\", \"john\");\n\n// 데이터 가져오기\nconst user = localStorage.____(\"username\");\n\n// 데이터 삭제\nlocalStorage.____(\"username\");\n```",
      "option_a": "save, load, delete",
      "option_b": "setItem, getItem, removeItem",
      "option_c": "put, get, remove",
      "option_d": "store, retrieve, clear",
      "correct_answer": "B",
      "explanation": "Web Storage API의 표준 메서드들은 다음과 같습니다:\n\n• `setItem(key, value)`: 키-값 쌍으로 데이터 저장\n• `getItem(key)`: 키에 해당하는 값을 가져오기\n• `removeItem(key)`: 특정 키의 데이터 삭제\n\n이 메서드들은 localStorage와 sessionStorage 모두에서 동일하게 사용됩니다. 추가로 `clear()` 메서드는 모든 저장된 데이터를 삭제할 때 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:55:15.000Z"
    },
    {
      "id": 1027,
      "subject_id": 8,
      "question": "Web Worker의 주요 목적은 무엇인가요?",
      "option_a": "웹페이지의 보안을 강화하기 위해",
      "option_b": "메인 스레드를 차단하지 않고 백그라운드에서 무거운 작업을 처리하기 위해",
      "option_c": "서버와의 통신 속도를 향상시키기 위해",
      "option_d": "웹페이지의 메모리 사용량을 줄이기 위해",
      "correct_answer": "B",
      "explanation": "Web Worker는 메인 UI 스레드와 별도로 백그라운드에서 JavaScript를 실행하기 위한 기술입니다. 주요 목적은:\n\n• 무거운 계산 작업을 백그라운드에서 처리\n• 메인 스레드 차단 방지로 웹페이지 반응성 유지\n• 사용자가 페이지와 상호작용하는 동안에도 병렬 처리 가능\n\n예를 들어, 대량의 데이터 처리, 복잡한 수학 계산, 이미지 처리 등을 Web Worker에서 수행하면 웹페이지가 멈추지 않고 부드럽게 동작합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T10:56:07.000Z"
    },
    {
      "id": 1028,
      "subject_id": 8,
      "question": "다음 Geolocation API 코드에서 빈칸에 들어갈 올바른 속성들은?\n\n```javascript\nfunction success(position) {\n    const lat = position.coords.______;\n    const lng = position.coords.______;\n    const accuracy = position.coords.______;\n}\n```",
      "option_a": "x, y, precision",
      "option_b": "latitude, longitude, accuracy",
      "option_c": "lat, lng, error",
      "option_d": "xCoord, yCoord, radius",
      "correct_answer": "B",
      "explanation": "Geolocation API의 getCurrentPosition() 성공 콜백에서 받는 position 객체의 좌표 속성들은 다음과 같습니다:\n\n• `position.coords.latitude`: 위도 (북위/남위)\n• `position.coords.longitude`: 경도 (동경/서경)\n• `position.coords.accuracy`: 위치 정확도 (미터 단위)\n\n이 세 속성은 항상 반환되며, 추가로 `altitude`(고도), `speed`(속도), `heading`(방향) 등도 기기가 지원하면 제공됩니다. GPS가 있는 스마트폰에서 가장 정확한 결과를 얻을 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:57:38.000Z"
    },
    {
      "id": 1029,
      "subject_id": 8,
      "question": "Server-Sent Events (SSE)에 대한 설명으로 올바른 것은?",
      "option_a": "클라이언트에서 서버로 실시간 데이터를 전송하는 기술",
      "option_b": "서버에서 클라이언트로 실시간 데이터를 푸시하는 단방향 통신 기술",
      "option_c": "서버와 클라이언트 간 양방향 실시간 통신 기술",
      "option_d": "파일 업로드를 위한 기술",
      "correct_answer": "B",
      "explanation": "Server-Sent Events (SSE)는 서버에서 웹페이지로 실시간 데이터를 푸시하는 단방향 통신 기술입니다:\n\n특징:\n\n• 단방향: 서버 → 클라이언트만 가능\n• 실시간 업데이트: 페이지 새로고침 없이 자동으로 데이터 수신\n• HTTP 기반: 기존 HTTP 프로토콜 사용\n• 자동 재연결: 연결이 끊어지면 자동으로 다시 연결\n\n사용 예시: 주식 가격, 뉴스 피드, 스포츠 경기 결과, SNS 알림 등\n\n양방향 통신이 필요하다면 WebSocket을 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T10:58:32.000Z"
    },
    {
      "id": 1030,
      "subject_id": 8,
      "question": "다음 Drag and Drop API 코드에서 빈칸에 들어갈 올바른 속성과 메서드는?\n\n```javascript\n// 드래그 시작 시\nfunction dragStart(ev) {\n    ev.dataTransfer.____(\"text\", ev.target.id);\n}\n\n// 드롭 영역에서\nfunction allowDrop(ev) {\n    ev.______();\n}\n\n// 드롭 시\nfunction drop(ev) {\n    ev.preventDefault();\n    const data = ev.dataTransfer.____(\"text\");\n}\n```",
      "option_a": "setData, preventDefault, getData",
      "option_b": "saveData, stopDefault, loadData",
      "option_c": "putData, cancelEvent, retrieveData",
      "option_d": "storeData, blockDefault, fetchData",
      "correct_answer": "A",
      "explanation": "Drag and Drop API의 핵심 메서드들입니다:\n\n`setData(type, data)`: 드래그 시작 시 전달할 데이터를 설정\n• 첫 번째 매개변수: 데이터 타입 (\"text\", \"text/html\" 등)\n• 두 번째 매개변수: 실제 전달할 데이터\n\n`preventDefault()`: 브라우저의 기본 동작 차단\n• 드롭 영역에서 필수 (기본적으로 드롭이 금지되어 있음)\n• 드롭 시에도 브라우저가 링크로 열지 않도록 차단\n\n`getData(type)`: 드롭 시 전달받은 데이터를 가져오기\n• `setData()`에서 설정한 같은 타입으로 데이터 추출",
      "difficulty": "medium",
      "created_at": "2025-08-09T11:00:02.000Z"
    },
    {
      "id": 1031,
      "subject_id": 8,
      "question": "다음 Web Worker 코드에서 빈칸에 들어갈 올바른 메서드는?\n\n```javascript\n// 메인 스레드에서\nif (typeof(w) == \"undefined\") {\n    w = new ______(\"worker.js\");\n}\n\nw.______ = function(event) {\n    document.getElementById(\"result\").innerHTML = event.data;\n};\n\n// worker.js 파일에서\nvar i = 0;\nfunction count() {\n    i++;\n    ______(i);\n    setTimeout(count, 500);\n}\n```",
      "option_a": "WebWorker, onreceive, sendMessage",
      "option_b": "Worker, onmessage, postMessage",
      "option_c": "BackgroundScript, ondata, pushMessage",
      "option_d": "JSWorker, onresponse, returnMessage",
      "correct_answer": "B",
      "explanation": "Web Worker의 핵심 통신 메커니즘입니다:\n\n`new Worker(\"파일명\")`: 외부 JavaScript 파일로 워커 생성\n\n`onmessage`: 워커로부터 메시지를 받을 때 실행되는 이벤트 핸들러\n• `event.data`로 워커가 보낸 데이터에 접근\n\n`postMessage(data)`: 워커에서 메인 스레드로 메시지 전송\n• 워커 내부에서 계산 결과나 진행 상황을 메인 스레드로 전달\n\n메인 스레드와 워커는 이 메시지 시스템을 통해서만 통신할 수 있으며, DOM에는 직접 접근할 수 없습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T11:01:39.000Z"
    },
    {
      "id": 1032,
      "subject_id": 8,
      "question": "다음 localStorage 사용 코드의 실행 결과는?\n\n```javascript\n// 초기 상태: localStorage가 비어있음\nif (localStorage.clickCount) {\n    localStorage.clickCount = Number(localStorage.clickCount) + 1;\n} else {\n    localStorage.clickCount = 1;\n}\nconsole.log(typeof localStorage.clickCount);\nconsole.log(localStorage.clickCount);\n```",
      "option_a": "\"number\", 1",
      "option_b": "\"string\", \"1\"",
      "option_c": "\"number\", \"1\"",
      "option_d": "\"string\", 1",
      "correct_answer": "B",
      "explanation": "Web Storage의 중요한 특징을 이해하는 문제입니다:\n\n핵심 포인트: localStorage는 모든 값을 문자열로 저장합니다\n\n코드 실행 과정:\n\n1. `localStorage.clickCount`가 없으므로 (undefined/falsy)\n2. `else` 블록 실행: `localStorage.clickCount = 1`\n3. 숫자 1이 저장되지만 자동으로 문자열 \"1\"로 변환됨\n\n결과:\n• `typeof localStorage.clickCount` → \"string\"\n• `localStorage.clickCount` → \"1\" (문자열)\n\n따라서 숫자 연산을 할 때는 반드시 `Number()`, `parseInt()` 등으로 형변환이 필요합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T11:03:09.000Z"
    },
    {
      "id": 1033,
      "subject_id": 8,
      "question": "다음 Geolocation API 에러 처리 코드에서 빈칸에 들어갈 올바른 에러 코드는?\n\n```javascript\nfunction handleError(error) {\n    switch(error.code) {\n        case error.______:\n            alert(\"사용자가 위치 접근을 거부했습니다.\");\n            break;\n        case error.______:\n            alert(\"위치 정보를 사용할 수 없습니다.\");\n            break;\n        case error.______:\n            alert(\"위치 요청 시간이 초과되었습니다.\");\n            break;\n    }\n}\n```",
      "option_a": "ACCESS_DENIED, NO_LOCATION, TIME_OUT",
      "option_b": "PERMISSION_DENIED, POSITION_UNAVAILABLE, TIMEOUT",
      "option_c": "USER_DENIED, LOCATION_ERROR, EXPIRED",
      "option_d": "DENIED, UNAVAILABLE, OVERTIME",
      "correct_answer": "B",
      "explanation": "Geolocation API의 표준 에러 코드들입니다:\n\n`PERMISSION_DENIED`: 사용자가 위치 정보 접근 권한을 거부\n\n• 브라우저에서 \"위치 접근 허용\" 팝업에서 \"차단\" 선택 시\n\n`POSITION_UNAVAILABLE`: 위치 정보를 얻을 수 없음\n\n• GPS 신호가 약하거나, 네트워크 문제, 하드웨어 오류 등\n\n`TIMEOUT`: 지정된 시간 내에 위치를 얻지 못함\n\n• `getCurrentPosition()`의 세 번째 매개변수로 타임아웃 설정 가능\n\n각 에러에 따라 적절한 사용자 안내 메시지를 표시하여 더 나은 사용자 경험을 제공할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T11:04:31.000Z"
    },
    {
      "id": 1034,
      "subject_id": 8,
      "question": "다음 코드에서 Web Storage 지원 여부를 확인하고 데이터를 안전하게 저장하는 올바른 방법은?\n\n```javascript\nfunction saveUserData(name, value) {\n    // 빈칸을 채워 완성하세요\n    if (typeof(______) !== \"undefined\") {\n        try {\n            localStorage.______(name, value);\n            return true;\n        } catch (e) {\n            console.error(\"Storage failed:\", e);\n            return false;\n        }\n    } else {\n        alert(\"브라우저가 Web Storage를 지원하지 않습니다.\");\n        return false;\n    }\n}\n```",
      "option_a": "WebStorage, save",
      "option_b": "Storage, setItem",
      "option_c": "localStorage, putItem",
      "option_d": "Browser, storeItem",
      "correct_answer": "B",
      "explanation": "안전한 Web Storage 사용을 위한 모범 사례입니다:\n\n`typeof(Storage) !== \"undefined\"`: Web Storage API 지원 확인\n\n• `Storage`는 localStorage와 sessionStorage의 상위 객체\n• 구형 브라우저에서는 undefined일 수 있음\n\n`localStorage.setItem(name, value)`: 표준 저장 메서드\n\n• 키-값 쌍으로 데이터 저장\n\ntry-catch 블록의 필요성:\n\n• 저장 공간 부족: 5MB 제한 초과 시\n• 프라이빗 브라우징 모드: 일부 브라우저에서 저장 차단\n• 브라우저 정책: 특정 상황에서 저장 금지\n\n이러한 에러 처리로 안정적인 웹 애플리케이션을 만들 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T11:05:59.000Z"
    },
    {
      "id": 1035,
      "subject_id": 9,
      "question": "CSS의 주요 목적은 무엇인가요?",
      "option_a": "웹페이지의 동작과 기능을 구현하기 위해",
      "option_b": "웹페이지의 내용과 구조를 정의하기 위해",
      "option_c": "웹페이지의 디자인과 레이아웃을 스타일링하기 위해",
      "option_d": "웹페이지와 서버 간의 통신을 위해",
      "correct_answer": "C",
      "explanation": "CSS(Cascading Style Sheets)는 웹페이지의 디자인, 레이아웃, 그리고 시각적 표현을 담당하는 언어입니다.\n\n각 기술의 역할:\n\n• HTML: 웹페이지의 내용과 구조 정의 (제목, 단락, 목록 등)\n• CSS: 웹페이지의 스타일링 (색상, 폰트, 배치, 크기 등)\n• JavaScript: 웹페이지의 동작과 기능 구현 (상호작용, 애니메이션 등)\n\nCSS가 도입되기 전에는 HTML에 `<font>` 태그나 색상 속성을 직접 넣어야 했는데, 이는 웹사이트 관리를 매우 어렵게 만들었습니다. CSS는 이런 문제를 해결하여 하나의 CSS 파일로 전체 웹사이트의 스타일을 통일성 있게 관리할 수 있게 해줍니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T12:33:17.000Z"
    },
    {
      "id": 1036,
      "subject_id": 9,
      "question": "CSS 규칙의 두 가지 주요 구성 요소는 무엇인가요?",
      "option_a": "태그와 속성",
      "option_b": "선택자와 선언 블록",
      "option_c": "요소와 값",
      "option_d": "클래스와 아이디",
      "correct_answer": "B",
      "explanation": "CSS 규칙(rule)은 두 가지 핵심 요소로 구성됩니다:\n\n1. 선택자(Selector): 스타일을 적용할 HTML 요소를 지정\n\n• 예: `p`, `h1`, `.class`, `#id` 등\n\n2. 선언 블록(Declaration Block): 실제 스타일 규칙들을 포함\n\n• 중괄호 `{}` 안에 작성\n• 하나 이상의 선언(declaration)을 포함\n• 각 선언은 속성(property)과 값(value)으로 구성\n\n기본 구조:\n```css\n선택자 {\n    속성: 값;\n    속성: 값;\n}\n```\n예시:\n```css\np {\n    color: red;\n    font-size: 16px;\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T12:59:43.000Z"
    },
    {
      "id": 1037,
      "subject_id": 9,
      "question": "다음 CSS 코드에서 빈칸에 들어갈 올바른 구문은?\n```css\nh1 {\n    color____ blue;\n    text-align____ center;\n____\n```",
      "option_a": "`=`, `=`, `}`",
      "option_b": "`:`, `:`, `}`",
      "option_c": "`=`, `:`, `;`",
      "option_d": "`:`, `=`, `}`",
      "correct_answer": "B",
      "explanation": "CSS의 기본 문법 구조입니다:\n\n콜론(:): 속성과 값을 구분\n\n• `속성: 값` 형태로 작성\n• 등호(=)가 아닌 콜론을 사용\n\n세미콜론(;): 각 선언의 끝을 표시\n\n• 여러 선언을 구분하는 역할\n• 마지막 선언에서는 생략 가능하지만 습관적으로 붙이는 것이 좋음\n\n중괄호(}): 선언 블록의 끝을 표시\n\n올바른 완성된 코드:\n```css\nh1 {\n    color: blue;\n    text-align: center;\n}\n```\n이는 모든 `<h1>` 요소의 글자색을 파란색으로, 정렬을 중앙으로 설정합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T13:01:45.000Z"
    },
    {
      "id": 1038,
      "subject_id": 9,
      "question": "다음 CSS 코드의 각 부분에 대한 설명으로 올바른 것은?\n```css\np {\n    font-family: verdana;\n    color: red;\n}\n```",
      "option_a": "`p`는 값, `font-family`는 선택자, `verdana`는 속성이다",
      "option_b": "`p`는 선택자, `font-family`는 속성, `verdana`는 값이다",
      "option_c": "`p`는 속성, `font-family`는 값, `red`는 선택자이다",
      "option_d": "`p`는 선언, `color`는 블록, `red`는 규칙이다",
      "correct_answer": "B",
      "explanation": "CSS 문법의 정확한 용어 이해가 중요합니다:\n\n`p`: 선택자(Selector)\n\n• 스타일을 적용할 HTML 요소를 지정\n• 여기서는 모든 `<p>` 태그를 선택\n\n`font-family`, `color`: 속성(Property)\n\n• 변경하고자 하는 스타일의 종류\n• `font-family`: 글꼴 종류를 지정\n• `color`: 글자 색상을 지정\n\n`verdana`, `red`: 값(Value)\n\n• 해당 속성에 적용할 구체적인 값\n• `verdana`: 글꼴명\n• `red`: 색상값\n\n이 코드는 \"모든 단락(`<p>`)의 글꼴을 Verdana로, 글자색을 빨간색으로 설정\"한다는 의미입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T13:08:24.000Z"
    },
    {
      "id": 1039,
      "subject_id": 9,
      "question": "외부 CSS 파일을 사용하는 주요 장점은 무엇인가요?",
      "option_a": "웹페이지 로딩 속도가 빨라진다",
      "option_b": "HTML 코드가 더 복잡해진다",
      "option_c": "하나의 CSS 파일로 여러 웹페이지의 스타일을 동시에 관리할 수 있다",
      "option_d": "웹페이지의 보안이 강화된다",
      "correct_answer": "C",
      "explanation": "외부 CSS 파일 사용의 가장 큰 장점은 효율적인 스타일 관리입니다:\n\n주요 장점들:\n\n1. 통일성: 전체 웹사이트의 일관된 디자인 유지\n2. 유지보수성: 하나의 CSS 파일만 수정하면 모든 페이지에 반영\n3. 분리: HTML(구조)와 CSS(스타일)의 명확한 분리\n4. 재사용성: 동일한 스타일을 여러 페이지에서 공유\n\n실제 예시: 웹사이트에 100개의 페이지가 있다고 가정해봅시다:\n\n• 외부 CSS 사용: 1개의 `.css` 파일만 수정하면 100개 페이지 모두 변경\n• 인라인/내부 CSS: 100개 페이지를 각각 수정해야 함\n\n이는 개발 시간과 비용을 대폭 절약하며, 실수 가능성도 줄여줍니다. 이것이 바로 CSS가 \"웹 개발에서 많은 작업을 절약해준다\"고 하는 이유입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T13:16:25.000Z"
    },
    {
      "id": 1040,
      "subject_id": 9,
      "question": "CSS에서 HTML 요소의 id를 선택할 때 사용하는 기호는 무엇인가요?",
      "option_a": "`.` (마침표)",
      "option_b": "`#` (해시/샵)",
      "option_c": "`*` (별표)",
      "option_d": "`@` (앳)",
      "correct_answer": "B",
      "explanation": "CSS에서 각 선택자는 고유한 기호로 구분됩니다:\n\n1. `#` (해시): id 선택자\n\n• 예: `#header` → `<div id=\"header\">`를 선택\n• 페이지에서 유일한 요소를 선택할 때 사용\n\n2. `.` (마침표): class 선택자\n\n• 예: `.center` → `<p class=\"center\">`를 선택\n\n3. `*` (별표): 전체 선택자\n\n• 페이지의 모든 요소를 선택\n\n중요: id는 HTML 문서에서 유일해야 합니다. 같은 id를 여러 요소에 사용하면 안 되며, 주로 특정한 하나의 요소(헤더, 네비게이션, 푸터 등)를 지정할 때 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T13:20:33.000Z"
    },
    {
      "id": 1041,
      "subject_id": 9,
      "question": "다음 CSS 코드에서 빈칸에 들어갈 올바른 기호는?\n```css\n/* 모든 div 요소를 선택 */\ndiv {\n    background-color: yellow;\n}\n\n/* class가 \"highlight\"인 요소를 선택 */\n____highlight {\n    color: red;\n}\n\n/* id가 \"main\"인 요소를 선택 */\n____main {\n    width: 100%;\n}\n```",
      "option_a": "`.`, `#`",
      "option_b": "`#`, `.`",
      "option_c": "`*`, `.`",
      "option_d": "`.`, `*`",
      "correct_answer": "A",
      "explanation": "각 선택자의 올바른 문법입니다:\n\nClass 선택자: `.클래스명`\n```css\n.highlight {\n    color: red;\n}\n```\n• HTML: `<span class=\"highlight\">강조된 텍스트</span>`\n• 같은 클래스를 여러 요소에 적용 가능\n\nID 선택자: `#아이디명`\n```css\n#main {\n    width: 100%;\n}\n```\n• HTML: `<div id=\"main\">메인 콘텐츠</div>`\n• 페이지에서 유일한 요소에만 사용\n\n기억법:\n• Class = Common (공통) → `.` (작은 점)\n• ID = Individual (개별) → `#` (큰 기호)",
      "difficulty": "easy",
      "created_at": "2025-08-09T13:23:48.000Z"
    },
    {
      "id": 1042,
      "subject_id": 9,
      "question": "다음 HTML과 CSS에서 실제로 스타일이 적용되는 요소는?\n```html\n<p class=\"intro\">첫 번째 단락</p>\n<p class=\"intro highlight\">두 번째 단락</p>\n<div class=\"highlight\">세 번째 요소</div>\n<p>네 번째 단락</p>\n```\n```css\np.intro {\n    font-size: 18px;\n    color: blue;\n}\n```",
      "option_a": "첫 번째와 두 번째 단락",
      "option_b": "첫 번째 단락만",
      "option_c": "두 번째와 세 번째 요소",
      "option_d": "모든 단락",
      "correct_answer": "A",
      "explanation": "`p.intro` 선택자는 특정 요소에 특정 클래스가 적용된 경우를 선택하는 복합 선택자입니다.\n\n분석:\n• `p.intro`: `<p>` 태그이면서 동시에 `class=\"intro\"`를 가진 요소\n\n각 요소 확인:\n1. 첫 번째: `<p class=\"intro\">` → ✅ 조건 만족 (p 태그 + intro 클래스)\n2. 두 번째: `<p class=\"intro highlight\">` → ✅ 조건 만족 (p 태그 + intro 클래스 포함)\n3. 세 번째: `<div class=\"highlight\">` → ❌ div 태그라서 불만족\n4. 네 번째: `<p>` → ❌ intro 클래스가 없어서 불만족\n\n참고: HTML 요소는 여러 클래스를 동시에 가질 수 있습니다. 두 번째 단락처럼 `class=\"intro highlight\"`는 두 클래스를 모두 적용받습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T13:31:49.000Z"
    },
    {
      "id": 1043,
      "subject_id": 9,
      "question": "다음 CSS 코드를 그룹 선택자를 사용해서 간단히 표현하면?\n```css\nh1 {\n    text-align: center;\n    color: red;\n}\nh2 {\n    text-align: center;\n    color: red;\n}\nh3 {\n    text-align: center;\n    color: red;\n}\n```",
      "option_a": "`h1 h2 h3 { text-align: center; color: red; }`",
      "option_b": "`h1, h2, h3 { text-align: center; color: red; }`",
      "option_c": "`h1 + h2 + h3 { text-align: center; color: red; }`",
      "option_d": "`h1 > h2 > h3 { text-align: center; color: red; }`",
      "correct_answer": "B",
      "explanation": "그룹 선택자는 동일한 스타일을 여러 요소에 적용할 때 코드 중복을 줄이는 방법입니다.\n\n올바른 문법: `선택자1, 선택자2, 선택자3`\n• 각 선택자를 **쉼표(,)**로 구분\n• 쉼표는 \"또는(OR)\"의 의미\n\n잘못된 선택지들:\n1. `h1 h2 h3`: 후손 선택자 (h1 안의 h2 안의 h3)\n2. `h1 + h2 + h3`: 인접 형제 선택자\n3. `h1 > h2 > h3`: 자식 선택자\n\n실무 활용:\n```css\n/* 비효율적 */\nh1 { font-family: Arial; }\nh2 { font-family: Arial; }\np { font-family: Arial; }\n\n/* 효율적 */\nh1, h2, p { font-family: Arial; }\n```\n그룹 선택자는 CSS 파일 크기를 줄이고 유지보수를 쉽게 만듭니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T13:33:54.000Z"
    },
    {
      "id": 1044,
      "subject_id": 9,
      "question": "다음 HTML과 CSS 코드에서 \"Hello World!\" 텍스트의 최종 색상은?\n```html\n<div>\n    <p id=\"special\" class=\"text\">Hello World!</p>\n</div>\n```\n```css\n* {\n    color: black;\n}\n\np {\n    color: blue;\n}\n\n.text {\n    color: green;\n}\n\n#special {\n    color: red;\n}\n```",
      "option_a": "black",
      "option_b": "blue",
      "option_c": "green",
      "option_d": "red",
      "correct_answer": "D",
      "explanation": "이 문제는 **CSS 우선순위(CSS Specificity)**를 이해하는 중요한 개념입니다.\n\nCSS 우선순위 규칙 (높은 순서부터):\n1. 인라인 스타일 (`style=\"...\"`)\n2. ID 선택자 (`#special`)\n3. 클래스 선택자 (`.text`)\n4. 요소 선택자 (`p`)\n5. 전체 선택자 (`*`)\n\n각 선택자의 적용:\n• `*` → `color: black` (우선순위: 가장 낮음)\n• `p` → `color: blue` (요소 선택자)\n• `.text` → `color: green` (클래스 선택자)\n• `#special` → `color: red` (ID 선택자, 가장 높은 우선순위)\n\n결과: ID 선택자가 가장 높은 우선순위를 가지므로 텍스트는 **빨간색(red)**으로 표시됩니다.\n\n기억법: \"ID가 가장 특별하고(Specific), 클래스는 공통적이고, 요소는 일반적이다\"",
      "difficulty": "hard",
      "created_at": "2025-08-09T13:36:41.000Z"
    },
    {
      "id": 1045,
      "subject_id": 9,
      "question": "CSS를 HTML에 적용하는 방법은 총 몇 가지인가요?",
      "option_a": "2가지 (외부, 내부)",
      "option_b": "3가지 (외부, 내부, 인라인)",
      "option_c": "4가지 (외부, 내부, 인라인, 임포트)",
      "option_d": "5가지 (외부, 내부, 인라인, 임포트, 링크)",
      "correct_answer": "B",
      "explanation": "CSS를 HTML에 적용하는 방법은 3가지입니다:\n\n1. 외부 CSS (External CSS)\n• 별도의 `.css` 파일을 만들어 `<link>` 태그로 연결\n• 여러 HTML 페이지에서 재사용 가능\n\n2. 내부 CSS (Internal CSS)\n• HTML 문서의 `<head>` 섹션 내 `<style>` 태그 안에 작성\n• 해당 HTML 페이지에서만 적용\n\n3. 인라인 CSS (Inline CSS)\n• HTML 요소의 `style` 속성에 직접 작성\n• 특정 요소 하나에만 적용\n\n각 방법은 서로 다른 장단점과 사용 목적을 가지고 있으며, 실제 개발에서는 주로 외부 CSS를 사용하고 필요에 따라 내부나 인라인 CSS를 보조적으로 활용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T13:42:03.000Z"
    },
    {
      "id": 1046,
      "subject_id": 9,
      "question": "다음 외부 CSS 연결 코드에서 빈칸에 들어갈 올바른 내용은?\n```html\n<head>\n    <______ rel=\"stylesheet\" href=\"style.css\">\n</head>\n```",
      "option_a": "style",
      "option_b": "link",
      "option_c": "css",
      "option_d": "import",
      "correct_answer": "B",
      "explanation": "외부 CSS 파일을 HTML에 연결할 때는 `<link>` 태그를 사용합니다.\n\n완전한 문법:\n```html\n<link rel=\"stylesheet\" href=\"style.css\">\n```\n각 속성의 의미:\n• `rel=\"stylesheet\"`: 연결되는 파일이 스타일시트임을 명시\n• `href=\"style.css\"`: CSS 파일의 경로 지정\n\n중요한 위치:\n• `<link>` 태그는 반드시 `<head>` 섹션 안에 위치해야 함\n• 여러 CSS 파일을 연결할 때는 여러 개의 `<link>` 태그 사용 가능\n\n다른 선택지들:\n• `<style>`: 내부 CSS용 태그\n• `<css>`: 존재하지 않는 태그\n• `<import>`: CSS 내에서 다른 CSS를 가져올 때 사용하는 @import와 혼동",
      "difficulty": "easy",
      "created_at": "2025-08-09T13:44:39.000Z"
    },
    {
      "id": 1047,
      "subject_id": 9,
      "question": "다음 CSS 코드에서 문법 오류가 있는 부분은?\n```css\nbody {\n    background-color: lightblue;\n}\n\nh1 {\n    color: navy;\n    margin-left: 20 px;\n    font-size: 24px;\n}\n```",
      "option_a": "`background-color: lightblue;`",
      "option_b": "`color: navy;`",
      "option_c": "`margin-left: 20 px;`",
      "option_d": "`font-size: 24px;`",
      "correct_answer": "C",
      "explanation": "CSS에서 숫자 값과 단위 사이에는 공백이 있으면 안 됩니다.\n\n오류 분석:\n• `margin-left: 20 px;` ❌ (숫자와 단위 사이에 공백)\n• `margin-left: 20px;` ✅ (올바른 형태)\n\n올바른 CSS 단위 사용법:\n```css\n/* 올바른 예시들 */\nwidth: 100px;     /* 공백 없음 */\nheight: 50%;      /* 공백 없음 */\nfont-size: 1.5em; /* 공백 없음 */\n\n/* 잘못된 예시들 */\nwidth: 100 px;    /* 공백 있음 - 오류! */\nheight: 50 %;     /* 공백 있음 - 오류! */\nfont-size: 1.5 em; /* 공백 있음 - 오류! */\n```\n이는 CSS 파싱 규칙에 의한 것으로, 브라우저가 값을 제대로 인식하지 못해 스타일이 적용되지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T13:46:30.000Z"
    },
    {
      "id": 1048,
      "subject_id": 9,
      "question": "다음 HTML에서 h1 요소의 최종 글자색은?\n```html\n<head>\n    <link rel=\"stylesheet\" href=\"external.css\">\n    <style>\n        h1 { color: green; }\n    </style>\n</head>\n<body>\n    <h1 style=\"color: red;\">제목</h1>\n</body>\n```\n```css\n/* external.css 파일 내용 */\nh1 { color: blue; }\n```",
      "option_a": "blue (외부 CSS)",
      "option_b": "green (내부 CSS)",
      "option_c": "red (인라인 CSS)",
      "option_d": "브라우저 기본색",
      "correct_answer": "C",
      "explanation": "이 문제는 **CSS 우선순위(Cascading Order)**를 이해하는 핵심 개념입니다.\n\nCSS 적용 우선순위 (높은 순서부터):\n1. 인라인 스타일 (`style=\"...\"`) - 최우선\n2. 내부/외부 스타일시트 (`<style>` 태그, `.css` 파일)\n3. 브라우저 기본 스타일 - 최하위\n\n각 스타일 분석:\n• 외부 CSS: `color: blue` (우선순위 낮음)\n• 내부 CSS: `color: green` (우선순위 중간)\n• 인라인 CSS: `color: red` (최우선 적용)\n\n결과: 인라인 스타일이 가장 높은 우선순위를 가지므로 h1의 글자색은 **빨간색(red)**이 됩니다.\n\n실무 팁: 인라인 스타일은 우선순위가 너무 높아서 나중에 수정하기 어려우므로 가급적 피하는 것이 좋습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T13:53:13.000Z"
    },
    {
      "id": 1049,
      "subject_id": 9,
      "question": "다음 두 경우에서 h1 요소의 글자색을 예측해보세요:\n\n경우 A:\n```html\n<head>\n    <link rel=\"stylesheet\" href=\"external.css\">\n    <style>\n        h1 { color: orange; }\n    </style>\n</head>\n```\n경우 B:\n```html\n<head>\n    <style>\n        h1 { color: orange; }\n    </style>\n    <link rel=\"stylesheet\" href=\"external.css\">\n</head>\n```\n```css\n/* external.css */\nh1 { color: navy; }\n```",
      "option_a": "경우 A: orange, 경우 B: orange",
      "option_b": "경우 A: navy, 경우 B: navy",
      "option_c": "경우 A: orange, 경우 B: navy",
      "option_d": "경우 A: navy, 경우 B: orange",
      "correct_answer": "C",
      "explanation": "이 문제는 동일한 우선순위에서의 CSS 적용 순서를 이해하는 고급 개념입니다.\n\n핵심 원리: 내부 CSS와 외부 CSS는 같은 우선순위를 가지므로, 나중에 로드되는 스타일이 이전 스타일을 덮어씁니다.\n\n경우 A 분석:\n```html\n<link rel=\"stylesheet\" href=\"external.css\">  <!-- 1. 먼저 로드: navy -->\n<style>h1 { color: orange; }</style>        <!-- 2. 나중 로드: orange (최종) -->\n```\n→ 결과: orange (내부 CSS가 외부 CSS를 덮어씀)\n\n경우 B 분석:\n```html\n<style>h1 { color: orange; }</style>        <!-- 1. 먼저 로드: orange -->\n<link rel=\"stylesheet\" href=\"external.css\">  <!-- 2. 나중 로드: navy (최종) -->\n```\n→ 결과: navy (외부 CSS가 내부 CSS를 덮어씀)\n\n실무 중요성: 이는 CSS 파일들의 로드 순서가 매우 중요함을 보여줍니다. 프레임워크 CSS → 커스텀 CSS 순서로 로드해야 원하는 스타일을 적용할 수 있습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T13:55:32.000Z"
    },
    {
      "id": 1050,
      "subject_id": 9,
      "question": "CSS에서 주석을 작성할 때 사용하는 올바른 문법은?",
      "option_a": "`// 이것은 주석입니다`",
      "option_b": "`<!-- 이것은 주석입니다 -->`",
      "option_c": "`/* 이것은 주석입니다 */`",
      "option_d": "`# 이것은 주석입니다`",
      "correct_answer": "C",
      "explanation": "CSS에서 주석을 작성할 때는 `/* */` 문법을 사용합니다.\n\n각 선택지 분석:\n1. `//` : JavaScript나 일부 프로그래밍 언어에서 사용하는 한 줄 주석\n2. `<!-- -->` : HTML에서 사용하는 주석 문법\n3. `/* */` : CSS에서 사용하는 올바른 주석 문법 ✅\n4. `#` : Python, Shell 스크립트 등에서 사용하는 주석\n\nCSS 주석의 특징:\n• 브라우저에서 화면에 표시되지 않음\n• 코드 설명이나 메모 용도로 사용\n• 한 줄 또는 여러 줄 모두 가능\n• 코드 중간에도 삽입 가능\n\n예시:\n```css\n/* 이것은 CSS 주석입니다 */\np {\n    color: red; /* 글자색을 빨간색으로 설정 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:08:11.000Z"
    },
    {
      "id": 1051,
      "subject_id": 9,
      "question": "다음 CSS 코드에서 오류를 찾아보세요:\n```css\n.container {\n    width: 300px\n    height: 200px;\n    background-color: blue;\n}\n```",
      "option_a": "width 속성 값이 잘못됨",
      "option_b": "height 속성 이름이 잘못됨",
      "option_c": "width 속성 뒤에 세미콜론이 누락됨",
      "option_d": "background-color 속성 값이 잘못됨",
      "correct_answer": "C",
      "explanation": "CSS에서 가장 흔한 오류 중 하나는 세미콜론(;) 누락입니다.\n\n세미콜론 누락의 영향:\n• 해당 속성이 적용되지 않을 수 있음\n• 다음 속성까지 영향을 받을 수 있음\n• 브라우저가 CSS 규칙을 제대로 파싱하지 못함\n\n예외: 마지막 속성에서는 세미콜론을 생략할 수 있지만, 일관성을 위해 항상 붙이는 것이 좋은 습관입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:14:37.000Z"
    },
    {
      "id": 1052,
      "subject_id": 9,
      "question": "다음 CSS 코드에서 실제로 적용되는 width 값은?\n```css\n.box {\n    width: -100px;\n    height: 50px;\n    width: 200px;\n}\n```",
      "option_a": "-100px",
      "option_b": "50px",
      "option_c": "200px",
      "option_d": "브라우저 기본값",
      "correct_answer": "C",
      "explanation": "이 문제는 유효하지 않은 값과 CSS 속성 덮어쓰기 두 가지 개념을 다룹니다.\n\n코드 분석:\n1. `width: -100px;` → 유효하지 않은 값 (음수 width는 불가능)\n2. `height: 50px;` → 정상 적용\n3. `width: 200px;` → 정상적인 값으로 덮어쓰기\n\nCSS 처리 과정:\n• 첫 번째 width(-100px)는 유효하지 않아 무시됨\n• 두 번째 width(200px)가 유효하므로 적용됨\n• 같은 속성이 여러 번 나올 때는 마지막 유효한 값이 적용\n\n유효하지 않은 값들의 예:\n• `width: -100px;` (음수 너비)\n• `color: 999;` (잘못된 색상 형식)\n• `font-size: -20px;` (음수 글자 크기)\n• `margin: hello;` (숫자가 아닌 값)\n\n결과: width는 200px로 적용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T14:16:41.000Z"
    },
    {
      "id": 1053,
      "subject_id": 9,
      "question": "다음 CSS 코드에서 빈칸에 들어가야 할 올바른 기호는?\n```css\n.header {\n    background-color____ blue;\n    padding____ 20px;\n____\n```",
      "option_a": "`=`, `=`, `;`",
      "option_b": "`:`, `:`, `}`",
      "option_c": "`=`, `:`, `}`",
      "option_d": "`:`, `=`, `;`",
      "correct_answer": "B",
      "explanation": "CSS의 기본 문법 구조를 정확히 이해하는 문제입니다.\n\nCSS 문법 규칙:\n• 속성과 값 구분: 콜론(`:`) 사용\n• 속성 선언 끝: 세미콜론(`;`) 사용\n• 규칙 블록 끝: 중괄호(`}`) 사용\n\n올바른 완성 코드:\n```css\n.header {\n    background-color: blue;\n    padding: 20px;\n}\n```\n각 기호의 역할:\n• 콜론(`:`): \"이 속성에 이 값을 적용하라\"\n• 세미콜론(`;`): \"이 속성 선언이 끝났다\"\n• 중괄호(`{}`): \"이 선택자의 스타일 규칙들\"",
      "difficulty": "medium",
      "created_at": "2025-08-09T14:19:49.000Z"
    },
    {
      "id": 1054,
      "subject_id": 9,
      "question": "CSS에서 색상을 지정하는 방법으로 올바르지 않은 것은?",
      "option_a": "미리 정의된 색상 이름 사용 (예: Tomato, DodgerBlue)",
      "option_b": "RGB 값 사용 (예: rgb(255, 99, 71))",
      "option_c": "HEX 값 사용 (예: `#ff6347`)",
      "option_d": "FONT 값 사용 (예: font(255, 99, 71))",
      "correct_answer": "D",
      "explanation": "CSS에서 색상을 지정할 때는 미리 정의된 색상 이름, RGB, HEX, HSL, RGBA, HSLA 값을 사용할 수 있습니다. FONT는 색상을 지정하는 방법이 아니라 글꼴과 관련된 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:23:34.000Z"
    },
    {
      "id": 1055,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n```html\n<h1 style=\"______:Tomato;\">Hello World</h1>\n```\n위 코드는 제목의 배경색을 토마토 색으로 만들고자 합니다.",
      "option_a": "color",
      "option_b": "background-color",
      "option_c": "border-color",
      "option_d": "text-color",
      "correct_answer": "B",
      "explanation": "`background-color` 속성은 HTML 요소의 배경색을 설정합니다. `color`는 텍스트 색상을, `border-color`는 테두리 색상을 설정하며, `text-color`는 존재하지 않는 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:25:02.000Z"
    },
    {
      "id": 1056,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 올바른 것은?\n```html\n<p style=\"color:______;\">텍스트 색상 변경</p>\n```",
      "option_a": "background-color:DodgerBlue",
      "option_b": "DodgerBlue",
      "option_c": "border:2px solid",
      "option_d": "rgba(255, 99, 71, 1.5)",
      "correct_answer": "B",
      "explanation": "`color` 속성의 값으로는 색상 이름이나 색상 값만 와야 합니다. 1)은 속성:값 형태이므로 부적절하고, 3)은 테두리 설정이며, 4)의 rgba에서 투명도 값은 0~1 사이여야 하는데 1.5는 유효하지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T14:27:05.000Z"
    },
    {
      "id": 1057,
      "subject_id": 9,
      "question": "다음 코드들 중에서 50% 투명한 토마토 색상을 올바르게 구현한 것은?\n```html\n<!-- A -->\n<div style=\"background-color:rgba(255, 99, 71, 0.5);\">Box A</div>\n\n<!-- B -->\n<div style=\"background-color:hsla(9, 100%, 64%, 50%);\">Box B</div>\n\n<!-- C -->\n<div style=\"background-color:rgb(255, 99, 71, 0.5);\">Box C</div>\n\n<!-- D -->\n<div style=\"background-color:hsla(9, 100%, 64%, 0.5);\">Box D</div>\n```",
      "option_a": "A와 B",
      "option_b": "A와 D",
      "option_c": "B와 C",
      "option_d": "C와 D",
      "correct_answer": "B",
      "explanation": "투명도를 표현하려면 RGBA나 HSLA를 사용해야 합니다. 토마토 색상의 50% 투명 버전은 `rgba(255, 99, 71, 0.5)`와 `hsla(9, 100%, 64%, 0.5)`입니다.\n\n• A: 올바름 (RGBA, 투명도 0.5)\n• B: 틀림 (HSLA이지만 투명도가 50%로 표기됨 - 올바른 값은 0.5)\n• C: 틀림 (RGB는 투명도 지원 안 함)\n• D: 올바름 (HSLA, 투명도 0.5)\n\n따라서 A와 D가 정답입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T14:28:27.000Z"
    },
    {
      "id": 1058,
      "subject_id": 9,
      "question": "RGB 색상 모델에서 각 색상 값의 범위는?",
      "option_a": "0부터 100까지",
      "option_b": "0부터 255까지",
      "option_c": "1부터 256까지",
      "option_d": "0부터 1까지",
      "correct_answer": "B",
      "explanation": "RGB 색상 모델에서 RED, GREEN, BLUE 각각의 강도는 0부터 255까지의 값으로 표현됩니다. 0은 해당 색상이 전혀 없음을, 255는 최대 강도를 의미합니다. 예를 들어 `rgb(255, 0, 0)`은 빨간색이 최대이고 녹색과 파란색이 없는 순수한 빨간색입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:30:01.000Z"
    },
    {
      "id": 1059,
      "subject_id": 9,
      "question": "다음 중 순수한 파란색을 나타내는 RGB 값은?",
      "option_a": "rgb(255, 0, 0)",
      "option_b": "rgb(0, 255, 0)",
      "option_c": "rgb(0, 0, 255)",
      "option_d": "rgb(255, 255, 0)",
      "correct_answer": "C",
      "explanation": "순수한 파란색은 파란색(BLUE) 값만 최대(255)로 설정하고 빨간색(RED)과 녹색(GREEN)은 0으로 설정하여 만듭니다.\n\n• rgb(255, 0, 0): 순수한 빨간색\n• rgb(0, 255, 0): 순수한 녹색\n• rgb(0, 0, 255): 순수한 파란색 ✓\n• rgb(255, 255, 0): 노란색 (빨강+녹색)",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:31:07.000Z"
    },
    {
      "id": 1060,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은?\n```css\n/* 회색을 만들기 위한 RGB 값 */\ncolor: rgb(__, __, __);\n```\n회색(gray)을 만들려고 합니다.",
      "option_a": "255, 0, 0",
      "option_b": "100, 150, 200",
      "option_c": "128, 128, 128",
      "option_d": "255, 255, 0",
      "correct_answer": "C",
      "explanation": "회색(gray)은 RED, GREEN, BLUE의 세 값이 모두 같을 때 만들어집니다. 세 값이 같으면 어떤 특정 색상으로 치우치지 않아 무채색인 회색이 됩니다.\n\n• 1번 보기: 빨간색\n• 2번 보기: 각 값이 달라 특정 색조를 가진 색상\n• 3번 보기: 세 값이 모두 128로 같아서 중간 톤의 회색 ✓\n• 4번 보기: 노란색",
      "difficulty": "medium",
      "created_at": "2025-08-09T14:33:36.000Z"
    },
    {
      "id": 1061,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은?\n```css\n/* 50% 투명한 토마토 색상 */\nbackground-color: rgba(255, 99, 71, ____);\n```",
      "option_a": "50",
      "option_b": "50%",
      "option_c": "0.5",
      "option_d": "128",
      "correct_answer": "C",
      "explanation": "RGBA에서 알파(투명도) 값은 0.0부터 1.0 사이의 소수로 표현합니다.\n\n• 0.0: 완전히 투명 (보이지 않음)\n• 1.0: 완전히 불투명 (투명하지 않음)\n• 0.5: 50% 투명\n\n자료에서 `rgba(255, 99, 71, 0.5)`가 50% 투명한 토마토 색상의 예시로 제시되어 있습니다. 퍼센트나 255 단위 값이 아닌 0~1 사이의 소수를 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T14:35:16.000Z"
    },
    {
      "id": 1062,
      "subject_id": 9,
      "question": "다음 중 가장 밝은 회색을 나타내는 RGB 값은?",
      "option_a": "rgb(60, 60, 60)",
      "option_b": "rgb(120, 120, 120)",
      "option_c": "rgb(180, 180, 180)",
      "option_d": "rgb(240, 240, 240)",
      "correct_answer": "D",
      "explanation": "회색의 밝기는 RGB 값의 크기로 결정됩니다. 세 값이 모두 같을 때 회색이 되며, 값이 클수록 더 밝은 회색이 됩니다.\n\n회색의 밝기 순서:\n• `rgb(0, 0, 0)`: 검은색 (가장 어두움)\n• `rgb(60, 60, 60)`: 매우 어두운 회색\n• `rgb(120, 120, 120)`: 중간 정도 어두운 회색\n• `rgb(180, 180, 180)`: 중간 정도 밝은 회색\n• `rgb(240, 240, 240)`: 매우 밝은 회색 ✓\n• `rgb(255, 255, 255)`: 흰색 (가장 밝음)",
      "difficulty": "hard",
      "created_at": "2025-08-09T14:36:50.000Z"
    },
    {
      "id": 1063,
      "subject_id": 9,
      "question": "HEX 색상 값의 올바른 형식은?",
      "option_a": "#RRGGBB",
      "option_b": "@RRGGBB",
      "option_c": "%RRGGBB",
      "option_d": "&RRGGBB",
      "correct_answer": "A",
      "explanation": "HEX 색상 값은 항상 #(해시) 기호로 시작하고, 그 뒤에 6자리 16진수가 옵니다. RR은 빨간색, GG는 녹색, BB는 파란색 강도를 나타냅니다. 예를 들어 `#ff6347`에서 ff는 빨간색, 63은 녹색, 47은 파란색 값입니다. @, %, & 기호는 HEX 색상에서 사용하지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:38:41.000Z"
    },
    {
      "id": 1064,
      "subject_id": 9,
      "question": "다음 중 순수한 빨간색을 나타내는 HEX 값은?",
      "option_a": "#00ff00",
      "option_b": "#0000ff",
      "option_c": "#ff0000",
      "option_d": "#ffffff",
      "correct_answer": "C",
      "explanation": "HEX 색상에서 각 색상의 강도는 00(최소)부터 ff(최대)까지 표현됩니다.\n\n• #ff0000: 빨간색 최대(ff), 녹색 없음(00), 파란색 없음(00) = 순수한 빨간색 ✓\n• #00ff00: 순수한 녹색\n• #0000ff: 순수한 파란색\n• #ffffff: 흰색 (모든 색상 최대)\n\nff는 16진수로 255(10진수)와 같으며, 해당 색상의 최대 강도를 의미합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:39:47.000Z"
    },
    {
      "id": 1065,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 회색을 만들려면?\n```css\nh1 {\n    color: #______;\n}\n```",
      "option_a": "ff0000",
      "option_b": "808080",
      "option_c": "00ff00",
      "option_d": "ff00ff",
      "correct_answer": "B",
      "explanation": "회색을 만들려면 빨간색, 녹색, 파란색의 값이 모두 같아야 합니다. 세 색상이 동일한 강도로 섞이면 무채색인 회색이 됩니다.\n\n• #808080: 80(빨강) = 80(녹색) = 80(파랑) = 중간 톤 회색 ✓\n• #ff0000: 빨간색\n• #00ff00: 녹색\n• #ff00ff: 자홍색 (빨강+파랑)\n\n다른 회색 예시: `#000000`(검은색), `#ffffff`(흰색), `#b4b4b4`(밝은 회색) 등",
      "difficulty": "medium",
      "created_at": "2025-08-09T14:41:30.000Z"
    },
    {
      "id": 1066,
      "subject_id": 9,
      "question": "다음 3자리 HEX 값을 6자리로 올바르게 확장한 것은?\n```css\ncolor: #f0c;\n```",
      "option_a": "`#ff00cc`",
      "option_b": "`#f0c000`",
      "option_c": "`#0f0c00`",
      "option_d": "`#f0cf0c`",
      "correct_answer": "A",
      "explanation": "3자리 HEX 값은 특별한 단축 표기법입니다. 각 자리수를 두 번 반복해서 6자리로 확장합니다.\n\n변환 규칙:\n• `#f0c` → `#ff00cc`\n• f → ff (빨간색 최대)\n• 0 → 00 (녹색 없음)\n• c → cc (파란색 중간 강도)\n\n이 단축 표기법은 각 색상 성분의 두 자리가 같을 때만 사용할 수 있습니다. 예를 들어 `#ff00cc`는 `#f0c`로 줄일 수 있지만, `#ff63cc`는 63 때문에 줄일 수 없습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T14:43:12.000Z"
    },
    {
      "id": 1067,
      "subject_id": 9,
      "question": "HSL에서 각 요소가 나타내는 의미로 올바른 것은?",
      "option_a": "H(Height), S(Size), L(Length)",
      "option_b": "H(Hue), S(Saturation), L(Lightness)",
      "option_c": "H(Horizontal), S(Scale), L(Level)",
      "option_d": "H(Hex), S(Style), L(Layout)",
      "correct_answer": "B",
      "explanation": "HSL은 색상을 표현하는 방식으로 각각 다음을 의미합니다:\n\n• H(Hue): 색상환에서의 색조 (0-360도)\n• S(Saturation): 채도, 색상의 순수성 (0%-100%)\n• L(Lightness): 명도, 밝기 정도 (0%-100%)\n\n이는 RGB나 HEX와는 다른 방식으로 색상을 표현하며, 사람이 색상을 인식하는 방식과 더 유사합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:46:09.000Z"
    },
    {
      "id": 1068,
      "subject_id": 9,
      "question": "다음 중 순수한 빨간색을 나타내는 HSL 값은?",
      "option_a": "hsl(0, 100%, 50%)",
      "option_b": "hsl(120, 100%, 50%)",
      "option_c": "hsl(240, 100%, 50%)",
      "option_d": "hsl(360, 100%, 50%)",
      "correct_answer": "A",
      "explanation": "색상환(Color Wheel)에서 각 색상은 특정 각도로 정의됩니다:\n• 0도: 빨간색 ✓\n• 120도: 녹색\n• 240도: 파란색\n• 360도: 다시 빨간색 (0도와 같음)\n\n`hsl(0, 100%, 50%)`에서:\n• 0: 빨간색 색조\n• 100%: 완전한 채도 (회색 섞임 없음)\n• 50%: 중간 밝기 (너무 어둡지도 밝지도 않음)",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:47:21.000Z"
    },
    {
      "id": 1069,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 회색을 만들려면?\n```css\n.gray-box {\n    background-color: hsl(0, ___%, 50%);\n}\n```",
      "option_a": "100",
      "option_b": "50",
      "option_c": "25",
      "option_d": "0",
      "correct_answer": "D",
      "explanation": "HSL에서 회색을 만들려면 **채도(Saturation)를 0%**로 설정해야 합니다.\n\n채도의 의미:\n• 100%: 순수한 색상 (회색 섞임 없음)\n• 50%: 50% 회색이 섞인 색상\n• 25%: 75% 회색이 섞인 색상\n• 0%: 완전한 회색 (색상을 더 이상 볼 수 없음) ✓\n\n채도가 0%일 때는 색상환에서의 위치(Hue)가 무엇이든 상관없이 회색이 됩니다. 명도(Lightness) 값에 따라 어두운 회색부터 밝은 회색까지 조절할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T14:48:46.000Z"
    },
    {
      "id": 1070,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은?\n```css\n/* 50% 투명한 파란색 */\n.transparent-blue {\n    color: hsla(240, 100%, 50%, ____);\n}\n```",
      "option_a": "50",
      "option_b": "50%",
      "option_c": "0.5",
      "option_d": "128",
      "correct_answer": "C",
      "explanation": "HSLA에서 알파(투명도) 값은 0.0부터 1.0 사이의 소수로 표현합니다.\n\n알파 값의 의미:\n• 0.0: 완전히 투명 (보이지 않음)\n• 0.5: 50% 투명 ✓\n• 1.0: 완전히 불투명\n\nRGB의 RGBA와 마찬가지로 퍼센트(%)나 255 단위가 아닌 0-1 사이의 소수를 사용합니다. `hsla(240, 100%, 50%, 0.5)`는 50% 투명한 순수한 파란색을 만듭니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T14:50:02.000Z"
    },
    {
      "id": 1071,
      "subject_id": 9,
      "question": "다음 HSL 값들을 밝기 순으로 올바르게 나열한 것은?\n```css\nA: hsl(0, 100%, 25%)\nB: hsl(0, 100%, 75%) \nC: hsl(0, 100%, 0%)\nD: hsl(0, 100%, 100%)\n```",
      "option_a": "C → A → B → D (어두운 순)",
      "option_b": "D → B → A → C (밝은 순)",
      "option_c": "A → B → C → D",
      "option_d": "C → B → A → D",
      "correct_answer": "B",
      "explanation": "HSL에서 밝기는 Lightness 값으로 결정됩니다. Hue와 Saturation이 같다면 Lightness만으로 밝기를 비교할 수 있습니다.\n\n각 값의 의미:\n• C: hsl(0, 100%, 0%) - 0% 밝기 = 검은색 (가장 어두움)\n• A: hsl(0, 100%, 25%) - 25% 밝기 = 어두운 빨간색\n• B: hsl(0, 100%, 75%) - 75% 밝기 = 밝은 빨간색\n• D: hsl(0, 100%, 100%) - 100% 밝기 = 흰색 (가장 밝음)\n\n밝기 순서 (밝은 순): D(100%) → B(75%) → A(25%) → C(0%)\n\nLightness 0%는 어떤 색상이든 검은색이 되고, 100%는 흰색이 됩니다. 50%일 때 해당 색상의 표준적인 밝기가 됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T14:51:15.000Z"
    },
    {
      "id": 1072,
      "subject_id": 9,
      "question": "HTML 요소의 배경색을 설정하는 CSS 속성은?",
      "option_a": "color",
      "option_b": "background-color",
      "option_c": "bg-color",
      "option_d": "background",
      "correct_answer": "B",
      "explanation": "`background-color` 속성은 HTML 요소의 배경색을 설정하는 전용 속성입니다.\n\n• color: 텍스트 색상을 설정\n• background-color: 배경색을 설정 ✓\n• bg-color: 존재하지 않는 속성\n• background: 배경 관련 여러 속성을 한 번에 설정하는 단축 속성\n\n`background-color`에는 색상 이름(red), HEX 값(`#ff0000`), RGB 값(rgb(255,0,0)) 등을 사용할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:53:42.000Z"
    },
    {
      "id": 1073,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n```css\nbody {\n    ______: lightblue;\n}\n```\n웹페이지 전체의 배경색을 연한 파란색으로 만들고자 합니다.",
      "option_a": "color",
      "option_b": "background-color",
      "option_c": "text-color",
      "option_d": "page-color",
      "correct_answer": "B",
      "explanation": "`body` 요소는 웹페이지 전체를 나타내므로, body의 배경색을 설정하면 페이지 전체의 배경색이 변경됩니다.\n```css\nbody {\n    background-color: lightblue;\n}\n```\n• color: 텍스트 색상 변경\n• background-color: 배경색 변경 ✓\n• text-color, page-color: 존재하지 않는 속성\n\n이 코드는 웹페이지 전체를 연한 파란색 배경으로 만듭니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T14:55:18.000Z"
    },
    {
      "id": 1074,
      "subject_id": 9,
      "question": "opacity 속성의 값과 투명도에 대한 설명으로 올바른 것은?",
      "option_a": "0.0 = 완전 불투명, 1.0 = 완전 투명",
      "option_b": "0.0 = 완전 투명, 1.0 = 완전 불투명",
      "option_c": "0 = 50% 투명, 1 = 100% 투명",
      "option_d": "값의 범위는 0부터 255까지",
      "correct_answer": "B",
      "explanation": "`opacity` 속성은 요소의 투명도를 제어하며, 0.0부터 1.0 사이의 값을 사용합니다.\n\nopacity 값의 의미:\n• 0.0: 완전히 투명 (보이지 않음) ✓\n• 0.3: 70% 투명 (30%만 보임)\n• 0.6: 40% 투명 (60%만 보임)\n• 1.0: 완전히 불투명 (100% 보임) ✓\n\n값이 낮을수록 더 투명해집니다. 예를 들어 `opacity: 0.3;`은 요소를 30%만 보이게 만듭니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T14:56:17.000Z"
    },
    {
      "id": 1075,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은?\n```css\ndiv {\n    background: rgba(0, 128, 0, ____);\n}\n```\n녹색 배경에 30% 투명도를 적용하고자 합니다.",
      "option_a": "30",
      "option_b": "30%",
      "option_c": "0.3",
      "option_d": "0.7",
      "correct_answer": "C",
      "explanation": "RGBA에서 알파(투명도) 값은 0.0부터 1.0 사이의 소수로 표현합니다.\n\nRGBA의 구조:\n• `rgba(red, green, blue, alpha)`\n• 처음 세 값: RGB 색상 (0-255)\n• 마지막 값: 투명도 (0.0-1.0)\n\n30% 투명도의 의미:\n• 30% 투명 = 70% 불투명\n• 알파 값: 0.7 (불투명도)이 아닌 0.3 (투명도) ✓\n\n`rgba(0, 128, 0, 0.3)`은 30% 투명한 녹색 배경을 만듭니다. 퍼센트나 255 단위가 아닌 0-1 사이의 소수를 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T14:57:40.000Z"
    },
    {
      "id": 1076,
      "subject_id": 9,
      "question": "다음 두 방법 중 차이점에 대한 설명으로 올바른 것은?\n```css\n/* 방법 A */\n.box {\n    background-color: green;\n    opacity: 0.5;\n}\n\n/* 방법 B */\n.box {\n    background-color: rgba(0, 128, 0, 0.5);\n}\n```",
      "option_a": "두 방법은 완전히 동일한 결과를 만든다",
      "option_b": "방법 A는 자식 요소도 투명해지지만, 방법 B는 배경만 투명해진다",
      "option_c": "방법 B는 자식 요소도 투명해지지만, 방법 A는 배경만 투명해진다",
      "option_d": "방법 A는 배경만 영향을 주고, 방법 B는 전체 요소에 영향을 준다",
      "correct_answer": "B",
      "explanation": "이 두 방법은 시각적으로 비슷해 보이지만 자식 요소에 미치는 영향이 다릅니다.\n\n방법 A: opacity 속성\n```css\nopacity: 0.5;\n```\n• 요소 전체가 50% 투명해짐\n• 자식 요소들도 모두 같은 투명도를 상속\n• 텍스트, 이미지 등 모든 내용이 투명해짐\n• 결과: 내부 텍스트를 읽기 어려울 수 있음\n\n방법 B: RGBA\n```css\nbackground-color: rgba(0, 128, 0, 0.5);\n```\n• 배경색만 50% 투명해짐\n• 자식 요소들은 영향받지 않음\n• 텍스트는 여전히 선명하게 보임\n• 결과: 가독성이 좋음 ✓\n\n실무 권장사항: 배경만 투명하게 하고 싶다면 RGBA를 사용하고, 요소 전체를 투명하게 하고 싶다면 opacity를 사용합니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T14:59:32.000Z"
    },
    {
      "id": 1077,
      "subject_id": 9,
      "question": "HTML 요소에 배경 이미지를 설정하는 CSS 속성은?",
      "option_a": "image",
      "option_b": "background-image",
      "option_c": "bg-image",
      "option_d": "background-picture",
      "correct_answer": "B",
      "explanation": "`background-image` 속성은 HTML 요소의 배경에 이미지를 설정하는 전용 CSS 속성입니다.\n\n• image: 존재하지 않는 CSS 속성\n• background-image: 배경 이미지를 설정하는 올바른 속성 ✓\n• bg-image: 존재하지 않는 속성\n• background-picture: 존재하지 않는 속성\n\n이 속성을 사용하면 요소의 배경에 다양한 형태의 이미지(JPG, PNG, GIF 등)를 설정할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T15:02:01.000Z"
    },
    {
      "id": 1078,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 함수는?\n```css\nbody {\n    background-image: ____(\"paper.gif\");\n}\n```",
      "option_a": "img",
      "option_b": "url",
      "option_c": "src",
      "option_d": "link",
      "correct_answer": "B",
      "explanation": "CSS에서 이미지 파일의 경로를 지정할 때는 url() 함수를 사용합니다.\n\n올바른 문법:\n```css\nbackground-image: url(\"파일경로\");\n```\n• url(): CSS에서 파일 경로를 지정하는 전용 함수 ✓\n• img: HTML 태그 이름\n• src: HTML 속성 이름\n• link: HTML 태그나 CSS 연결과 관련된 용어\n\nurl() 함수 안에는 따옴표(\"\") 또는 작은따옴표('')로 파일 경로를 감싸서 작성합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T15:03:18.000Z"
    },
    {
      "id": 1079,
      "subject_id": 9,
      "question": "배경 이미지의 기본 동작에 대한 설명으로 올바른 것은?",
      "option_a": "이미지가 한 번만 표시되고 끝난다",
      "option_b": "이미지가 요소 크기에 맞게 늘어난다",
      "option_c": "이미지가 반복되어 전체 요소를 덮는다",
      "option_d": "이미지가 중앙에만 표시된다",
      "correct_answer": "C",
      "explanation": "background-image의 기본 동작은 이미지를 반복(repeat)해서 요소 전체를 덮는 것입니다.\n\n기본 동작의 특징:\n• 이미지가 요소보다 작으면 → 가로, 세로로 반복해서 표시\n• 이미지가 요소보다 크면 → 일부분만 보임\n• 별도 설정 없이는 자동으로 반복됨 ✓\n\n예시:\n```css\ndiv {\n    width: 300px;\n    height: 200px;\n    background-image: url(\"small-pattern.gif\");\n    /* 작은 이미지가 반복되어 300x200 영역을 채움 */\n}\n```\n이 기본 동작을 변경하려면 `background-repeat` 속성을 사용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T15:04:47.000Z"
    },
    {
      "id": 1080,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 요소 선택자는?\n```css\n____ {\n    background-image: url(\"paper.gif\");\n}\n```\n웹페이지 전체에 배경 이미지를 적용하고자 합니다.",
      "option_a": "html",
      "option_b": "body",
      "option_c": "page",
      "option_d": "background",
      "correct_answer": "B",
      "explanation": "웹페이지 전체에 배경 이미지를 적용하려면 body 요소를 선택해야 합니다.\n\nHTML 구조와 배경:\n• html: 문서의 최상위 요소이지만 실제 콘텐츠 영역은 아님\n• body: 실제 웹페이지의 콘텐츠 영역, 사용자가 보는 전체 페이지 ✓\n• page: 존재하지 않는 HTML 요소\n• background: CSS 속성 이름",
      "difficulty": "medium",
      "created_at": "2025-08-09T15:06:04.000Z"
    },
    {
      "id": 1081,
      "subject_id": 9,
      "question": "배경 이미지의 기본 반복 동작은?",
      "option_a": "가로로만 반복",
      "option_b": "세로로만 반복",
      "option_c": "가로와 세로 모두 반복",
      "option_d": "반복하지 않음",
      "correct_answer": "C",
      "explanation": "`background-image`를 설정하면 기본적으로 가로와 세로 모두 반복됩니다. 이는 이미지가 요소 전체를 덮을 때까지 가로세로로 타일처럼 반복되는 것을 의미합니다.\n\n기본 동작:\n```css\nbackground-image: url(\"pattern.png\");\n/* 별도 설정 없으면 가로세로 모두 반복 */\n```\n이 기본 동작을 변경하려면 `background-repeat` 속성을 사용해서 원하는 방향으로만 반복하거나 아예 반복하지 않도록 설정할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T15:10:19.000Z"
    },
    {
      "id": 1082,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 가로로만 반복하게 하려면?\n```css\nbody {\n    background-image: url(\"gradient_bg.png\");\n    background-repeat: ______;\n}\n```",
      "option_a": "repeat-x",
      "option_b": "repeat-y",
      "option_c": "no-repeat",
      "option_d": "repeat-horizontal",
      "correct_answer": "A",
      "explanation": "`background-repeat` 속성의 값들은 각각 다른 반복 패턴을 만듭니다.\n\n주요 repeat 값들:\n• repeat-x: 가로(horizontal)로만 반복 ✓\n• repeat-y: 세로(vertical)로만 반복\n• no-repeat: 반복하지 않음 (한 번만 표시)\n• repeat: 가로세로 모두 반복 (기본값)\n\nrepeat-x 사용 예시:\n그라데이션 이미지처럼 가로로 늘어나야 하는 이미지에 주로 사용합니다. 세로로 반복하면 부자연스러워 보이는 이미지들에 적합합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T15:11:30.000Z"
    },
    {
      "id": 1083,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 이미지를 한 번만 표시하려면?\n```css\n.header {\n    background-image: url(\"logo.png\");\n    background-repeat: ______;\n}\n```",
      "option_a": "once",
      "option_b": "single",
      "option_c": "no-repeat",
      "option_d": "stop",
      "correct_answer": "C",
      "explanation": "배경 이미지를 반복하지 않고 한 번만 표시하려면 `no-repeat` 값을 사용합니다.\n\nno-repeat의 특징:\n• 이미지가 한 번만 표시됨\n• 보통 로고나 아이콘처럼 반복되면 안 되는 이미지에 사용\n• 기본적으로 요소의 왼쪽 상단에 위치\n\n사용 예시:\n```css\n.logo-area {\n    background-image: url(\"company-logo.png\");\n    background-repeat: no-repeat;\n    /* 로고는 한 번만 나타나야 함 */\n}\n```\n로고, 특정 아이콘, 장식용 이미지 등에 주로 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T15:13:06.000Z"
    },
    {
      "id": 1084,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성명은?\n```css\n.banner {\n    background-image: url(\"tree.png\");\n    background-repeat: no-repeat;\n    ______: right top;\n}\n```\n배경 이미지를 오른쪽 상단에 위치시키고자 합니다.",
      "option_a": "background-location",
      "option_b": "background-position",
      "option_c": "background-place",
      "option_d": "image-position",
      "correct_answer": "B",
      "explanation": "배경 이미지의 위치를 지정하는 CSS 속성은 `background-position`입니다.\n\nbackground-position의 기본 사용법:\n```css\nbackground-position: 가로위치 세로위치;\n```\n주요 위치 값들:\n• 가로: left, center, right\n• 세로: top, center, bottom\n• 조합 예시:\n`right top`: 오른쪽 상단 ✓\n`center center`: 정중앙\n`left bottom`: 왼쪽 하단\n\n이 속성은 특히 `background-repeat: no-repeat`과 함께 사용해서 이미지를 원하는 위치에 정확히 배치할 때 유용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T15:14:49.000Z"
    },
    {
      "id": 1085,
      "subject_id": 9,
      "question": "다음 상황에서 가장 적절한 CSS 코드는?\n상황: 헤더 영역에 회사 로고를 배경 이미지로 넣되, 오른쪽 상단 모서리에 한 번만 표시하고 싶습니다.",
      "option_a": "```css\n.header {\n    background-image: url(\"logo.png\");\n}\n```",
      "option_b": "```css\n.header {\n    background-image: url(\"logo.png\");\n    background-repeat: repeat-x;\n}\n```",
      "option_c": "```css\n.header {\n    background-image: url(\"logo.png\");\n    background-repeat: no-repeat;\n}\n```",
      "option_d": "```css\n.header {\n    background-image: url(\"logo.png\");\n    background-repeat: no-repeat;\n    background-position: right top;\n}\n```",
      "correct_answer": "D",
      "explanation": "요구사항을 모두 만족하려면 세 가지 속성을 조합해야 합니다.\n\n요구사항 분석:\n1. 로고를 배경 이미지로 → `background-image: url(\"logo.png\")`\n2. 한 번만 표시 → `background-repeat: no-repeat`\n3. 오른쪽 상단에 위치 → `background-position: right top`\n\n각 선택지 분석:\n1) 기본 설정만 있어서 이미지가 반복되고 왼쪽 상단에 위치\n2) 가로로 반복되어 로고가 여러 개 나타남\n3) 한 번만 표시되지만 기본 위치(왼쪽 상단)에 있음\n4) 모든 요구사항을 만족 ✓\n\n실무 활용:\n```css\n.header {\n    height: 80px;\n    background-image: url(\"company-logo.png\");\n    background-repeat: no-repeat;\n    background-position: right top;\n    /* 로고가 헤더 오른쪽 상단에 깔끔하게 배치됨 */\n}\n```\n이런 패턴은 웹사이트 헤더, 카드 컴포넌트, 배너 등에서 자주 사용됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T15:16:55.000Z"
    },
    {
      "id": 1086,
      "subject_id": 9,
      "question": "배경 이미지의 스크롤 동작을 제어하는 CSS 속성은?",
      "option_a": "background-scroll",
      "option_b": "background-attachment",
      "option_c": "background-fixed",
      "option_d": "background-position",
      "correct_answer": "B",
      "explanation": "`background-attachment` 속성은 배경 이미지가 페이지 스크롤과 함께 움직일지, 아니면 고정될지를 결정하는 CSS 속성입니다.\n\n속성명 분석:\n• background-scroll: 존재하지 않는 속성\n• background-attachment: 배경 이미지의 스크롤 동작을 제어하는 올바른 속성 ✓\n• background-fixed: 존재하지 않는 속성\n• background-position: 배경 이미지의 위치를 설정하는 속성\n\n\"attachment\"는 \"부착\"이라는 뜻으로, 배경 이미지가 어떻게 부착되는지(스크롤과 함께 움직이는지, 고정되는지)를 제어합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T15:21:10.000Z"
    },
    {
      "id": 1087,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 배경 이미지를 고정시키려면?\n```css\nbody {\n    background-image: url(\"mountain.jpg\");\n    background-attachment: ______;\n}\n```",
      "option_a": "fixed",
      "option_b": "static",
      "option_c": "absolute",
      "option_d": "sticky",
      "correct_answer": "A",
      "explanation": "`background-attachment` 속성의 주요 값들과 그 의미는 다음과 같습니다:\n\n주요 attachment 값들:\n• fixed: 배경 이미지가 뷰포트에 고정되어 스크롤해도 움직이지 않음 ✓\n• scroll: 배경 이미지가 페이지와 함께 스크롤됨 (기본값)\n\n다른 선택지들:\n• static, absolute, sticky: CSS의 `position` 속성 값들로, background-attachment와는 무관\n\nfixed 효과:\n페이지를 아래로 스크롤해도 배경 이미지는 그 자리에 고정되어 있어서 마치 창문을 통해 풍경을 보는 것 같은 효과를 만듭니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T15:22:30.000Z"
    },
    {
      "id": 1088,
      "subject_id": 9,
      "question": "배경 이미지의 기본 스크롤 동작은?",
      "option_a": "고정되어 움직이지 않는다",
      "option_b": "페이지 내용과 함께 스크롤된다",
      "option_c": "반대 방향으로 스크롤된다",
      "option_d": "속성을 지정해야만 동작한다",
      "correct_answer": "B",
      "explanation": "`background-attachment` 속성을 별도로 지정하지 않으면 **기본값은 `scroll`**입니다.\n\n기본 동작의 특징:\n• 배경 이미지가 페이지 내용과 함께 움직임 ✓\n• 사용자가 스크롤하면 배경도 같이 위아래로 이동\n• 일반적인 웹페이지에서 볼 수 있는 자연스러운 동작\n\n기본값을 사용하는 경우:\n```css\n.section {\n    background-image: url(\"pattern.jpg\");\n    /* background-attachment: scroll; 생략 가능 (기본값) */\n}\n```\n대부분의 웹사이트에서는 이 기본 동작을 그대로 사용하며, 특별한 시각적 효과가 필요할 때만 `fixed`를 사용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T15:23:44.000Z"
    },
    {
      "id": 1089,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 페이지와 함께 스크롤되게 하려면?\n```css\n.hero-section {\n    background-image: url(\"hero-bg.jpg\");\n    background-repeat: no-repeat;\n    background-position: center center;\n    background-attachment: ______;\n}\n```",
      "option_a": "move",
      "option_b": "scroll",
      "option_c": "follow",
      "option_d": "normal",
      "correct_answer": "B",
      "explanation": "배경 이미지가 페이지 내용과 함께 스크롤되도록 하려면 `scroll` 값을 사용합니다.\n\nscroll vs fixed 비교:\n\nscroll: 배경이 페이지와 함께 움직임 ✓\n• 자연스러운 스크롤 경험\n• 성능상 유리함\n• 대부분의 상황에서 사용\n\nfixed: 배경이 고정되어 움직이지 않음\n• 특별한 시각적 효과\n• 패럴랙스 효과의 기초\n• 성능상 부담이 있을 수 있음\n\n실무 팁:\n기본값이 `scroll`이므로 굳이 명시하지 않아도 되지만, 명확한 의도 표현을 위해 작성하기도 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T15:25:48.000Z"
    },
    {
      "id": 1090,
      "subject_id": 9,
      "question": "다음 상황에서 가장 적절한 background-attachment 설정은?\n상황: 랜딩 페이지의 히어로 섹션에 큰 배경 이미지를 넣고, 사용자가 스크롤할 때 배경은 고정된 채로 텍스트만 위로 올라가는 시각적 효과를 만들고 싶습니다.\n```css\n.hero {\n    height: 100vh;\n    background-image: url(\"hero-background.jpg\");\n    background-size: cover;\n    background-position: center;\n    background-repeat: no-repeat;\n    background-attachment: ______;\n}\n```",
      "option_a": "scroll (기본 동작을 위해)",
      "option_b": "fixed (패럴랙스 효과를 위해)",
      "option_c": "static (안정적인 배치를 위해)",
      "option_d": "inherit (부모 요소 설정을 따르기 위해)",
      "correct_answer": "B",
      "explanation": "설명된 효과는 패럴랙스(Parallax) 효과의 기본 형태로, `fixed` 값을 사용해야 합니다.\n\n패럴랙스 효과 분석:\n• 목적: 배경은 고정, 텍스트만 스크롤되는 시각적 효과\n• 원리: 배경 이미지가 뷰포트에 고정되어 있어서 스크롤해도 움직이지 않음\n• 결과: 텍스트가 배경 위를 지나가는 듯한 입체적 효과 ✓\n\n각 선택지 분석:\n1) scroll: 배경과 텍스트가 함께 움직여서 패럴랙스 효과 없음\n2) fixed: 원하는 패럴랙스 효과 구현 ✓\n3) static: `position` 속성 값으로 여기서는 무의미\n4) inherit: 부모 설정을 따르지만 원하는 효과와 무관\n\n완성된 코드:\n```css\n.hero {\n    height: 100vh;\n    background-image: url(\"hero-background.jpg\");\n    background-size: cover;\n    background-position: center;\n    background-repeat: no-repeat;\n    background-attachment: fixed;\n}\n```\n주의사항:\n• 모바일에서는 성능 이슈로 `fixed`가 제대로 작동하지 않을 수 있음\n• 과도한 사용은 사용자 경험을 해칠 수 있으므로 적절히 사용\n\n실무 활용:\n이런 패턴은 현대 웹사이트의 히어로 섹션, 포트폴리오 사이트, 브랜드 소개 페이지 등에서 자주 사용됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T15:27:50.000Z"
    },
    {
      "id": 1091,
      "subject_id": 9,
      "question": "여러 개의 배경 관련 속성을 한 번에 설정할 수 있는 단축 속성은?",
      "option_a": "bg",
      "option_b": "background",
      "option_c": "background-all",
      "option_d": "backgrounds",
      "correct_answer": "B",
      "explanation": "`background`는 CSS의 단축 속성(shorthand property)으로, 여러 개의 배경 관련 속성들을 하나의 선언으로 설정할 수 있습니다.\n\n단축 속성의 장점:\n• 코드가 간결해짐\n• 한 줄로 여러 속성을 설정 가능\n• 작성 시간 단축\n• 가독성 향상\n\n예시:\n```css\n/* 여러 줄로 작성하는 대신 */\nbackground-color: white;\nbackground-image: url(\"image.png\");\nbackground-repeat: no-repeat;\n\n/* 한 줄로 간단히 */\nbackground: white url(\"image.png\") no-repeat;\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T15:30:48.000Z"
    },
    {
      "id": 1092,
      "subject_id": 9,
      "question": "다음 중 올바른 background 단축 속성 사용법은?",
      "option_a": "`background: url(\"tree.png\") white no-repeat;`",
      "option_b": "`background: white url(\"tree.png\") no-repeat;`",
      "option_c": "`background: no-repeat white url(\"tree.png\");`",
      "option_d": "`background: white no-repeat url(\"tree.png\");`",
      "correct_answer": "B",
      "explanation": "background 단축 속성에는 정해진 순서가 있습니다. 순서를 지켜야 브라우저가 올바르게 해석할 수 있습니다.\n\n올바른 순서:\n1. background-color (배경색)\n2. background-image (배경 이미지)\n3. background-repeat (반복 방식)\n4. background-attachment (고정 여부)\n5. background-position (위치)\n\n선택지 분석:\n1) 이미지가 색상보다 앞에 있어서 틀림\n2) white(색상) → url(이미지) → no-repeat(반복) 순서 ✓\n3) no-repeat가 맨 앞에 있어서 틀림\n4) 이미지가 맨 뒤에 있어서 틀림",
      "difficulty": "easy",
      "created_at": "2025-08-09T15:31:59.000Z"
    },
    {
      "id": 1093,
      "subject_id": 9,
      "question": "다음 코드를 background 단축 속성으로 올바르게 변환한 것은?\n```css\n.header {\n    background-color: #ffffff;\n    background-image: url(\"logo.png\");\n    background-repeat: no-repeat;\n    background-position: right top;\n}\n```",
      "option_a": "`background: #ffffff url(\"logo.png\") no-repeat right top;`",
      "option_b": "`background: url(\"logo.png\") #ffffff no-repeat right top;`",
      "option_c": "`background: right top #ffffff url(\"logo.png\") no-repeat;`",
      "option_d": "`background: no-repeat #ffffff url(\"logo.png\") right top;`",
      "correct_answer": "A",
      "explanation": "개별 속성들을 단축 속성으로 변환할 때는 정확한 순서를 따라야 합니다.\n```css\nbackground: #ffffff url(\"logo.png\") no-repeat right top;\n```\n순서 체크:\n색상 → 이미지 → 반복 → 위치 순서가 정확히 지켜졌습니다. background-attachment는 이 예시에서 사용되지 않아 생략되었습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T15:33:44.000Z"
    },
    {
      "id": 1094,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값들은?\n```css\n.banner {\n    background: lightblue ______ ______ center center;\n}\n```\n파란 배경에 \"banner.jpg\" 이미지를 한 번만 표시하고 중앙에 배치하려고 합니다.",
      "option_a": "`url(\"banner.jpg\") no-repeat`",
      "option_b": "`no-repeat url(\"banner.jpg\")`",
      "option_c": "`url(\"banner.jpg\") repeat`",
      "option_d": "`\"banner.jpg\" no-repeat`",
      "correct_answer": "A",
      "explanation": "순서별 분석:\n• lightblue: background-color ✓\n• 첫 번째 빈칸: background-image 자리\n• 두 번째 빈칸: background-repeat 자리\n• center center: background-position ✓\n\n요구사항 분석:\n• 이미지: \"banner.jpg\" → `url(\"banner.jpg\")`\n• 한 번만 표시 → `no-repeat`\n\n올바른 순서:\n```css\nbackground: lightblue url(\"banner.jpg\") no-repeat center center;\n```\n따라서 `url(\"banner.jpg\") no-repeat`가 정답입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T15:35:33.000Z"
    },
    {
      "id": 1095,
      "subject_id": 9,
      "question": "다음 두 코드는 완전히 동일한 결과를 만듭니다. 이때 빈칸에 들어갈 값은?\n```css\n/* 코드 A */\n.section {\n    background-color: white;\n    background-image: url(\"pattern.gif\");\n    background-repeat: repeat-x;\n    background-position: left bottom;\n}\n\n/* 코드 B */\n.section {\n    background: ______ ______ ______ ______ ______;\n}\n```",
      "option_a": "`white url(\"pattern.gif\") repeat-x left bottom`",
      "option_b": "`url(\"pattern.gif\") white repeat-x left bottom`",
      "option_c": "`white repeat-x url(\"pattern.gif\") left bottom`",
      "option_d": "`left bottom white url(\"pattern.gif\") repeat-x`",
      "correct_answer": "A",
      "explanation": "개별 속성을 단축 속성으로 변환할 때는 정확한 순서를 지켜야 하며, 모든 값이 올바른 위치에 있어야 합니다.\n\n색상 → 이미지 → 반복 → 고정 → 위치\nwhite → url(\"pattern.gif\") → repeat-x → (생략) → left bottom\n\n실무 팁:\n단축 속성을 사용할 때는 순서를 외우기보다는 \"색상-이미지-반복-고정-위치\"라는 논리적 흐름으로 기억하면 쉽습니다.",
      "difficulty": "hard",
      "created_at": "2025-08-09T15:37:37.000Z"
    },
    {
      "id": 1096,
      "subject_id": 9,
      "question": "HTML 요소에 테두리를 만들기 위해 반드시 먼저 설정해야 하는 CSS 속성은?",
      "option_a": "border-color",
      "option_b": "border-width",
      "option_c": "border-style",
      "option_d": "border-radius",
      "correct_answer": "C",
      "explanation": "CSS에서 테두리를 만들 때 가장 중요한 규칙이 있습니다. `border-style` 속성을 먼저 설정하지 않으면 다른 테두리 속성들이 전혀 효과가 없습니다.\n\n우선순위와 의존성:\n• border-style: 테두리의 기본 형태 정의 (필수) ✓\n• border-color: 테두리 색상 (style 설정 후 적용)\n• border-width: 테두리 두께 (style 설정 후 적용)\n• border-radius: 테두리 둥글게 (style 설정 후 적용)\n\n예시:\n```css\n/* 잘못된 순서 - 아무것도 보이지 않음 */\n.box {\n    border-color: red;\n    border-width: 5px;\n    /* border-style이 없으면 테두리가 나타나지 않음 */\n}\n\n/* 올바른 순서 */\n.box {\n    border-style: solid; /* 먼저 스타일 설정 */\n    border-color: red;\n    border-width: 5px;\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T15:40:58.000Z"
    },
    {
      "id": 1097,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 실선 테두리를 만들려면?\n```css\n.card {\n    border-style: ______;\n}\n```",
      "option_a": "line",
      "option_b": "solid",
      "option_c": "straight",
      "option_d": "full",
      "correct_answer": "B",
      "explanation": "CSS에서 테두리 스타일은 정해진 키워드를 사용해야 합니다. 실선 테두리는 `solid` 값으로 만듭니다.\n\n주요 border-style 값들:\n• solid: 실선 (가장 많이 사용) ✓\n• dotted: 점선 (· · · ·)\n• dashed: 대시선 (- - - -)\n• double: 이중선 (두 개의 실선)\n• none: 테두리 없음\n\n다른 선택지들:\n• line, straight, full: CSS에서 존재하지 않는 값들\n\n실무 활용:\n```css\n.button {\n    border-style: solid;\n    border-width: 1px;\n    border-color: #333;\n}\n```\n실선은 버튼, 카드, 입력 필드 등에서 가장 널리 사용되는 테두리 스타일입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T15:42:40.000Z"
    },
    {
      "id": 1098,
      "subject_id": 9,
      "question": "다음 중 점선 테두리를 만드는 올바른 코드는?",
      "option_a": "```css\n.box { border-style: dots; }\n```",
      "option_b": "```css\n.box { border-style: dotted; }\n```",
      "option_c": "```css\n.box { border-style: pointed; }\n```",
      "option_d": "```css\n.box { border-style: circle; }\n```",
      "correct_answer": "B",
      "explanation": "점선 테두리는 `dotted` 값으로 만듭니다. CSS의 border-style 값들은 정확한 키워드를 사용해야 합니다.\n\n점선과 관련된 스타일들:\n• dotted: 점선 (· · · ·) ✓\n• dashed: 대시선 (- - - -) - 점선과 비슷하지만 다름\n\n잘못된 선택지들:\n• dots: 존재하지 않는 값\n• pointed: 존재하지 않는 값\n• circle: 존재하지 않는 값\n\n시각적 차이:\n```css\n.dotted-border { border-style: dotted; }  /* · · · · */\n.dashed-border { border-style: dashed; }  /* - - - - */\n.solid-border { border-style: solid; }    /* ━━━━ */\n```\n점선은 섬세하고 부드러운 느낌을 주어 장식적인 목적이나 구분선으로 자주 사용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T15:44:23.000Z"
    },
    {
      "id": 1099,
      "subject_id": 9,
      "question": "다음 코드의 결과로 나타나는 테두리는?\n```css\n.special-box {\n    border-style: dotted dashed solid double;\n}\n```",
      "option_a": "모든 면이 실선",
      "option_b": "위쪽 점선, 오른쪽 대시선, 아래쪽 실선, 왼쪽 이중선",
      "option_c": "모든 면이 점선",
      "option_d": "위아래 점선, 좌우 대시선",
      "correct_answer": "B",
      "explanation": "`border-style`에 4개의 값을 제공하면 각각 시계방향으로 적용됩니다.\n\n4개 값의 적용 순서:\n```css\nborder-style: 위 오른쪽 아래 왼쪽;\n```\n코드 분석:\n```css\nborder-style: dotted dashed solid double;\n```\n• dotted: 위쪽 테두리 (점선)\n• dashed: 오른쪽 테두리 (대시선)\n• solid: 아래쪽 테두리 (실선)\n• double: 왼쪽 테두리 (이중선)\n\n다른 값 개수별 적용:\n• 1개: 모든 면에 동일하게\n• 2개: 위아래 / 좌우\n• 3개: 위 / 좌우 / 아래\n• 4개: 위 / 오른쪽 / 아래 / 왼쪽",
      "difficulty": "medium",
      "created_at": "2025-08-09T15:46:13.000Z"
    },
    {
      "id": 1100,
      "subject_id": 9,
      "question": "다음 상황에서 가장 적절한 border-style 조합은?\n\n상황: 양식(form)의 입력 필드를 디자인하는데, 평상시에는 연한 실선으로 표시하다가 사용자가 클릭(focus)했을 때는 더 진하고 두꺼운 실선으로 변경하고 싶습니다. 또한 오류가 있을 때는 빨간색 점선으로 표시하고 싶습니다.",
      "option_a": "```css\ninput { border-style: none; }\ninput:focus { border-style: solid; }\ninput.error { border-style: dashed; }\n```",
      "option_b": "```css\ninput { border-style: solid; }\ninput:focus { border-style: double; }\ninput.error { border-style: dotted; }\n```",
      "option_c": "```css\ninput { border-style: dotted; }\ninput:focus { border-style: solid; }\ninput.error { border-style: groove; }\n```",
      "option_d": "```css\ninput { border-style: dashed; }\ninput:focus { border-style: ridge; }\ninput.error { border-style: inset; }\n```",
      "correct_answer": "B",
      "explanation": "사용자 경험(UX)을 고려한 적절한 테두리 스타일 선택이 중요합니다.\n\n요구사항 분석:\n1. 평상시: 연한 실선 → 기본적이고 깔끔한 `solid`\n2. 포커스 시: 진하고 두꺼운 → `double`로 강조 효과\n3. 오류 시: 주의를 끄는 → `dotted`로 시각적 구분\n\n선택지 분석:\n\n2번 (정답):\n• `solid`: 깔끔하고 표준적인 입력 필드 스타일 ✓\n• `double`: 포커스 시 시각적 강조 효과 ✓\n• `dotted`: 오류 상태의 부드러운 경고 효과 ✓\n\n다른 선택지들의 문제점:\n• 1번: 기본 상태가 `none`이면 테두리가 없어서 입력 필드 인식 어려움\n• 3번: 기본 상태가 `dotted`이면 너무 산만함\n• 4번: `ridge`, `inset` 등 3D 효과는 현대적 디자인에 부적합",
      "difficulty": "hard",
      "created_at": "2025-08-09T15:50:53.000Z"
    },
    {
      "id": 1101,
      "subject_id": 9,
      "question": "테두리의 두께를 설정하는 CSS 속성은?",
      "option_a": "border-size",
      "option_b": "border-thickness",
      "option_c": "border-width",
      "option_d": "border-weight",
      "correct_answer": "C",
      "explanation": "CSS에서 테두리의 두께를 조절하는 속성은 `border-width`입니다.\n\nCSS 테두리 관련 속성들:\n• border-style: 테두리 스타일 (solid, dotted 등)\n• border-width: 테두리 두께 ✓\n• border-color: 테두리 색상\n\n다른 선택지들:\n• border-size: 존재하지 않는 속성\n• border-thickness: 존재하지 않는 속성\n• border-weight: 존재하지 않는 속성\n\n기본 사용법:\n```css\n.box {\n    border-style: solid;\n    border-width: 2px; /* 2픽셀 두께 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T15:56:17.000Z"
    },
    {
      "id": 1102,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 수 있는 값이 아닌 것은?\n```css\n.button {\n    border-style: solid;\n    border-width: ______;\n}\n```",
      "option_a": "3px",
      "option_b": "thin",
      "option_c": "medium",
      "option_d": "small",
      "correct_answer": "D",
      "explanation": "`border-width`에는 구체적인 크기 값과 미리 정의된 키워드를 사용할 수 있습니다.\n\n• 구체적 크기: px, em, rem, pt 등의 단위 사용\n`3px`, `1em`, `0.5rem` 등 ✓\n\n• 미리 정의된 키워드:\n`thin` (얇음) ✓\n`medium` (중간) ✓\n`thick` (두꺼움)",
      "difficulty": "easy",
      "created_at": "2025-08-09T16:17:09.000Z"
    },
    {
      "id": 1103,
      "subject_id": 9,
      "question": "다음 코드의 결과는?\n```css\n.card {\n    border-style: solid;\n    border-width: 5px 20px;\n}\n```",
      "option_a": "모든 면이 5px",
      "option_b": "모든 면이 20px",
      "option_c": "위아래 5px, 좌우 20px",
      "option_d": "위아래 20px, 좌우 5px",
      "correct_answer": "C",
      "explanation": "`border-width`에 2개의 값을 제공하면 위아래와 좌우로 구분되어 적용됩니다.\n\n2개 값의 적용 규칙:\n```css\nborder-width: 첫번째값 두번째값;\n```\n• 첫번째값: 위쪽, 아래쪽 테두리에 적용\n• 두번째값: 왼쪽, 오른쪽 테두리에 적용",
      "difficulty": "medium",
      "created_at": "2025-08-09T16:18:34.000Z"
    },
    {
      "id": 1104,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값들은?\n```css\n.special-box {\n    border-style: solid;\n    border-width: ______ ______ ______ ______;\n}\n```\n위쪽 10px, 오른쪽 5px, 아래쪽 15px, 왼쪽 8px로 설정하려고 합니다.",
      "option_a": "`10px 5px 15px 8px`",
      "option_b": "`8px 15px 5px 10px`",
      "option_c": "`10px 8px 15px 5px`",
      "option_d": "`5px 10px 8px 15px`",
      "correct_answer": "A",
      "explanation": "`border-width`에 4개의 값을 제공하면 시계방향으로 적용됩니다.\n\n4개 값의 적용 순서:\n```css\nborder-width: 위 오른쪽 아래 왼쪽;\n```",
      "difficulty": "medium",
      "created_at": "2025-08-09T16:20:24.000Z"
    },
    {
      "id": 1105,
      "subject_id": 9,
      "question": "테두리의 색상을 설정하는 CSS 속성은?",
      "option_a": "border-paint",
      "option_b": "border-color",
      "option_c": "border-fill",
      "option_d": "color-border",
      "correct_answer": "B",
      "explanation": "CSS에서 테두리의 색상을 조절하는 속성은 `border-color`입니다.\n\nCSS 테두리 관련 주요 속성들:\n• border-style: 테두리 스타일 (solid, dotted 등)\n• border-width: 테두리 두께\n• border-color: 테두리 색상 ✓\n\n다른 선택지들:\n• border-paint: 존재하지 않는 속성\n• border-fill: 존재하지 않는 속성\n• color-border: 존재하지 않는 속성\n\n기본 사용법:\n```css\n.box {\n    border-style: solid;\n    border-width: 2px;\n    border-color: red; /* 빨간색 테두리 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T16:24:45.000Z"
    },
    {
      "id": 1106,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 수 있는 값이 아닌 것은?\n```css\n.card {\n    border-style: solid;\n    border-color: ______;\n}\n```",
      "option_a": "red",
      "option_b": "`#ff0000`",
      "option_c": "rgb(255, 0, 0)",
      "option_d": "color-red",
      "correct_answer": "D",
      "explanation": "`border-color`에는 CSS에서 지원하는 다양한 색상 표현 방식을 사용할 수 있습니다.\n\n사용 가능한 색상 표현 방식:\n• 색상 이름: red, blue, green, black 등 ✓\n• HEX 값: `#ff0000`, #333, #abc 등 ✓\n• RGB 값: rgb(255, 0, 0), rgb(100, 150, 200) 등 ✓\n• HSL 값: hsl(0, 100%, 50%) 등\n• 특수 값: transparent (투명)\n\n잘못된 선택지:\n• color-red: CSS에서 지원하지 않는 문법\n\n실제 사용 예시:\n```css\n.red-border-1 { border-color: red; }              /* 색상 이름 */\n.red-border-2 { border-color: #ff0000; }          /* HEX 값 */\n.red-border-3 { border-color: rgb(255, 0, 0); }   /* RGB 값 */\n.red-border-4 { border-color: hsl(0, 100%, 50%); } /* HSL 값 */\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T16:26:20.000Z"
    },
    {
      "id": 1107,
      "subject_id": 9,
      "question": "`border-color` 속성을 설정하지 않으면 어떻게 됩니까?",
      "option_a": "테두리가 검은색이 된다",
      "option_b": "테두리가 투명해진다",
      "option_c": "해당 요소의 텍스트 색상을 상속받는다",
      "option_d": "테두리가 표시되지 않는다",
      "correct_answer": "C",
      "explanation": "`border-color`를 명시적으로 설정하지 않으면 요소의 color 속성 값을 자동으로 상속받습니다.\n\n상속 동작의 예시:\n```css\n.text-box {\n    color: blue;           /* 텍스트 색상 파란색 */\n    border-style: solid;\n    border-width: 2px;\n    /* border-color를 설정하지 않음 */\n}\n/* 결과: 테두리도 파란색이 됨 */\n```\n왜 이런 동작을 할까요?\n• 일관성: 텍스트와 테두리가 같은 색상으로 조화\n• 편의성: 매번 색상을 중복 설정할 필요 없음\n• 유지보수: 텍스트 색상만 변경해도 테두리도 함께 변경\n\n명시적 설정 예시:\n```css\n.custom-box {\n    color: black;              /* 텍스트는 검은색 */\n    border-style: solid;\n    border-color: red;         /* 테두리는 빨간색 */\n}\n```\n이런 기본 동작을 이해하면 더 효율적인 CSS를 작성할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T16:28:01.000Z"
    },
    {
      "id": 1108,
      "subject_id": 9,
      "question": "다음 코드의 결과는?\n```css\n.special-box {\n    border-style: solid;\n    border-color: red green blue yellow;\n}\n```",
      "option_a": "모든 면이 빨간색",
      "option_b": "위쪽 빨강, 오른쪽 녹색, 아래쪽 파랑, 왼쪽 노랑",
      "option_c": "위아래 빨강, 좌우 녹색",
      "option_d": "대각선으로 색상이 섞임",
      "correct_answer": "B",
      "explanation": "`border-color`에 4개의 값을 제공하면 시계방향으로 각 면에 적용됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T16:29:04.000Z"
    },
    {
      "id": 1109,
      "subject_id": 9,
      "question": "위쪽 테두리만 점선으로 설정하는 CSS 속성은?",
      "option_a": "border-top-style",
      "option_b": "top-border-style",
      "option_c": "border-style-top",
      "option_d": "style-border-top",
      "correct_answer": "A",
      "explanation": "CSS에서 특정 면의 테두리 스타일을 개별적으로 설정할 때는 방향별 개별 속성을 사용합니다.\n\n개별 테두리 스타일 속성들:\n• border-top-style: 위쪽 테두리 스타일 ✓\n• border-right-style: 오른쪽 테두리 스타일\n• border-bottom-style: 아래쪽 테두리 스타일\n• border-left-style: 왼쪽 테두리 스타일\n\n명명 규칙: border-[방향]-[속성]",
      "difficulty": "easy",
      "created_at": "2025-08-09T16:33:14.000Z"
    },
    {
      "id": 1110,
      "subject_id": 9,
      "question": "다음 두 코드는 동일한 결과를 만듭니다. 빈칸에 들어갈 값은?\n```css\n/* 코드 A - 개별 속성 */\n.box {\n    border-top-style: dotted;\n    border-right-style: solid;\n    border-bottom-style: dotted;\n    border-left-style: solid;\n}\n\n/* 코드 B - 단축 속성 */\n.box {\n    border-style: ______;\n}\n```",
      "option_a": "dotted solid dotted solid",
      "option_b": "solid dotted solid dotted",
      "option_c": "dotted solid",
      "option_d": "solid dotted",
      "correct_answer": "C",
      "explanation": "개별 속성을 단축 속성으로 변환할 때는 패턴을 파악하는 것이 중요합니다.\n\n개별 속성 분석:\n• 위쪽(top): dotted\n• 오른쪽(right): solid\n• 아래쪽(bottom): dotted\n• 왼쪽(left): solid\n\n패턴 발견:\n• 위쪽 = 아래쪽 (dotted)\n• 오른쪽 = 왼쪽 (solid)\n\n단축 속성 규칙: 2개 값을 사용하면 `첫번째값(위아래) 두번째값(좌우)`",
      "difficulty": "easy",
      "created_at": "2025-08-09T16:35:17.000Z"
    },
    {
      "id": 1111,
      "subject_id": 9,
      "question": "다음 코드의 결과는?\n```css\n.special-div {\n    border-style: dotted solid double;\n}\n```",
      "option_a": "위: dotted, 우: solid, 아래: double, 좌: solid",
      "option_b": "위: dotted, 우: solid, 아래: double, 좌: dotted",
      "option_c": "위: dotted, 우: solid, 아래: solid, 좌: double",
      "option_d": "모든 면이 dotted",
      "correct_answer": "A",
      "explanation": "`border-style`에 3개의 값을 제공하면 특별한 규칙에 따라 적용됩니다.\n\n3개 값의 적용 규칙:\n```css\nborder-style: 첫번째 두번째 세번째;\n```\n• 첫번째: 위쪽에 적용\n• 두번째: 오른쪽, 왼쪽에 적용 (좌우 동일)\n• 세번째: 아래쪽에 적용",
      "difficulty": "medium",
      "created_at": "2025-08-09T16:36:48.000Z"
    },
    {
      "id": 1112,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값들은?\n```css\n.menu-item {\n    border-style: ______ ______ ______ ______;\n}\n```\n위쪽 실선, 오른쪽 없음, 아래쪽 점선, 왼쪽 대시선으로 설정하려고 합니다.",
      "option_a": "`solid none dotted dashed`",
      "option_b": "`dashed dotted none solid`",
      "option_c": "`solid dotted dashed none`",
      "option_d": "`none solid dashed dotted`",
      "correct_answer": "A",
      "explanation": "4개 값을 사용할 때는 시계방향 순서를 정확히 지켜야 합니다.\n\n4개 값의 적용 순서:\n```css\nborder-style: 위 오른쪽 아래 왼쪽;\n```",
      "difficulty": "medium",
      "created_at": "2025-08-09T16:38:19.000Z"
    },
    {
      "id": 1113,
      "subject_id": 9,
      "question": "다음 상황에서 가장 효율적인 CSS 작성 방법은?\n\n상황: 네비게이션 메뉴의 각 항목을 디자인하는데, 위쪽과 아래쪽은 테두리가 없고, 왼쪽은 3px 실선, 오른쪽은 1px 점선으로 만들고 싶습니다. 또한 코드의 가독성과 유지보수성을 고려해야 합니다.",
      "option_a": "```css\n.nav-item {\n    border-top-style: none;\n    border-right-style: dotted;\n    border-right-width: 1px;\n    border-bottom-style: none;\n    border-left-style: solid;\n    border-left-width: 3px;\n}\n```",
      "option_b": "```css\n.nav-item {\n    border-style: none dotted none solid;\n    border-width: 0 1px 0 3px;\n}\n```",
      "option_c": "```css\n.nav-item {\n    border: none;\n    border-right: 1px dotted;\n    border-left: 3px solid;\n}\n```",
      "option_d": "```css\n.nav-item {\n    border-left: 3px solid;\n    border-right: 1px dotted;\n}\n```",
      "correct_answer": "D",
      "explanation": "효율적인 CSS 작성을 위해서는 필요한 것만 명시하는 것이 가장 좋습니다.\n\n실무 팁:\n```css\n/* 기본 상태에서는 테두리가 없으므로 none을 명시할 필요 없음 */\n.nav-item {\n    border-left: 3px solid #007bff;\n    border-right: 1px dotted #ccc;\n    padding: 10px 15px;\n    transition: border-color 0.3s ease;\n}\n\n.nav-item:hover {\n    border-left-color: #0056b3;\n}\n```\n성능 고려사항:\n• 브라우저는 기본적으로 테두리가 없는 상태이므로 none을 명시할 필요 없음\n• 필요한 속성만 설정하면 렌더링 효율성 향상",
      "difficulty": "hard",
      "created_at": "2025-08-09T16:40:45.000Z"
    },
    {
      "id": 1114,
      "subject_id": 9,
      "question": "다음 중 `border` 단축 속성에 포함되는 개별 속성이 아닌 것은?",
      "option_a": "border-width",
      "option_b": "border-style",
      "option_c": "border-color",
      "option_d": "border-radius",
      "correct_answer": "D",
      "explanation": "`border` 단축 속성은 테두리의 기본 형태를 설정하는 속성들만 포함합니다.\n\nborder 단축 속성에 포함되는 것들:\n• border-width: 테두리 두께 ✓\n• border-style: 테두리 스타일 (필수) ✓\n• border-color: 테두리 색상 ✓\n\n포함되지 않는 것:\n• border-radius: 테두리 둥글게 만드는 별도 속성\n\n기본 문법:\n```css\nborder: [두께] [스타일] [색상];\n```\n실제 예시:\n```css\n.box {\n    border: 2px solid blue;     /* 단축 속성 */\n    border-radius: 10px;        /* 별도로 설정해야 함 */\n}\n```\nborder-radius는 테두리의 모양을 둥글게 만드는 별도의 기능이므로 border 단축 속성에는 포함되지 않습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T16:45:03.000Z"
    },
    {
      "id": 1115,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 필수 값은?\n```css\n.card {\n    border: 3px ______ red;\n}\n```",
      "option_a": "thick",
      "option_b": "solid",
      "option_c": "wide",
      "option_d": "color",
      "correct_answer": "B",
      "explanation": "`border` 단축 속성에서 border-style은 반드시 설정해야 하는 필수 값입니다.\n\nborder 단축 속성의 특징:\n• border-style: 필수 입력 ✓\n• border-width: 선택 사항 (기본값: medium)\n• border-color: 선택 사항 (기본값: 요소의 color 값)\n\n왜 style이 필수일까요?\n• style이 없으면 아무런 테두리도 나타나지 않음\n• width와 color는 의미가 있으려면 먼저 style이 정의되어야 함\n\n다른 선택지들:\n• thick: border-width의 키워드 값이지만 이미 3px가 있음\n• wide: 존재하지 않는 CSS 값\n• color: 속성명이지 값이 아님",
      "difficulty": "easy",
      "created_at": "2025-08-09T16:47:03.000Z"
    },
    {
      "id": 1116,
      "subject_id": 9,
      "question": "다음 두 코드는 동일한 결과를 만듭니다. 빈칸에 들어갈 값은?\n```css\n/* 코드 A - 개별 속성 */\n.button {\n    border-width: 2px;\n    border-style: dashed;\n    border-color: green;\n}\n\n/* 코드 B - 단축 속성 */\n.button {\n    border: ______;\n}\n```",
      "option_a": "`green 2px dashed`",
      "option_b": "`2px dashed green`",
      "option_c": "`dashed 2px green`",
      "option_d": "`2px green dashed`",
      "correct_answer": "B",
      "explanation": "`border` 단축 속성에는 정해진 순서가 있지만, 실제로는 순서가 유연합니다. 하지만 일반적인 관례를 따르는 것이 좋습니다.\n\n일반적인 순서 (권장):\n```css\nborder: [두께] [스타일] [색상];\n```\n순서의 유연성: 실제로 CSS는 다음 순서들도 모두 인식합니다:\n• `border: 2px dashed green;` ✓ (권장)\n• `border: dashed 2px green;`\n• `border: green 2px dashed;`\n\n하지만 권장하는 이유:\n• 가독성: 두께 → 스타일 → 색상이 논리적\n• 일관성: 대부분의 개발자가 사용하는 순서\n• 유지보수: 팀 작업에서 통일성 제공",
      "difficulty": "medium",
      "created_at": "2025-08-09T16:49:09.000Z"
    },
    {
      "id": 1117,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성명은?\n```css\n.sidebar {\n    ______: 4px solid blue;\n}\n```\n왼쪽 테두리만 설정하고자 합니다.",
      "option_a": "border-left",
      "option_b": "left-border",
      "option_c": "border-left-side",
      "option_d": "side-border-left",
      "correct_answer": "A",
      "explanation": "특정 방향의 테두리를 설정할 때는 방향별 단축 속성을 사용합니다.\n\n방향별 테두리 단축 속성들:\n• border-top: 위쪽 테두리\n• border-right: 오른쪽 테두리\n• border-bottom: 아래쪽 테두리\n• border-left: 왼쪽 테두리 ✓\n\n명명 규칙: border-[방향]",
      "difficulty": "medium",
      "created_at": "2025-08-09T16:50:38.000Z"
    },
    {
      "id": 1118,
      "subject_id": 9,
      "question": "다음 상황에서 가장 효율적인 CSS 작성 방법은?\n\n상황: 폼의 입력 필드를 디자인하는데, 기본 상태에서는 연한 회색 테두리(1px solid #ccc)를 가지고, 포커스 상태에서는 파란색 테두리(2px solid #007bff)로 변경하고 싶습니다. 또한 브라우저의 기본 outline을 제거해야 합니다.",
      "option_a": "```css\n.input-field {\n    border-width: 1px;\n    border-style: solid;\n    border-color: #ccc;\n}\n.input-field:focus {\n    border-width: 2px;\n    border-style: solid;\n    border-color: #007bff;\n    outline: none;\n}\n```",
      "option_b": "```css\n.input-field {\n    border: 1px solid #ccc;\n}\n.input-field:focus {\n    border: 2px solid #007bff;\n    outline: none;\n}\n```",
      "option_c": "```css\n.input-field {\n    border: 1px solid #ccc;\n}\n.input-field:focus {\n    border-color: #007bff;\n    border-width: 2px;\n    outline: 0;\n}\n```",
      "option_d": "```css\n.input-field {\n    border: 1px solid #ccc;\n    outline: none;\n}\n.input-field:focus {\n    border: 2px solid #007bff;\n}\n```",
      "correct_answer": "D",
      "explanation": "효율적인 CSS 작성을 위해서는 코드의 간결성, 성능, 사용자 경험을 모두 고려해야 합니다.\n\n4번 선택지 분석 (정답):\n```css\n.input-field {\n    border: 1px solid #ccc;\n    outline: none;\n}\n.input-field:focus {\n    border: 2px solid #007bff;\n}\n```\n장점:\n• 간결성: 단축 속성으로 코드가 깔끔 ✓\n• 성능: 최소한의 속성 변경으로 리플로우 최소화 ✓\n• 일관성: outline 제거를 기본 상태에서 처리 ✓\n• 유지보수: 수정할 부분이 명확함 ✓\n\n다른 선택지들의 문제점:\n\n1번: 너무 장황함\n• 개별 속성으로 인한 코드 길이 증가\n• 유지보수 시 여러 곳을 수정해야 함\n\n2번: outline 처리 위치 문제\n• focus 상태에서만 outline을 제거하면 다른 상황에서 문제 발생 가능\n\n3번: 혼재된 방식\n• 단축 속성과 개별 속성이 섞여 일관성 부족\n• `outline: 0`과 `outline: none`의 불일치",
      "difficulty": "hard",
      "created_at": "2025-08-09T16:54:45.000Z"
    },
    {
      "id": 1119,
      "subject_id": 9,
      "question": "CSS에서 마진(margin)의 역할은?",
      "option_a": "요소의 내부 여백을 만든다",
      "option_b": "요소의 외부 여백을 만든다",
      "option_c": "요소의 테두리 두께를 설정한다",
      "option_d": "요소의 배경색을 설정한다",
      "correct_answer": "B",
      "explanation": "마진(margin)은 요소의 바깥쪽 여백을 만드는 CSS 속성입니다.\n\n여백의 종류:\n• margin: 요소의 외부 여백 (테두리 바깥쪽) ✓\n• padding: 요소의 내부 여백 (테두리 안쪽)\n\n실제 사용 예시:\n```css\n.box {\n    margin: 20px;    /* 요소 주변에 20px 공간 생성 */\n    padding: 10px;   /* 요소 내부에 10px 공간 생성 */\n    border: 2px solid black;\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T16:59:03.000Z"
    },
    {
      "id": 1120,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 수 있는 값이 아닌 것은?\n```css\n.container {\n    margin-top: ______;\n}\n```",
      "option_a": "50px",
      "option_b": "auto",
      "option_c": "10%",
      "option_d": "solid",
      "correct_answer": "D",
      "explanation": "마진 속성에는 크기나 특별한 키워드만 사용할 수 있습니다.\n\n사용 가능한 마진 값들:\n\n• 길이 단위: px, em, rem, pt, cm 등\n`50px`, `2em`, `1.5rem` ✓\n\n• 백분율: 부모 요소 너비의 비율\n`10%`, `25%` ✓\n\n• auto: 브라우저가 자동으로 계산\n주로 중앙 정렬에 사용 ✓\n\n• inherit: 부모 요소의 값 상속\n\n• 음수 값도 허용: `-10px`, `-5%`\n\n사용할 수 없는 값:\n\n• solid: border-style에서 사용하는 값으로 마진과 무관",
      "difficulty": "easy",
      "created_at": "2025-08-09T17:01:40.000Z"
    },
    {
      "id": 1121,
      "subject_id": 9,
      "question": "다음 코드의 결과는?\n```css\n.card {\n    margin: 10px 20px;\n}\n```",
      "option_a": "모든 면에 10px 마진",
      "option_b": "모든 면에 20px 마진",
      "option_c": "위아래 10px, 좌우 20px 마진",
      "option_d": "위아래 20px, 좌우 10px 마진",
      "correct_answer": "C",
      "explanation": "`margin`에 2개의 값을 제공하면 위아래와 좌우로 구분되어 적용됩니다.\n\n2개 값의 적용 규칙:\n```css\nmargin: 첫번째값 두번째값;\n```\n• 첫번째값: 위쪽, 아래쪽 마진\n• 두번째값: 왼쪽, 오른쪽 마진",
      "difficulty": "medium",
      "created_at": "2025-08-09T17:02:49.000Z"
    },
    {
      "id": 1122,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 요소를 수평 중앙 정렬하려면?\n```css\n.center-box {\n    width: 300px;\n    margin: ______;\n}\n```",
      "option_a": "center",
      "option_b": "auto",
      "option_c": "middle",
      "option_d": "0 auto",
      "correct_answer": "D",
      "explanation": "요소를 수평 중앙 정렬하려면 좌우 마진을 auto로 설정해야 하며, 요소에는 구체적인 너비가 있어야 합니다.\n\n중앙 정렬의 조건:\n1. 너비 설정: `width: 300px` ✓ (이미 설정됨)\n2. 좌우 마진 auto: 남은 공간을 좌우로 균등 분배\n\n선택지 분석:\n1) center: CSS 마진 값이 아님\n2) auto: 모든 면이 auto가 되어 위아래도 auto (비추천)\n3) middle: CSS 마진 값이 아님\n4) 0 auto: 위아래 0, 좌우 auto (정확한 중앙 정렬) ✓\n\n동작 원리:\n```css\n.center-box {\n    width: 300px;\n    margin: 0 auto;\n}\n```\n부모 요소가 800px일 때:\n• 요소 너비: 300px\n• 남은 공간: 800px - 300px = 500px\n• 좌우 마진: 500px ÷ 2 = 250px씩",
      "difficulty": "medium",
      "created_at": "2025-08-09T17:04:45.000Z"
    },
    {
      "id": 1123,
      "subject_id": 9,
      "question": "다음 상황에서 가장 적절한 마진 설정은?\n\n상황: 블로그 포스트 레이아웃을 만들고 있습니다. 전체 콘텐츠는 최대 800px 너비로 화면 중앙에 배치하고, 각 문단 사이에는 적절한 간격을 두며, 모바일에서는 좌우에 최소 20px의 여백을 확보하고 싶습니다.",
      "option_a": "```css\n.post-container {\n    width: 800px;\n    margin: 0 auto;\n}\n.post-container p {\n    margin: 16px 0;\n}\n```",
      "option_b": "```css\n.post-container {\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 0 20px;\n}\n.post-container p {\n    margin: 16px 0;\n}\n```",
      "option_c": "```css\n.post-container {\n    max-width: 800px;\n    margin: 0 20px;\n}\n.post-container p {\n    margin: 16px auto;\n}\n```",
      "option_d": "```css\n.post-container {\n    width: 100%;\n    margin: 0 20px;\n}\n.post-container p {\n    margin: 16px;\n}\n```",
      "correct_answer": "B",
      "explanation": "반응형 레이아웃에서는 유연성과 사용성을 모두 고려해야 합니다.\n\n요구사항 분석:\n1. 최대 800px 너비 → `max-width: 800px`\n2. 화면 중앙 배치 → `margin: 0 auto`\n3. 문단 간격 → `margin: 16px 0`\n4. 모바일 최소 여백 → `padding: 0 20px`\n\n2번 선택지 분석 (정답):\n```css\n.post-container {\n    max-width: 800px;     /* 최대 너비 제한 */\n    margin: 0 auto;       /* 중앙 정렬 */\n    padding: 0 20px;      /* 모바일 여백 확보 */\n}\n.post-container p {\n    margin: 16px 0;       /* 문단 간 세로 간격 */\n}\n```\n장점:\n• 반응형: max-width로 큰 화면에서는 800px, 작은 화면에서는 유연하게 조절 ✓\n• 중앙 정렬: margin: 0 auto로 완벽한 중앙 배치 ✓\n• 모바일 배려: padding으로 모든 화면 크기에서 최소 여백 보장 ✓\n• 가독성: 문단 간 적절한 세로 간격 ✓\n\n다른 선택지들의 문제점:\n\n1번: 모바일 고려 부족\n• `width: 800px`로 고정되어 작은 화면에서 가로 스크롤 발생\n• 좌우 여백 없음\n\n3번: 중앙 정렬 실패\n• `margin: 0 20px`로 인해 중앙 정렬되지 않음\n• 좌우에 각각 20px씩만 고정\n\n4번: 너비 제한 없음\n• `width: 100%`로 매우 큰 화면에서 가독성 저하\n• 마진 설정 부적절\n\n실무 베스트 프랙티스:\n```css\n.post-container {\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 0 20px;\n    \n    /* 추가 고려사항 */\n    box-sizing: border-box;  /* 패딩 포함 너비 계산 */\n}\n\n.post-container p {\n    margin: 16px 0;\n    line-height: 1.6;        /* 줄 간격으로 가독성 향상 */\n}\n\n/* 모바일 최적화 */\n@media (max-width: 480px) {\n    .post-container {\n        padding: 0 16px;     /* 모바일에서는 조금 더 좁게 */\n    }\n    \n    .post-container p {\n        margin: 12px 0;      /* 모바일에서는 간격을 줄임 */\n    }\n}\n```\n핵심 개념:\n• max-width vs width: 반응형 디자인에서는 max-width 선호\n• margin vs padding: 바깥 여백 vs 안쪽 여백의 적절한 조합\n• 중앙 정렬: margin: 0 auto의 정확한 활용\n• 사용자 경험: 모든 디바이스에서의 가독성 고려",
      "difficulty": "hard",
      "created_at": "2025-08-09T17:08:01.000Z"
    },
    {
      "id": 1124,
      "subject_id": 9,
      "question": "마진 병합(Margin Collapse)이 발생하는 방향은?",
      "option_a": "위아래(상하) 마진에서만",
      "option_b": "좌우(좌우) 마진에서만",
      "option_c": "모든 방향의 마진에서",
      "option_d": "대각선 방향의 마진에서",
      "correct_answer": "A",
      "explanation": "마진 병합은 위아래(상하) 마진에서만 발생하는 CSS의 특별한 동작입니다.\n\n마진 병합의 기본 규칙:\n• 위아래 마진: 병합 발생 ✓\n• 좌우 마진: 병합 발생하지 않음 (항상 더해짐)\n\n예시로 이해하기:\n```css\n.box1 { margin-bottom: 30px; }\n.box2 { margin-top: 20px; }\n```\n결과:\n• 세로 간격: 30px (더 큰 값) - 병합됨\n• 가로로 배치된다면: 30px + 20px = 50px - 더해짐\n\n왜 이런 차이가 있을까요?\n• 세로 방향: 문서의 자연스러운 흐름을 위해 병합\n• 가로 방향: 레이아웃의 정확한 제어를 위해 더함",
      "difficulty": "easy",
      "created_at": "2025-08-09T17:11:45.000Z"
    },
    {
      "id": 1125,
      "subject_id": 9,
      "question": "다음 코드에서 h1과 h2 사이의 실제 간격은?\n```css\nh1 {\n    margin: 0 0 40px 0;\n}\nh2 {\n    margin: 25px 0 0 0;\n}\n```",
      "option_a": "65px (40px + 25px)",
      "option_b": "40px (더 큰 값)",
      "option_c": "25px (더 작은 값)",
      "option_d": "0px (마진이 상쇄됨)",
      "correct_answer": "B",
      "explanation": "마진 병합에서는 더 큰 마진 값이 적용됩니다.\n\n마진 병합의 핵심 원리:\n• 두 마진이 만날 때 더하는 것이 아니라\n• 더 큰 값 하나만 사용\n\n코드 분석:\n```css\nh1 { margin-bottom: 40px; }  /* 아래쪽 40px */\nh2 { margin-top: 25px; }     /* 위쪽 25px */\n```\n병합 과정:\n1. h1의 아래쪽 마진: 40px\n2. h2의 위쪽 마진: 25px\n3. 둘 중 더 큰 값: 40px ✓\n4. 실제 적용되는 간격: 40px\n\n시각적 표현:\n<h1>제목 1</h1>\n     ↓ 40px (실제 간격)\n<h2>제목 2</h2>",
      "difficulty": "easy",
      "created_at": "2025-08-09T17:13:39.000Z"
    },
    {
      "id": 1126,
      "subject_id": 9,
      "question": "다음 중 마진 병합이 발생하지 않는 상황은?",
      "option_a": "```css\n.box1 { margin-bottom: 20px; }\n.box2 { margin-top: 30px; }\n```",
      "option_b": "```css\n.box1 { margin-right: 20px; }\n.box2 { margin-left: 30px; }\n```",
      "option_c": "```css\n.parent { margin-bottom: 15px; }\n.child { margin-top: 25px; }\n```",
      "option_d": "```css\np { margin-bottom: 10px; }\nh2 { margin-top: 20px; }\n```",
      "correct_answer": "B",
      "explanation": "마진 병합은 세로 방향(위아래)에서만 발생하므로, 가로 방향 마진은 항상 더해집니다.\n\n각 상황 분석:\n\n2번 (정답) - 가로 방향:\n```css\n.box1 { margin-right: 20px; }   /* 오른쪽 마진 */\n.box2 { margin-left: 30px; }    /* 왼쪽 마진 */\n```\n• 결과: 20px + 30px = 50px 간격 (더해짐)\n• 이유: 좌우 마진은 병합되지 않음 ✓\n\n다른 선택지들 - 세로 방향 (모두 병합됨):\n1번: 인접한 요소들의 세로 마진 → 30px로 병합\n3번: 부모-자식 간 세로 마진 → 25px로 병합\n4번: 다른 요소들의 세로 마진 → 20px로 병합",
      "difficulty": "medium",
      "created_at": "2025-08-09T17:16:06.000Z"
    },
    {
      "id": 1127,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 h1과 p 사이의 간격을 정확히 50px로 만들려면?\n```css\nh1 {\n    margin-bottom: 30px;\n}\np {\n    margin-top: ______;\n}\n```",
      "option_a": "20px",
      "option_b": "50px",
      "option_c": "80px",
      "option_d": "불가능함",
      "correct_answer": "B",
      "explanation": "마진 병합에서 원하는 간격을 만들려면 그 값 이상의 마진을 설정해야 합니다.\n\n마진 병합의 동작 원리:\n• 더 큰 값이 최종 간격이 됨\n• 원하는 간격 = max(첫번째 마진, 두번째 마진)\n\n각 선택지 분석:\n\n1번 (20px):\n• h1: margin-bottom: 30px\n• p: margin-top: 20px\n• 결과: max(30px, 20px) = 30px ❌\n\n2번 (50px):\n• h1: margin-bottom: 30px\n• p: margin-top: 50px\n• 결과: max(30px, 50px) = 50px ✓\n\n3번 (80px):\n• h1: margin-bottom: 30px\n• p: margin-top: 80px\n• 결과: max(30px, 80px) = 80px ❌",
      "difficulty": "medium",
      "created_at": "2025-08-09T17:18:00.000Z"
    },
    {
      "id": 1128,
      "subject_id": 9,
      "question": "다음 상황에서 가장 좋은 해결 방법은?\n\n상황: 카드 컴포넌트들을 세로로 나열했는데, 각 카드의 margin-bottom이 20px, 다음 카드의 margin-top이 15px로 설정되어 있습니다. 디자인에서는 카드 간격이 정확히 25px여야 하는데, 마진 병합 때문에 20px로 나타나고 있습니다.",
      "option_a": "```css\n.card {\n    margin-bottom: 25px;\n    margin-top: 0;\n}\n```",
      "option_b": "```css\n.card {\n    margin-bottom: 25px;\n    margin-top: 25px;\n}\n```",
      "option_c": "```css\n.card {\n    margin-bottom: 12.5px;\n    margin-top: 12.5px;\n}\n```",
      "option_d": "```css\n.card:not(:last-child) {\n    margin-bottom: 25px;\n}\n.card {\n    margin-top: 0;\n}\n```",
      "correct_answer": "D",
      "explanation": "마진 병합 문제를 해결할 때는 한 방향으로만 마진을 설정하는 것이 가장 예측 가능하고 유지보수하기 좋습니다.\n\n각 선택지 분석:\n\n4번 (정답) - 단방향 마진:\n```css\n.card:not(:last-child) {\n    margin-bottom: 25px;    /* 마지막 카드 제외하고 아래쪽만 */\n}\n.card {\n    margin-top: 0;          /* 위쪽 마진 제거 */\n}\n```\n장점:\n• 예측 가능: 마진 병합 걱정 없음 ✓\n• 정확한 간격: 정확히 25px 간격 보장 ✓\n• 깔끔한 코드: 마지막 요소에 불필요한 마진 없음 ✓\n• 유지보수성: 간격 변경 시 한 곳만 수정 ✓\n\n다른 선택지들의 문제점:\n\n1번: 일관성 문제\n• margin-top이 다른 곳에서 설정될 가능성\n\n2번: 비효율성\n• 모든 카드에 불필요한 상하 마진\n\n3번: 복잡성과 오차 가능성\n• 소수점 계산으로 브라우저별 차이 발생 가능",
      "difficulty": "hard",
      "created_at": "2025-08-09T17:19:50.000Z"
    },
    {
      "id": 1129,
      "subject_id": 9,
      "question": "CSS에서 패딩(padding)의 역할은?",
      "option_a": "요소의 외부 여백을 만든다",
      "option_b": "요소의 내부 여백을 만든다",
      "option_c": "요소의 테두리 두께를 설정한다",
      "option_d": "요소의 너비를 설정한다",
      "correct_answer": "B",
      "explanation": "패딩(padding)은 요소의 내부 여백을 만드는 CSS 속성입니다.\n\n패딩과 마진의 차이:\n• padding: 요소의 내부 여백 (테두리 안쪽) ✓\n• margin: 요소의 외부 여백 (테두리 바깥쪽)\n\n실제 사용 예시:\n```css\n.button {\n    padding: 10px 20px;    /* 버튼 내부에 여백 생성 */\n    margin: 10px;          /* 버튼 외부에 여백 생성 */\n    border: 1px solid #333;\n}\n```\n패딩은 클릭 영역을 넓히고, 텍스트와 테두리 사이에 공간을 만들어 가독성을 높입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T17:22:58.000Z"
    },
    {
      "id": 1130,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 수 있는 값이 아닌 것은?\n```css\n.card {\n    padding-top: ______;\n}\n```",
      "option_a": "20px",
      "option_b": "5%",
      "option_c": "-10px",
      "option_d": "inherit",
      "correct_answer": "C",
      "explanation": "패딩에는 음수 값을 사용할 수 없습니다. 이는 패딩의 본질적 목적 때문입니다.\n\n사용 가능한 패딩 값들:\n\n• 길이 단위: px, em, rem, pt 등\n`20px`, `1.5em`, `2rem` ✓\n\n• 백분율: 부모 요소 너비의 비율\n`5%`, `10%` ✓\n\n• inherit: 부모 요소의 값 상속 ✓\n\n사용할 수 없는 값:\n\n• 음수 값: `-10px`, `-5%` 등\n내부 여백이 음수라는 개념 자체가 모순\n\n왜 음수 값이 불가능할까요?\n```css\n/* 패딩의 목적: 내용과 테두리 사이 공간 확보 */\n.box {\n    padding: 20px;    /* 내용 주변에 20px 공간 */\n    padding: -10px;   /* 불가능! 공간을 음수로 줄일 수 없음 */\n}\n```\n마진 vs 패딩의 음수 값:\n```css\n.element {\n    margin: -10px;     /* 가능! 요소를 겹치게 만들 수 있음 */\n    padding: -10px;    /* 불가능! 내부 공간은 음수가 될 수 없음 */\n}\n```\n실무 활용:\n```css\n.container {\n    padding: 20px;           /* 20px 내부 여백 */\n    padding: 5%;             /* 부모 너비의 5% */\n    padding: inherit;        /* 부모로부터 상속 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T17:26:35.000Z"
    },
    {
      "id": 1131,
      "subject_id": 9,
      "question": "다음 코드의 결과는?\n```css\n.box {\n    padding: 10px 20px;\n}\n```",
      "option_a": "모든 면에 10px 패딩",
      "option_b": "모든 면에 20px 패딩",
      "option_c": "위아래 10px, 좌우 20px 패딩",
      "option_d": "위아래 20px, 좌우 10px 패딩",
      "correct_answer": "C",
      "explanation": "`padding`에 2개의 값을 제공하면 위아래와 좌우로 구분되어 적용됩니다.\n\n2개 값의 적용 규칙:\n```css\npadding: 첫번째값 두번째값;\n```\n• 첫번째값: 위쪽, 아래쪽 패딩\n• 두번째값: 왼쪽, 오른쪽 패딩\n\n코드 분석:\n```css\npadding: 10px 20px;\n```\n• 10px: 위쪽, 아래쪽 패딩 ✓\n• 20px: 왼쪽, 오른쪽 패딩 ✓\n\n시각적 표현:\n        10px (위)\n        ┌─────────┐\n20px ← │  content  │ → 20px\n        └─────────┘\n        10px (아래)\n\n모든 값 개수별 적용:\n• 1개: 모든 면 동일\n• 2개: 위아래 / 좌우 ✓\n• 3개: 위 / 좌우 / 아래\n• 4개: 위 / 우 / 아래 / 좌 (시계방향)",
      "difficulty": "medium",
      "created_at": "2025-08-09T17:28:28.000Z"
    },
    {
      "id": 1132,
      "subject_id": 9,
      "question": "다음 코드에서 실제 요소의 전체 너비는?\n```css\n.box {\n    width: 200px;\n    padding: ______;\n    border: 2px solid black;\n}\n```\n전체 너비가 250px이 되도록 빈칸에 들어갈 값은?",
      "option_a": "23px",
      "option_b": "24px",
      "option_c": "25px",
      "option_d": "48px",
      "correct_answer": "A",
      "explanation": "CSS의 기본 박스 모델에서는 width + padding + border가 실제 요소의 전체 너비가 됩니다.\n\n박스 모델 계산:\n전체 너비 = width + padding-left + padding-right + border-left + border-right\n\n주어진 조건:\n• 원하는 전체 너비: 250px\n• width: 200px\n• border: 2px solid (좌우 각각 2px = 총 4px)\n\n계산 과정:\n250px = 200px + padding-left + padding-right + 4px\n250px = 204px + (padding-left + padding-right)\n46px = padding-left + padding-right\n\npadding 값 구하기:\n```css\npadding: 23px;  /* 좌우 각각 23px = 총 46px */\n```\n검증:\n• width: 200px\n• padding: 23px × 2 = 46px\n• border: 2px × 2 = 4px\n• 총합: 200 + 46 + 4 = 250px ✓\n\n실무에서 자주 하는 실수:\n```css\n/* 개발자가 원한 것 */\n.box { width: 200px; }  /* 전체 200px 원함 */\n\n/* 실제 결과 */\n.box {\n    width: 200px;        /* 콘텐츠 영역만 200px */\n    padding: 20px;       /* +40px */\n    border: 1px solid;   /* +2px */\n}\n/* 실제 전체 너비: 242px */\n```\n이런 문제 때문에 modern CSS에서는 `box-sizing: border-box`를 많이 사용합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-09T17:30:23.000Z"
    },
    {
      "id": 1133,
      "subject_id": 9,
      "question": "다음 상황에서 가장 적절한 CSS 설정은?\n\n상황: 카드 컴포넌트를 만들고 있는데, 카드의 전체 너비를 300px로 고정하면서 내부 콘텐츠에는 상하 20px, 좌우 30px의 패딩을 주고 싶습니다. 또한 1px 테두리도 포함되어야 하며, 패딩 값이 변경되어도 전체 너비는 항상 300px을 유지해야 합니다.",
      "option_a": "```css\n.card {\n    width: 300px;\n    padding: 20px 30px;\n    border: 1px solid #ccc;\n}\n```",
      "option_b": "```css\n.card {\n    width: 238px;\n    padding: 20px 30px;\n    border: 1px solid #ccc;\n}\n```",
      "option_c": "```css\n.card {\n    width: 300px;\n    padding: 20px 30px;\n    border: 1px solid #ccc;\n    box-sizing: border-box;\n}\n```",
      "option_d": "```css\n.card {\n    max-width: 300px;\n    padding: 20px 30px;\n    border: 1px solid #ccc;\n}\n```",
      "correct_answer": "C",
      "explanation": "`box-sizing: border-box`를 사용하면 width에 padding과 border가 포함되어 더 직관적인 크기 제어가 가능합니다.\n\n각 선택지 분석:\n\n3번 (정답) - box-sizing: border-box:\n```css\n.card {\n    width: 300px;               /* 전체 너비 300px */\n    padding: 20px 30px;         /* 패딩 포함 */\n    border: 1px solid #ccc;     /* 테두리 포함 */\n    box-sizing: border-box;     /* 패딩/테두리 포함 계산 */\n}\n```\n장점:\n• 직관적: width가 실제 전체 너비 ✓\n• 유지보수성: 패딩 변경해도 전체 크기 유지 ✓\n• 예측 가능: 설정한 너비가 실제 보이는 너비 ✓\n\n다른 선택지들의 문제점:\n\n1번: 기본 박스 모델\n• 실제 너비: 300 + 60 + 2 = 362px (너무 큼)\n\n2번: 수동 계산\n• width: 238px (300 - 60 - 2)\n• 패딩 변경 시 다시 계산해야 함 (유지보수 어려움)\n\n4번: max-width\n• 최대 너비만 제한, 정확한 크기 제어 불가\n\nbox-sizing의 두 가지 모드:\n\ncontent-box (기본값):\n```css\n.box {\n    width: 200px;           /* 콘텐츠 영역만 */\n    padding: 20px;          /* +40px */\n    border: 1px solid;      /* +2px */\n    /* 실제 너비: 242px */\n}\n```\nborder-box (권장):\n```css\n.box {\n    width: 200px;           /* 전체 너비 */\n    padding: 20px;          /* 포함됨 */\n    border: 1px solid;      /* 포함됨 */\n    box-sizing: border-box;\n    /* 실제 너비: 200px */\n    /* 콘텐츠 영역: 158px */\n}\n```\n현대 CSS 베스트 프랙티스:\n```css\n/* 전역 설정 */\n* {\n    box-sizing: border-box;\n}\n\n/* 또는 */\nhtml {\n    box-sizing: border-box;\n}\n*, *:before, *:after {\n    box-sizing: inherit;\n}\n```",
      "difficulty": "hard",
      "created_at": "2025-08-09T17:33:04.000Z"
    },
    {
      "id": 1134,
      "subject_id": 9,
      "question": "CSS의 `width`와 `height` 속성이 설정하는 영역은?",
      "option_a": "마진을 포함한 전체 영역",
      "option_b": "테두리를 포함한 영역",
      "option_c": "패딩을 포함한 영역",
      "option_d": "콘텐츠 영역만",
      "correct_answer": "D",
      "explanation": "CSS의 `width`와 `height` 속성은 콘텐츠 영역만을 설정합니다. 패딩, 테두리, 마진은 포함되지 않습니다.\n\n실제 예시:\n```css\n.box {\n    width: 200px;           /* 콘텐츠 영역 너비 */\n    height: 100px;          /* 콘텐츠 영역 높이 */\n    padding: 20px;          /* 포함되지 않음 */\n    border: 2px solid;      /* 포함되지 않음 */\n    margin: 10px;           /* 포함되지 않음 */\n}\n/* 실제 보이는 전체 크기: 244px × 144px */\n```\n헷갈리기 쉬운 점:\n많은 초보자들이 width/height가 전체 크기라고 생각하지만, 실제로는 콘텐츠 영역만을 의미합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-09T17:37:19.000Z"
    },
    {
      "id": 1135,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 수 있는 값이 아닌 것은?\n```css\n.container {\n    width: ______;\n}\n```",
      "option_a": "300px",
      "option_b": "80%",
      "option_c": "auto",
      "option_d": "bold",
      "correct_answer": "D",
      "explanation": "CSS의 `width` 속성에는 크기나 특별한 키워드만 사용할 수 있습니다.\n\n사용 가능한 width 값들:\n\n• 길이 단위: px, em, rem, pt, cm 등\n`300px`, `20em`, `5rem` ✓\n\n• 백분율: 부모 요소 너비의 비율\n`80%`, `100%`, `50%` ✓\n\n• auto: 브라우저가 자동으로 계산 (기본값) ✓\n\n• initial: 기본값으로 재설정\n\n• inherit: 부모 요소의 값 상속\n\n사용할 수 없는 값:\n\n• bold: font-weight에서 사용하는 값으로 크기와 무관",
      "difficulty": "easy",
      "created_at": "2025-08-09T17:39:05.000Z"
    },
    {
      "id": 1136,
      "subject_id": 9,
      "question": "`max-width`의 주요 목적과 장점은?",
      "option_a": "요소의 최소 너비를 보장한다",
      "option_b": "작은 화면에서 가로 스크롤을 방지한다",
      "option_c": "요소를 중앙 정렬한다",
      "option_d": "패딩을 자동으로 조절한다",
      "correct_answer": "B",
      "explanation": "`max-width`는 반응형 디자인에서 작은 화면에 대응하기 위한 중요한 속성입니다.\n\nmax-width의 동작 원리:\n• 화면이 클 때: 설정한 max-width까지 확장\n• 화면이 작을 때: 화면 크기에 맞춰 자동 축소\n\nwidth vs max-width 비교:\n\nwidth 사용 시 (문제 상황):\n```css\n.fixed-box {\n    width: 800px;          /* 고정 너비 */\n}\n/* 화면이 800px보다 작으면 가로 스크롤 발생! */\n```\nmax-width 사용 시 (해결):\n```css\n.responsive-box {\n    max-width: 800px;      /* 최대 너비 제한 */\n}\n/* 화면이 작아지면 자동으로 축소됨 */\n```",
      "difficulty": "medium",
      "created_at": "2025-08-09T17:40:33.000Z"
    },
    {
      "id": 1137,
      "subject_id": 9,
      "question": "다음 코드에서 실제로 적용되는 너비는?\n```css\n.box {\n    width: 600px;\n    max-width: 400px;\n}\n```",
      "option_a": "600px",
      "option_b": "400px",
      "option_c": "1000px (600px + 400px)",
      "option_d": "오류가 발생한다",
      "correct_answer": "B",
      "explanation": "`width`와 `max-width`가 동시에 설정된 경우, 더 작은 값이 우선적으로 적용됩니다.\n\nCSS 우선순위 규칙:\n• `width` > `max-width`인 경우: `max-width`가 적용\n• `width` < `max-width`인 경우: `width`가 적용\n\n코드 분석:\n```css\n.box {\n    width: 600px;          /* 원하는 너비 */\n    max-width: 400px;      /* 최대 허용 너비 */\n}\n/* 600px > 400px이므로 max-width인 400px가 적용 */\n```",
      "difficulty": "medium",
      "created_at": "2025-08-09T17:42:30.000Z"
    },
    {
      "id": 1138,
      "subject_id": 9,
      "question": "다음 상황에서 가장 적절한 CSS 설정은?\n\n상황: 블로그 포스트 레이아웃을 만들고 있습니다. 콘텐츠 영역은 데스크톱에서 최대 800px 너비를 가지되, 태블릿과 모바일에서는 화면에 맞게 축소되어야 합니다. 또한 작은 화면에서는 좌우에 최소 20px의 여백을 확보하고, 콘텐츠가 부족해도 최소 500px의 높이를 유지해야 합니다.",
      "option_a": "```css\n.post-content {\n    width: 800px;\n    height: 500px;\n    margin: 0 auto;\n}\n```",
      "option_b": "```css\n.post-content {\n    max-width: 800px;\n    min-height: 500px;\n    margin: 0 auto;\n    padding: 0 20px;\n}\n```",
      "option_c": "```css\n.post-content {\n    width: 100%;\n    height: auto;\n    max-width: 760px;\n    padding: 0 20px;\n}\n```",
      "option_d": "```css\n.post-content {\n    max-width: calc(100% - 40px);\n    min-height: 500px;\n    margin: 0 20px;\n}\n```",
      "correct_answer": "B",
      "explanation": "반응형 레이아웃에서는 유연성과 제약 조건을 모두 고려해야 합니다.\n\n요구사항 분석:\n1. 데스크톱 최대 800px → `max-width: 800px`\n2. 태블릿/모바일 축소 → max-width 사용으로 자동 해결\n3. 좌우 최소 20px 여백 → `padding: 0 20px`\n4. 최소 500px 높이 → `min-height: 500px`\n5. 중앙 정렬 → `margin: 0 auto`\n\n2번 선택지 분석 (정답):\n```css\n.post-content {\n    max-width: 800px;      /* 데스크톱에서 최대 800px */\n    min-height: 500px;     /* 최소 높이 보장 */\n    margin: 0 auto;        /* 중앙 정렬 */\n    padding: 0 20px;       /* 좌우 여백 확보 */\n}\n```\n장점:\n• 완전 반응형: 모든 화면 크기에 대응 ✓\n• 제약 조건 충족: 모든 요구사항 만족 ✓\n• 사용자 경험: 가로 스크롤 없는 자연스러운 레이아웃 ✓\n\n핵심 원칙:\n1. max-width: 반응형 디자인의 핵심\n2. min-height: 콘텐츠 부족 시에도 적절한 높이 유지\n3. padding: 내부 여백으로 안전한 가독성 확보\n4. margin: 0 auto: 중앙 정렬의 표준 방법",
      "difficulty": "hard",
      "created_at": "2025-08-09T17:45:44.000Z"
    },
    {
      "id": 1139,
      "subject_id": 9,
      "question": "CSS 박스 모델의 구성 요소를 안쪽에서 바깥쪽 순서로 올바르게 나열한 것은?",
      "option_a": "Margin → Border → Padding → Content",
      "option_b": "Content → Padding → Border → Margin",
      "option_c": "Content → Border → Padding → Margin",
      "option_d": "Padding → Content → Border → Margin",
      "correct_answer": "B",
      "explanation": "각 영역의 역할:\n• Content: 실제 내용 (텍스트, 이미지)\n• Padding: 내용과 테두리 사이의 투명한 공간\n• Border: 패딩과 콘텐츠를 둘러싸는 테두리\n• Margin: 요소 바깥쪽의 투명한 공간\n\n실제 코드 예시:\n```css\n.box {\n    /* 안쪽부터 바깥쪽 순으로 설정 */\n    width: 200px;           /* Content 영역 */\n    padding: 20px;          /* Padding 영역 */\n    border: 2px solid red;  /* Border 영역 */\n    margin: 10px;           /* Margin 영역 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T17:49:38.000Z"
    },
    {
      "id": 1140,
      "subject_id": 9,
      "question": "다음 중 박스의 실제 크기에 포함되지 않는 영역은?",
      "option_a": "Content",
      "option_b": "Padding",
      "option_c": "Border",
      "option_d": "Margin",
      "correct_answer": "D",
      "explanation": "마진(Margin)은 요소의 실제 크기에 포함되지 않습니다. 마진은 요소가 차지하는 공간에는 영향을 주지만, 요소 자체의 크기는 테두리까지입니다.\n\n박스 크기 계산에 포함되는 것:\n• Content: 기본 콘텐츠 영역 ✓\n• Padding: 내부 여백 ✓\n• Border: 테두리 ✓\n• Margin: 외부 여백 (포함되지 않음)\n\n계산:\n• 요소의 실제 크기: 100px + 40px + 10px = 150px\n• 요소가 차지하는 공간: 150px + 60px = 210px",
      "difficulty": "easy",
      "created_at": "2025-08-09T17:51:00.000Z"
    },
    {
      "id": 1141,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 계산 공식은?\n```css\n.box {\n    width: 150px;\n    height: 80px;\n    padding: 25px;\n    border: 5px solid;\n}\n```\n전체 너비 = ______",
      "option_a": "`150px + 25px + 5px`",
      "option_b": "`150px + 50px + 10px`",
      "option_c": "`150px + 100px + 20px`",
      "option_d": "`150px + 25px + 25px + 5px + 5px`",
      "correct_answer": "B",
      "explanation": "전체 너비를 계산할 때는 모든 방향의 패딩과 테두리를 고려해야 합니다.\n\n박스 모델 계산 공식:\n전체 너비 = width + padding-left + padding-right + border-left + border-right\n\n주어진 값 분석:\n```css\nwidth: 150px;           /* 콘텐츠 영역 너비 */\npadding: 25px;          /* 모든 면에 25px */\nborder: 5px solid;      /* 모든 면에 5px */\n```\n계산:\n전체 너비 = 150px + 25px + 25px + 5px + 5px = 210px\n또는\n전체 너비 = 150px + 50px + 10px = 210px",
      "difficulty": "medium",
      "created_at": "2025-08-09T17:53:34.000Z"
    },
    {
      "id": 1142,
      "subject_id": 9,
      "question": "CSS에서 outline과 border의 가장 큰 차이점은?",
      "option_a": "outline은 색상을 설정할 수 없다",
      "option_b": "outline은 테두리 바깥쪽에 그려진다",
      "option_c": "outline은 사각형만 가능하다",
      "option_d": "outline은 두께를 조절할 수 없다",
      "correct_answer": "B",
      "explanation": "outline은 테두리(border) 바깥쪽에 그려지는 것이 가장 핵심적인 차이점입니다.\n\nBorder vs Outline 비교:\n\n위치:\n• Border: 패딩과 마진 사이 (요소 경계)\n• Outline: 테두리 바깥쪽 ✓\n\n주요 차이점들:\n• 크기 영향: outline은 요소 크기에 영향 없음\n• 위치: outline은 다른 콘텐츠와 겹칠 수 있음\n• 용도: outline은 주로 접근성과 포커스 표시에 사용\n\n실제 예시:\n```css\n.box {\n    width: 100px;\n    border: 5px solid blue;     /* 테두리 */\n    outline: 3px solid red;     /* 테두리 바깥에 빨간 선 */\n}\n/* 요소 크기는 여전히 110px (100px + 5px*2) */\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T17:57:37.000Z"
    },
    {
      "id": 1143,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 필수 속성은?\n```css\n.focus-element {\n    outline-color: blue;\n    outline-width: 2px;\n    ______: solid;\n}\n```",
      "option_a": "outline-type",
      "option_b": "outline-style",
      "option_c": "outline-border",
      "option_d": "outline-line",
      "correct_answer": "B",
      "explanation": "`outline-style`은 반드시 설정해야 하는 필수 속성입니다. 이 속성이 없으면 다른 outline 속성들이 전혀 효과가 없습니다.\n\nOutline 속성의 우선순위:\n• outline-style: 필수! 이것부터 설정해야 함 ✓\n• outline-width: 선택사항 (기본값: medium)\n• outline-color: 선택사항 (기본값: 요소의 color 값)\n\n왜 outline-style이 필수일까요?\n```css\n/* 잘못된 순서 - 아무것도 나타나지 않음 */\n.element {\n    outline-color: red;\n    outline-width: 5px;\n    /* outline-style이 없어서 outline이 보이지 않음 */\n}\n\n/* 올바른 순서 */\n.element {\n    outline-style: solid;   /* 먼저 스타일 설정 */\n    outline-color: red;\n    outline-width: 5px;\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T17:59:57.000Z"
    },
    {
      "id": 1144,
      "subject_id": 9,
      "question": "outline이 요소의 크기에 미치는 영향은?",
      "option_a": "요소의 너비와 높이를 증가시킨다",
      "option_b": "요소의 크기에 전혀 영향을 주지 않는다",
      "option_c": "마진 영역을 축소시킨다",
      "option_d": "패딩 영역을 확장시킨다",
      "correct_answer": "B",
      "explanation": "outline은 요소의 크기(dimensions)에 전혀 영향을 주지 않습니다. 이는 border와의 가장 중요한 차이점 중 하나입니다.\n\nBorder vs Outline 크기 영향 비교:\n\nBorder가 있는 경우:\n```css\n.with-border {\n    width: 100px;\n    height: 50px;\n    border: 10px solid red;\n}\n/* 실제 전체 크기: 120px × 70px */\n```\nOutline이 있는 경우:\n```css\n.with-outline {\n    width: 100px;\n    height: 50px;\n    outline: 10px solid blue;\n}\n/* 실제 전체 크기: 여전히 100px × 50px */\n```",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:01:21.000Z"
    },
    {
      "id": 1145,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 실선 아웃라인을 만들려면?\n```css\n.highlight-box {\n    outline-width: 3px;\n    outline-color: green;\n    outline-style: ______;\n}\n```",
      "option_a": "line",
      "option_b": "solid",
      "option_c": "straight",
      "option_d": "border",
      "correct_answer": "B",
      "explanation": "실선 아웃라인을 만들려면 `outline-style: solid`를 사용해야 합니다.\n\n주요 outline-style 값들:\n• solid: 실선 ✓ (가장 많이 사용)\n• dotted: 점선 (· · · ·)\n• dashed: 대시선 (- - - -)\n• double: 이중선 (두 개의 실선)\n• none: 아웃라인 없음\n\n다른 선택지들:\n• line: CSS에서 유효하지 않은 값\n• straight: CSS에서 유효하지 않은 값\n• border: 다른 속성 이름",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:02:41.000Z"
    },
    {
      "id": 1146,
      "subject_id": 9,
      "question": "다음 상황에서 가장 적절한 CSS 설정은?\n\n상황: 웹 접근성을 고려한 버튼을 디자인하고 있습니다. 평상시에는 아웃라인이 없고, 키보드로 포커스했을 때만 파란색 실선 아웃라인이 나타나야 합니다. 또한 아웃라인으로 인해 레이아웃이 변경되지 않아야 하며, 마우스 클릭 시에는 아웃라인이 나타나지 않아야 합니다.",
      "option_a": "```css\n.accessible-button {\n    outline: none;\n}\n.accessible-button:focus {\n    border: 2px solid blue;\n}\n```",
      "option_b": "```css\n.accessible-button {\n    outline: 2px solid blue;\n}\n.accessible-button:not(:focus) {\n    outline: none;\n}\n```",
      "option_c": "```css\n.accessible-button {\n    outline: none;\n}\n.accessible-button:focus-visible {\n    outline: 2px solid blue;\n}\n```",
      "option_d": "```css\n.accessible-button:focus {\n    outline: 2px solid blue;\n    margin: -2px;\n}\n```",
      "correct_answer": "C",
      "explanation": "`:focus-visible` 가상 클래스는 키보드 포커스와 마우스 클릭을 구분하여 접근성을 고려한 최적의 사용자 경험을 제공합니다.\n\n요구사항 분석:\n1. 평상시 아웃라인 없음 → `outline: none`\n2. 키보드 포커스 시에만 표시 → `:focus-visible` 사용\n3. 레이아웃 변경 없음 → outline 사용 (border 대신)\n4. 마우스 클릭 시 아웃라인 없음 → `:focus-visible`로 자동 해결\n\n3번 선택지 분석 (정답):\n```css\n.accessible-button {\n    outline: none;              /* 기본 아웃라인 제거 */\n}\n.accessible-button:focus-visible {\n    outline: 2px solid blue;    /* 키보드 포커스 시에만 표시 */\n}\n```\n장점:\n• 접근성: 키보드 사용자에게 명확한 포커스 표시 ✓\n• 사용자 경험: 마우스 사용자에게는 방해되지 않음 ✓\n• 레이아웃 안정성: outline 사용으로 크기 변화 없음 ✓\n• 현대적 접근: 최신 웹 표준 활용 ✓\n\n다른 선택지들의 문제점:\n\n1번: border 사용 문제\n• border로 인해 버튼 크기가 변경됨\n• 레이아웃이 깨질 수 있음\n\n2번: 논리적 오류\n• 모든 상황에서 아웃라인이 표시됨\n• `:not(:focus)`는 포커스가 아닐 때를 의미\n\n4번: margin 해킹\n• margin으로 크기 변화를 상쇄하려는 잘못된 접근\n• 다른 부작용 발생 가능",
      "difficulty": "hard",
      "created_at": "2025-08-09T18:05:08.000Z"
    },
    {
      "id": 1147,
      "subject_id": 9,
      "question": "`outline-width` 속성에 사용할 수 있는 값이 아닌 것은?",
      "option_a": "thin",
      "option_b": "medium",
      "option_c": "thick",
      "option_d": "bold",
      "correct_answer": "D",
      "explanation": "`outline-width`에는 크기 관련 키워드와 구체적인 값만 사용할 수 있습니다.\n\n사용 가능한 outline-width 값들:\n\n• 미리 정의된 키워드:\n`thin` (보통 1px) ✓\n`medium` (보통 3px) ✓\n`thick` (보통 5px) ✓\n\n• 구체적인 크기:\n`px`, `em`, `rem`, `pt`, `cm` 등의 단위 ✓\n예: `2px`, `1.5em`, `0.2rem`\n\n사용할 수 없는 값:\n• bold: `font-weight`에서 사용하는 값으로 두께와 무관",
      "difficulty": "easy",
      "created_at": "2025-08-09T18:09:41.000Z"
    },
    {
      "id": 1148,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 중간 두께 아웃라인을 만들려면?\n```css\n.notice-box {\n    outline-style: solid;\n    outline-color: blue;\n    outline-width: ______;\n}\n```",
      "option_a": "middle",
      "option_b": "medium",
      "option_c": "normal",
      "option_d": "average",
      "correct_answer": "B",
      "explanation": "중간 두께의 아웃라인을 만들려면 `medium` 키워드를 사용합니다.\n\noutline-width의 3가지 기본 키워드:\n• thin: 얇은 두께 (보통 1px)\n• medium: 중간 두께 (보통 3px) ✓\n• thick: 두꺼운 두께 (보통 5px)",
      "difficulty": "easy",
      "created_at": "2025-08-09T18:10:51.000Z"
    },
    {
      "id": 1149,
      "subject_id": 9,
      "question": "다음 중 `outline-width: thick`와 가장 비슷한 시각적 효과를 내는 것은?",
      "option_a": "outline-width: 2px",
      "option_b": "outline-width: 5px",
      "option_c": "outline-width: 8px",
      "option_d": "outline-width: 10px",
      "correct_answer": "B",
      "explanation": "`thick` 키워드는 보통 5px 정도의 두께를 나타냅니다.\n\n미리 정의된 키워드의 대략적 크기:\n• thin: ≈ 1px\n• medium: ≈ 3px\n• thick: ≈ 5px ✓\n\n실무에서의 선택:\n```css\n/* 빠른 프로토타이핑 */\n.quick-outline { outline-width: medium; }\n\n/* 정확한 디자인 구현 */\n.precise-outline { outline-width: 3px; }\n\n/* 반응형 디자인 */\n.responsive-outline { \n    outline-width: 0.2rem;   /* 상대 단위 사용 */\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:12:44.000Z"
    },
    {
      "id": 1150,
      "subject_id": 9,
      "question": "다음 중 `outline-color: invert`의 주요 목적은?",
      "option_a": "아웃라인을 투명하게 만든다",
      "option_b": "배경 색상과 관계없이 아웃라인이 잘 보이게 한다",
      "option_c": "아웃라인을 흑백으로 만든다",
      "option_d": "아웃라인의 방향을 뒤집는다",
      "correct_answer": "B",
      "explanation": "`invert` 값은 배경 색상을 반전시켜 아웃라인이 항상 배경과 대비되어 잘 보이도록 하는 특별한 값입니다.\n\ninvert의 작동 원리:\n• 배경이 밝으면 → 아웃라인이 어두워짐\n• 배경이 어두우면 → 아웃라인이 밝아짐\n• 자동으로 대비 확보하여 가시성 보장\n\n시각적 이해:\n```css\n/* 흰 배경에서 */\n.white-bg {\n    background: white;\n    outline-color: invert;   /* → 검은색 아웃라인 */\n}\n\n/* 검은 배경에서 */\n.black-bg {\n    background: black;\n    outline-color: invert;   /* → 흰색 아웃라인 */\n}\n\n/* 빨간 배경에서 */\n.red-bg {\n    background: red;\n    outline-color: invert;   /* → 청록색 아웃라인 */\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:18:10.000Z"
    },
    {
      "id": 1151,
      "subject_id": 9,
      "question": "다음 세 코드는 모두 같은 색상의 아웃라인을 만듭니다. 빈칸에 들어갈 값은?\n```css\n/* 코드 A */\n.element-a { outline-color: red; }\n\n/* 코드 B */\n.element-b { outline-color: #ff0000; }\n\n/* 코드 C */\n.element-c { outline-color: rgb(255, 0, 0); }\n\n/* 코드 D */\n.element-d { outline-color: hsl(0, 100%, ______);\n```",
      "option_a": "25%",
      "option_b": "50%",
      "option_c": "75%",
      "option_d": "100%",
      "correct_answer": "B",
      "explanation": "HSL 색상 모델에서 순수한 빨간색을 만들려면 Lightness(명도) 값이 **50%**여야 합니다.\n\nHSL 색상 모델 이해:\n• H (Hue): 색조, 0-360도\n• S (Saturation): 채도, 0-100%\n• L (Lightness): 명도, 0-100%\n\n빨간색의 HSL 값:\n```css\nhsl(0, 100%, 50%)\n```\n• 0: 빨간색 색조 (색상환에서 0도)\n• 100%: 완전한 채도 (회색 섞임 없음)\n• 50%: 중간 명도 (너무 어둡지도 밝지도 않음) ✓\n\nLightness 값에 따른 변화:\n```css\nhsl(0, 100%, 0%)    /* 검은색 (너무 어두움) */\nhsl(0, 100%, 25%)   /* 어두운 빨간색 */\nhsl(0, 100%, 50%)   /* 순수한 빨간색 ✓ */\nhsl(0, 100%, 75%)   /* 밝은 빨간색 */\nhsl(0, 100%, 100%)  /* 흰색 (너무 밝음) */\n```",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:20:03.000Z"
    },
    {
      "id": 1152,
      "subject_id": 9,
      "question": "`outline-offset` 속성의 역할은?",
      "option_a": "아웃라인의 색상을 변경한다",
      "option_b": "아웃라인과 요소 테두리 사이의 간격을 조절한다",
      "option_c": "아웃라인의 두께를 설정한다",
      "option_d": "아웃라인의 스타일을 변경한다",
      "correct_answer": "B",
      "explanation": "`outline-offset`은 아웃라인과 요소의 테두리(border) 사이에 투명한 공간을 만드는 속성입니다.\n\n실제 사용 예시:\n```css\n.card {\n    border: 2px solid black;\n    outline: 2px solid red;\n    outline-offset: 5px;        /* 테두리와 아웃라인 사이 5px 간격 */\n}\n```\n왜 유용할까요?\n• 포커스 표시를 더 명확하게 만들기\n• 시각적 강조 효과 개선\n• 디자인적 여백 확보",
      "difficulty": "easy",
      "created_at": "2025-08-09T18:24:23.000Z"
    },
    {
      "id": 1153,
      "subject_id": 9,
      "question": "`outline-offset`으로 만든 간격의 특성은?",
      "option_a": "배경색이 있다",
      "option_b": "완전히 투명하다",
      "option_c": "반투명하다",
      "option_d": "테두리와 같은 색상이다",
      "correct_answer": "B",
      "explanation": "`outline-offset`으로 만든 간격은 완전히 투명하여 뒤의 배경이나 다른 요소들이 그대로 보입니다.\n\n투명성의 의미:\n• 간격 영역에는 아무런 색상이나 배경이 없음\n• 부모 요소의 배경이나 뒤의 요소들이 그대로 보임\n• 마치 \"구멍이 뚫린\" 것처럼 투명",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:25:39.000Z"
    },
    {
      "id": 1154,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 아웃라인을 테두리에 더 가깝게 만들려면?\n```css\n.element {\n    border: 3px solid black;\n    outline: 2px solid red;\n    outline-offset: ______;\n}\n```",
      "option_a": "5px",
      "option_b": "0px",
      "option_c": "-2px",
      "option_d": "auto",
      "correct_answer": "C",
      "explanation": "`outline-offset`에 음수 값을 사용하면 아웃라인이 테두리보다 안쪽으로 들어가서 더 가깝게 (또는 겹치게) 됩니다.\n\noutline-offset 값의 효과:\n\n양수 값: 바깥쪽으로 밀어냄\n```css\noutline-offset: 5px;    /* 테두리에서 5px 바깥쪽 */\n```\n0: 테두리에 바로 붙음\n```css\noutline-offset: 0px;    /* 테두리에 바로 붙음 (기본값) */\n```\n음수 값: 안쪽으로 들어감\n```css\noutline-offset: -2px;   /* 테두리보다 2px 안쪽 ✓ */\n```",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:27:18.000Z"
    },
    {
      "id": 1155,
      "subject_id": 9,
      "question": "페이지 전체의 기본 텍스트 색상을 설정하려면 어떤 선택자를 사용해야 할까요?\n```css\n______ {\n    color: #333;\n}\n```",
      "option_a": "html",
      "option_b": "body",
      "option_c": "page",
      "option_d": "text",
      "correct_answer": "B",
      "explanation": "페이지 전체의 기본 텍스트 색상은 body 선택자에 설정하는 것이 표준적인 방법입니다.\n\nbody 선택자의 역할:\n• 웹페이지의 실제 콘텐츠 영역을 나타냄\n• 여기서 설정한 색상이 모든 자식 요소에 상속됨\n• 페이지 전체의 기본 스타일을 정의하는 곳\n\n올바른 설정:\n```css\nbody {\n    color: #333;             /* 페이지 전체 기본 텍스트 색상 */\n    background-color: white; /* 페이지 전체 배경 색상 */\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:31:12.000Z"
    },
    {
      "id": 1156,
      "subject_id": 9,
      "question": "텍스트의 가로 정렬을 설정하는 CSS 속성은?",
      "option_a": "align-text",
      "option_b": "text-align",
      "option_c": "horizontal-align",
      "option_d": "text-position",
      "correct_answer": "B",
      "explanation": "CSS에서 텍스트의 가로 정렬(수평 정렬)을 설정하는 속성은 `text-align`입니다.\n\ntext-align의 주요 값들:\n• left: 왼쪽 정렬 (기본값)\n• center: 중앙 정렬\n• right: 오른쪽 정렬\n• justify: 양쪽 정렬 (양끝 맞춤)\n\n실제 사용 예시:\n```css\nh1 {\n    text-align: center;         /* 제목을 중앙 정렬 */\n}\n\np {\n    text-align: left;           /* 문단을 왼쪽 정렬 */\n}\n\n.quote {\n    text-align: right;          /* 인용문을 오른쪽 정렬 */\n}\n\n.article {\n    text-align: justify;        /* 기사 본문을 양쪽 정렬 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T18:34:46.000Z"
    },
    {
      "id": 1157,
      "subject_id": 9,
      "question": "`text-align: justify`의 특징으로 올바른 것은?",
      "option_a": "텍스트를 세로 중앙에 배치한다",
      "option_b": "각 줄을 늘여서 왼쪽과 오른쪽 끝을 맞춘다",
      "option_c": "텍스트를 대각선으로 배치한다",
      "option_d": "텍스트를 원형으로 배치한다",
      "correct_answer": "B",
      "explanation": "`justify`는 양쪽 정렬로, 각 줄의 텍스트를 늘여서 왼쪽과 오른쪽 끝을 모두 맞추는 정렬 방식입니다.\n\njustify의 작동 원리:\n• 각 줄의 단어 사이 간격을 자동으로 조절\n• 모든 줄이 같은 너비를 가지도록 함\n• 신문이나 잡지에서 볼 수 있는 정렬 방식",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:36:05.000Z"
    },
    {
      "id": 1158,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 속성으로 마지막 줄의 정렬을 설정하려면?\n```css\n.paragraph {\n    text-align: justify;\n    ______: center;\n}\n```",
      "option_a": "text-align-end",
      "option_b": "text-align-last",
      "option_c": "last-line-align",
      "option_d": "final-text-align",
      "correct_answer": "B",
      "explanation": "텍스트의 마지막 줄 정렬을 별도로 설정하는 속성은 `text-align-last`입니다.\n\ntext-align-last의 필요성:\n• `text-align: justify`를 사용할 때 마지막 줄은 보통 왼쪽 정렬됨\n• 마지막 줄만 다른 정렬을 원할 때 사용\n\ntext-align-last의 값들:\n• left: 마지막 줄 왼쪽 정렬\n• center: 마지막 줄 중앙 정렬\n• right: 마지막 줄 오른쪽 정렬\n• justify: 마지막 줄도 양쪽 정렬",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:37:42.000Z"
    },
    {
      "id": 1159,
      "subject_id": 9,
      "question": "다음 상황에서 가장 적절한 텍스트 정렬 조합은?\n\n상황: 온라인 잡지 기사를 디자인하고 있습니다. 기사 제목은 임팩트 있게 중앙 정렬하고, 본문은 전문적인 느낌을 위해 양쪽 정렬을 사용하되, 각 문단의 마지막 줄은 자연스럽게 왼쪽 정렬로 마무리하고 싶습니다. 또한 기사 끝의 저자명은 오른쪽에 배치하고 싶습니다.",
      "option_a": "```css\n.article-title { text-align: center; }\n.article-content { text-align: justify; }\n.author-name { text-align: right; }\n```",
      "option_b": "```css\n.article-title { text-align: center; }\n.article-content { \n    text-align: justify; \n    text-align-last: left; \n}\n.author-name { text-align: right; }\n```",
      "option_c": "```css\n.article-title { text-align: left; }\n.article-content { text-align: center; }\n.author-name { text-align: center; }\n```",
      "option_d": "```css\n.article-title { text-align: justify; }\n.article-content { text-align: center; }\n.author-name { text-align: left; }\n```",
      "correct_answer": "B",
      "explanation": "온라인 잡지의 전문성과 가독성을 모두 고려한 완전한 정렬 시스템이 필요합니다.\n\n요구사항 분석:\n1. 제목: 임팩트 있게 → `text-align: center`\n2. 본문: 전문적인 느낌 → `text-align: justify`\n3. 본문 마지막 줄: 자연스럽게 → `text-align-last: left`\n4. 저자명: 오른쪽 배치 → `text-align: right`",
      "difficulty": "hard",
      "created_at": "2025-08-09T18:39:57.000Z"
    },
    {
      "id": 1160,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 텍스트에 밑줄을 추가하려면?\n```css\nh1 {\n    text-decoration-line: ______;\n}\n```",
      "option_a": "bottom-line",
      "option_b": "underline",
      "option_c": "under",
      "option_d": "line-bottom",
      "correct_answer": "B",
      "explanation": "텍스트에 밑줄을 추가하려면 `text-decoration-line: underline`을 사용합니다.\n\ntext-decoration-line의 주요 값들:\n• underline: 밑줄 ✓\n• overline: 윗줄 (텍스트 위쪽에 선)\n• line-through: 취소선 (텍스트 중간에 선)\n• none: 장식 없음\n\n다른 선택지들:\n• bottom-line: 존재하지 않는 CSS 값\n• under: 존재하지 않는 CSS 값\n• line-bottom: 존재하지 않는 CSS 값",
      "difficulty": "easy",
      "created_at": "2025-08-09T18:43:47.000Z"
    },
    {
      "id": 1161,
      "subject_id": 9,
      "question": "링크의 기본 밑줄을 제거하려면?\n```css\na {\n    text-decoration: ______;\n}\n```",
      "option_a": "none",
      "option_b": "remove",
      "option_c": "hide",
      "option_d": "off",
      "correct_answer": "A",
      "explanation": "HTML 링크의 기본 밑줄을 제거하려면 `text-decoration: none`을 사용합니다.\n\n링크 밑줄 제거의 필요성:\n• HTML 링크는 기본적으로 밑줄이 있음\n• 현대적인 웹 디자인에서는 밑줄 없는 링크를 선호\n• 버튼 스타일 링크나 네비게이션 메뉴에서 주로 사용",
      "difficulty": "easy",
      "created_at": "2025-08-09T18:45:04.000Z"
    },
    {
      "id": 1162,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 속성으로 장식선의 색상을 설정하려면?\n```css\n.highlight {\n    text-decoration-line: underline;\n    ______: red;\n}\n```",
      "option_a": "text-decoration-paint",
      "option_b": "text-decoration-color",
      "option_c": "decoration-color",
      "option_d": "underline-color",
      "correct_answer": "B",
      "explanation": "텍스트 장식선(밑줄, 윗줄, 취소선)의 색상을 설정하는 속성은 `text-decoration-color`입니다.\n\ntext-decoration-color의 역할:\n• 장식선의 색상을 텍스트 색상과 다르게 설정 가능\n• 모든 종류의 장식선에 적용 (underline, overline, line-through)",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:46:35.000Z"
    },
    {
      "id": 1163,
      "subject_id": 9,
      "question": "다음 중 `text-decoration-style` 속성에 사용할 수 없는 값은?",
      "option_a": "solid",
      "option_b": "dotted",
      "option_c": "wavy",
      "option_d": "curved",
      "correct_answer": "D",
      "explanation": "`text-decoration-style`은 장식선의 스타일을 설정하는 속성으로, curved는 지원하지 않는 값입니다.\n\n사용 가능한 text-decoration-style 값들:\n• solid: 실선 (기본값) ✓\n• double: 이중선 ✓\n• dotted: 점선 ✓\n• dashed: 대시선 ✓\n• wavy: 물결선 ✓\n\n사용할 수 없는 값:\n• curved: 존재하지 않는 값",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:48:20.000Z"
    },
    {
      "id": 1164,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 속성으로 첫 번째 줄을 들여쓰기하려면?\n```css\np {\n    ______: 50px;\n}\n```",
      "option_a": "text-margin",
      "option_b": "text-indent",
      "option_c": "first-line-indent",
      "option_d": "paragraph-indent",
      "correct_answer": "B",
      "explanation": "텍스트의 첫 번째 줄을 들여쓰기하는 속성은 `text-indent`입니다.\n\ntext-indent의 특징:\n• 블록 요소의 첫 번째 줄에만 적용\n• 양수 값: 오른쪽으로 들여쓰기\n• 음수 값: 왼쪽으로 내어쓰기 (hanging indent)\n\n다른 선택지들:\n• text-margin: 존재하지 않는 CSS 속성\n• first-line-indent: 존재하지 않는 CSS 속성\n• paragraph-indent: 존재하지 않는 CSS 속성",
      "difficulty": "easy",
      "created_at": "2025-08-09T18:52:55.000Z"
    },
    {
      "id": 1165,
      "subject_id": 9,
      "question": "텍스트의 줄 간격(행간)을 설정하는 CSS 속성은?",
      "option_a": "line-spacing",
      "option_b": "row-height",
      "option_c": "line-height",
      "option_d": "text-height",
      "correct_answer": "C",
      "explanation": "텍스트의 줄과 줄 사이의 간격을 설정하는 속성은 `line-height`입니다.\n\nline-height의 중요성:\n• 가독성에 가장 큰 영향을 미치는 속성\n• 텍스트의 수직적 리듬 결정\n• 요소의 높이에도 영향\n\nline-height 값의 종류:\n```css\n/* 숫자 (권장) - font-size의 배수 */\np {\n    line-height: 1.6;           /* font-size의 1.6배 */\n}\n\n/* 길이 단위 */\nh1 {\n    line-height: 24px;          /* 고정 크기 */\n}\n\n/* 백분율 */\n.content {\n    line-height: 150%;          /* font-size의 150% */\n}\n\n/* 키워드 */\n.normal-text {\n    line-height: normal;        /* 브라우저 기본값 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T18:54:20.000Z"
    },
    {
      "id": 1166,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 속성으로 글자 사이의 간격을 조절하려면?\n```css\n.title {\n    ______: 3px;\n}\n```",
      "option_a": "character-spacing",
      "option_b": "letter-spacing",
      "option_c": "font-spacing",
      "option_d": "text-spacing",
      "correct_answer": "B",
      "explanation": "개별 글자(문자) 사이의 간격을 조절하는 속성은 `letter-spacing`입니다.\n\nletter-spacing의 효과:\n• 양수 값: 글자 사이를 벌림\n• 음수 값: 글자 사이를 좁힘\n• 0: 기본 간격",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:56:31.000Z"
    },
    {
      "id": 1167,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 텍스트 줄바꿈을 방지하려면?\n```css\n.no-wrap {\n    white-space: ______;\n}\n```",
      "option_a": "no-break",
      "option_b": "nowrap",
      "option_c": "prevent-wrap",
      "option_d": "single-line",
      "correct_answer": "B",
      "explanation": "텍스트의 자동 줄바꿈을 방지하려면 `white-space: nowrap`을 사용합니다.\n\nwhite-space의 주요 값들:\n• normal: 기본값, 자동 줄바꿈\n• nowrap: 줄바꿈 없음 ✓\n• pre: 공백과 줄바꿈 보존 (HTML의 `<pre>` 태그처럼)\n• pre-line: 줄바꿈만 보존\n• pre-wrap: 공백과 줄바꿈 보존하면서 자동 줄바꿈도 허용",
      "difficulty": "medium",
      "created_at": "2025-08-09T18:58:08.000Z"
    },
    {
      "id": 1168,
      "subject_id": 9,
      "question": "텍스트에 그림자 효과를 추가하는 CSS 속성은?",
      "option_a": "text-effect",
      "option_b": "text-shadow",
      "option_c": "font-shadow",
      "option_d": "shadow-text",
      "correct_answer": "B",
      "explanation": "CSS에서 텍스트에 그림자 효과를 추가하는 속성은 `text-shadow`입니다.\n\ntext-shadow의 기본 구조:\n```css\ntext-shadow: 가로오프셋 세로오프셋 블러반경 색상;\n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T19:02:07.000Z"
    },
    {
      "id": 1169,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 순서는?\n```css\nh1 {\n    text-shadow: ______ ______ red;\n}\n```\n오른쪽으로 3px, 아래쪽으로 3px 이동한 빨간색 그림자를 만들고자 합니다.",
      "option_a": "3px 3px",
      "option_b": "3px -3px",
      "option_c": "-3px 3px",
      "option_d": "-3px -3px",
      "correct_answer": "A",
      "explanation": "`text-shadow`의 첫 번째와 두 번째 값은 각각 가로 오프셋과 세로 오프셋을 나타냅니다.\n\n오프셋 값의 의미:\n\n• 가로 오프셋 (첫 번째 값):\n양수: 오른쪽으로 이동 ✓\n음수: 왼쪽으로 이동\n\n• 세로 오프셋 (두 번째 값):\n양수: 아래쪽으로 이동 ✓\n음수: 위쪽으로 이동",
      "difficulty": "easy",
      "created_at": "2025-08-09T19:18:43.000Z"
    },
    {
      "id": 1170,
      "subject_id": 9,
      "question": "다음 코드에서 `5px`가 나타내는 것은?\n```css\n.title {\n    text-shadow: 2px 2px 5px blue;\n}\n```",
      "option_a": "가로 오프셋",
      "option_b": "세로 오프셋",
      "option_c": "블러 반경",
      "option_d": "그림자 투명도",
      "correct_answer": "C",
      "explanation": "`text-shadow`의 세 번째 값은 **블러 반경(blur radius)**을 나타냅니다.\n\ntext-shadow 값의 순서:\n```css\ntext-shadow: 가로오프셋 세로오프셋 블러반경 색상;\n```\n블러 반경의 효과:\n• 0 또는 생략: 선명한 그림자 (기본값)\n• 양수: 블러 효과로 부드러운 그림자\n• 값이 클수록: 더 흐릿하고 넓게 퍼진 그림자",
      "difficulty": "medium",
      "created_at": "2025-08-09T19:20:31.000Z"
    },
    {
      "id": 1171,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 값으로 글로우(발광) 효과를 만들려면?\n```css\n.glow-text {\n    color: white;\n    text-shadow: ______ ______ 10px red;\n}\n```",
      "option_a": "5px 5px",
      "option_b": "0 0",
      "option_c": "10px 10px",
      "option_d": "-5px -5px",
      "correct_answer": "B",
      "explanation": "글로우(발광) 효과를 만들려면 오프셋을 0으로 설정하여 그림자가 텍스트 뒤에서 골고루 퍼지도록 해야 합니다.\n\n글로우 효과의 원리:\n• 가로 오프셋 0: 좌우로 이동하지 않음\n• 세로 오프셋 0: 상하로 이동하지 않음\n• 블러 반경만 설정: 텍스트 주변으로 빛이 퍼짐",
      "difficulty": "medium",
      "created_at": "2025-08-09T19:24:40.000Z"
    },
    {
      "id": 1172,
      "subject_id": 9,
      "question": "CSS에서 텍스트의 글꼴을 설정하는 속성은?",
      "option_a": "text-font",
      "option_b": "font-family",
      "option_c": "font-type",
      "option_d": "family-font",
      "correct_answer": "B",
      "explanation": "CSS에서 텍스트의 글꼴(폰트)을 설정하는 속성은 `font-family`입니다.\n\nfont-family의 기본 사용법:\n```css\np {\n    font-family: Arial;         /* 단일 폰트 */\n}\n\nh1 {\n    font-family: \"Times New Roman\";  /* 공백이 있는 폰트명은 따옴표 */\n}\n```\n중요한 규칙:\n• 폰트명에 공백이 있으면 반드시 따옴표로 감싸야 함\n• 대소문자를 구분하지 않음\n• 여러 폰트를 쉼표로 구분하여 나열 가능 (fallback)",
      "difficulty": "easy",
      "created_at": "2025-08-09T19:40:46.000Z"
    },
    {
      "id": 1173,
      "subject_id": 9,
      "question": "다음 중 Serif 폰트 패밀리에 속하는 것은?",
      "option_a": "Arial",
      "option_b": "Helvetica",
      "option_c": "Times New Roman",
      "option_d": "Verdana",
      "correct_answer": "C",
      "explanation": "Times New Roman은 대표적인 Serif 폰트입니다. Serif 폰트는 글자 끝에 작은 장식(serif)이 있는 폰트입니다.\n\nSerif vs Sans-serif 구분:\n\nSerif 폰트 (세리프 있음):\n• 글자 끝에 작은 장식선이 있음\n• 격식있고 우아한 느낌\n• 인쇄물에서 가독성이 좋음\n• 예: Times New Roman ✓, Georgia, Garamond\n\nSans-serif 폰트 (세리프 없음):\n• 글자 끝이 깔끔함 (장식 없음)\n• 현대적이고 미니멀한 느낌\n• 컴퓨터 화면에서 가독성이 좋음\n• 예: Arial, Helvetica, Verdana",
      "difficulty": "easy",
      "created_at": "2025-08-09T19:42:00.000Z"
    },
    {
      "id": 1174,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 폰트 패밀리는?\n```css\n.code-block {\n    font-family: \"Courier New\", ______;\n}\n```\n프로그래밍 코드를 표시하는 블록에 적합한 폰트를 설정하고자 합니다.",
      "option_a": "serif",
      "option_b": "sans-serif",
      "option_c": "monospace",
      "option_d": "cursive",
      "correct_answer": "C",
      "explanation": "프로그래밍 코드 표시에는 monospace 폰트 패밀리가 가장 적합합니다.\n\nmonospace 폰트의 특징:\n• 모든 글자가 동일한 너비를 가짐\n• 코드의 정렬과 들여쓰기가 정확히 표현됨\n• 숫자와 문자의 구분이 명확함\n• 기계적이고 정확한 느낌\n\n5가지 제네릭 폰트 패밀리:\n1. serif: 격식있는 문서용\n2. sans-serif: 현대적인 웹사이트용\n3. monospace: 코드, 데이터 표시용 ✓\n4. cursive: 손글씨 스타일\n5. fantasy: 장식적/재미있는 폰트",
      "difficulty": "medium",
      "created_at": "2025-08-09T19:43:48.000Z"
    },
    {
      "id": 1175,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 문법은?\n```css\n.article-title {\n    font-family: ______, serif;\n}\n```",
      "option_a": "Times New Roman",
      "option_b": "\"Times New Roman\"",
      "option_c": "'Times-New-Roman'",
      "option_d": "TimesNewRoman",
      "correct_answer": "B",
      "explanation": "폰트명에 공백이 포함되어 있으면 반드시 따옴표로 감싸야 합니다.\n\nCSS 폰트명 규칙:\n• 공백이 없는 경우: 따옴표 생략 가능\n• 공백이 있는 경우: 반드시 따옴표 필요 ✓",
      "difficulty": "medium",
      "created_at": "2025-08-09T19:45:12.000Z"
    },
    {
      "id": 1176,
      "subject_id": 9,
      "question": "웹 안전 폰트(Web Safe Fonts)란?",
      "option_a": "인터넷에서 무료로 다운로드할 수 있는 폰트",
      "option_b": "모든 브라우저와 기기에 공통으로 설치되어 있는 폰트",
      "option_c": "보안이 강화된 암호화된 폰트",
      "option_d": "웹사이트에서만 사용할 수 있는 전용 폰트",
      "correct_answer": "B",
      "explanation": "웹 안전 폰트는 모든 브라우저와 기기에 공통으로 설치되어 있어서 어떤 환경에서든 동일하게 표시될 수 있는 폰트를 의미합니다.\n\n웹 안전 폰트의 특징:\n• 운영체제에 기본적으로 설치되어 있음\n• 브라우저나 기기에 관계없이 일관된 표시\n• 별도의 다운로드나 설치가 필요 없음\n• 빠른 로딩 속도\n\n대표적인 웹 안전 폰트들:\n```css\n/* Sans-serif 계열 */\n.arial { font-family: Arial, sans-serif; }\n.verdana { font-family: Verdana, sans-serif; }\n.tahoma { font-family: Tahoma, sans-serif; }\n\n/* Serif 계열 */\n.times { font-family: \"Times New Roman\", serif; }\n.georgia { font-family: Georgia, serif; }\n\n/* Monospace 계열 */\n.courier { font-family: \"Courier New\", monospace; \n```",
      "difficulty": "easy",
      "created_at": "2025-08-09T19:49:48.000Z"
    },
    {
      "id": 1177,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 가장 안전한 마지막 fallback은?\n```css\np {\n    font-family: Tahoma, Verdana, ______;\n}\n```",
      "option_a": "Arial",
      "option_b": "Helvetica",
      "option_c": "sans-serif",
      "option_d": "\"Times New Roman\"",
      "correct_answer": "C",
      "explanation": "fallback 폰트 목록의 마지막에는 항상 제네릭 폰트 패밀리를 사용해야 합니다.\n\nfallback 시스템의 원리:\n1. Tahoma → 첫 번째 선택 폰트\n2. Verdana → Tahoma가 없을 때 대체\n3. sans-serif → 위 폰트들이 모두 없을 때 브라우저가 적절한 Sans-serif 폰트 선택",
      "difficulty": "easy",
      "created_at": "2025-08-09T19:51:02.000Z"
    },
    {
      "id": 1178,
      "subject_id": 9,
      "question": "다음 중 코딩 화면이나 데이터 표시에 가장 적합한 웹 안전 폰트는?",
      "option_a": "Arial",
      "option_b": "Georgia",
      "option_c": "Courier New",
      "option_d": "Brush Script MT",
      "correct_answer": "C",
      "explanation": "Courier New는 대표적인 웹 안전 monospace 폰트로, 코딩이나 데이터 표시에 가장 적합합니다.\n\nCourier New의 특징:\n• Monospace 폰트: 모든 글자가 동일한 너비\n• 코딩에 최적: 들여쓰기와 정렬이 정확\n• 가독성: 숫자와 문자 구분이 명확\n• 범용성: 가장 널리 사용되는 monospace 폰트\n\n실제 사용 예시:\n```css\n/* 코드 블록 */\n.code-block {\n    font-family: \"Courier New\", monospace;\n    background-color: #f4f4f4;\n    border: 1px solid #ddd;\n    padding: 10px;\n    white-space: pre;  /* 공백과 줄바꿈 보존 */\n}\n\n/* 터미널 스타일 */\n.terminal {\n    font-family: \"Courier New\", monospace;\n    background-color: #000;\n    color: #0f0;\n    padding: 15px;\n}\n\n/* 데이터 테이블 */\n.data-table td {\n    font-family: \"Courier New\", monospace;\n    text-align: right;  /* 숫자 정렬 */\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-09T19:52:27.000Z"
    },
    {
      "id": 1179,
      "subject_id": 9,
      "question": "텍스트를 기울임꼴(이탤릭)로 표시하고 싶을 때 사용하는 CSS 속성은?",
      "option_a": "font-weight",
      "option_b": "font-style",
      "option_c": "font-variant",
      "option_d": "font-family",
      "correct_answer": "B",
      "explanation": "텍스트의 기울임 정도를 조절하는 속성은 font-style입니다. font-style: italic으로 설정하면 텍스트가 기울임꼴로 표시됩니다. font-weight는 굵기, font-variant는 대소문자 변형, font-family는 글꼴 종류를 다루는 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T06:56:18.000Z"
    },
    {
      "id": 1180,
      "subject_id": 9,
      "question": "다음 중 font-style 속성의 값이 아닌 것은?",
      "option_a": "normal",
      "option_b": "italic",
      "option_c": "oblique",
      "option_d": "bold",
      "correct_answer": "D",
      "explanation": "font-style 속성은 텍스트의 기울임을 제어하므로 normal(보통), italic(이탤릭), oblique(경사)의 세 가지 값만 가질 수 있습니다. bold는 font-weight 속성의 값으로, 텍스트를 굵게 만들 때 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T06:56:45.000Z"
    },
    {
      "id": 1181,
      "subject_id": 9,
      "question": "font-variant: small-caps 속성의 효과로 올바른 것은?",
      "option_a": "모든 글자를 대문자로 변환한다",
      "option_b": "모든 글자를 소문자로 변환한다",
      "option_c": "소문자를 작은 크기의 대문자로 변환한다",
      "option_d": "글자 크기를 작게 만든다",
      "correct_answer": "C",
      "explanation": "font-variant: small-caps는 소문자를 대문자로 변환하되, 원래 대문자보다 작은 크기로 표시합니다. 예를 들어 \"Hello World\"가 \"HELLO WORLD\"로 변환되지만, 원래 소문자였던 부분(ello, orld)은 원래 대문자(H, W)보다 작게 표시됩니다. 이는 시각적으로 우아한 효과를 만들어냅니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T06:57:21.000Z"
    },
    {
      "id": 1182,
      "subject_id": 9,
      "question": "다음 CSS 코드를 분석했을 때, 결과적으로 텍스트에 적용되지 않는 효과는?\n```css\n.special-text {\n    font-style: italic;\n    font-weight: bold;  \n    font-variant: small-caps;\n    font-style: normal;\n}\n```",
      "option_a": "굵은 글씨 효과",
      "option_b": "기울임꼴 효과",
      "option_c": "소문자의 작은 대문자 변환 효과",
      "option_d": "모든 효과가 적용된다",
      "correct_answer": "B",
      "explanation": "CSS에서 같은 속성이 여러 번 선언되면 나중에 선언된 값이 이전 값을 덮어씁니다. 따라서 font-style: italic이 먼저 선언되었지만, 마지막에 font-style: normal이 선언되어 기울임꼴 효과가 취소됩니다. 결과적으로 텍스트는 굵은 글씨(font-weight: bold)와 작은 대문자 변환(font-variant: small-caps) 효과만 적용되고, 기울임꼴은 적용되지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T06:59:25.000Z"
    },
    {
      "id": 1183,
      "subject_id": 9,
      "question": "브라우저의 기본 텍스트 크기(paragraph 등)는 몇 픽셀인가요?",
      "option_a": "12px",
      "option_b": "14px",
      "option_c": "16px",
      "option_d": "18px",
      "correct_answer": "C",
      "explanation": "대부분의 브라우저에서 기본 텍스트 크기는 16px로 설정되어 있습니다. 이는 1em과 같은 값이기도 합니다. 즉, 16px = 1em이라는 기준이 됩니다. 이 기본값을 알아두면 em 단위로 계산할 때 매우 유용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T07:01:07.000Z"
    },
    {
      "id": 1184,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 속성명은?\n```css\nh1 {\n    font-_____: 24px;\n}\n```",
      "option_a": "weight",
      "option_b": "style",
      "option_c": "size",
      "option_d": "family",
      "correct_answer": "C",
      "explanation": "글자 크기를 조절하는 속성은 font-size입니다. 이 속성으로 픽셀(px), em, 퍼센트(%) 등 다양한 단위를 사용해 텍스트 크기를 설정할 수 있습니다. font-weight는 굵기, font-style은 기울임, font-family는 글꼴 종류를 다루는 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T07:01:50.000Z"
    },
    {
      "id": 1185,
      "subject_id": 9,
      "question": "1em이 16px일 때, 24px을 em 단위로 올바르게 변환한 값은?",
      "option_a": "1.2em",
      "option_b": "1.5em",
      "option_c": "2em",
      "option_d": "2.4em",
      "correct_answer": "B",
      "explanation": "em 단위 계산 공식은 \"픽셀 ÷ 16 = em\"입니다. 따라서 24px을 em으로 변환하면 24 ÷ 16 = 1.5em이 됩니다. em 단위는 상대적 크기로, 사용자가 브라우저에서 텍스트 크기를 조절할 수 있어 접근성 측면에서 유리합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T07:03:33.000Z"
    },
    {
      "id": 1186,
      "subject_id": 9,
      "question": "반응형 웹에서 브라우저 창 크기에 따라 글자 크기가 자동으로 조절되게 하려면 어떤 단위를 사용해야 하나요?",
      "option_a": "px",
      "option_b": "em",
      "option_c": "%",
      "option_d": "vw",
      "correct_answer": "D",
      "explanation": "vw(viewport width) 단위는 뷰포트(브라우저 창) 너비의 백분율을 나타냅니다. 1vw는 뷰포트 너비의 1%를 의미하므로, 브라우저 창 크기가 변할 때마다 글자 크기도 자동으로 조절됩니다. 예를 들어 font-size: 5vw로 설정하면 창이 커질수록 글자도 커지고, 창이 작아질수록 글자도 작아집니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T07:04:17.000Z"
    },
    {
      "id": 1187,
      "subject_id": 9,
      "question": "다음 CSS 코드에서 모든 브라우저 호환성과 사용자 텍스트 크기 조절을 모두 지원하는 가장 적절한 방식은?\n```css\n/* 방법 A */\nh1 { font-size: 40px; }\n\n/* 방법 B */  \nh1 { font-size: 2.5em; }\n\n/* 방법 C */\nbody { font-size: 100%; }\nh1 { font-size: 2.5em; }\n\n/* 방법 D */\nh1 { font-size: 250%; }\n```",
      "option_a": "방법 A",
      "option_b": "방법 B",
      "option_c": "방법 C",
      "option_d": "방법 D",
      "correct_answer": "C",
      "explanation": "방법 C가 가장 이상적인 해결책입니다. body에 font-size: 100%를 설정하면 브라우저의 기본 크기를 그대로 사용하면서도, h1에 2.5em을 적용하여 상대적 크기 조절이 가능합니다",
      "difficulty": "hard",
      "created_at": "2025-08-10T07:05:37.000Z"
    },
    {
      "id": 1188,
      "subject_id": 9,
      "question": "Google Fonts를 사용하기 위해 HTML 문서의 어느 부분에 링크를 추가해야 하나요?",
      "option_a": "`<body>` 태그 안",
      "option_b": "`<head>` 태그 안",
      "option_c": "`<footer>` 태그 안",
      "option_d": "`<main>` 태그 안",
      "correct_answer": "B",
      "explanation": "Google Fonts를 사용하려면 HTML 문서의 `<head>` 섹션에 특별한 스타일시트 링크를 추가해야 합니다. `<head>` 태그는 문서의 메타데이터와 외부 리소스를 정의하는 곳이므로, 폰트와 같은 외부 스타일시트는 반드시 이곳에 위치해야 합니다. 브라우저가 페이지를 렌더링하기 전에 필요한 폰트를 미리 로드할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T07:08:54.000Z"
    },
    {
      "id": 1189,
      "subject_id": 9,
      "question": "다음 코드의 빈칸에 들어갈 올바른 태그는?\n```html\n<head>\n<_____ rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Sofia\">\n</head>\n```",
      "option_a": "style",
      "option_b": "script",
      "option_c": "link",
      "option_d": "meta",
      "correct_answer": "C",
      "explanation": "외부 스타일시트를 연결할 때는 `<link>` 태그를 사용합니다. `rel=\"stylesheet\"`는 링크된 파일이 스타일시트임을 나타내고, `href` 속성에는 Google Fonts의 CSS 파일 URL을 지정합니다. `<style>` 태그는 내부 CSS를 작성할 때, `<script>`는 JavaScript를 위해, `<meta>`는 메타데이터를 위해 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T07:10:27.000Z"
    },
    {
      "id": 1190,
      "subject_id": 9,
      "question": "Google Font를 CSS에서 사용할 때 반드시 포함해야 하는 것은?\n```css\nbody {\n    font-family: \"Sofia\", _______;\n}\n```",
      "option_a": "bold",
      "option_b": "sans-serif",
      "option_c": "16px",
      "option_d": "normal",
      "correct_answer": "B",
      "explanation": "Google Font를 사용할 때는 반드시 fallback 폰트(대체 폰트)를 지정해야 합니다. 만약 Google Font가 로드되지 않거나 사용할 수 없는 상황에서 브라우저가 대신 사용할 수 있는 generic font family(serif, sans-serif, monospace 등)를 마지막에 추가해야 합니다. 이렇게 하면 예상치 못한 폰트 표시 문제를 방지할 수 있습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T07:11:50.000Z"
    },
    {
      "id": 1191,
      "subject_id": 9,
      "question": "여러 개의 Google Fonts를 한 번에 요청하려면 어떤 기호로 폰트 이름들을 구분해야 하나요?\n```html\n<link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Sofia____Audiowide____Trirong\">\n```",
      "option_a": ", (쉼표)",
      "option_b": "; (세미콜론)",
      "option_c": "| (파이프)",
      "option_d": "& (앰퍼샌드)",
      "correct_answer": "C",
      "explanation": "여러 Google Fonts를 동시에 요청할 때는 파이프 문자(|)로 폰트 이름들을 구분합니다. 예를 들어 `family=Sofia|Audiowide|Trirong`처럼 작성하면 세 개의 폰트를 한 번의 요청으로 가져올 수 있습니다. 하지만 너무 많은 폰트를 한 번에 요청하면 웹페이지 로딩 속도가 느려질 수 있으므로 주의해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T07:13:04.000Z"
    },
    {
      "id": 1192,
      "subject_id": 9,
      "question": "다음 코드에서 실제로 화면에 표시될 폰트는 무엇인가요?\n```html\n<head>\n<link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Roboto|OpenSans\">\n<style>\n.text1 { font-family: \"Roboto\", Arial, sans-serif; }\n.text2 { font-family: \"Ubuntu\", \"Open Sans\", serif; }\n</style>\n</head>\n```",
      "option_a": "text1: Roboto, text2: Ubuntu",
      "option_b": "text1: Roboto, text2: Open Sans",
      "option_c": "text1: Arial, text2: serif",
      "option_d": "text1: Roboto, text2: serif",
      "correct_answer": "D",
      "explanation": "이 문제는 Google Fonts 로딩과 fallback 메커니즘을 이해하는 문제입니다. Google Fonts 링크에서는 \"Roboto\"와 \"OpenSans\"만 요청했습니다. text1은 \"Roboto\"가 성공적으로 로드되므로 Roboto 폰트로 표시됩니다. 하지만 text2에서 요청한 \"Ubuntu\"는 Google Fonts에서 로드되지 않았고, \"Open Sans\"도 링크에서는 \"OpenSans\"로 요청했지만 CSS에서는 \"Open Sans\"(공백 포함)로 작성되어 매치되지 않습니다. 따라서 마지막 fallback인 serif 폰트가 사용됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-10T07:14:53.000Z"
    },
    {
      "id": 1193,
      "subject_id": 9,
      "question": "다음 CSS 코드에서 어떤 폰트가 \"boss(주도적)\" 역할을 하고 있나요?\n```css\nbody {\n    font-family: Verdana, sans-serif;\n    font-size: 16px;\n    color: gray;\n}\nh1 {\n    font-family: ______, serif;\n    font-size: 60px;\n    color: white;\n}\n```",
      "option_a": "Verdana",
      "option_b": "sans-serif",
      "option_c": "빈칸에 들어갈 폰트",
      "option_d": "둘 다 동등한 역할",
      "correct_answer": "C",
      "explanation": "\"Choose Only One Boss\" 원칙에 따르면, 하나의 폰트가 주도적 역할을 해야 합니다. 이 코드에서 h1의 폰트는 크기(60px vs 16px), 색상(white vs gray), 폰트 타입(serif vs sans-serif)에서 모두 더 강조되어 있습니다. 따라서 h1에 사용된 폰트가 \"boss\" 역할을 하며, 이는 크기, 굵기, 색상을 통해 시각적 계층구조를 만드는 방법입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T07:18:02.000Z"
    },
    {
      "id": 1194,
      "subject_id": 9,
      "question": "CSS의 `font` 속성은 어떤 종류의 속성인가요?",
      "option_a": "개별 속성 (individual property)",
      "option_b": "축약 속성 (shorthand property)",
      "option_c": "상속 속성 (inherited property)",
      "option_d": "블록 속성 (block property)",
      "correct_answer": "B",
      "explanation": "`font` 속성은 여러 개의 개별 폰트 속성들을 하나로 묶어서 사용할 수 있는 축약 속성입니다. font-style, font-variant, font-weight, font-size, line-height, font-family 등을 한 번에 설정할 수 있어 코드를 간결하게 만들어줍니다. 축약 속성을 사용하면 코딩 시간을 단축하고 CSS 파일 크기도 줄일 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T07:44:17.000Z"
    },
    {
      "id": 1195,
      "subject_id": 9,
      "question": "`font` 축약 속성을 사용할 때 반드시 포함해야 하는 두 가지 값은?",
      "option_a": "font-size와 font-style",
      "option_b": "font-family와 font-weight",
      "option_c": "font-size와 font-family",
      "option_d": "font-variant와 font-size",
      "correct_answer": "C",
      "explanation": "`font` 축약 속성을 사용할 때는 font-size와 font-family 값이 반드시 필요합니다. 이 두 값이 없으면 CSS가 올바르게 작동하지 않습니다. 나머지 속성들(font-style, font-variant, font-weight, line-height)은 선택사항이며, 생략하면 기본값이 사용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T07:45:14.000Z"
    },
    {
      "id": 1196,
      "subject_id": 9,
      "question": "다음 두 CSS 코드 중 어느 것이 올바른 font 축약 속성 사용법인가요?\n```css\n/* 코드 A */\np.a { font: Arial 16px bold; }\n\n/* 코드 B */\np.b { font: bold 16px Arial; }\n```",
      "option_a": "코드 A만 올바름",
      "option_b": "코드 B만 올바름",
      "option_c": "둘 다 올바름",
      "option_d": "둘 다 틀림",
      "correct_answer": "B",
      "explanation": "font 축약 속성에서는 정해진 순서를 반드시 지켜야 합니다. 올바른 순서는 font-style, font-variant, font-weight, font-size, font-family입니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T07:46:28.000Z"
    },
    {
      "id": 1197,
      "subject_id": 9,
      "question": "HTML 페이지에 아이콘을 추가하는 가장 간단한 방법은?",
      "option_a": "이미지 파일을 다운로드해서 사용하기",
      "option_b": "아이콘 라이브러리 사용하기",
      "option_c": "CSS로 직접 그리기",
      "option_d": "JavaScript로 생성하기",
      "correct_answer": "B",
      "explanation": "아이콘 라이브러리(Font Awesome, Bootstrap Icons, Google Icons 등)를 사용하는 것이 가장 간단하고 효율적인 방법입니다. 라이브러리를 사용하면 다운로드나 설치 없이 CDN 링크만으로 수많은 아이콘을 사용할 수 있습니다. 또한 이러한 아이콘들은 벡터 형태라서 크기 조절이 자유롭고, CSS로 색상이나 효과를 쉽게 변경할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T07:49:11.000Z"
    },
    {
      "id": 1198,
      "subject_id": 9,
      "question": "다음 코드의 빈칸에 들어갈 올바른 태그는?\n```html\n<head>\n<_____ rel=\"stylesheet\" href=\"https://fonts.googleapis.com/icon?family=Material+Icons\">\n</head>\n```",
      "option_a": "script",
      "option_b": "link",
      "option_c": "style",
      "option_d": "meta",
      "correct_answer": "B",
      "explanation": "외부 CSS 파일이나 아이콘 라이브러리를 연결할 때는 `<link>` 태그를 사용합니다. `rel=\"stylesheet\"`는 연결되는 파일이 스타일시트임을 나타내고, href 속성에는 외부 리소스의 URL을 지정합니다. \n\nGoogle Icons, Bootstrap Icons 등은 모두 CSS 기반이므로 `<link>` 태그로 연결합니다. Font Awesome의 경우에만 `<script>` 태그를 사용합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T07:50:23.000Z"
    },
    {
      "id": 1199,
      "subject_id": 9,
      "question": "다음 HTML 코드에서 실제로 표시되는 아이콘은 몇 개인가요?\n```html\n<head>\n<script src=\"https://kit.fontawesome.com/a076d05399.js\"></script>\n<link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/icon?family=Material+Icons\">\n</head>\n<body>\n<i class=\"fas fa-heart\"></i>\n<i class=\"material-icons\">favorite</i>\n<i class=\"glyphicon glyphicon-user\"></i>\n<i class=\"fas fa-car\"></i>\n<i class=\"material-icons\">computer</i>\n</body>\n```",
      "option_a": "2개",
      "option_b": "3개",
      "option_c": "4개",
      "option_d": "5개",
      "correct_answer": "C",
      "explanation": "이 코드에서는 Font Awesome과 Google Material Icons 라이브러리만 연결되어 있습니다. 따라서:\n\n• `<i class=\"fas fa-heart\"></i>` ✓ (Font Awesome)\n• `<i class=\"material-icons\">favorite</i>` ✓ (Google Icons)\n• `<i class=\"glyphicon glyphicon-user\"></i>` ✗ (Bootstrap 라이브러리가 없음)\n• `<i class=\"fas fa-car\"></i>` ✓ (Font Awesome)\n• `<i class=\"material-icons\">computer</i>` ✓ (Google Icons)\n\nBootstrap Icons를 사용하려면 Bootstrap CSS 라이브러리를 추가로 연결해야 하는데, 이 코드에는 Bootstrap 라이브러리가 없으므로 glyphicon은 표시되지 않습니다. 따라서 총 4개의 아이콘만 표시됩니다.",
      "difficulty": "hard",
      "created_at": "2025-08-10T07:52:18.000Z"
    },
    {
      "id": 1200,
      "subject_id": 9,
      "question": "CSS에서 링크의 네 가지 상태가 아닌 것은?",
      "option_a": "a:link",
      "option_b": "a:visited",
      "option_c": "a:hover",
      "option_d": "a:focus",
      "correct_answer": "D",
      "explanation": "CSS에서 링크의 기본적인 네 가지 상태는 a:link(방문하지 않은 링크), a:visited(방문한 링크), a:hover(마우스를 올렸을 때), a:active(클릭하는 순간)입니다. \n\na:focus는 키보드 탐색 등에서 사용되는 상태이지만, 기본적인 네 가지 링크 상태에는 포함되지 않습니다. 이 네 가지 상태를 이용해서 링크의 다양한 상호작용을 디자인할 수 있습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T07:54:47.000Z"
    },
    {
      "id": 1201,
      "subject_id": 9,
      "question": "링크에서 밑줄을 제거하려면 어떤 CSS 속성을 사용해야 하나요?\n```css\na {\n    _____: none;\n}\n```",
      "option_a": "text-decoration",
      "option_b": "text-underline",
      "option_c": "border-bottom",
      "option_d": "text-style",
      "correct_answer": "A",
      "explanation": "링크의 기본 밑줄을 제거하려면 `text-decoration: none;`을 사용합니다. \n\ntext-decoration 속성은 텍스트에 장식을 추가하거나 제거하는 속성으로, none은 모든 장식을 제거하고, underline은 밑줄을 추가합니다. \n\n링크는 기본적으로 text-decoration: underline이 적용되어 있어서 밑줄이 표시되는데, 이를 none으로 바꾸면 밑줄이 사라집니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T07:55:38.000Z"
    },
    {
      "id": 1202,
      "subject_id": 9,
      "question": "다음 CSS 코드에서 링크 상태 순서의 문제점은?\n```css\na:active { color: blue; }\na:hover { color: red; }\na:link { color: green; }\na:visited { color: purple; }\n```",
      "option_a": "순서가 완전히 잘못되었음",
      "option_b": "a:hover와 a:active의 순서가 바뀜",
      "option_c": "a:link와 a:visited의 순서가 바뀜",
      "option_d": "순서에 문제없음",
      "correct_answer": "A",
      "explanation": "링크 상태를 정의할 때는 반드시 올바른 순서를 지켜야 합니다. 올바른 순서는 a:link → a:visited → a:hover → a:active입니다. \n\n이 순서를 지키지 않으면 CSS의 특정성 규칙에 의해 일부 상태가 제대로 작동하지 않을 수 있습니다. \n\n특히 a:hover는 a:link와 a:visited 뒤에, a:active는 a:hover 뒤에 와야 합니다. 이는 \"LVHA\" 순서로 기억하면 됩니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T07:56:26.000Z"
    },
    {
      "id": 1203,
      "subject_id": 9,
      "question": "다음 CSS 코드에서 사용자가 링크를 클릭하는 순간 실제로 나타나는 스타일은?\n```css\na:link { color: red; background: yellow; }\na:visited { color: blue; background: green; }\na:hover { color: white; }\na:active { background: pink; }\n```\n가정: 사용자가 이전에 방문한 적이 있는 링크를 마우스로 클릭하는 상황",
      "option_a": "color: red, background: pink",
      "option_b": "color: blue, background: pink",
      "option_c": "color: white, background: pink",
      "option_d": "color: white, background: green",
      "correct_answer": "C",
      "explanation": "이 문제는 CSS의 특정성과 상속 규칙을 이해해야 합니다. 방문한 적이 있는 링크를 마우스로 클릭하는 순간에는 :visited, :hover, :active 상태가 모두 동시에 적용됩니다. \n\nCSS에서 나중에 선언된 속성이 우선순위를 가지므로:\n\n• color는 :hover에서 white로 설정됨 (:active에는 color 속성이 없음)\n• background는 :active에서 pink로 설정됨 (가장 나중에 선언됨)\n\n따라서 최종적으로 color: white, background: pink가 적용됩니다.\n",
      "difficulty": "hard",
      "created_at": "2025-08-10T07:58:04.000Z"
    },
    {
      "id": 1204,
      "subject_id": 9,
      "question": "CSS에서 리스트의 마커(불릿이나 숫자)를 완전히 제거하려면 어떤 속성값을 사용해야 하나요?",
      "option_a": "list-style-type: hidden",
      "option_b": "list-style-type: none",
      "option_c": "list-style-type: remove",
      "option_d": "list-style-type: invisible",
      "correct_answer": "B",
      "explanation": "리스트에서 불릿이나 숫자 마커를 제거하려면 `list-style-type: none;`을 사용합니다. \n\n이는 가장 기본적이고 자주 사용되는 방법으로, 순서 없는 리스트(ul)의 불릿이나 순서 있는 리스트(ol)의 숫자를 모두 제거합니다. 내비게이션 메뉴를 만들 때 특히 자주 사용되는 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:00:57.000Z"
    },
    {
      "id": 1205,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 속성은?\n```css\nul {\n    _____: square;\n}\n```",
      "option_a": "list-style-type",
      "option_b": "list-style-position",
      "option_c": "list-style-image",
      "option_d": "list-marker",
      "correct_answer": "A",
      "explanation": "마커의 종류를 설정하는 속성은 `list-style-type`입니다. \n\nsquare는 사각형 모양의 불릿을 만들며, 순서 없는 리스트에서 사용할 수 있는 값 중 하나입니다. \n\n다른 값들로는 circle(원), disc(기본 불릿) 등이 있습니다. \n\nlist-style-position은 마커의 위치를, list-style-image는 이미지 마커를 설정하는 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:01:46.000Z"
    },
    {
      "id": 1206,
      "subject_id": 9,
      "question": "`list-style-position: inside;`와 `list-style-position: outside;`의 차이점은?",
      "option_a": "inside는 마커가 텍스트 안쪽에, outside는 텍스트 바깥쪽에 위치",
      "option_b": "inside는 마커가 텍스트 바깥쪽에, outside는 텍스트 안쪽에 위치",
      "option_c": "inside는 마커 크기가 작아지고, outside는 마커 크기가 커짐",
      "option_d": "inside는 마커가 숨겨지고, outside는 마커가 표시됨",
      "correct_answer": "A",
      "explanation": "`list-style-position`은 마커의 위치를 조절합니다. \n\n`outside`(기본값)는 마커가 텍스트 영역 바깥쪽에 위치하여 텍스트가 수직으로 정렬됩니다. \n\n`inside`는 마커가 텍스트 영역 안쪽에 위치하여 마커도 텍스트의 일부가 되어 첫 번째 줄을 밀어냅니다. \n\n이는 레이아웃에 중요한 영향을 미치므로 디자인에 따라 적절히 선택해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:02:47.000Z"
    },
    {
      "id": 1207,
      "subject_id": 9,
      "question": "다음 코드에서 완전히 스타일이 제거된 리스트를 만들기 위해 빈칸에 들어가야 할 속성들은?\n```css\nul {\n    list-style-type: none;\n    _____: 0;\n    _____: 0;\n}\n```",
      "option_a": "width, height",
      "option_b": "margin, padding",
      "option_c": "border, outline",
      "option_d": "top, left",
      "correct_answer": "B",
      "explanation": "리스트에서 마커만 제거해도 브라우저 기본 스타일인 margin과 padding이 남아있어 들여쓰기가 유지됩니다. 완전히 깔끔한 리스트를 만들려면 `margin: 0; padding: 0;`을 추가해야 합니다. \n\n이는 내비게이션 메뉴나 커스텀 리스트를 만들 때 필수적인 단계입니다. \n\n이 세 속성(list-style-type: none, margin: 0, padding: 0)은 리스트 초기화의 기본 세트입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:03:46.000Z"
    },
    {
      "id": 1208,
      "subject_id": 9,
      "question": "다음 list-style 축약 속성 코드의 올바른 해석은?\n```css\nul {\n    list-style: circle inside url(\"bullet.png\");\n}\n```",
      "option_a": "마커: circle, 위치: inside, 이미지: bullet.png (이미지가 우선)",
      "option_b": "마커: circle, 위치: inside, 이미지: bullet.png (circle이 우선)",
      "option_c": "마커: url(\"bullet.png\"), 위치: inside, 백업: circle",
      "option_d": "마커: inside, 위치: circle, 이미지: bullet.png",
      "correct_answer": "C",
      "explanation": "list-style 축약 속성의 순서는 `list-style-type list-style-position list-style-image`입니다. \n\n이미지가 지정되면 이미지가 주 마커로 사용되고, list-style-type(circle)은 이미지를 로드할 수 없을 때의 백업 역할을 합니다. \n\n따라서 정상적으로는 bullet.png 이미지가 마커로 표시되고, 이미지 로딩에 실패하면 circle이 대신 표시됩니다. \n\ninside는 마커의 위치를 나타냅니다.",
      "difficulty": "hard",
      "created_at": "2025-08-10T08:04:56.000Z"
    },
    {
      "id": 1209,
      "subject_id": 9,
      "question": "HTML 테이블에 테두리를 추가하려면 어떤 CSS 속성을 사용해야 하나요?",
      "option_a": "outline",
      "option_b": "border",
      "option_c": "frame",
      "option_d": "edge",
      "correct_answer": "B",
      "explanation": "테이블에 테두리를 추가할 때는 `border` 속성을 사용합니다. 예를 들어 `border: 1px solid black;`처럼 작성하면 1픽셀 두께의 검은색 실선 테두리가 생성됩니다. 테이블, th(헤더 셀), td(데이터 셀) 요소 모두에 개별적으로 border를 적용할 수 있습니다. \n\noutline은 요소 바깥쪽 윤곽선, frame과 edge는 CSS 속성이 아닙니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:08:31.000Z"
    },
    {
      "id": 1210,
      "subject_id": 9,
      "question": "테이블을 화면 전체 너비로 만들기 위한 CSS 코드의 빈칸은?\n```css\ntable {\n    _____: 100%;\n}\n```",
      "option_a": "height",
      "option_b": "width",
      "option_c": "size",
      "option_d": "scale",
      "correct_answer": "B",
      "explanation": "테이블을 화면 전체 너비로 확장하려면 `width: 100%;`를 사용합니다. width 속성은 요소의 가로 크기를 설정하며, 100%는 부모 요소의 전체 너비를 의미합니다. 이렇게 하면 테이블이 브라우저 창의 너비에 맞춰 늘어나게 됩니다. \n\nheight는 세로 크기, size와 scale은 CSS에서 테이블 크기 조절에 사용되지 않는 속성입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:09:18.000Z"
    },
    {
      "id": 1211,
      "subject_id": 9,
      "question": "다음 CSS를 적용했을 때 테이블에 나타나는 문제점은?\n```css\ntable, th, td {\n    border: 1px solid black;\n}\n```",
      "option_a": "테두리가 표시되지 않음",
      "option_b": "테두리가 이중으로 표시됨",
      "option_c": "테두리 색상이 변경됨",
      "option_d": "테이블이 깨짐",
      "correct_answer": "B",
      "explanation": "table, th, td 요소에 각각 border를 적용하면 인접한 셀들 사이에 테두리가 겹쳐서 이중 테두리가 나타납니다. 이는 각 요소가 독립적인 테두리를 가지고 있기 때문입니다. 예를 들어 두 개의 인접한 셀이 각각 1px 테두리를 가지면, 그 사이는 2px 두께로 보이게 됩니다. \n\n이 문제를 해결하려면 border-collapse 속성을 사용해야 합니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:13:06.000Z"
    },
    {
      "id": 1212,
      "subject_id": 9,
      "question": "이중 테두리 문제를 해결하기 위한 CSS 속성과 값은?\n```css\ntable {\n    border-_____: _____;\n}\n```",
      "option_a": "style, single",
      "option_b": "collapse, collapse",
      "option_c": "merge, true",
      "option_d": "double, false",
      "correct_answer": "B",
      "explanation": "이중 테두리를 단일 테두리로 만들려면 `border-collapse: collapse;`를 사용합니다. 이 속성은 인접한 셀들의 테두리를 하나로 합쳐서 깔끔한 테이블을 만들어줍니다. collapse는 \"축소하다, 합치다\"라는 의미로, 겹치는 테두리들을 하나로 합쳐주는 역할을 합니다. 이는 테이블 스타일링에서 가장 중요한 속성 중 하나입니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:14:02.000Z"
    },
    {
      "id": 1213,
      "subject_id": 9,
      "question": "다음 세 가지 CSS 코드의 결과로 나타나는 테두리의 차이점을 올바르게 설명한 것은?\n```css\n/* 코드 A */\ntable, th, td { border: 1px solid; }\n\n/* 코드 B */\ntable { border-collapse: collapse; }\ntable, th, td { border: 1px solid; }\n\n/* 코드 C */\ntable { border: 1px solid; }\n```",
      "option_a": "A: 이중테두리, B: 단일테두리, C: 테이블만 테두리",
      "option_b": "A: 단일테두리, B: 이중테두리, C: 전체 테두리",
      "option_c": "A: 테두리 없음, B: 이중테두리, C: 단일테두리",
      "option_d": "모두 동일한 결과",
      "correct_answer": "A",
      "explanation": "코드 A는 table, th, td 모든 요소에 테두리를 적용하지만 border-collapse가 없어서 이중 테두리가 나타납니다. \n\n코드 B는 border-collapse: collapse로 인해 겹치는 테두리들이 하나로 합쳐져 깔끔한 단일 테두리가 됩니다. \n\n코드 C는 table 요소에만 테두리를 적용했으므로 테이블 전체 외곽에만 테두리가 나타나고 개별 셀에는 테두리가 없습니다. \n\n이는 테이블 스타일링의 핵심 개념들을 보여주는 중요한 차이점입니다.",
      "difficulty": "hard",
      "created_at": "2025-08-10T08:15:42.000Z"
    },
    {
      "id": 1214,
      "subject_id": 9,
      "question": "테이블의 크기를 조절할 때 사용하는 두 가지 주요 CSS 속성은?",
      "option_a": "size와 scale",
      "option_b": "width와 height",
      "option_c": "length와 breadth",
      "option_d": "horizontal과 vertical",
      "correct_answer": "B",
      "explanation": "테이블 크기 조절의 핵심 속성:\n\n• width: 테이블의 가로 너비를 설정\n• height: 테이블의 세로 높이를 설정\n• 픽셀(px), 퍼센트(%), em 등 다양한 단위 사용 가능\n• 테이블뿐만 아니라 th, td 요소에도 개별 적용 가능\n\n나머지 선택지들은 CSS에서 테이블 크기 조절에 사용되지 않는 속성들입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:21:43.000Z"
    },
    {
      "id": 1215,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 값은?\n```css\ntable {\n    width: _____;\n}\n```\n페이지 전체 너비로 테이블을 만들고 싶을 때",
      "option_a": "100px",
      "option_b": "100%",
      "option_c": "full",
      "option_d": "auto",
      "correct_answer": "B",
      "explanation": "페이지 전체 너비 설정 방법:\n\n• 100%: 부모 요소의 전체 너비를 차지\n• 반응형: 브라우저 창 크기에 따라 자동 조절\n• 유연성: 다양한 화면 크기에 적응\n\n다른 선택지 분석:\n\n• 100px: 고정 크기로 작은 테이블이 됨\n• full: CSS에서 유효하지 않은 값\n• auto: 콘텐츠에 맞춰 자동 조절 (전체 너비 아님)",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:22:34.000Z"
    },
    {
      "id": 1216,
      "subject_id": 9,
      "question": "다음 코드에서 테이블 헤더의 높이를 50픽셀로 설정하는 올바른 CSS는?\n```css\ntable {\n    width: 100%;\n}\n_____ {\n    _____: 50px;\n}\n```",
      "option_a": "th, height",
      "option_b": "td, height",
      "option_c": "table, height",
      "option_d": "tr, height",
      "correct_answer": "A",
      "explanation": "테이블 헤더 높이 설정:\n\n• th 요소: 테이블 헤더 셀을 의미\n• height 속성: 세로 높이를 픽셀 단위로 설정\n• 결과: 모든 헤더 행이 동일한 높이를 가짐\n\n다른 요소들과의 차이:\n\n• td: 일반 데이터 셀 (헤더가 아님)\n• table: 전체 테이블 높이\n• tr: 행 전체 (th보다 덜 구체적)",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:23:47.000Z"
    },
    {
      "id": 1217,
      "subject_id": 9,
      "question": "페이지의 절반 너비를 차지하는 테이블을 만들려면?\n```css\ntable {\n    width: _____;\n}\n```",
      "option_a": "50px",
      "option_b": "50%",
      "option_c": "half",
      "option_d": "0.5",
      "correct_answer": "B",
      "explanation": "페이지 절반 너비 설정:\n\n• 50%: 부모 요소 너비의 절반\n• 유연한 크기: 화면 크기에 비례하여 조절\n• 반응형 디자인: 모바일과 데스크톱에서 모두 적절한 비율 유지\n\n다른 값들의 문제점:\n\n• 50px: 고정 크기로 너무 작음\n• half: CSS에서 인식되지 않는 값\n• 0.5: 부모 요소의 0.5픽셀 (거의 보이지 않음)",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:24:49.000Z"
    },
    {
      "id": 1218,
      "subject_id": 9,
      "question": "다음 CSS 코드가 적용된 테이블의 최종 모습은?\n```css\ntable {\n    width: 80%;\n}\nth {\n    height: 60px;\n}\ntd {\n    height: 40px;\n}\n```",
      "option_a": "전체 페이지 너비, 모든 셀 높이 60px",
      "option_b": "페이지 80% 너비, 헤더 60px, 데이터 셀 40px 높이",
      "option_c": "페이지 80% 너비, 모든 셀 높이 40px",
      "option_d": "전체 페이지 너비, 헤더 60px, 데이터 셀 40px 높이",
      "correct_answer": "B",
      "explanation": "각 CSS 규칙의 적용 결과:\n\n테이블 너비 (width: 80%):\n• 부모 요소의 80% 너비를 차지\n• 좌우로 10%씩 여백이 생김\n\n헤더 높이 (th height: 60px):\n• 테이블 헤더 셀들이 60픽셀 높이\n• 제목 행이 더 큰 높이로 강조됨\n\n데이터 셀 높이 (td height: 40px):\n• 일반 데이터 셀들이 40픽셀 높이\n• 헤더보다 낮아서 시각적 계층 구조 형성\n\n전체적인 효과:\n• 적당한 너비로 읽기 편함\n• 헤더와 데이터 셀의 높이 차이로 구분이 명확함",
      "difficulty": "hard",
      "created_at": "2025-08-10T08:26:41.000Z"
    },
    {
      "id": 1219,
      "subject_id": 9,
      "question": "테이블 셀의 수평 정렬을 조절하는 CSS 속성은?",
      "option_a": "horizontal-align",
      "option_b": "text-align",
      "option_c": "cell-align",
      "option_d": "align-horizontal",
      "correct_answer": "B",
      "explanation": "테이블 셀의 수평 정렬 제어:\n\n• text-align: 셀 내용의 가로 정렬을 설정\n• 주요 값들: left(왼쪽), center(가운데), right(오른쪽)\n• 적용 대상: th(헤더 셀), td(데이터 셀) 모두 가능\n• 기본값: th는 center, td는 left\n\n나머지 선택지들은 실제 CSS 속성이 아니거나 테이블 정렬과 관련이 없습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:30:48.000Z"
    },
    {
      "id": 1220,
      "subject_id": 9,
      "question": "테이블의 기본 정렬 상태로 올바른 것은?",
      "option_a": "th: 왼쪽 정렬, td: 가운데 정렬",
      "option_b": "th: 가운데 정렬, td: 왼쪽 정렬",
      "option_c": "th: 오른쪽 정렬, td: 가운데 정렬",
      "option_d": "th: 왼쪽 정렬, td: 오른쪽 정렬",
      "correct_answer": "B",
      "explanation": "브라우저의 기본 테이블 정렬:\n\n헤더 셀 (th):\n• 기본값: center (가운데 정렬)\n• 이유: 헤더는 열의 제목이므로 시각적으로 강조\n\n데이터 셀 (td):\n• 기본값: left (왼쪽 정렬)\n• 이유: 텍스트 읽기에 가장 자연스러운 정렬\n\n실용적 팁:\n• 숫자 데이터는 보통 right 정렬 사용\n• 텍스트 데이터는 left 정렬이 읽기 편함",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:31:35.000Z"
    },
    {
      "id": 1221,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 값은?\n```css\ntd {\n    text-align: _____;\n}\n```\n모든 데이터 셀을 가운데 정렬하고 싶을 때",
      "option_a": "middle",
      "option_b": "center",
      "option_c": "central",
      "option_d": "mid",
      "correct_answer": "B",
      "explanation": "text-align의 수평 정렬 값들:\n\n유효한 값들:\n• left: 왼쪽 정렬\n• center: 가운데 정렬 ✓\n• right: 오른쪽 정렬\n• justify: 양쪽 정렬\n\n주의사항:\n• middle은 vertical-align의 값 (세로 정렬용)\n• central, mid는 CSS에서 유효하지 않은 값\n\n실무 활용:\n• 제품 이미지나 아이콘: center 정렬\n• 숫자나 가격: right 정렬\n• 일반 텍스트: left 정렬",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:32:35.000Z"
    },
    {
      "id": 1222,
      "subject_id": 9,
      "question": "테이블 셀의 세로 정렬을 조절하는 CSS 속성과 기본값은?\n```css\ntd {\n    _____: _____;\n}\n```",
      "option_a": "vertical-align, top",
      "option_b": "vertical-align, middle",
      "option_c": "text-align, center",
      "option_d": "align-vertical, middle",
      "correct_answer": "B",
      "explanation": "세로 정렬의 핵심 개념:\n\nvertical-align 속성:\n• 테이블 셀의 세로 정렬 제어\n• th와 td 모두에 적용 가능\n\n주요 값들:\n• top: 셀 상단에 정렬\n• middle: 셀 가운데 정렬 (기본값)\n• bottom: 셀 하단에 정렬\n\n기본값이 middle인 이유:\n• 다양한 높이의 셀에서 가장 균형 잡힌 외관\n• 텍스트와 이미지가 섞여 있을 때 자연스러운 배치",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:33:51.000Z"
    },
    {
      "id": 1223,
      "subject_id": 9,
      "question": "다음 CSS 코드가 적용된 테이블 셀의 최종 정렬 상태는?\n```css\nth {\n    text-align: left;\n    vertical-align: top;\n    height: 60px;\n}\ntd {\n    text-align: center;\n    vertical-align: bottom;\n    height: 40px;\n}\n```",
      "option_a": "헤더: 왼쪽상단, 데이터: 가운데하단",
      "option_b": "헤더: 가운데상단, 데이터: 왼쪽하단",
      "option_c": "헤더: 왼쪽가운데, 데이터: 가운데가운데",
      "option_d": "헤더: 가운데하단, 데이터: 왼쪽상단",
      "correct_answer": "A",
      "explanation": "각 CSS 규칙의 최종 효과:\n\n헤더 셀 (th) 분석:\n• text-align: left → 수평으로 왼쪽 정렬\n• vertical-align: top → 수직으로 상단 정렬\n• height: 60px → 높은 셀에서 상단 정렬 효과 확실히 보임\n• 결과: 왼쪽 상단 정렬\n\n데이터 셀 (td) 분석:\n• text-align: center → 수평으로 가운데 정렬\n• vertical-align: bottom → 수직으로 하단 정렬\n• height: 40px → 적당한 높이에서 하단 정렬\n• 결과: 가운데 하단 정렬\n\n실무에서의 활용:\n• 헤더를 상단 정렬하면 데이터와 명확히 구분\n• 숫자 데이터를 하단 정렬하면 소수점 맞춤 효과\n• 높이가 다른 셀들 간의 시각적 일관성 확보",
      "difficulty": "hard",
      "created_at": "2025-08-10T08:34:51.000Z"
    },
    {
      "id": 1224,
      "subject_id": 9,
      "question": "테이블 셀의 내용과 테두리 사이의 공간을 조절하는 CSS 속성은?",
      "option_a": "margin",
      "option_b": "padding",
      "option_c": "spacing",
      "option_d": "gap",
      "correct_answer": "B",
      "explanation": "테이블 셀의 내부 여백 조절:\n\n• padding: 셀 내용과 테두리 사이의 공간\n• 적용 대상: th(헤더 셀), td(데이터 셀)\n• 효과: 텍스트가 테두리에 붙지 않아 가독성 향상\n• 예시: `padding: 15px;` → 모든 방향으로 15픽셀 여백\n\n다른 속성들과의 차이:\n\n• margin: 요소 외부 여백 (테이블에서는 셀 간격이 아님)\n• spacing, gap: CSS에서 테이블 패딩과 관련 없는 속성",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:38:44.000Z"
    },
    {
      "id": 1225,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 속성은?\n```css\nth, td {\n    _____: 1px solid #ddd;\n}\n```\n테이블에 수평선(가로줄)을 추가하고 싶을 때",
      "option_a": "border-top",
      "option_b": "border-bottom",
      "option_c": "border-left",
      "option_d": "border-right",
      "correct_answer": "B",
      "explanation": "테이블 수평선 생성 방법:\n\n• border-bottom: 셀 하단에 테두리 추가\n• 결과: 각 행 아래에 구분선이 생김\n• 시각적 효과: 데이터를 행별로 명확히 구분\n\n다른 border 방향들:\n\n• border-top: 셀 상단 테두리 (일반적이지 않음)\n• border-left/right: 세로 구분선 (수평선과 다름)\n\n실무 팁:\n\n• `#ddd`처럼 연한 색상 사용으로 부드러운 구분\n• 모든 셀에 적용하여 일관된 디자인",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:39:43.000Z"
    },
    {
      "id": 1226,
      "subject_id": 9,
      "question": "마우스를 올렸을 때 테이블 행을 강조하려면 어떤 선택자를 사용해야 하나요?\n```css\n_____:_____ {\n    background-color: coral;\n}\n```",
      "option_a": "td, hover",
      "option_b": "table, hover",
      "option_c": "tr, hover",
      "option_d": "th, hover",
      "correct_answer": "C",
      "explanation": "호버 효과의 구성 요소:\n\ntr 요소 선택 이유:\n• tr: 테이블의 행(row) 전체를 나타냄\n• 전체 행 강조: 한 행의 모든 셀이 함께 강조됨\n• 사용자 경험: 데이터 행을 따라가기 쉬워짐\n\n:hover 가상 클래스:\n• 마우스 포인터가 요소 위에 있을 때 활성화\n• 인터랙티브한 사용자 경험 제공\n\n다른 선택자들의 문제점:\n• td:hover: 개별 셀만 강조 (행 전체 아님)\n• table:hover: 테이블 전체 강조 (너무 광범위)\n• th:hover: 헤더만 강조 (데이터 행과 무관)",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:40:47.000Z"
    },
    {
      "id": 1227,
      "subject_id": 9,
      "question": "줄무늬 테이블(zebra-striped table)을 만들기 위한 CSS 선택자는?\n```css\ntr:_____(____) {\n    background-color: #f2f2f2;\n}\n```",
      "option_a": "nth-child, odd",
      "option_b": "nth-child, even",
      "option_c": "last-child, 2",
      "option_d": "first-child, even",
      "correct_answer": "B",
      "explanation": "줄무늬 테이블 생성 원리:\n\nnth-child() 선택자:\n• 특정 순서의 자식 요소를 선택\n• 패턴을 만들어 시각적 구분 효과\n\neven과 odd의 차이:\n• even: 짝수 번째 행 (2, 4, 6번째...)\n• odd: 홀수 번째 행 (1, 3, 5번째...)\n• 둘 중 하나만 사용해도 줄무늬 효과 생성\n\n시각적 효과:\n• 교대로 나타나는 배경색\n• 긴 테이블에서 행 구분이 쉬워짐\n• 데이터 읽기 오류 방지",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:41:58.000Z"
    },
    {
      "id": 1228,
      "subject_id": 9,
      "question": "반응형 테이블이란 무엇인가요?",
      "option_a": "자동으로 색상이 변하는 테이블",
      "option_b": "화면 크기에 따라 가로 스크롤바가 나타나는 테이블",
      "option_c": "클릭할 수 있는 인터랙티브 테이블",
      "option_d": "데이터가 자동으로 업데이트되는 테이블",
      "correct_answer": "B",
      "explanation": "반응형 테이블의 핵심 개념:\n\n• 목적: 작은 화면에서 테이블 내용을 모두 볼 수 있게 함\n• 동작 원리: 화면이 테이블보다 작을 때 수평 스크롤 제공\n• 사용자 경험: 모든 데이터에 접근 가능하면서 레이아웃 파괴 방지\n• 모바일 친화적: 스마트폰, 태블릿에서 특히 유용",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:45:18.000Z"
    },
    {
      "id": 1229,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 속성은?\n```css\ndiv {\n    _____: auto;\n}\n```\n테이블을 반응형으로 만들기 위해 컨테이너에 적용할 때",
      "option_a": "overflow-y",
      "option_b": "overflow-x",
      "option_c": "scroll",
      "option_d": "display",
      "correct_answer": "B",
      "explanation": "overflow-x 속성의 역할:\n• x축 오버플로우 제어: 가로 방향 넘침 처리\n• auto 값: 필요할 때만 스크롤바 표시\n• 반응형 핵심: 테이블이 컨테이너보다 넓을 때 스크롤 생성\n\n다른 속성들과의 차이:\n• overflow-y: 세로 방향 스크롤 (테이블 반응형과 무관)\n• scroll: 항상 스크롤바 표시 (불필요할 때도)\n• display: 요소 표시 방식 변경 (오버플로우와 무관)\n\n실무 팁:\n• `overflow-x: auto`는 가장 일반적인 반응형 테이블 구현법\n• 스크롤바가 필요할 때만 나타나므로 깔끔한 디자인",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:46:42.000Z"
    },
    {
      "id": 1230,
      "subject_id": 9,
      "question": "반응형 테이블을 만들기 위한 올바른 HTML 구조는?",
      "option_a": "`<table style=\"overflow-x:auto\">...</table>`",
      "option_b": "`<div style=\"overflow-x:auto\"><table>...</table></div>`",
      "option_c": "`<table><div style=\"overflow-x:auto\">...</div></table>`",
      "option_d": "`<div><table style=\"overflow-x:auto\">...</table></div>`",
      "correct_answer": "B",
      "explanation": "컨테이너 div 필요성:\n• table 요소 특성: 기본적으로 overflow 속성이 제대로 작동하지 않음\n• wrapper div: table을 감싸는 컨테이너가 overflow 제어\n• 계층 구조: div(컨테이너) → table(내용)\n\n다른 구조들의 문제점:\n• 1번: table에 직접 적용 - 브라우저에서 제대로 작동하지 않음\n• 3번: table 내부에 div - HTML 문법상 올바르지 않음\n• 4번: div에 overflow 속성 없음 - 반응형 효과 없음\n\n실제 구현 예시:\n```html\n<div style=\"overflow-x: auto;\">\n  <table>\n    <tr><th>Name</th><th>Data1</th><th>Data2</th></tr>\n    <tr><td>Item</td><td>Value</td><td>More</td></tr>\n  </table>\n</div>\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:48:26.000Z"
    },
    {
      "id": 1231,
      "subject_id": 9,
      "question": "다음 중 반응형 테이블의 스크롤바 동작으로 올바른 것은?\n```css\n.table-container {\n    overflow-x: auto;\n}\n```",
      "option_a": "항상 가로 스크롤바가 표시됨",
      "option_b": "테이블이 컨테이너보다 넓을 때만 가로 스크롤바 표시",
      "option_c": "세로 스크롤바만 표시됨",
      "option_d": "스크롤바가 전혀 표시되지 않음",
      "correct_answer": "B",
      "explanation": "overflow-x: auto의 동작 원리:\n\n조건부 스크롤바:\n\n• 자동 판단: 내용이 컨테이너보다 넓은지 체크\n• 필요시에만: 넘칠 때만 스크롤바 생성\n• 깔끔한 UI: 불필요한 스크롤바로 인한 공간 낭비 방지\n\n다양한 상황별 동작:\n\n• 큰 화면: 테이블이 모두 보이므로 스크롤바 없음\n• 작은 화면: 테이블이 넘치므로 스크롤바 생성\n• 중간 화면: 테이블 크기에 따라 동적 결정",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:49:50.000Z"
    },
    {
      "id": 1232,
      "subject_id": 9,
      "question": "다음 CSS와 HTML이 적용된 상황에서 스크롤바가 나타나는 조건은?\n```html\n<div class=\"responsive-wrapper\">\n  <table class=\"data-table\">\n    <tr><th>Col1</th><th>Col2</th><th>Col3</th><th>Col4</th><th>Col5</th></tr>\n  </table>\n</div>\n```\n```css\n.responsive-wrapper {\n    width: 300px;\n    overflow-x: auto;\n}\n.data-table {\n    width: 500px;\n    border-collapse: collapse;\n}\n```",
      "option_a": "항상 스크롤바가 표시됨",
      "option_b": "스크롤바가 전혀 표시되지 않음",
      "option_c": "브라우저 창이 300px보다 작을 때만 표시됨",
      "option_d": "마우스를 올릴 때만 표시됨",
      "correct_answer": "A",
      "explanation": "고정된 크기 설정:\n\n• 컨테이너 너비: 300px (responsive-wrapper)\n• 테이블 너비: 500px (data-table)\n• 크기 차이: 500px > 300px → 200px만큼 넘침\n\n스크롤바 생성 조건 충족:\n\n• 테이블(500px)이 컨테이너(300px)보다 확실히 넓음\n• overflow-x: auto에 의해 가로 스크롤바 생성\n• 브라우저 창 크기와 무관하게 항상 넘침 발생\n\n실제 사용자 경험:\n\n• 보이는 영역: 300px 너비만큼의 테이블 일부\n• 스크롤 가능: 나머지 200px 영역을 스크롤로 확인\n• 고정 동작: 브라우저 창 크기 변경과 관계없이 일정\n\n실무에서의 활용:\n\n• 정확한 크기 제어가 필요한 대시보드\n• 고정 너비 사이드바 내의 테이블\n• 특정 크기로 제한된 컨테이너 내 데이터 표시",
      "difficulty": "hard",
      "created_at": "2025-08-10T08:51:36.000Z"
    },
    {
      "id": 1233,
      "subject_id": 9,
      "question": "블록 레벨 요소(block-level element)의 특징으로 올바른 것은?",
      "option_a": "새로운 줄에서 시작하고 필요한 만큼의 너비만 차지함",
      "option_b": "새로운 줄에서 시작하지 않고 전체 너비를 차지함",
      "option_c": "새로운 줄에서 시작하고 사용 가능한 전체 너비를 차지함",
      "option_d": "인라인 요소와 동일한 동작을 함",
      "correct_answer": "C",
      "explanation": "블록 레벨 요소의 핵심 특성:\n\n새 줄에서 시작:\n• 이전 요소 다음 줄에 배치됨\n• 세로로 쌓이는 구조 형성\n• 레이아웃의 기본 단위 역할\n\n전체 너비 차지:\n• 부모 요소의 사용 가능한 너비를 모두 차지\n• 좌우로 최대한 늘어남\n• 내용이 적어도 한 줄 전체를 점유\n\n대표적인 블록 요소들:\n• `<div>`, `<p>`, `<h1>~<h6>`\n• `<header>`, `<footer>`, `<section>`\n• `<form>` 등",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:55:12.000Z"
    },
    {
      "id": 1234,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 값은?\n```css\nli {\n    display: _____;\n}\n```\n가로 메뉴를 만들기 위해 리스트 아이템을 한 줄에 배치하고 싶을 때",
      "option_a": "block",
      "option_b": "inline",
      "option_c": "none",
      "option_d": "flex",
      "correct_answer": "B",
      "explanation": "가로 메뉴 구현을 위한 display 변경:\n\n기본 li 요소:\n• 기본값: `display: list-item` (블록과 유사)\n• 세로로 쌓이는 구조\n• 각 항목이 새 줄에 표시\n\ninline으로 변경한 효과:\n• 한 줄에 나란히 배치\n• 메뉴 항목들이 가로로 정렬\n• 내비게이션 메뉴 구현에 필수\n\n다른 선택지 분석:\n• block: 세로 배치 (가로 메뉴 부적합)\n• none: 요소 숨김 (메뉴 표시 안됨)\n• flex: 최신 방법이지만 기본적인 inline이 더 간단",
      "difficulty": "easy",
      "created_at": "2025-08-10T08:56:56.000Z"
    },
    {
      "id": 1235,
      "subject_id": 9,
      "question": "`display: none;`과 `visibility: hidden;`의 차이점으로 올바른 것은?",
      "option_a": "둘 다 동일한 효과를 가짐",
      "option_b": "display: none은 공간을 차지하지 않고, visibility: hidden은 공간을 차지함",
      "option_c": "display: none은 공간을 차지하고, visibility: hidden은 공간을 차지하지 않음",
      "option_d": "둘 다 공간을 차지함",
      "correct_answer": "B",
      "explanation": "두 속성의 근본적인 차이점:\n\ndisplay: none:\n• 완전 제거: 요소가 DOM에서 렌더링되지 않음\n• 공간 없음: 다른 요소들이 빈 공간을 채움\n• 레이아웃 변화: 페이지 구조가 재배치됨\n• 용도: 토글 메뉴, 조건부 표시\n\nvisibility: hidden:\n• 투명화: 요소가 보이지 않지만 존재함\n• 공간 유지: 원래 차지하던 공간을 그대로 보존\n• 레이아웃 유지: 다른 요소들의 위치 변화 없음\n• 용도: 페이드 효과, 임시 숨김",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:58:06.000Z"
    },
    {
      "id": 1236,
      "subject_id": 9,
      "question": "다음 코드에서 span 요소의 동작은?\n```css\nspan {\n    display: _____;\n    width: 200px;\n    height: 100px;\n}\n```\nspan 요소를 인라인으로 유지하면서 width와 height를 적용하고 싶을 때",
      "option_a": "inline",
      "option_b": "block",
      "option_c": "inline-block",
      "option_d": "none",
      "correct_answer": "C",
      "explanation": "inline-block의 특별한 특성:\n\ninline 특성:\n• 한 줄에 다른 요소들과 나란히 배치\n• 새 줄에서 시작하지 않음\n• 텍스트 흐름을 방해하지 않음\n\nblock 특성:\n• width, height 속성 적용 가능\n• padding, margin 모든 방향 적용 가능\n• 크기 제어 완전히 가능\n\n다른 선택지들의 한계:\n• inline: width, height 무시됨\n• block: 새 줄에서 시작하여 전체 너비 차지\n• none: 요소가 보이지 않음",
      "difficulty": "medium",
      "created_at": "2025-08-10T08:59:17.000Z"
    },
    {
      "id": 1237,
      "subject_id": 9,
      "question": "다음 CSS가 적용된 HTML의 최종 레이아웃은?\n```html\n<div class=\"container\">\n  <span class=\"item-a\">A</span>\n  <span class=\"item-b\">B</span>\n  <span class=\"item-c\">C</span>\n</div>\n```\n```css\n.item-a { display: inline; }\n.item-b { display: none; }\n.item-c { display: block; }\n```",
      "option_a": "A, B, C가 모두 한 줄에 표시",
      "option_b": "A와 C가 한 줄에, B는 다음 줄에 표시",
      "option_c": "A가 첫 줄에, C가 다음 줄에, B는 숨김",
      "option_d": "A, B, C가 모두 세로로 배치",
      "correct_answer": "C",
      "explanation": "각 요소별 display 속성 분석:\n\nitem-a (display: inline):\n• span의 기본 inline 특성 유지\n• 첫 번째 줄에 표시\n• 다음 요소와 같은 줄 공유 가능\n\nitem-b (display: none):\n• 완전히 숨겨짐\n• 공간을 차지하지 않음\n• 렌더링에서 제외됨\n\nitem-c (display: block):\n• 원래 inline인 span이 block으로 변경\n• 새로운 줄에서 시작\n• 전체 너비를 차지\n\n최종 레이아웃 결과:\n• 첫 번째 줄: A만 표시 (B가 없으므로)\n• 두 번째 줄: C가 블록 요소로 새 줄에 표시\n• B는 완전히 보이지 않음",
      "difficulty": "hard",
      "created_at": "2025-08-10T09:01:03.000Z"
    },
    {
      "id": 1238,
      "subject_id": 9,
      "question": "블록 레벨 요소에 width를 설정하지 않으면 어떻게 동작하나요?",
      "option_a": "내용에 맞춰 최소 너비만 차지함",
      "option_b": "사용 가능한 전체 너비를 차지함",
      "option_c": "고정된 기본 너비(예: 300px)를 가짐",
      "option_d": "부모 요소의 절반 너비를 차지함",
      "correct_answer": "B",
      "explanation": "블록 레벨 요소의 기본 너비 동작:\n\n자동 확장 특성:\n• 부모 컨테이너의 사용 가능한 너비를 모두 차지\n• 좌우로 최대한 늘어나는 특성\n• 내용이 적어도 전체 너비 점유\n\n실제 동작 예시:\n• `<div>`: 부모의 100% 너비 차지\n• `<p>`: 문장이 짧아도 한 줄 전체 사용\n• `<h1>`: 제목이 짧아도 전체 너비 점유\n\nwidth 설정의 필요성:\n• 레이아웃 제어를 위해 너비 제한\n• 가독성 향상 (너무 긴 텍스트 줄 방지)\n• 반응형 디자인 구현",
      "difficulty": "easy",
      "created_at": "2025-08-10T09:04:03.000Z"
    },
    {
      "id": 1239,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 값은?\n```css\ndiv {\n    width: 600px;\n    margin: _____;\n}\n```\ndiv 요소를 가로로 가운데 정렬하고 싶을 때",
      "option_a": "center",
      "option_b": "auto",
      "option_c": "0",
      "option_d": "middle",
      "correct_answer": "B",
      "explanation": "가로 가운데 정렬의 원리:\n\nmargin: auto의 동작:\n• 좌우 여백을 자동으로 균등 분배\n• 남은 공간을 양쪽으로 동일하게 배분\n• 결과적으로 요소가 가운데 위치\n\n계산 과정 예시:\n• 부모 너비: 1000px\n• 자식 너비: 600px\n• 남은 공간: 400px\n• 좌우 margin: 각각 200px\n\n다른 값들의 문제점:\n• center: margin 값이 아님 (text-align용)\n• 0: 여백 없음 (왼쪽 정렬 유지)\n• middle: margin 값이 아님",
      "difficulty": "easy",
      "created_at": "2025-08-10T09:05:06.000Z"
    },
    {
      "id": 1240,
      "subject_id": 9,
      "question": "`width: 500px;`와 `max-width: 500px;`의 차이점으로 올바른 것은?",
      "option_a": "둘 다 동일한 효과를 가짐",
      "option_b": "width는 고정값, max-width는 브라우저가 500px보다 작을 때 자동 축소",
      "option_c": "width는 자동 축소, max-width는 고정값",
      "option_d": "둘 다 브라우저 크기에 따라 자동 변경됨",
      "correct_answer": "B",
      "explanation": "두 속성의 반응형 차이:\n\nwidth: 500px (고정 너비):\n• 항상 정확히 500px 유지\n• 브라우저가 500px보다 작아도 크기 변경 안됨\n• 가로 스크롤바 생성 가능\n• 모바일에서 사용성 문제 발생\n\nmax-width: 500px (최대 너비):\n• 최대 500px까지만 확장\n• 브라우저가 500px보다 작으면 자동 축소\n• 부모 컨테이너에 맞춰 유연하게 조절\n• 스크롤바 없이 반응형 동작\n\n모바일 환경에서의 차이:\n• width: 화면 밖으로 넘침 → 스크롤 필요\n• max-width: 화면에 맞춰 축소 → 사용성 향상",
      "difficulty": "medium",
      "created_at": "2025-08-10T09:06:24.000Z"
    },
    {
      "id": 1241,
      "subject_id": 9,
      "question": "다음 CSS 코드가 적용된 div의 동작으로 올바른 것은?\n```css\ndiv {\n    max-width: 800px;\n    margin: auto;\n    padding: 20px;\n}\n```",
      "option_a": "항상 800px 너비를 유지하며 가운데 정렬",
      "option_b": "최대 800px까지 확장하며 가운데 정렬, 작은 화면에서는 축소",
      "option_c": "800px 너비로 고정되며 왼쪽 정렬",
      "option_d": "부모 요소의 전체 너비를 차지",
      "correct_answer": "B",
      "explanation": "max-width: 800px:\n• 최대 너비 제한\n• 부모가 800px보다 크면 800px로 제한\n• 부모가 800px보다 작으면 부모에 맞춰 축소\n\nmargin: auto:\n• 좌우 가운데 정렬\n• 남은 공간을 양쪽으로 균등 분배\n• 반응형 환경에서도 가운데 유지\n\npadding: 20px:\n• 내부 여백 추가\n• 콘텐츠와 테두리 사이 공간 확보\n• 전체 크기에는 영향 없음 (box-sizing 기본값 기준)",
      "difficulty": "medium",
      "created_at": "2025-08-10T09:08:00.000Z"
    },
    {
      "id": 1242,
      "subject_id": 9,
      "question": "다음 두 div 요소가 브라우저 너비 400px에서 어떻게 표시되는지 올바른 설명은?\n```css\n.container1 {\n    width: 600px;\n    margin: auto;\n    background: lightblue;\n}\n\n.container2 {\n    max-width: 600px;\n    margin: auto;\n    background: lightgreen;\n}\n```",
      "option_a": "둘 다 400px 너비로 표시되며 가운데 정렬",
      "option_b": "container1은 600px 유지(스크롤 생성), container2는 400px로 축소",
      "option_c": "둘 다 600px로 유지되며 화면 밖으로 넘침",
      "option_d": "container1은 400px 축소, container2는 600px 유지",
      "correct_answer": "B",
      "explanation": "작은 화면에서의 서로 다른 동작:\n\ncontainer1 (width: 600px):\n• 고정 너비: 브라우저 크기와 관계없이 600px 유지\n• 스크롤 발생: 400px 화면에서 200px 넘침\n• 사용성 문제: 가로 스크롤 필요로 모바일에서 불편\n• margin: auto 무력화: 넘침으로 인해 가운데 정렬 효과 상실\n\ncontainer2 (max-width: 600px):\n• 유연한 너비: 브라우저에 맞춰 400px로 자동 축소\n• 스크롤 없음: 화면에 완전히 맞춤\n• 반응형 동작: 다양한 기기에서 최적 표시\n• 가운데 정렬 유지: margin: auto가 정상 작동",
      "difficulty": "hard",
      "created_at": "2025-08-10T09:09:27.000Z"
    },
    {
      "id": 1243,
      "subject_id": 9,
      "question": "HTML 요소의 기본 position 값은 무엇인가요?",
      "option_a": "relative",
      "option_b": "static",
      "option_c": "absolute",
      "option_d": "fixed",
      "correct_answer": "B",
      "explanation": "position 속성의 기본값과 특성:\n\nposition: static (기본값):\n• 모든 HTML 요소의 기본 포지셔닝 방식\n• 일반적인 문서 흐름을 따라 배치\n• top, bottom, left, right 속성이 작동하지 않음\n• 특별한 위치 지정 없이 순서대로 배치\n\n기본 동작 방식:\n• 블록 요소: 세로로 순차 배치\n• 인라인 요소: 가로로 순차 배치\n• 부모-자식 관계에 따른 자연스러운 배치\n\n다른 position 값들과의 차이:\n• relative/absolute/fixed: 특별한 위치 지정이 가능\n• static: 위치 속성들이 무시됨\n\n실무에서의 의미:\n• 대부분의 일반적인 레이아웃은 static으로 구성\n• 특별한 위치 조정이 필요할 때만 다른 값 사용",
      "difficulty": "easy",
      "created_at": "2025-08-10T09:12:32.000Z"
    },
    {
      "id": 1244,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 값은?\n```css\ndiv {\n    position: _____;\n    top: 0;\n    right: 0;\n}\n```\ndiv를 브라우저 우상단에 고정하고 스크롤해도 항상 같은 위치에 유지하고 싶을 때",
      "option_a": "static",
      "option_b": "relative",
      "option_c": "absolute",
      "option_d": "fixed",
      "correct_answer": "D",
      "explanation": "position: fixed의 핵심 특성:\n\n뷰포트 기준 고정:\n• 브라우저 창(뷰포트)을 기준으로 위치 설정\n• 스크롤과 관계없이 항상 같은 자리 유지\n• top: 0, right: 0으로 우상단에 고정\n\n실무 활용 사례:\n• 헤더 내비게이션: 스크롤해도 메뉴가 항상 보임\n• 플로팅 버튼: \"맨 위로\" 버튼, 채팅 버튼 등\n• 광고 배너: 화면 모서리에 고정된 광고\n• 사이드바: 스크롤과 무관한 고정 메뉴\n\n다른 position 값들과의 차이:\n• static: top, right 속성 무시\n• relative: 원래 위치 기준으로 이동 (고정 아님)\n• absolute: 부모 요소 기준 (뷰포트 기준 아님)",
      "difficulty": "easy",
      "created_at": "2025-08-10T09:14:05.000Z"
    },
    {
      "id": 1245,
      "subject_id": 9,
      "question": "`position: relative;`의 특징으로 올바른 것은?",
      "option_a": "뷰포트를 기준으로 위치가 결정됨",
      "option_b": "원래 위치를 기준으로 이동하며, 원래 공간은 유지됨",
      "option_c": "문서 흐름에서 완전히 제거됨",
      "option_d": "부모 요소를 기준으로 위치가 결정됨",
      "correct_answer": "B",
      "explanation": "position: relative의 독특한 동작 방식:\n\n원래 위치 기준 이동:\n• 요소가 원래 있던 자리를 기준점으로 설정\n• top, left 등으로 기준점에서 상대적으로 이동\n• 시각적으로만 이동, 실제 공간은 원래 자리에 유지\n\n공간 유지의 의미:\n• 다른 요소들은 이 요소가 원래 자리에 있다고 인식\n• 레이아웃에 빈 공간이 남음\n• 문서 흐름이 깨지지 않음\n\n실무 활용:\n• 미세한 위치 조정: 요소를 살짝 이동시킬 때\n• 부모 역할: absolute 자식의 기준점 역할\n• 애니메이션: 호버 효과로 요소 이동",
      "difficulty": "medium",
      "created_at": "2025-08-10T09:15:19.000Z"
    },
    {
      "id": 1246,
      "subject_id": 9,
      "question": "다음 CSS에서 absolute 요소가 위치를 결정하는 기준은?\n```css\n.parent {\n    position: relative;\n    width: 300px;\n    height: 200px;\n}\n.child {\n    position: absolute;\n    top: 20px;\n    left: 30px;\n}\n```",
      "option_a": "브라우저 창 (뷰포트)",
      "option_b": ".parent 요소",
      "option_c": "body 요소",
      "option_d": "html 요소",
      "correct_answer": "B",
      "explanation": "position: absolute의 기준점 결정 규칙:\n\n가장 가까운 positioned 조상 찾기:\n• positioned: static이 아닌 position 값을 가진 요소\n• 부모부터 상위로 올라가며 첫 번째 positioned 요소를 찾음\n• .parent가 `position: relative`이므로 기준점이 됨\n\n기준점 결정 과정:\n1. .child의 부모인 .parent 확인\n2. .parent가 `position: relative` → positioned 요소\n3. .parent를 기준점으로 설정\n4. top: 20px, left: 30px는 .parent 기준으로 적용\n\n만약 positioned 조상이 없다면:\n• body 요소를 기준으로 위치 결정\n• 페이지 스크롤 시 함께 이동\n\n실무에서의 패턴:\n• 부모에 `position: relative` 설정\n• 자식에 `position: absolute`로 정확한 위치 지정\n• 모달, 툴팁, 드롭다운 메뉴 구현에 필수",
      "difficulty": "medium",
      "created_at": "2025-08-10T09:16:55.000Z"
    },
    {
      "id": 1247,
      "subject_id": 9,
      "question": "다음 CSS가 적용된 sticky 요소의 동작으로 올바른 것은?\n```css\n.sticky-header {\n    position: sticky;\n    top: 20px;\n    background: white;\n    z-index: 100;\n}\n```",
      "option_a": "항상 뷰포트 상단에서 20px 떨어진 곳에 고정됨",
      "option_b": "스크롤 시 원래 위치에서 20px 위로 이동 후 그 자리에 고정됨",
      "option_c": "스크롤하다가 뷰포트 상단에서 20px 지점에 도달하면 그 위치에 고정됨",
      "option_d": "relative와 동일하게 동작함",
      "correct_answer": "C",
      "explanation": "position: sticky의 복잡한 동작 원리:\n\n이중 동작 방식:\n• 1단계: 일반적인 문서 흐름을 따라 배치 (relative처럼)\n• 2단계: 스크롤로 임계점에 도달하면 고정 (fixed처럼)\n\n구체적인 동작 과정:\n1. 초기 상태: 문서 흐름에 따라 자연스럽게 배치\n2. 스크롤 중: 요소가 뷰포트 상단으로 올라감\n3. 임계점 도달: 뷰포트 상단에서 20px 지점에 도달\n4. 고정 상태: 더 이상 올라가지 않고 그 자리에 \"달라붙음\"\n\n실무 활용 사례:\n• 테이블 헤더: 스크롤해도 항목명이 항상 보임\n• 내비게이션: 일정 스크롤 후 상단에 고정\n• 사이드바 메뉴: 스크롤 중 특정 위치에서 고정\n\n다른 position과의 차이점:\n• fixed: 처음부터 고정 위치\n• relative: 이동 후에도 고정되지 않음\n• sticky: 조건부 고정 (스크롤 위치에 따라)\n\n필수 조건:\n• top, bottom, left, right 중 최소 하나는 반드시 설정\n• 부모 컨테이너에 overflow: hidden이 있으면 작동 안 함",
      "difficulty": "hard",
      "created_at": "2025-08-10T09:18:43.000Z"
    },
    {
      "id": 1248,
      "subject_id": 9,
      "question": "z-index 속성의 주요 역할은 무엇인가요?",
      "option_a": "요소의 투명도를 조절함",
      "option_b": "요소들이 겹쳤을 때 쌓임 순서를 결정함",
      "option_c": "요소의 크기를 조절함",
      "option_d": "요소의 배경색을 설정함",
      "correct_answer": "B",
      "explanation": "z-index의 핵심 개념:\n\n스택 순서 제어:\n• 요소들이 겹쳐있을 때 어떤 요소가 앞에 올지 결정\n• 3차원적인 쌓임(stack) 개념으로 이해\n• 높은 z-index 값 = 앞쪽(위쪽)에 배치\n\n실무에서의 필요성:\n• 모달 창: 다른 내용 위에 표시\n• 드롭다운 메뉴: 다른 요소들을 가리고 표시\n• 툴팁: 호버 시 다른 요소 위에 나타남\n이미지 오버레이: 텍스트를 이미지 위에 배치\n\n값의 의미:\n• 양수: 다른 요소들보다 앞쪽에 배치\n• 음수: 다른 요소들보다 뒤쪽에 배치\n• 0: 기본 쌓임 레벨",
      "difficulty": "easy",
      "created_at": "2025-08-10T09:21:55.000Z"
    },
    {
      "id": 1249,
      "subject_id": 9,
      "question": "z-index 속성이 작동하는 조건으로 올바른 것은?",
      "option_a": "모든 HTML 요소에서 항상 작동함",
      "option_b": "position이 설정된 요소에서만 작동함",
      "option_c": "블록 요소에서만 작동함",
      "option_d": "인라인 요소에서만 작동함",
      "correct_answer": "B",
      "explanation": "z-index 작동 조건:\n\n필수 조건 - positioned 요소:\n• `position: relative`\n• `position: absolute`\n• `position: fixed`\n• `position: sticky`\n\n작동하지 않는 경우:\n• `position: static` (기본값)\n• position 속성이 설정되지 않은 요소\n\n추가 작동 조건:\n• `display: flex`의 직접 자식 요소 (flex items)\n• `display: grid`의 직접 자식 요소 (grid items)\n\n실무 팁:\n• z-index가 작동하지 않으면 먼저 position 확인\n• 가장 간단한 해결법: `position: relative` 추가\n• relative는 위치 변경 없이 positioned 상태만 만듦",
      "difficulty": "easy",
      "created_at": "2025-08-10T09:23:35.000Z"
    },
    {
      "id": 1250,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 값은?\n```css\n.background-image {\n    position: absolute;\n    z-index: _____;\n}\n.text-content {\n    position: relative;\n    z-index: 1;\n}\n```\n이미지를 텍스트 뒤에 배치하고 싶을 때",
      "option_a": "2",
      "option_b": "0",
      "option_c": "-1",
      "option_d": "999",
      "correct_answer": "C",
      "explanation": "상대적인 z-index 값 설정:\n\n값 비교 원리:\n• z-index는 상대적인 값으로 작동\n• 낮은 값이 뒤쪽, 높은 값이 앞쪽에 배치\n• text-content의 z-index: 1보다 낮아야 함\n\n각 선택지 분석:\n• 2: 텍스트(1)보다 앞쪽 → 텍스트가 가려짐\n• 0: 텍스트(1)보다 뒤쪽이지만 -1보다 명확하지 않음\n• -1: 명확히 텍스트(1)보다 뒤쪽 ✓\n• 999: 훨씬 앞쪽 → 의도와 반대\n\n실무에서의 패턴:\n• 배경 요소: z-index: -1 (가장 뒤)\n• 일반 콘텐츠: z-index: 0~10\n• 네비게이션: z-index: 100\n• 모달/팝업: z-index: 1000+",
      "difficulty": "medium",
      "created_at": "2025-08-10T09:44:01.000Z"
    },
    {
      "id": 1251,
      "subject_id": 9,
      "question": "z-index가 설정되지 않은 positioned 요소들이 겹칠 때의 쌓임 순서는?\n```html\n<div class=\"box1\">Box 1</div>\n<div class=\"box2\">Box 2</div>\n<div class=\"box3\">Box 3</div>\n```\n```css\n.box1, .box2, .box3 {\n    position: absolute;\n    /* z-index 설정 없음 */\n}\n```",
      "option_a": "box1이 가장 위에 표시됨",
      "option_b": "box3이 가장 위에 표시됨",
      "option_c": "브라우저가 랜덤하게 결정함",
      "option_d": "모든 박스가 같은 레벨에 표시됨",
      "correct_answer": "B",
      "explanation": "기본 쌓임 순서 규칙:\n\nHTML 순서 기반 쌓임:\n• z-index가 없을 때는 HTML 작성 순서를 따름\n• 나중에 작성된 요소가 위에 표시됨\n• \"나중에 그려진 것이 위에 보임\" 원리\n\n쌓임 순서 (아래 → 위):\n1. box1 (가장 아래)\n2. box2 (중간)\n3. box3 (가장 위) ✓\n\n실무에서의 의미:\n• z-index 없이도 기본적인 레이어링 가능\n• 간단한 오버레이는 HTML 순서로 해결\n• 복잡한 레이아웃에서는 명시적 z-index 권장",
      "difficulty": "medium",
      "created_at": "2025-08-10T09:47:26.000Z"
    },
    {
      "id": 1252,
      "subject_id": 9,
      "question": "다음 코드에서 실제 화면에 표시되는 요소들의 쌓임 순서는? (위에서부터)\n```css\n.element-a {\n    position: relative;\n    z-index: 3;\n}\n.element-b {\n    position: absolute;\n    z-index: 1;\n}\n.element-c {\n    position: relative;\n    z-index: 2;\n}\n.element-d {\n    position: static;\n    z-index: 999;\n}\n```",
      "option_a": "d → a → c → b",
      "option_b": "a → c → b → d",
      "option_c": "a → c → b (d는 영향 없음)",
      "option_d": "d → a → c → b (모든 z-index 적용)",
      "correct_answer": "C",
      "explanation": "z-index 적용 규칙과 예외 상황:\n\n각 요소별 분석:\n\nelement-a (z-index: 3):\n• `position: relative` → positioned 요소\n• z-index 적용됨\n• 가장 높은 값 → 1순위 (가장 위)\n\nelement-c (z-index: 2):\n• `position: relative` → positioned 요소\n• z-index 적용됨\n• 두 번째로 높은 값 → 2순위\n\nelement-b (z-index: 1):\n• `position: absolute` → positioned 요소\n• z-index 적용됨\n• 가장 낮은 값 → 3순위\n\nelement-d (z-index: 999):\n• `position: static` → 기본값\n• positioned 요소가 아니므로 z-index 무시됨\n• 일반 문서 흐름을 따라 배치\n• positioned 요소들과 별개의 레이어",
      "difficulty": "hard",
      "created_at": "2025-08-10T09:50:04.000Z"
    },
    {
      "id": 1253,
      "subject_id": 9,
      "question": "CSS overflow 속성의 주요 역할은 무엇인가요?",
      "option_a": "요소의 크기를 자동으로 조절함",
      "option_b": "요소보다 큰 콘텐츠가 넘칠 때의 처리 방법을 결정함",
      "option_c": "요소의 배경색을 설정함",
      "option_d": "요소의 위치를 조절함",
      "correct_answer": "B",
      "explanation": "overflow 속성의 핵심 개념:\n\n콘텐츠 넘침 제어:\n• 정해진 크기의 컨테이너보다 내용이 클 때 발생하는 상황\n• 넘치는 부분을 어떻게 처리할지 결정\n• 레이아웃 파괴 방지와 사용자 경험 개선\n\n발생하는 상황들:\n• 긴 텍스트: 고정 높이 박스에 많은 내용\n• 큰 이미지: 작은 컨테이너에 큰 이미지\n• 동적 콘텐츠: 사용자 입력이나 API 데이터\n\n실무 활용 사례:\n• 채팅창: 메시지가 많아질 때 스크롤\n• 카드 컴포넌트: 제목이 길 때 처리\n• 사이드바: 메뉴 항목이 많을 때\n• 텍스트 박스: 고정 크기 내 긴 설명",
      "difficulty": "easy",
      "created_at": "2025-08-10T09:56:14.000Z"
    },
    {
      "id": 1254,
      "subject_id": 9,
      "question": "overflow 속성의 기본값(default)은 무엇인가요?",
      "option_a": "hidden",
      "option_b": "scroll",
      "option_c": "auto",
      "option_d": "visible",
      "correct_answer": "D",
      "explanation": "overflow: visible의 특성:\n\n기본 동작 방식:\n• 콘텐츠가 컨테이너를 넘어도 그대로 표시\n• 넘치는 부분이 잘리지 않음 (clipping 없음)\n• 요소의 경계 밖으로 내용이 렌더링됨\n\n장점과 단점:\n• 장점: 모든 콘텐츠가 보임, 정보 손실 없음\n• 단점: 레이아웃이 깨질 수 있음, 다른 요소와 겹칠 가능성\n\n실제 효과:\n• 긴 텍스트가 박스 밖으로 튀어나옴\n• 큰 이미지가 컨테이너 경계를 무시하고 표시\n• 다른 요소들과 시각적으로 겹칠 수 있음\n\n다른 값들과의 비교:\n• hidden: 넘치는 부분 완전히 숨김\n• scroll: 항상 스크롤바 표시\n• auto: 필요할 때만 스크롤바 표시",
      "difficulty": "easy",
      "created_at": "2025-08-10T09:59:36.000Z"
    },
    {
      "id": 1255,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 값은?\n```css\n.chat-container {\n    height: 300px;\n    overflow: _____;\n}\n```\n채팅창에서 메시지가 많아질 때 자동으로 스크롤바가 나타나게 하고 싶을 때",
      "option_a": "visible",
      "option_b": "hidden",
      "option_c": "scroll",
      "option_d": "auto",
      "correct_answer": "D",
      "explanation": "overflow: auto의 스마트한 동작:\n\n자동 판단 기능:\n• 콘텐츠가 컨테이너에 맞으면 스크롤바 없음\n• 콘텐츠가 넘치면 자동으로 스크롤바 생성\n• 가장 사용자 친화적인 선택\n\n채팅창에서의 장점:\n• 적은 메시지: 깔끔한 UI (스크롤바 없음)\n• 많은 메시지: 자동으로 스크롤 가능\n• 공간 효율성: 불필요한 스크롤바로 인한 공간 낭비 없음\n\n다른 값들의 문제점:\n• visible: 메시지가 채팅창 밖으로 넘침\n• hidden: 오래된 메시지를 볼 수 없음\n• scroll: 메시지가 적어도 항상 스크롤바 표시",
      "difficulty": "medium",
      "created_at": "2025-08-10T10:00:40.000Z"
    },
    {
      "id": 1256,
      "subject_id": 9,
      "question": "`overflow-x`와 `overflow-y`의 차이점으로 올바른 것은?\n```css\n.container {\n    overflow-x: hidden;\n    overflow-y: scroll;\n}\n```",
      "option_a": "둘 다 동일한 기능을 함",
      "option_b": "overflow-x는 가로 방향, overflow-y는 세로 방향 제어",
      "option_c": "overflow-x는 상하, overflow-y는 좌우 제어",
      "option_d": "하나만 설정하면 다른 하나는 자동으로 같은 값이 적용됨",
      "correct_answer": "B",
      "explanation": "방향별 overflow 제어:\n\noverflow-x (가로 방향):\n• 좌우로 넘치는 콘텐츠 제어\n• 긴 텍스트 한 줄, 넓은 테이블 등\n• `overflow-x: hidden` → 가로 스크롤바 숨김\n\noverflow-y (세로 방향):\n• 위아래로 넘치는 콘텐츠 제어\n• 긴 텍스트 여러 줄, 많은 리스트 항목 등\n• `overflow-y: scroll` → 세로 스크롤바 강제 표시\n\n예시 코드의 효과:\n• 가로 넘침: 숨김 처리 (가로 스크롤 없음)\n• 세로 넘침: 스크롤바로 처리 (세로 스크롤 제공)",
      "difficulty": "medium",
      "created_at": "2025-08-10T10:02:12.000Z"
    },
    {
      "id": 1257,
      "subject_id": 9,
      "question": "다음 CSS가 적용된 요소의 실제 동작으로 올바른 것은?\n```css\n.content-box {\n    width: 200px;\n    height: 100px;\n    overflow: scroll;\n    border: 1px solid black;\n}\n```\n가정: 내용이 150px × 80px 크기일 때",
      "option_a": "스크롤바가 전혀 나타나지 않음",
      "option_b": "세로 스크롤바만 나타남",
      "option_c": "가로와 세로 스크롤바가 모두 나타남",
      "option_d": "가로 스크롤바만 나타남",
      "correct_answer": "C",
      "explanation": "overflow: scroll의 고정 동작 방식:\n\nscroll 값의 특성:\n• 콘텐츠 크기와 관계없이 항상 스크롤바 표시\n• 필요 여부를 판단하지 않음\n• 가로와 세로 스크롤바를 모두 강제로 생성\n\n현재 상황 분석:\n• 컨테이너: 200px × 100px\n• 콘텐츠: 150px × 80px\n• 실제 넘침: 없음 (콘텐츠가 더 작음)\n\n그럼에도 스크롤바가 나타나는 이유:\n• `overflow: scroll`은 \"강제 표시\" 모드\n• 콘텐츠가 작아도 스크롤바 영역 확보\n• 일관된 레이아웃 유지 (스크롤바 깜빡임 방지)\n\n다른 값들과의 비교:\n• auto: 이 경우 스크롤바 없음 (넘침 없으므로)\n• hidden: 스크롤바 없음, 넘침 시 잘림\n• visible: 스크롤바 없음, 넘침 시 그대로 표시",
      "difficulty": "hard",
      "created_at": "2025-08-10T10:03:53.000Z"
    },
    {
      "id": 1258,
      "subject_id": 9,
      "question": "CSS float 속성의 기본값은 무엇인가요?",
      "option_a": "left",
      "option_b": "right",
      "option_c": "none",
      "option_d": "center",
      "correct_answer": "C",
      "explanation": "float 속성의 기본 동작:\n\nfloat: none (기본값):\n\n• 요소가 일반적인 문서 흐름을 따름\n• 블록 요소는 세로로, 인라인 요소는 가로로 배치\n• 다른 요소들과 겹치지 않고 순서대로 배치\n\n다른 float 값들:\n\n• left: 요소를 왼쪽으로 띄움\n• right: 요소를 오른쪽으로 띄움\n• inherit: 부모 요소의 float 값을 상속\n\n기본값이 none인 이유:\n\n• 대부분의 웹 콘텐츠는 일반적인 흐름으로 배치\n• 특별한 레이아웃이 필요할 때만 float 사용\n• 예측 가능한 기본 동작 제공",
      "difficulty": "easy",
      "created_at": "2025-08-10T10:10:29.000Z"
    },
    {
      "id": 1259,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 값은?\n```css\nimg {\n    float: _____;\n}\n```\n이미지를 텍스트 왼쪽에 배치하고 텍스트가 이미지 오른쪽으로 감싸게 하고 싶을 때",
      "option_a": "left",
      "option_b": "right",
      "option_c": "center",
      "option_d": "wrap",
      "correct_answer": "A",
      "explanation": "float: left의 동작 원리:\n\n요소 배치 방식:\n\n• 이미지가 컨테이너의 왼쪽으로 이동\n• 텍스트가 이미지의 오른쪽 공간을 채움\n• 이미지 주변으로 텍스트가 자연스럽게 감쌈",
      "difficulty": "easy",
      "created_at": "2025-08-10T10:11:24.000Z"
    },
    {
      "id": 1260,
      "subject_id": 9,
      "question": "`float: left`가 적용된 여러 div 요소들의 배치 결과는?\n```css\ndiv {\n    float: left;\n    width: 100px;\n    height: 100px;\n}\n```",
      "option_a": "세로로 쌓여서 배치됨",
      "option_b": "가로로 나란히 배치됨",
      "option_c": "겹쳐서 배치됨",
      "option_d": "랜덤하게 배치됨",
      "correct_answer": "B",
      "explanation": "multiple float 요소들의 동작:\n\nfloat: left의 연속 효과:\n\n• 첫 번째 div가 왼쪽으로 이동\n• 두 번째 div가 첫 번째 옆으로 배치\n• 세 번째 div가 두 번째 옆으로 배치\n• 가로 공간이 있는 한 계속 나란히 배치\n\n배치 순서:\n[div1] [div2] [div3] [div4]\n\n공간 부족 시 동작:\n\n• 컨테이너 너비가 부족하면 다음 줄로 넘어감\n• 마치 단어가 줄바꿈되는 것처럼 동작\n• 자동으로 \"wrap\" 효과 발생\n\n실무 활용 패턴:\n\n• 이미지 갤러리: 사진들을 가로로 나열\n• 카드 레이아웃: 여러 카드를 가로 배치\n• 메뉴 버튼: 내비게이션 버튼들을 가로 정렬\n• 상품 목록: 제품들을 그리드 형태로 배치",
      "difficulty": "medium",
      "created_at": "2025-08-10T10:14:37.000Z"
    },
    {
      "id": 1261,
      "subject_id": 9,
      "question": "float 속성이 텍스트와 이미지에 미치는 영향으로 올바른 것은?\n```css\n.article-image {\n    float: right;\n    margin: 10px;\n}\n```",
      "option_a": "이미지가 텍스트 뒤에 숨겨짐",
      "option_b": "이미지가 오른쪽에 배치되고 텍스트가 왼쪽으로 감쌈",
      "option_c": "이미지가 텍스트 위에 겹쳐짐",
      "option_d": "이미지와 텍스트가 분리되어 배치됨",
      "correct_answer": "B",
      "explanation": "float: right의 텍스트 wrapping 효과:\n\n이미지 배치:\n\n• 이미지가 컨테이너의 오른쪽으로 이동\n• margin: 10px로 주변에 여백 생성\n• 일반 문서 흐름에서 분리됨\n\n텍스트 동작:\n\n• 텍스트가 이미지 왼쪽 공간을 자동으로 채움\n• 이미지 높이만큼 텍스트가 옆으로 감쌈\n• 이미지 아래쪽부터는 전체 너비 사용\n\n시각적 결과:\n\n텍스트 텍스트 텍스트 [이미지]\n텍스트 텍스트 텍스트 [이미지]  \n텍스트 텍스트 텍스트 [이미지]\n텍스트 텍스트 텍스트 텍스트\n텍스트 텍스트 텍스트 텍스트",
      "difficulty": "medium",
      "created_at": "2025-08-10T10:17:03.000Z"
    },
    {
      "id": 1262,
      "subject_id": 9,
      "question": "다음 상황에서 나타날 수 있는 문제와 해결 방법으로 올바른 것은?\n```css\n.container {\n    border: 2px solid black;\n}\n.floated-item {\n    float: left;\n    width: 200px;\n    height: 150px;\n    background: lightblue;\n}\n```\n```html\n<div class=\"container\">\n    <div class=\"floated-item\">Float Item</div>\n</div>\n```",
      "option_a": "문제없음 - 정상적으로 표시됨",
      "option_b": "container의 높이가 0이 되어 테두리만 보임 - clear나 clearfix 필요",
      "option_c": "float-item이 보이지 않음 - display: block 필요",
      "option_d": "텍스트가 겹쳐짐 - z-index 필요",
      "correct_answer": "B",
      "explanation": "float로 인한 부모 높이 손실 문제:\n\n문제 발생 원인:\n\n• float된 요소는 일반 문서 흐름에서 제거됨\n• 부모 컨테이너가 float된 자식의 높이를 인식하지 못함\n• 결과적으로 부모의 높이가 0이 되거나 매우 작아짐\n\n해결 방법들:\n\n1. Clear 방법:\n```css\n.container::after {\n    content: \"\";\n    display: table;\n    clear: both;\n}\n```\n2. Overflow 방법:\n```css\n.container {\n    overflow: auto; /* 또는 hidden */\n}\n```\n3. Flexbox 현대적 해결책:\n```css\n.container {\n    display: flex;\n}\n.floated-item {\n    /* float 제거 */\n}\n```",
      "difficulty": "hard",
      "created_at": "2025-08-10T10:19:54.000Z"
    },
    {
      "id": 1263,
      "subject_id": 9,
      "question": "CSS clear 속성의 주요 역할은 무엇인가요?",
      "option_a": "요소의 내용을 지움",
      "option_b": "요소를 투명하게 만듦",
      "option_c": "float된 요소의 옆이 아닌 아래쪽에 요소를 배치함",
      "option_d": "요소의 배경을 제거함",
      "correct_answer": "C",
      "explanation": "clear 속성의 핵심 개념:\n\nclear의 기본 목적:\n\n• float된 요소 옆에 오지 않도록 방지\n• 해당 요소를 float된 요소 아래쪽으로 강제 이동\n• 일반적인 문서 흐름을 복원하는 역할\n\n실무에서 필요한 상황:\n\n• 사이드바 뒤 푸터: 사이드바 옆이 아닌 아래에 푸터 배치\n• 이미지 뒤 단락: 이미지 옆이 아닌 아래에 새 단락 시작\n• 레이아웃 구분: float 영역과 일반 영역의 명확한 분리\n\n시각적 효과:\n\n[Float 요소]  텍스트가 옆으로\n                    감싸서 흐름\n─────────── clear 지점 ───────────\n새로운 요소 (float 영향 받지 않음)",
      "difficulty": "easy",
      "created_at": "2025-08-10T10:25:00.000Z"
    },
    {
      "id": 1264,
      "subject_id": 9,
      "question": "clear 속성의 기본값은 무엇인가요?",
      "option_a": "left",
      "option_b": "right",
      "option_c": "both",
      "option_d": "none",
      "correct_answer": "D",
      "explanation": "clear 속성의 기본 동작:\n\nclear: none (기본값):\n\n• float된 요소의 영향을 받음\n• 좌우 어느 쪽 float 요소든 옆에 배치 허용\n• 일반적인 float 감싸기 효과가 정상 작동\n\n다른 clear 값들의 효과:\n\n• left: 왼쪽 float 요소 아래로 이동\n• right: 오른쪽 float 요소 아래로 이동\n• both: 양쪽 float 요소 모두 아래로 이동\n\n기본값이 none인 이유:\n\n• 대부분의 경우 float 감싸기 효과를 원함\n• 특별히 구분이 필요할 때만 clear 사용\n• 자연스러운 텍스트 흐름을 기본으로 제공",
      "difficulty": "easy",
      "created_at": "2025-08-10T10:27:19.000Z"
    },
    {
      "id": 1265,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 값은?\n```css\n.sidebar {\n    float: left;\n    width: 200px;\n}\n.footer {\n    clear: _____;\n}\n```\n사이드바 옆이 아닌 아래쪽에 푸터를 배치하고 싶을 때",
      "option_a": "right",
      "option_b": "left",
      "option_c": "none",
      "option_d": "center",
      "correct_answer": "B",
      "explanation": "clear 값과 float 방향의 매칭:\n\n매칭 원칙:\n\n• float된 방향과 같은 방향으로 clear 설정\n• `.sidebar`가 `float: left` → `.footer`는 `clear: left`\n• 왼쪽 float 요소의 영향을 차단\n\n시각적 결과:\n\n[사이드바]  메인 콘텐츠\n[200px]    텍스트 내용\n─────────── clear: left ───────────\n푸터 (전체 너비 사용)\n\n다른 값들의 문제점:\n\n• right: 오른쪽 float만 차단 (왼쪽 사이드바 영향 계속)\n• none: clear 효과 없음 (푸터가 사이드바 옆에 붙음)\n• center: clear 속성에 없는 값\n\n실무 패턴:\n\n• 왼쪽 사이드바: `clear: left` 사용\n• 오른쪽 사이드바: `clear: right` 사용\n• 양쪽 사이드바: `clear: both` 사용",
      "difficulty": "medium",
      "created_at": "2025-08-10T10:29:21.000Z"
    },
    {
      "id": 1266,
      "subject_id": 9,
      "question": "clearfix가 필요한 상황과 해결하는 문제로 올바른 것은?\n```css\n.container {\n    border: 2px solid black;\n}\n.floated-child {\n    float: left;\n    height: 200px;\n}\n```",
      "option_a": "자식 요소가 보이지 않는 문제 해결",
      "option_b": "부모 컨테이너의 높이가 0이 되는 문제 해결",
      "option_c": "텍스트가 겹치는 문제 해결",
      "option_d": "색상이 표시되지 않는 문제 해결",
      "correct_answer": "B",
      "explanation": "clearfix가 해결하는 핵심 문제:\n\n문제 발생 원인:\n\n• float된 자식 요소가 일반 문서 흐름에서 분리\n• 부모가 float된 자식의 높이를 인식하지 못함\n• 결과: 부모 높이가 0이 되거나 매우 작아짐\n\nclearfix 해결 방법들:\n\n1. Modern Clearfix (권장):\n```css\n.container::after {\n    content: \"\";\n    clear: both;\n    display: table;\n}\n```\n2. Overflow Method:\n```css\n.container {\n    overflow: auto;\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T10:31:03.000Z"
    },
    {
      "id": 1267,
      "subject_id": 9,
      "question": "다음 두 clearfix 방법의 차이점과 장단점으로 올바른 것은?\n```css\n/* 방법 A */\n.clearfix-old {\n    overflow: auto;\n}\n\n/* 방법 B */  \n.clearfix-modern::after {\n    content: \"\";\n    clear: both;\n    display: table;\n}\n```",
      "option_a": "A가 더 안전하고 B는 구형 브라우저 전용",
      "option_b": "B가 더 안전하고 A는 스크롤바 문제 가능성",
      "option_c": "둘 다 동일한 효과와 안전성",
      "option_d": "A는 float 전용, B는 flexbox 전용",
      "correct_answer": "B",
      "explanation": "두 clearfix 방법의 상세 비교:\n\n방법 A (overflow: auto)의 특성:\n\n장점:\n\n• 코드가 간단하고 직관적\n• 구형 브라우저에서도 잘 작동\n• 빠른 임시 해결책으로 유용\n\n단점 및 위험성:\n\n• 스크롤바 생성 위험: margin/padding이 컨테이너를 넘으면 스크롤바 표시\n• 제어 어려움: 복잡한 레이아웃에서 예상치 못한 스크롤\n• 디자인 깨짐: 의도하지 않은 스크롤바로 레이아웃 변형\n\n방법 B (::after pseudo-element)의 특성:\n\n장점:\n\n• 부작용 없음: 스크롤바나 레이아웃 변형 위험 없음\n• 정확한 제어: 오직 clearfix 목적으로만 작동\n• 모던 표준: 현재 웹 개발에서 권장되는 방식\n• 안정성: 다양한 상황에서 안전하게 작동\n\n단점:\n\n• 코드가 상대적으로 복잡\n• IE7 이하에서는 지원하지 않음 (현재는 문제없음)\n\n각 요소의 역할:\n\n• `content: \" \"`: 빈 가상 요소 생성\n• `clear: both`: 양쪽 float 모두 clear\n• `display: table`: 블록 레벨 특성 부여",
      "difficulty": "hard",
      "created_at": "2025-08-10T10:33:54.000Z"
    },
    {
      "id": 1268,
      "subject_id": 9,
      "question": "3개의 박스를 가로로 나란히 배치하려면 각 박스의 width 값은?\n```css\n.box {\n    float: left;\n    width: _____;\n}\n```",
      "option_a": "30%",
      "option_b": "33.33%",
      "option_c": "25%",
      "option_d": "50%",
      "correct_answer": "B",
      "explanation": "등분할 레이아웃의 계산법:\n\n기본 계산 원리:\n\n• 전체 너비 100%를 박스 개수로 나눔\n• 3개 박스 = 100% ÷ 3 = 33.33%\n• 각 박스가 동일한 크기를 가짐\n\n다른 개수별 너비:\n\n• 2개 박스: 50% 각각\n• 3개 박스: 33.33% 각각 ✓\n• 4개 박스: 25% 각각\n• 5개 박스: 20% 각각\n\n실무 활용 사례:\n\n• 상품 목록: 3열 그리드로 제품 표시\n• 이미지 갤러리: 사진을 3개씩 한 줄에 배치\n• 카드 레이아웃: 서비스 소개 카드 3개\n• 뉴스 섹션: 기사를 3개 컬럼으로 나열\n\n정확한 소수점의 중요성:\n\n• 33%만 사용하면 총 99%로 약간의 여백 발생\n• 33.33%를 사용해야 정확한 전체 너비 활용\n• 브라우저가 자동으로 반올림 처리\n\nbox-sizing과의 관계:\n\n• `box-sizing: border-box` 설정 시 padding/border 포함\n• 계산이 더 간단하고 예측 가능해짐",
      "difficulty": "easy",
      "created_at": "2025-08-10T10:38:24.000Z"
    },
    {
      "id": 1269,
      "subject_id": 9,
      "question": "다음 CSS에서 박스가 깨지지 않도록 하는 속성은?\n```css\n* {\n    _____: border-box;\n}\n.box {\n    float: left;\n    width: 33.33%;\n    padding: 50px;\n    border: 2px solid black;\n}\n```",
      "option_a": "display",
      "option_b": "box-sizing",
      "option_c": "overflow",
      "option_d": "position",
      "correct_answer": "B",
      "explanation": "box-sizing의 필수적 역할:\n\n문제 상황:\n\n• `width: 33.33%` + `padding: 50px` + `border: 2px`\n• 기본적으로는 총 너비가 33.33%를 초과\n• 결과: 3개 박스가 한 줄에 들어가지 않고 레이아웃 깨짐\n\nbox-sizing: border-box의 해결책:\n\n• width 값에 padding과 border를 포함\n• 총 너비가 정확히 33.33%로 유지\n• 3개 박스가 완벽하게 한 줄에 배치",
      "difficulty": "easy",
      "created_at": "2025-08-10T10:39:55.000Z"
    },
    {
      "id": 1270,
      "subject_id": 9,
      "question": "float로 만든 박스들의 높이를 동일하게 만드는 방법으로 제한이 있는 것은?\n```css\n.box {\n    float: left;\n    width: 33.33%;\n    _____: 500px;\n}\n```",
      "option_a": "min-height",
      "option_b": "max-height",
      "option_c": "height",
      "option_d": "line-height",
      "correct_answer": "C",
      "explanation": "고정 height의 장단점과 한계:\n\nheight: 500px의 효과:\n\n• 모든 박스가 정확히 500px 높이\n• 시각적으로 완벽하게 정렬된 레이아웃\n• 깔끔하고 일관된 디자인\n\n심각한 제한사항들:\n\n콘텐츠 넘침 문제:\n\n• 내용이 500px를 초과하면 박스 밖으로 넘침\n• 텍스트가 다른 요소와 겹칠 수 있음\n• 사용자 경험 크게 저하\n\n더 나은 대안들:\n\n• Flexbox: `display: flex` + `align-items: stretch`\n• CSS Grid: `display: grid` + `grid-template-rows: 1fr`\n• JavaScript: 동적으로 최대 높이 계산\n\nFlexbox 해결책:\n```css\n.container {\n    display: flex;\n}\n.box {\n    flex: 1; /* 동일한 크기 + 자동 높이 맞춤 */\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T10:42:06.000Z"
    },
    {
      "id": 1271,
      "subject_id": 9,
      "question": "다음 상황에서 가장 적절한 해결책은?\n```css\n/* 현재 코드 */\n.box {\n    float: left;\n    width: 33.33%;\n    height: 400px; /* 고정 높이 */\n    padding: 20px;\n}\n```\n문제점: 모바일에서 콘텐츠가 박스 밖으로 넘치고, 각 박스의 콘텐츠 양이 다름",
      "option_a": "height를 더 크게 설정 (600px)",
      "option_b": "overflow: hidden 추가",
      "option_c": "Flexbox로 대체",
      "option_d": "min-height로 변경",
      "correct_answer": "C",
      "explanation": "레거시 float 문제의 근본적 해결책:\n\n현재 코드의 multiple 문제점:\n\n고정 높이 문제:\n\n• 콘텐츠 양에 따라 넘침 또는 빈 공간 발생\n• 모바일에서 특히 심각한 레이아웃 깨짐\n• 다국어나 동적 콘텐츠 대응 불가\n\nfloat의 근본적 한계:\n\n• 원래 텍스트 감싸기 용도로 설계됨\n• 2차원 레이아웃에 부적합\n• clearfix 등 복잡한 해킹 필요\n\nFlexbox 해결책의 우수성:\n\n완벽한 높이 자동 맞춤:\n```css\n.container {\n    display: flex;\n    flex-wrap: wrap; /* 반응형 지원 */\n}\n.box {\n    flex: 1 1 33.33%; /* 유연한 크기 */\n    padding: 20px;\n    /* height 불필요! 자동으로 맞춰짐 */\n}\n```\n반응형 대응:\n```css\n@media (max-width: 768px) {\n    .box {\n        flex: 1 1 100%; /* 모바일에서 세로 배치 */\n    }\n}\n```",
      "difficulty": "hard",
      "created_at": "2025-08-10T10:45:30.000Z"
    },
    {
      "id": 1272,
      "subject_id": 9,
      "question": "`display: inline-block`의 주요 특징으로 올바른 것은?",
      "option_a": "새로운 줄에서 시작하고 width, height 설정 불가",
      "option_b": "새로운 줄에서 시작하지 않고 width, height 설정 가능",
      "option_c": "새로운 줄에서 시작하고 width, height 설정 가능",
      "option_d": "인라인 요소와 완전히 동일한 동작",
      "correct_answer": "B",
      "explanation": "inline-block의 핵심 특성:\n\n인라인 특성 (inline의 장점):\n\n• 다른 요소들과 같은 줄에 나란히 배치\n• 새로운 줄로 넘어가지 않음\n• 텍스트 흐름을 방해하지 않음\n\n블록 특성 (block의 장점):\n\n• width와 height 속성 적용 가능\n• padding, margin 모든 방향 적용 가능\n• 박스 모델의 모든 속성 사용 가능\n\n실무 활용 사례:\n\n• 버튼 그룹: 여러 버튼을 가로로 나열\n• 내비게이션 메뉴: 메뉴 항목들의 가로 정렬\n• 카드 레이아웃: 작은 카드들을 가로로 배치\n• 인라인 폼 요소: 입력 필드와 버튼을 한 줄에\n\n다른 display 값과의 차이:\n\n• inline: width/height 적용 불가\n• block: 새로운 줄에서 시작 (가로 나열 불가)\n• inline-block: 두 장점을 모두 가짐",
      "difficulty": "easy",
      "created_at": "2025-08-10T10:49:25.000Z"
    },
    {
      "id": 1273,
      "subject_id": 9,
      "question": "다음 중 `display: inline`에서는 작동하지 않지만 `display: inline-block`에서는 작동하는 속성은?",
      "option_a": "color",
      "option_b": "font-size",
      "option_c": "width",
      "option_d": "text-align",
      "correct_answer": "C",
      "explanation": "inline과 inline-block의 속성 지원 차이:\n\ninline에서 작동하지 않는 속성들:\n\n• width, height: 크기 지정 불가\n• margin-top, margin-bottom: 세로 여백 무시\n• padding-top, padding-bottom: 레이아웃에 영향 없음\n\ninline-block에서 추가로 지원되는 속성들:\n\n• width, height: 정확한 크기 제어 ✓\n• margin: 모든 방향 여백 적용\n• padding: 모든 방향 내부 여백 적용\n\n두 방식 모두 지원하는 속성들:\n\n• color: 텍스트 색상\n• font-size: 글자 크기\n• text-align: 텍스트 정렬 (부모 요소에 적용)\n• background: 배경 관련 속성",
      "difficulty": "easy",
      "created_at": "2025-08-10T10:50:32.000Z"
    },
    {
      "id": 1274,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 값은?\n```css\n.nav li {\n    display: _____;\n    width: 150px;\n    padding: 20px;\n    text-align: center;\n}\n```\n리스트 아이템들을 가로로 나열하면서 각각의 크기를 제어하고 싶을 때",
      "option_a": "inline",
      "option_b": "block",
      "option_c": "inline-block",
      "option_d": "flex",
      "correct_answer": "C",
      "explanation": "내비게이션 메뉴 구현의 최적 선택:\n\n요구사항 분석:\n\n• 가로 나열: 메뉴 항목들이 한 줄에 배치\n• 크기 제어: width: 150px 적용 필요\n• 패딩 적용: 클릭 영역 확보를 위한 padding\n• 텍스트 정렬: text-align: center로 가운데 정렬\n\ninline-block이 최적인 이유:\n\n• 가로 배치: 리스트 아이템들이 자연스럽게 나란히\n• 크기 적용: width와 padding이 정확히 작동\n• 클릭 영역: 전체 박스 영역이 클릭 가능\n• 일관성: 모든 메뉴 항목이 동일한 크기\n\n현대적 대안:\n```css\n/* Flexbox 방식 (더 권장) */\n.nav {\n    display: flex;\n}\n.nav li {\n    flex: 0 0 150px; /* 고정 크기 */\n    text-align: center;\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T10:53:32.000Z"
    },
    {
      "id": 1275,
      "subject_id": 9,
      "question": "블록 요소를 가로로 가운데 정렬하는 기본적인 방법은?\n```css\n.center {\n    _____: auto;\n    width: 50%;\n}\n```",
      "option_a": "padding",
      "option_b": "margin",
      "option_c": "text-align",
      "option_d": "position",
      "correct_answer": "B",
      "explanation": "블록 요소 가로 가운데 정렬의 기본 원리:\n\nmargin: auto의 동작 방식:\n\n• 좌우 여백을 자동으로 균등 분배\n• 남은 공간을 양쪽으로 동일하게 할당\n• 결과적으로 요소가 가운데 배치됨\n\n필수 조건:\n\n• width 속성이 반드시 설정되어야 함\n• width가 100%이거나 설정되지 않으면 효과 없음\n• 블록 레벨 요소에만 적용 가능",
      "difficulty": "easy",
      "created_at": "2025-08-10T10:59:58.000Z"
    },
    {
      "id": 1276,
      "subject_id": 9,
      "question": "텍스트를 가운데 정렬하는 속성과 값은?\n```css\n.text-center {\n    _____: _____;\n}\n```",
      "option_a": "margin, auto",
      "option_b": "text-align, center",
      "option_c": "display, center",
      "option_d": "position, center",
      "correct_answer": "B",
      "explanation": "텍스트 정렬의 기본 속성:\n\ntext-align: center의 효과:\n\n• 요소 내부의 텍스트를 가운데 정렬\n• 인라인 요소들도 함께 가운데 정렬\n• 블록 요소 자체가 아닌 내용물을 정렬\n\n적용 대상:\n\n• 텍스트 콘텐츠: 문장, 단어, 문자\n• 인라인 요소: `<span>`, `<a>`, `<img>` 등\n• 인라인 블록 요소: `display: inline-block`\n\n실무에서의 활용:\n\n• 제목: 페이지나 섹션 제목 가운데 정렬\n• 버튼 텍스트: 버튼 내부 텍스트 중앙 배치\n• 카드 내용: 카드 제목이나 설명 텍스트\n• 내비게이션: 메뉴 항목 텍스트 정렬\n\ntext-align의 다른 값들:\n\n• left: 왼쪽 정렬 (기본값)\n• right: 오른쪽 정렬\n• justify: 양쪽 정렬 (양끝 맞춤)\n\nmargin: auto와의 차이점:\n\n• margin: auto: 요소 자체를 정렬\n• text-align: center: 요소 내부 콘텐츠를 정렬\n\n상속 특성:\n\n• 부모에 설정하면 자식 요소에 상속됨\n• 필요 시 자식에서 다른 값으로 재정의 가능",
      "difficulty": "easy",
      "created_at": "2025-08-10T11:01:50.000Z"
    },
    {
      "id": 1277,
      "subject_id": 9,
      "question": "이미지를 가운데 정렬하기 위한 올바른 CSS 조합은?\n```css\nimg {\n    display: _____;\n    margin: _____;\n    width: 40%;\n}\n```",
      "option_a": "inline, auto",
      "option_b": "block, auto",
      "option_c": "inline-block, 0 auto",
      "option_d": "block, 0 auto",
      "correct_answer": "D",
      "explanation": "이미지 가운데 정렬의 완전한 해결책:\n\ndisplay: block의 필요성:\n\n• 이미지는 기본적으로 인라인 요소\n• 인라인 요소에는 margin: auto가 적용되지 않음\n• 블록 요소로 변경해야 가로 margin 자동 분배 가능\n\nmargin: 0 auto의 의미:\n\n• 0: 상하 여백 없음\n• auto: 좌우 여백 자동 분배 (가운데 정렬 효과)\n• 축약형으로 간결하게 표현\n\n완전한 동작 과정:\n\n• `display: block` → 이미지를 블록 요소로 변환\n• `width: 40%` → 명시적 너비 설정\n• `margin: 0 auto` → 좌우 가운데 정렬",
      "difficulty": "medium",
      "created_at": "2025-08-10T11:03:01.000Z"
    },
    {
      "id": 1278,
      "subject_id": 9,
      "question": "다음 중 세로 가운데 정렬을 위한 현대적이고 가장 권장되는 방법은?\n```css\n.container {\n    height: 200px;\n    display: _____;\n    _____: center;\n    _____: center;\n}\n```",
      "option_a": "block, text-align, vertical-align",
      "option_b": "flex, justify-content, align-items",
      "option_c": "inline, margin, padding",
      "option_d": "relative, top, left",
      "correct_answer": "B",
      "explanation": "Flexbox를 이용한 완벽한 가운데 정렬:\n\nFlexbox 정렬의 우수성:\n\n• 가로 + 세로 동시 정렬 가능\n• 간단하고 직관적인 문법\n• 반응형에 최적화된 동작\n• 브라우저 호환성 우수 (IE11+)\n\n각 속성의 역할:\n\n• display: flex: 플렉스 컨테이너로 설정\n• justify-content: center: 주축(가로) 가운데 정렬\n• align-items: center: 교차축(세로) 가운데 정렬",
      "difficulty": "medium",
      "created_at": "2025-08-10T11:04:08.000Z"
    },
    {
      "id": 1279,
      "subject_id": 9,
      "question": "다음 상황에서 가장 적절한 세로 가운데 정렬 방법은?\n\n조건:\n\n• 콘텐츠의 높이를 미리 알 수 없음\n• IE10+ 지원 필요\n• 텍스트가 여러 줄일 수 있음\n\n```css\n.container {\n    height: 300px;\n    position: relative;\n}\n.content {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    _____: translate(-50%, -50%);\n}\n```",
      "option_a": "display",
      "option_b": "transform",
      "option_c": "margin",
      "option_d": "padding",
      "correct_answer": "B",
      "explanation": "position + transform 조합의 정교한 활용:\n\n이 방법이 최적인 이유:\n\n동적 크기 대응:\n\n• 콘텐츠 높이를 미리 알 필요 없음\n• 런타임에 자동 계산되어 정확한 중앙 배치\n• 텍스트 줄 수 변화에도 자동 적응\n\ntransform: translate(-50%, -50%) 원리:\n\n• -50%: 요소 자신의 크기 기준으로 이동\n• 가로 -50%: 자신의 너비만큼 왼쪽으로\n• 세로 -50%: 자신의 높이만큼 위로\n• 결과: 정확한 중앙 위치\n\n전체 동작 과정:\n\n1. `position: absolute` → 일반 흐름에서 분리\n2. `top: 50%, left: 50%` → 왼쪽 상단 모서리를 중앙에 배치\n3. `transform: translate(-50%, -50%)` → 요소 중심을 실제 중앙으로 이동",
      "difficulty": "hard",
      "created_at": "2025-08-10T11:05:40.000Z"
    },
    {
      "id": 1280,
      "subject_id": 9,
      "question": "CSS Combinator의 주요 역할은 무엇인가요?",
      "option_a": "CSS 속성들을 결합함",
      "option_b": "선택자들 간의 관계를 설명함",
      "option_c": "여러 CSS 파일을 합침",
      "option_d": "HTML 요소를 생성함",
      "correct_answer": "B",
      "explanation": "CSS Combinator의 핵심 개념:\n\nCombinator의 기본 역할:\n\n• 두 개 이상의 선택자 사이의 관계를 정의\n• HTML 문서 구조에서 요소들 간의 위치 관계 표현\n• 더 정밀하고 구체적인 요소 선택 가능\n\n4가지 주요 Combinator:\n\n• 공백( ): 후손 선택자 (descendant)\n• >: 자식 선택자 (child)\n• +: 인접 형제 선택자 (next sibling)\n• ~: 일반 형제 선택자 (subsequent sibling)",
      "difficulty": "easy",
      "created_at": "2025-08-10T11:10:24.000Z"
    },
    {
      "id": 1281,
      "subject_id": 9,
      "question": "다음 CSS에서 실제로 스타일이 적용되는 요소는?\n```css\ndiv > p {\n    color: red;\n}\n```\n```html\n<div>\n    <p>A</p>\n    <section>\n        <p>B</p>\n    </section>\n    <p>C</p>\n</div>\n```",
      "option_a": "A만",
      "option_b": "B만",
      "option_c": "A와 C만",
      "option_d": "A, B, C 모두",
      "correct_answer": "C",
      "explanation": "Child Combinator (>)의 정확한 동작:\n\nChild Combinator의 엄격한 기준:\n\n• 오직 직접 자식 요소만 선택\n• 한 레벨 아래 요소에만 적용\n• 손자, 증손자 등은 제외\n\n각 요소별 분석:\n\n요소 A (`<p>A</p>`):\n\n• div의 직접 자식 ✓\n• 중간에 다른 요소 없이 바로 div 아래 위치\n• 스타일 적용됨\n\n요소 B (`<section><p>B</p></section>`):\n\n• div의 손자 요소 (div → section → p)\n• section이 중간에 있어서 직접 자식 아님\n• 스타일 적용 안됨\n\n요소 C (`<p>C</p>`):\n\n• div의 직접 자식 ✓\n• A와 마찬가지로 바로 div 아래 위치\n• 스타일 적용됨\n\nDescendant vs Child 비교:\n\n• `div p`: A, B, C 모두 선택 (후손 선택자)\n• `div > p`: A, C만 선택 (자식 선택자)",
      "difficulty": "medium",
      "created_at": "2025-08-10T11:12:51.000Z"
    },
    {
      "id": 1282,
      "subject_id": 9,
      "question": "다음 CSS의 차이점으로 올바른 것은?\n```css\n/* 코드 A */\nh2 + p { margin-top: 0; }\n\n/* 코드 B */  \nh2 ~ p { margin-top: 0; }\n```",
      "option_a": "A는 모든 p, B는 첫 번째 p만 선택",
      "option_b": "A는 첫 번째 p만, B는 모든 p 선택",
      "option_c": "둘 다 동일한 효과",
      "option_d": "A는 자식 p, B는 형제 p 선택",
      "correct_answer": "B",
      "explanation": "Adjacent vs General Sibling Combinator의 차이:\n\n+ (Adjacent Sibling Combinator):\n\n• 바로 다음에 오는 형제 요소만 선택\n• 첫 번째 인접 요소에만 적용\n• \"immediately following\" 개념\n\n~ (General Sibling Combinator):\n\n• h2 이후의 모든 형제 p 요소 선택\n• 순서대로 오는 모든 형제 요소에 적용\n• \"subsequent siblings\" 개념\n\nHTML 예시로 이해하기:\n```html\n<h2>제목</h2>\n<p>첫 번째 단락</p>  ← A(+)와 B(~) 모두 선택\n<div>다른 요소</div>\n<p>두 번째 단락</p>    ← B(~)만 선택\n<p>세 번째 단락</p>    ← B(~)만 선택\n```\n결과 비교:\n\n• h2 + p: 첫 번째 단락만 `margin-top: 0` 적용\n• h2 ~ p: 모든 p 단락에 `margin-top: 0` 적용",
      "difficulty": "medium",
      "created_at": "2025-08-10T11:14:28.000Z"
    },
    {
      "id": 1283,
      "subject_id": 9,
      "question": "다음 HTML 구조에서 각 CSS 선택자가 선택하는 요소의 개수는?\n```html\n<article>\n    <h2>제목1</h2>\n    <p>단락1</p>\n    <p>단락2</p>\n</article>\n<p>단락3</p>\n<article>\n    <h2>제목2</h2>\n    <p>단락4</p>\n</article>\n<p>단락5</p>\n```\n```css\nA: article p      /* ? 개 */\nB: article > p    /* ? 개 */  \nC: h2 + p         /* ? 개 */\nD: article ~ p    /* ? 개 */\n```",
      "option_a": "A:4개, B:3개, C:2개, D:2개",
      "option_b": "A:3개, B:3개, C:2개, D:2개",
      "option_c": "A:3개, B:3개, C:2개, D:1개",
      "option_d": "A:4개, B:3개, C:2개, D:1개",
      "correct_answer": "B",
      "explanation": "복합 구조에서 Combinator들의 정확한 동작 분석:\n\nA: `article p` (Descendant) - 3개:\n\n• article 요소 내부의 모든 p 요소\n• 단락1, 단락2, 단락4 선택\n• 단락3, 단락5는 article 밖이므로 제외\n\nB: `article > p` (Child) - 3개:\n\n• article의 직접 자식인 p 요소들\n• 단락1, 단락2, 단락4 선택\n• 모든 p가 article의 직접 자식이므로 A와 동일\n\nC: `h2 + p` (Adjacent Sibling) - 2개:\n\n• h2 바로 다음에 오는 p 요소\n• 제목1 → 단락1 ✓\n• 제목2 → 단락4 ✓\n• 총 2개 선택\n\nD: `article ~ p` (General Sibling) - 2개:\n\n• article 이후의 모든 형제 p 요소\n• 첫 번째 article 이후 → 단락3 ✓\n• 두 번째 article 이후 → 단락5 ✓\n• 총 2개 선택",
      "difficulty": "hard",
      "created_at": "2025-08-10T11:17:18.000Z"
    },
    {
      "id": 1284,
      "subject_id": 9,
      "question": "Pseudo-class의 주요 목적은 무엇인가요?",
      "option_a": "HTML 요소를 새로 생성함",
      "option_b": "요소의 특별한 상태를 정의하고 스타일링함",
      "option_c": "CSS 파일을 여러 개로 나눔",
      "option_d": "JavaScript 이벤트를 추가함",
      "correct_answer": "B",
      "explanation": "Pseudo-class의 핵심 개념:\n\nPseudo-class의 기본 역할:\n\n• 요소의 특별한 상태나 조건을 선택\n• 사용자 상호작용에 따른 스타일 변화\n• 구조적 위치에 따른 선택 (첫 번째 자식 등)\n\n주요 사용 목적:\n\n• 호버 효과: 마우스를 올렸을 때 변화\n• 링크 상태: 방문/미방문 링크 구분\n• 폼 상태: 포커스, 유효성 검사 상태\n• 구조 선택: 첫 번째, 마지막 요소 등\n\n문법 구조:\n```css\nselector:pseudo-class {\n    property: value;\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T11:38:54.000Z"
    },
    {
      "id": 1285,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 pseudo-class는?\n```css\na:_____ {\n    color: #FF00FF;\n}\n```\n링크에 마우스를 올렸을 때 색상을 변경하고 싶을 때",
      "option_a": "link",
      "option_b": "visited",
      "option_c": "hover",
      "option_d": "active",
      "correct_answer": "C",
      "explanation": "링크 상태 pseudo-class들의 구분:\n\n:hover의 특성:\n\n• 마우스 포인터가 요소 위에 있을 때 활성화\n• 모든 요소에 사용 가능 (링크뿐만 아니라)\n• 가장 직관적이고 자주 사용되는 상호작용\n\n다른 링크 상태들과의 차이:\n\n:link:\n\n• 방문하지 않은 링크의 기본 상태\n• 초기 스타일 설정용\n\n:visited:\n\n• 이미 방문한 링크의 상태\n• 보안상 제한된 속성만 변경 가능\n\n:active:\n\n• 링크를 클릭하는 순간의 짧은 상태\n• 마우스 버튼을 누르고 있는 동안",
      "difficulty": "easy",
      "created_at": "2025-08-10T11:40:08.000Z"
    },
    {
      "id": 1286,
      "subject_id": 9,
      "question": "다음 CSS에서 실제로 스타일이 적용되는 요소는?\n```css\np:first-child {\n    color: blue;\n}\n```\n```html\n<div>\n    <h1>제목</h1>\n    <p>첫 번째 단락</p>\n    <p>두 번째 단락</p>\n</div>\n<section>\n    <p>세 번째 단락</p>\n    <span>기타 요소</span>\n</section>\n```",
      "option_a": "첫 번째 단락만",
      "option_b": "세 번째 단락만",
      "option_c": "첫 번째와 세 번째 단락",
      "option_d": "모든 p 요소",
      "correct_answer": "B",
      "explanation": "first-child pseudo-class의 정확한 동작:\n\n:first-child의 엄격한 조건:\n\n• 해당 요소가 부모의 첫 번째 자식이어야 함\n• 요소 타입과 위치 조건을 동시에 만족해야 함\n\n각 요소별 분석:\n\n첫 번째 단락 (`<p>첫 번째 단락</p>`):\n\n• div의 자식이지만 두 번째 자식 (h1이 첫 번째)\n• p 요소이지만 first-child 조건 불만족 ✗\n\n두 번째 단락 (`<p>두 번째 단락</p>`):\n\n• div의 세 번째 자식\n• first-child 조건 불만족 ✗\n\n세 번째 단락 (`<p>세 번째 단락</p>`):\n\n• section의 첫 번째 자식 ✓\n• p 요소 조건도 만족 ✓\n• 스타일 적용됨",
      "difficulty": "medium",
      "created_at": "2025-08-10T11:42:09.000Z"
    },
    {
      "id": 1287,
      "subject_id": 9,
      "question": "다음 툴팁 효과 CSS에서 빈칸에 들어갈 올바른 선택자는?\n```css\np {\n    display: none;\n    background-color: yellow;\n    padding: 20px;\n}\n_____ {\n    display: block;\n}\n```\ndiv에 마우스를 올렸을 때 내부의 p 요소가 나타나게 하고 싶을 때",
      "option_a": "div p:hover",
      "option_b": "div:hover p",
      "option_c": "div:hover + p",
      "option_d": "div ~ p:hover",
      "correct_answer": "B",
      "explanation": "Pseudo-class와 Combinator의 조합 활용:\n\ndiv:hover p의 동작 원리:\n\n• div에 호버가 발생했을 때\n• div 내부의 모든 p 요소를 선택\n• 호버 상태에서 p 요소의 display 변경\n\n선택자 구조 분석:\n\n• `div:hover`: 호버 상태인 div 요소\n• 공백(descendant combinator): 후손 관계\n• `p`: div 내부의 모든 p 요소\n\n다른 선택지들의 문제점:\n\ndiv p:hover:\n\n• p 요소에 직접 호버해야 함\n• p가 숨겨져 있으면 호버 불가능\n• 툴팁 용도로 부적합\n\ndiv:hover + p:\n\n• div 바로 다음 형제 p만 선택\n• div 내부가 아닌 외부 p 선택\n• 구조적으로 맞지 않음\n\ndiv ~ p:hover:\n\n• div 이후 형제 p에 직접 호버\n• 의도한 동작과 완전히 다름",
      "difficulty": "medium",
      "created_at": "2025-08-10T11:43:52.000Z"
    },
    {
      "id": 1288,
      "subject_id": 9,
      "question": "다음 두 CSS 선택자의 차이점으로 올바른 것은?\n```css\n/* 선택자 A */\np i:first-child {\n    color: blue;\n}\n\n/* 선택자 B */\np:first-child i {\n    color: blue;\n}\n```\n```html\n<div>\n    <p><i>텍스트1</i> <span>기타</span> <i>텍스트2</i></p>\n    <p><i>텍스트3</i> <span>기타</span> <i>텍스트4</i></p>\n</div>\n```",
      "option_a": "A는 텍스트1만, B는 텍스트1,2만 선택",
      "option_b": "A는 텍스트1,3만, B는 텍스트1,2만 선택",
      "option_c": "A는 텍스트1,3만, B는 모든 i 요소 선택",
      "option_d": "둘 다 동일한 결과",
      "correct_answer": "B",
      "explanation": "복합 선택자에서 :first-child 위치의 중요성:\n\n선택자 A: `p i:first-child`:\n\n• 모든 p 요소 내부에서\n• 첫 번째 자식인 i 요소를 선택\n• p의 첫 번째 자식이 i여야 함\n\n선택자 B: `p:first-child i`:\n\n• 첫 번째 자식인 p 요소 내부의\n• 모든 i 요소를 선택\n• p가 부모의 첫 번째 자식이어야 함",
      "difficulty": "hard",
      "created_at": "2025-08-10T11:45:24.000Z"
    },
    {
      "id": 1289,
      "subject_id": 9,
      "question": "Pseudo-element의 주요 목적은 무엇인가요?",
      "option_a": "요소의 상태를 변경함",
      "option_b": "요소의 특정 부분을 스타일링함",
      "option_c": "새로운 HTML 태그를 만듦",
      "option_d": "JavaScript 이벤트를 추가함",
      "correct_answer": "B",
      "explanation": "Pseudo-element의 핵심 개념:\n\nPseudo-element의 기본 역할:\n\n• 요소의 특정 부분이나 위치를 선택하여 스타일링\n• 가상의 요소를 생성하여 콘텐츠 추가 가능\n• HTML 구조를 변경하지 않고도 시각적 효과 구현\n\n주요 사용 목적:\n\n• 첫 글자/첫 줄: 드롭캐피털, 첫 줄 강조\n• 콘텐츠 삽입: 아이콘, 장식 요소 추가\n• 리스트 마커: 불릿 포인트 커스터마이징\n• 선택 영역: 텍스트 선택 시 스타일\n\nPseudo-class vs Pseudo-element:\n\n• Pseudo-class (:hover, :focus): 요소의 상태\n• Pseudo-element (::before, ::after): 요소의 부분\n\n문법 특징:\n```css\n/* 이중 콜론 사용 (CSS3) */\nselector::pseudo-element {\n    property: value;\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T11:49:13.000Z"
    },
    {
      "id": 1290,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 pseudo-element는?\n```css\np::_____ {\n    color: #ff0000;\n    font-size: xx-large;\n}\n```\n문단의 첫 번째 글자만 크고 빨갛게 만들고 싶을 때",
      "option_a": "first-line",
      "option_b": "first-letter",
      "option_c": "before",
      "option_d": "after",
      "correct_answer": "B",
      "explanation": "::first-letter pseudo-element의 특성:\n\n::first-letter의 기능:\n\n• 텍스트의 첫 번째 글자만 선택\n• 드롭캐피털 효과 구현에 최적\n• 신문이나 잡지 스타일의 우아한 시작 연출\n\n적용 가능한 속성들:\n\n• 폰트 관련: font-size, font-family, font-weight 등\n• 색상: color, background-color\n• 여백: margin, padding\n• 테두리: border 관련 속성\n• 특수효과: text-shadow, float 등\n\n다른 pseudo-element들과의 차이:\n\n::first-line:\n\n• 첫 번째 줄 전체를 선택\n• 브라우저 창 크기에 따라 동적으로 변함\n• 줄바꿈 지점이 바뀌면 영향받는 텍스트도 변함\n\n::before / ::after:\n\n• 콘텐츠를 추가하는 용도\n• content 속성 필수\n• 기존 텍스트 수정이 아닌 새 요소 생성",
      "difficulty": "easy",
      "created_at": "2025-08-10T11:50:35.000Z"
    },
    {
      "id": 1291,
      "subject_id": 9,
      "question": "::before와 ::after pseudo-element 사용 시 반드시 필요한 속성은?\n```css\nh1::before {\n    _____: \"★\";\n    color: gold;\n}\n```",
      "option_a": "display",
      "option_b": "position",
      "option_c": "content",
      "option_d": "width",
      "correct_answer": "C",
      "explanation": "::before와 ::after의 필수 content 속성:\n\ncontent 속성의 필수성:\n\n• ::before와 ::after는 가상 요소를 생성\n• content 속성이 없으면 요소가 렌더링되지 않음\n• 빈 값이라도 `content: \"\";` 필수\n\ncontent 속성의 다양한 값들:\n\n텍스트 추가:\n```css\nh1::before { content: \"★ \"; }\nh1::after { content: \" ★\"; }\n```\n이미지 추가:\n```css\nh1::before { content: url(\"icon.png\"); }\n```\n빈 요소 (장식용):\n```css\n.divider::after {\n    content: \"\";\n    display: block;\n    width: 100%;\n    height: 1px;\n    background: #ccc;\n}\n```\nCSS 카운터 활용:\n```css\nh2::before {\n    content: counter(chapter) \". \";\n    counter-increment: chapter;\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T11:52:39.000Z"
    },
    {
      "id": 1292,
      "subject_id": 9,
      "question": "다음 CSS에서 ::first-line과 ::first-letter를 함께 사용했을 때의 결과는?\n```css\np::first-letter {\n    color: red;\n    font-size: 3em;\n}\np::first-line {\n    color: blue;\n    font-variant: small-caps;\n}\n```",
      "option_a": "충돌로 인해 아무 효과 없음",
      "option_b": "첫 글자는 빨간색 3em, 첫 줄 나머지는 파란색 small-caps",
      "option_c": "첫 줄 전체가 파란색 small-caps로만 표시",
      "option_d": "첫 글자만 빨간색 3em으로 표시",
      "correct_answer": "B",
      "explanation": "Multiple Pseudo-elements의 조화로운 작동:\n\n두 pseudo-element의 협력:\n\n• ::first-letter가 우선순위를 가짐\n• ::first-line은 나머지 부분에 적용\n• 서로 충돌하지 않고 조화롭게 작동\n\n구체적인 적용 결과:\n\n첫 번째 글자:\n\n• `color: red` (::first-letter 적용)\n• `font-size: 3em` (::first-letter 적용)\n• ::first-line의 스타일은 첫 글자에 적용되지 않음\n\n첫 줄의 나머지 부분:\n\n• `color: blue` (::first-line 적용)\n• `font-variant: small-caps` (::first-line 적용)\n• 첫 글자를 제외한 첫 줄의 모든 텍스트",
      "difficulty": "medium",
      "created_at": "2025-08-10T11:54:17.000Z"
    },
    {
      "id": 1293,
      "subject_id": 9,
      "question": "다음 상황에서 가장 적절한 pseudo-element 조합은?\n\n요구사항:\n\n• 제목 앞에 카테고리 아이콘 추가\n• 제목 뒤에 \"새글\" 배지 추가\n• 첫 번째 글자만 특별한 스타일 적용\n• 모든 효과가 HTML 수정 없이 CSS로만 구현\n```css\n.news-title::_____ { content: \"📰\"; }\n.news-title::_____ { content: \"NEW\"; }  \n.news-title::_____ { color: gold; }\n```",
      "option_a": "before, after, first-line",
      "option_b": "first-letter, before, after",
      "option_c": "before, after, first-letter",
      "option_d": "after, before, first-letter",
      "correct_answer": "C",
      "explanation": "복합 pseudo-element 활용의 실무적 구현:\n\n각 pseudo-element의 역할 분담:\n\n::before (앞쪽 아이콘):\n\n• 제목 시작 부분에 카테고리 아이콘 배치\n• `content: \"📰\";`로 뉴스 아이콘 추가\n• 콘텐츠 앞에서 컨텍스트 제공\n\n::after (뒤쪽 배지):\n\n• 제목 끝 부분에 상태 표시\n• `content: \"NEW\";`로 새글 표시\n• 추가 정보나 액션 힌트 제공\n\n::first-letter (첫 글자 강조):\n\n• 실제 제목 텍스트의 첫 번째 글자 스타일링\n• 드롭캐피털이나 시각적 임팩트 강화\n• 타이포그래피 효과 구현\n\n다른 선택지들의 문제점:\n\n• first-line: 첫 글자가 아닌 첫 줄 전체 (요구사항 불일치)\n• 순서 변경: 논리적 흐름과 맞지 않음",
      "difficulty": "hard",
      "created_at": "2025-08-10T11:56:02.000Z"
    },
    {
      "id": 1294,
      "subject_id": 9,
      "question": "CSS opacity 속성이 가질 수 있는 값의 범위는?",
      "option_a": "0 ~ 100",
      "option_b": "0.0 ~ 1.0",
      "option_c": "1 ~ 10",
      "option_d": "0% ~ 100%",
      "correct_answer": "B",
      "explanation": "opacity 속성의 기본 특성:\n\n값의 범위와 의미:\n\n• 0.0: 완전히 투명 (보이지 않음)\n• 1.0: 완전히 불투명 (기본값)\n• 0.5: 50% 투명도 (반투명)\n• 0.1: 90% 투명 (거의 보이지 않음)\n\n소수점 사용:\n\n• 정밀한 투명도 조절 가능\n• 예: `opacity: 0.3`, `opacity: 0.75`\n• 더 세밀한 시각적 효과 구현\n\n다른 단위들과의 차이:\n\n• 퍼센트(%): opacity에서는 사용하지 않음\n• 정수(1~10): CSS opacity에서 무효\n• 0~100: 다른 프로그램의 투명도 시스템",
      "difficulty": "easy",
      "created_at": "2025-08-10T12:22:08.000Z"
    },
    {
      "id": 1295,
      "subject_id": 9,
      "question": "다음 CSS 코드의 빈칸에 들어갈 올바른 값은?\n```css\nimg {\n    opacity: 0.3;\n}\nimg:hover {\n    opacity: _____;\n}\n```\n이미지에 마우스를 올렸을 때 완전히 선명하게 보이게 하고 싶을 때",
      "option_a": "0",
      "option_b": "0.5",
      "option_c": "1.0",
      "option_d": "100",
      "correct_answer": "C",
      "explanation": "호버 효과에서의 opacity 활용:\n\n기본 상태 (opacity: 0.3):\n\n• 이미지가 70% 투명한 상태\n• 흐릿하고 연한 모습으로 표시\n• 사용자의 주의를 덜 끌도록 설정\n\n호버 상태 (opacity: 1.0):\n\n• 이미지가 완전히 선명하게 변화\n• 100% 불투명한 원래 모습\n• 마우스 오버 시 강조 효과 생성\n\n인터랙션 흐름:\n\n1. 초기: 연한 이미지 (0.3)\n2. 호버: 선명한 이미지 (1.0)\n3. 호버 해제: 다시 연한 이미지 (0.3)",
      "difficulty": "easy",
      "created_at": "2025-08-10T12:23:45.000Z"
    },
    {
      "id": 1296,
      "subject_id": 9,
      "question": "opacity 속성을 부모 요소에 적용했을 때 발생하는 문제는?\n```css\n.container {\n    opacity: 0.3;\n}\n```\n```html\n<div class=\"container\">\n    <h1>제목</h1>\n    <p>내용</p>\n</div>\n```",
      "option_a": "자식 요소들이 모두 동일한 투명도를 상속받음",
      "option_b": "부모 요소만 투명해지고 자식은 영향 없음",
      "option_c": "CSS 오류로 인해 스타일이 적용되지 않음",
      "option_d": "자식 요소들이 완전히 보이지 않게 됨",
      "correct_answer": "A",
      "explanation": "opacity 상속의 문제점과 해결책:\n\nopacity 상속의 특성:\n\n• 부모의 opacity는 모든 자식 요소에 강제 적용\n• 자식이 개별적으로 opacity를 설정해도 부모의 영향 받음\n• 전체 요소가 하나의 단위로 투명도 적용\n\n문제가 되는 상황:\n\n• 텍스트 가독성 저하: 배경만 투명하게 하려고 했는데 텍스트도 투명\n• UI 요소 구분 어려움: 버튼이나 링크의 시인성 문제\n• 의도하지 않은 디자인: 전체적으로 흐릿한 모습\n\n실제 렌더링 결과:\n\n부모 opacity: 0.3\n├── h1 (실제로는 0.3 × 1.0 = 0.3)\n└── p (실제로는 0.3 × 1.0 = 0.3)\n\n해결책 1: RGBA 사용:\n```css\n.container {\n    /* opacity: 0.3; 대신 */\n    background-color: rgba(255, 255, 255, 0.3);\n}\n/* 자식 요소들은 영향받지 않음 */\n```\n해결책 2: 가상 요소 활용:\n```css\n.container {\n    position: relative;\n}\n.container::before {\n    content: \"\";\n    position: absolute;\n    top: 0; left: 0; right: 0; bottom: 0;\n    background: rgba(0, 0, 0, 0.3);\n    pointer-events: none;\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T12:26:04.000Z"
    },
    {
      "id": 1297,
      "subject_id": 9,
      "question": "배경만 투명하게 하고 텍스트는 선명하게 유지하려면?\n```css\n.box {\n    background: _____;\n    color: black;\n}\n```",
      "option_a": "opacity: 0.3",
      "option_b": "rgba(255, 255, 255, 0.3)",
      "option_c": "transparent: 0.3",
      "option_d": "alpha: 0.3",
      "correct_answer": "B",
      "explanation": "RGBA를 이용한 선택적 투명화:\n\nRGBA 문법 구조:\n\n• rgba(red, green, blue, alpha)\n• red, green, blue: 0~255 (색상값)\n• alpha: 0.0~1.0 (투명도)\n\n예시 코드 분석:\n\n• `rgba(255, 255, 255, 0.3)`: 흰색 배경에 30% 투명도\n• 텍스트는 `color: black`으로 선명하게 유지\n• 배경만 선택적으로 투명화\n\n다른 선택지들의 문제점:\n\nopacity: 0.3:\n• 전체 요소(텍스트 포함) 투명화\n• 텍스트 가독성 저하\n\ntransparent: 0.3:\n• 잘못된 CSS 문법\n• transparent는 완전 투명 키워드\n\nalpha: 0.3:\n• CSS에 없는 속성\n• RGBA 내부 파라미터와 혼동",
      "difficulty": "medium",
      "created_at": "2025-08-10T12:29:37.000Z"
    },
    {
      "id": 1298,
      "subject_id": 9,
      "question": "웹 사이트에서 내비게이션 바를 만들 때 가장 기본이 되는 HTML 요소는 무엇인가요?",
      "option_a": "`<div>`와 `<span>` 요소",
      "option_b": "`<ul>`과 `<li>` 요소",
      "option_c": "`<nav>`와 `<menu>` 요소",
      "option_d": "`<table>`과 `<tr>` 요소",
      "correct_answer": "B",
      "explanation": "• 내비게이션 바는 본질적으로 링크의 목록입니다\n• HTML에서 목록을 표현할 때는 순서가 없는 목록인 `<ul>`(unordered list)과 목록 항목인 `<li>`(list item)를 사용합니다\n• 각 `<li>` 안에 `<a>` 태그로 링크를 넣어서 내비게이션 메뉴를 구성합니다\n• 의미적으로도 내비게이션은 페이지들의 목록이므로 리스트 요소가 가장 적합합니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T12:32:41.000Z"
    },
    {
      "id": 1299,
      "subject_id": 9,
      "question": "다음 중 내비게이션 바에서 불필요한 요소를 제거하기 위해 사용하는 CSS 속성은?",
      "option_a": "`display: none;`",
      "option_b": "`visibility: hidden;`",
      "option_c": "`list-style-type: none;`",
      "option_d": "`text-decoration: none;`",
      "correct_answer": "C",
      "explanation": "• HTML 리스트 요소는 기본적으로 각 항목 앞에 불릿(•) 마커가 표시됩니다\n• 내비게이션 바에서는 이런 리스트 마커가 불필요하므로 제거해야 합니다\n• `list-style-type: none;`을 사용하면 불릿을 완전히 제거할 수 있습니다\n• 1,2번은 요소 자체를 숨기는 속성이고, 4번은 링크의 밑줄을 제거하는 속성입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T12:33:51.000Z"
    },
    {
      "id": 1300,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 CSS 속성값은?\n```css\nul {\n    list-style-type: none;\n    margin: _____;\n    padding: _____;\n}\n```",
      "option_a": "`auto`, `auto`",
      "option_b": "`0`, `0`",
      "option_c": "`10px`, `10px`",
      "option_d": "`inherit`, `inherit`",
      "correct_answer": "B",
      "explanation": "• 브라우저는 기본적으로 `<ul>` 요소에 자동으로 여백(margin)과 안쪽 여백(padding)을 적용합니다\n• 이 기본 여백들이 내비게이션 바의 레이아웃을 방해할 수 있습니다\n• `margin: 0;`과 `padding: 0;`을 설정하여 브라우저의 기본 스타일을 초기화합니다\n• 이렇게 해야 내비게이션 바가 예상한 위치에 정확히 배치됩니다\n• 깔끔한 내비게이션 바를 만들기 위한 표준적인 초기화 방법입니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T12:35:11.000Z"
    },
    {
      "id": 1301,
      "subject_id": 9,
      "question": "내비게이션 바를 만들 때 사용되는 완전한 HTML 구조는?\n```html\n<____>\n    <____><a href=\"home.html\">Home</a></____>\n    <____><a href=\"news.html\">News</a></____>\n    <____><a href=\"contact.html\">Contact</a></____>\n</____>\n```",
      "option_a": "`<ol>`, `<li>`, `</li>`, `</ol>`",
      "option_b": "`<ul>`, `<li>`, `</li>`, `</ul>`",
      "option_c": "`<div>`, `<span>`, `</span>`, `</div>`",
      "option_d": "`<nav>`, `<item>`, `</item>`, `</nav>`",
      "correct_answer": "B",
      "explanation": "• 내비게이션 바는 순서가 중요하지 않은 링크들의 목록이므로 `<ul>` (unordered list)를 사용합니다\n• 각각의 메뉴 항목은 `<li>` (list item) 태그로 감쌉니다\n• `<li>` 안에는 실제 링크인 `<a>` 태그가 들어갑니다\n• `<ol>`은 순서가 있는 목록용이고, `<div>`와 `<span>`은 의미적으로 부적절하며, `<item>`은 존재하지 않는 태그입니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T12:37:29.000Z"
    },
    {
      "id": 1302,
      "subject_id": 9,
      "question": "다음 CSS 코드가 내비게이션 바에 미치는 주된 효과를 모두 포함한 설명은?\n```css\nul {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n}\n```",
      "option_a": "리스트 불릿만 제거",
      "option_b": "브라우저 기본 여백만 제거",
      "option_c": "리스트 불릿 제거 + 브라우저 기본 여백 제거 + 깔끔한 내비게이션 바 기반 구축",
      "option_d": "리스트를 가로로 정렬",
      "correct_answer": "C",
      "explanation": "이 CSS 코드는 내비게이션 바의 기본 초기화 코드입니다\n\n세 가지 핵심 효과:\n• `list-style-type: none;`: HTML 리스트의 기본 불릿(•) 마커 완전 제거\n• `margin: 0;`: 리스트 외부 여백을 0으로 설정하여 브라우저 기본 마진 제거\n• `padding: 0;`: 리스트 내부 여백을 0으로 설정하여 브라우저 기본 패딩 제거\n\n결과적으로: 깔끔하고 예측 가능한 내비게이션 바의 기반을 만듭니다\n이 코드는 세로형, 가로형 내비게이션 바 모두에서 공통으로 사용되는 표준 초기화 방법입니다\n1,2번은 부분적인 효과만 설명하고, 4번은 이 코드로는 달성되지 않는 효과입니다",
      "difficulty": "hard",
      "created_at": "2025-08-10T12:39:09.000Z"
    },
    {
      "id": 1303,
      "subject_id": 9,
      "question": "세로형 내비게이션 바에서 링크(`<a>`)를 세로로 배치하고 전체 영역을 클릭 가능하게 만들기 위해 사용하는 CSS 속성은?",
      "option_a": "`display: inline;`",
      "option_b": "`display: block;`",
      "option_c": "`display: flex;`",
      "option_d": "`display: grid;`",
      "correct_answer": "B",
      "explanation": "• `display: block;`을 사용하면 링크가 블록 요소가 되어 세로로 배치됩니다\n• 블록 요소는 가로 전체 영역을 차지하므로 텍스트뿐만 아니라 전체 링크 영역이 클릭 가능해집니다\n• 인라인 요소(`display: inline;`)는 텍스트 부분만 클릭 가능합니다\n• 블록 요소로 설정하면 `width`, `height`, `padding`, `margin` 등의 속성도 자유롭게 조절할 수 있습니다\n• 세로형 내비게이션 바의 기본이 되는 핵심 속성입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T12:42:10.000Z"
    },
    {
      "id": 1304,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은?\n```css\nli a {\n    display: _____;\n    width: 60px;\n}\n```",
      "option_a": "`inline`",
      "option_b": "`block`",
      "option_c": "`none`",
      "option_d": "`flex`",
      "correct_answer": "B",
      "explanation": "• 세로형 내비게이션 바에서 각 링크는 블록 요소로 설정해야 합니다\n• `display: block;`을 사용해야 `width: 60px;`이 정상적으로 적용됩니다\n• 인라인 요소는 width 속성이 적용되지 않기 때문에 `display: inline;`은 부적절합니다\n• 블록 요소가 되면:\n각 링크가 새로운 줄에 배치됩니다 (세로 배치)\n지정한 너비가 정확히 적용됩니다\n전체 영역이 클릭 가능해집니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T12:44:16.000Z"
    },
    {
      "id": 1305,
      "subject_id": 9,
      "question": "사용자가 마우스를 올렸을 때 링크의 배경색을 변경하려면 어떤 CSS 선택자를 사용해야 하나요?\n```css\nli a_____ {\n    background-color: #555;\n    color: white;\n}\n```",
      "option_a": "`:active`",
      "option_b": "`:focus`",
      "option_c": "`:hover`",
      "option_d": "`:visited`",
      "correct_answer": "C",
      "explanation": "`:hover` 가상 선택자는 사용자가 요소 위에 마우스를 올렸을 때 스타일을 적용합니다\n\n내비게이션 바에서 사용자 경험을 향상시키는 중요한 인터랙션 효과입니다\n\n다른 선택자들의 차이점:\n• `:active`: 요소를 클릭하는 순간에만 적용\n• `:focus`: 요소가 포커스를 받았을 때 적용 (주로 키보드 탐색)\n• `:visited`: 이미 방문한 링크에 적용\n\n`li a:hover`는 \"li 안의 a 요소에 마우스가 올라갔을 때\"를 의미합니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T12:46:05.000Z"
    },
    {
      "id": 1306,
      "subject_id": 9,
      "question": "현재 활성화된 페이지를 표시하기 위한 완전한 CSS 코드는?\n```html\n<li><a href=\"#\" class=\"active\">Home</a></li>\n```",
      "option_a": "`.active { color: blue; }`",
      "option_b": "`#active { background-color: green; }`",
      "option_c": "`.active { background-color: #04AA6D; color: white; }`",
      "option_d": "`active { text-decoration: underline; }`",
      "correct_answer": "C",
      "explanation": "• `.active` 클래스 선택자를 사용하여 현재 페이지를 시각적으로 구분합니다\n\n• `background-color: #04AA6D;`로 녹색 배경을 설정합니다\n\n• `color: white;`로 텍스트를 흰색으로 만들어 가독성을 높입니다\n\n• 잘못된 선택지 분석:\n1번: 색상만 변경하여 시각적 구분이 약함\n2번: `#active`는 ID 선택자이지만 HTML에서는 class 사용\n4번: 선택자 앞에 점(.)이 없어서 문법 오류\n\n• 배경색과 텍스트 색을 함께 변경하여 명확한 시각적 구분을 제공합니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T12:47:50.000Z"
    },
    {
      "id": 1307,
      "subject_id": 9,
      "question": "전체 높이를 차지하는 고정형 세로 내비게이션 바를 만들기 위한 핵심 CSS 속성 조합은?\n```css\nul {\n    width: 25%;\n    background-color: #f1f1f1;\n    height: _____;\n    position: _____;\n    overflow: _____;\n}\n```",
      "option_a": "`auto`, `relative`, `hidden`",
      "option_b": "`100vh`, `absolute`, `visible`",
      "option_c": "`100%`, `fixed`, `auto`",
      "option_d": "`inherit`, `static`, `scroll`",
      "correct_answer": "C",
      "explanation": "전체 높이 고정형 사이드바의 핵심 속성들:\n\n• `height: 100%;`: 뷰포트 전체 높이를 차지\n• `position: fixed;`: 스크롤해도 위치가 고정됨 (sticky 효과)\n• `overflow: auto;`: 내용이 많을 경우 내비게이션 바 내에서 스크롤 가능\n\n각 속성의 역할:\n\n• `height: 100%`: 브라우저 창의 전체 높이만큼 내비게이션 바 확장\n• `position: fixed`: 페이지를 스크롤해도 내비게이션 바가 화면에 고정\n• `overflow: auto`: 메뉴 항목이 많아서 넘칠 경우 자동으로 스크롤바 생성\n\n잘못된 선택지 분석:\n\n• 1번: `position: relative`는 고정 효과 없음\n• 2번: `100vh`도 가능하지만 `position: absolute`는 스크롤 시 같이 움직임\n• 4번: `position: static`은 기본값으로 고정 효과 없음\n\n모바일에서는 제대로 작동하지 않을 수 있어 반응형 디자인 고려 필요",
      "difficulty": "hard",
      "created_at": "2025-08-10T12:50:39.000Z"
    },
    {
      "id": 1308,
      "subject_id": 9,
      "question": "`<li>` 요소들을 가로로 한 줄에 배치하는 가장 간단한 방법은?",
      "option_a": "`display: flex;`",
      "option_b": "`display: inline;`",
      "option_c": "`display: grid;`",
      "option_d": "`display: table;`",
      "correct_answer": "B",
      "explanation": "• `<li>` 요소는 기본적으로 블록 요소이므로 세로로 배치됩니다\n\n• `display: inline;`을 사용하면 각 리스트 항목 사이의 줄바꿈이 제거됩니다\n\n• 인라인 요소의 특징:\n한 줄에 나란히 배치됩니다\n너비와 높이를 지정할 수 없습니다\n좌우 margin/padding만 적용됩니다\n\n• 가로형 내비게이션 바를 만드는 첫 번째 방법으로 매우 간단합니다\n\n• `flex`나 `grid`도 가능하지만 더 복잡한 방법입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T12:53:54.000Z"
    },
    {
      "id": 1309,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은?\n```css\nli {\n    float: _____;\n}\na {\n    display: block;\n    padding: 8px;\n    background-color: #dddddd;\n}\n```",
      "option_a": "`right`",
      "option_b": "`center`",
      "option_c": "`left`",
      "option_d": "`none`",
      "correct_answer": "C",
      "explanation": "• `float: left;`는 가로형 내비게이션 바를 만드는 두 번째 방법입니다\n\n• float의 작동 원리:\n각 `<li>` 요소가 왼쪽부터 차례로 배치됩니다\n블록 요소들이 가로로 나란히 떠있게 됩니다\n일반적인 문서 흐름에서 벗어나 배치됩니다\n\n• inline 방법과의 차이점:\n`float`은 블록 요소 특성을 유지하면서 가로 배치\n`width`, `height`, `padding` 등을 자유롭게 조절 가능\n\n• `float: right;`를 사용하면 오른쪽 정렬이 됩니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T12:55:32.000Z"
    },
    {
      "id": 1310,
      "subject_id": 9,
      "question": "가로형 내비게이션 바에서 `overflow: hidden;`을 `<ul>`에 적용하는 이유는?\n```css\nul {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n    overflow: hidden;\n    background-color: #333;\n}\n```",
      "option_a": "텍스트가 길 때 자르기 위해서",
      "option_b": "`float` 속성으로 인한 레이아웃 문제 해결",
      "option_c": "스크롤바를 숨기기 위해서",
      "option_d": "배경색을 제대로 표시하기 위해서",
      "correct_answer": "B",
      "explanation": "• `float` 속성을 사용하면 자식 요소들이 부모의 높이에 영향을 주지 않습니다\n\n• 문제 상황:\n`<li>` 요소들이 `float: left;`로 떠있음\n부모인 `<ul>`의 높이가 0이 되어 배경색이 보이지 않음\n레이아웃이 깨져 보임\n\n• `overflow: hidden;`의 효과:\n새로운 Block Formatting Context(BFC) 생성\n떠있는 자식 요소들을 포함하도록 부모 높이 확장\n배경색과 테두리가 제대로 표시됨\n\n• 이를 \"clearfix\" 기법이라고 부르며, float 레이아웃의 필수 기술입니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T12:57:23.000Z"
    },
    {
      "id": 1311,
      "subject_id": 9,
      "question": "내비게이션 바의 특정 링크를 오른쪽 끝으로 정렬하려면?\n```html\n<ul>\n    <li><a href=\"#home\">Home</a></li>\n    <li><a href=\"#news\">News</a></li>\n    <li><a href=\"#contact\">Contact</a></li>\n    <li _____><a href=\"#about\">About</a></li>\n</ul>\n```",
      "option_a": "`class=\"right\"`",
      "option_b": "`style=\"text-align: right\"`",
      "option_c": "`style=\"float: right\"`",
      "option_d": "`style=\"position: absolute\"`",
      "correct_answer": "C",
      "explanation": "• **`style=\"float: right\"`**를 사용하면 해당 항목이 내비게이션 바의 오른쪽 끝으로 이동합니다\n\n• float 정렬의 특징:\n`float: left`: 왼쪽부터 차례로 배치\n`float: right`: 오른쪽부터 차례로 배치\n같은 내비게이션 바 내에서 혼용 가능\n\n• 실제 사용 예시:\n왼쪽: Home, News, Contact (기본 메뉴)\n오른쪽: Login, About (보조 메뉴)\n\n• 잘못된 선택지 분석:\n1번: CSS 클래스는 별도 정의 필요\n2번: 텍스트만 오른쪽 정렬, 항목 위치는 그대로\n4번: 절대 위치로 문서 흐름에서 완전히 벗어남",
      "difficulty": "medium",
      "created_at": "2025-08-10T12:58:45.000Z"
    },
    {
      "id": 1312,
      "subject_id": 9,
      "question": "스크롤해도 항상 화면 상단에 고정되는 내비게이션 바를 만들기 위한 CSS는?\n```css\nul {\n    position: _____;\n    top: _____;\n    width: _____;\n    z-index: 1000;\n}\n```",
      "option_a": "`relative`, `0`, `auto`",
      "option_b": "`absolute`, `0px`, `100%`",
      "option_c": "`fixed`, `0`, `100%`",
      "option_d": "`sticky`, `auto`, `inherit`",
      "correct_answer": "C",
      "explanation": "• 고정형 내비게이션 바의 핵심 속성들:\n`position: fixed;`: 뷰포트를 기준으로 절대 위치 고정\n`top: 0;`: 화면 맨 위에 고정\n`width: 100%;`: 화면 전체 너비를 차지\n\n• 각 속성의 역할:\n`position: fixed`: 스크롤과 관계없이 항상 같은 위치에 고정\n`top: 0`: 브라우저 창의 맨 위쪽에 배치\n`width: 100%`: 화면 전체 너비를 덮도록 설정\n`z-index: 1000`: 다른 요소들보다 위에 표시\n\n• 다른 position 값과의 차이:\n`relative`: 원래 위치 기준으로 상대적 이동 (스크롤 시 함께 움직임)\n`absolute`: 부모 요소 기준 절대 위치 (스크롤 시 함께 움직임)\n`sticky`: 스크롤 위치에 따라 relative와 fixed 사이를 전환\n\n• 주의사항: 모바일 기기에서는 제대로 작동하지 않을 수 있어 추가 고려사항이 필요합니다",
      "difficulty": "hard",
      "created_at": "2025-08-10T13:01:39.000Z"
    },
    {
      "id": 1313,
      "subject_id": 9,
      "question": "CSS만으로 드롭다운 메뉴를 만들 때, 평상시에는 숨겨져 있다가 마우스를 올렸을 때 나타나게 하는 기본 원리는?",
      "option_a": "`visibility: hidden;`을 `visibility: visible;`로 변경",
      "option_b": "`opacity: 0;`을 `opacity: 1;`로 변경",
      "option_c": "`display: none;`을 `display: block;`으로 변경",
      "option_d": "`height: 0;`을 `height: auto;`로 변경",
      "correct_answer": "C",
      "explanation": "• 드롭다운 메뉴의 기본 동작 원리는 표시/숨김 전환입니다\n\n• `display` 속성을 활용한 방법:\n• 평상시: `display: none;` (완전히 숨김)\n• 호버 시: `display: block;` (표시)\n\n• `:hover` 가상 선택자와 함께 사용하여 마우스 오버 시 자동으로 전환됩니다\n\n• 다른 방법들과의 차이점:\n• `visibility`: 공간은 차지하면서 보이지만 않음\n• `opacity`: 투명하게 만들지만 공간은 차지\n• `height`: 애니메이션 효과는 좋지만 복잡함\n\n• `display` 방법이 가장 간단하고 직관적입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T13:06:45.000Z"
    },
    {
      "id": 1314,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은?\n```css\n.dropdown {\n    position: _____;\n    display: inline-block;\n}\n.dropdown-content {\n    position: _____;\n    display: none;\n}\n```",
      "option_a": "`static`, `fixed`",
      "option_b": "`relative`, `absolute`",
      "option_c": "`absolute`, `relative`",
      "option_d": "`fixed`, `static`",
      "correct_answer": "B",
      "explanation": "• 드롭다운 메뉴의 위치 지정에는 부모-자식 관계가 중요합니다\n\n• `.dropdown` (부모 컨테이너):\n  • `position: relative;`: 자식 요소의 기준점 역할\n  • 자신의 위치는 문서 흐름을 따름\n\n• `.dropdown-content` (드롭다운 내용):\n  • `position: absolute;`: 부모 기준으로 절대 위치\n  • 문서 흐름에서 벗어나 다른 요소에 영향 안 줌\n\n• 이 조합의 장점:\n  • 드롭다운이 버튼 바로 아래 정확히 배치됨\n  • 페이지 레이아웃을 깨뜨리지 않음\n  • 다른 요소들과 겹치지 않음\n\n• `relative` + `absolute` 조합은 CSS 포지셔닝의 기본 패턴입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T13:09:45.000Z"
    },
    {
      "id": 1315,
      "subject_id": 9,
      "question": "마우스를 올렸을 때 드롭다운이 나타나게 하는 CSS 선택자는?\n```css\n.dropdown_____ .dropdown-content {\n    display: block;\n}\n```",
      "option_a": "`:active`",
      "option_b": "`:hover`",
      "option_c": "`:focus`",
      "option_d": "`:visited`",
      "correct_answer": "B",
      "explanation": "• **`.dropdown:hover .dropdown-content`**는 \"dropdown에 마우스가 올라갔을 때 그 안의 dropdown-content를 선택\"한다는 의미입니다\n\n• `:hover` 가상 선택자의 특징:\n  • 마우스가 요소 위에 있는 동안 스타일 적용\n  • 마우스가 벗어나면 자동으로 원래 상태로 복귀\n  • JavaScript 없이도 인터랙티브한 효과 구현 가능\n\n• 다른 선택자들의 용도:\n  • `:active`: 클릭하는 순간에만 적용\n  • `:focus`: 키보드나 클릭으로 포커스받을 때\n  • `:visited`: 이미 방문한 링크에 적용\n\n• 실제 동작: 사용자가 드롭다운 버튼에 마우스를 올리면 숨겨진 메뉴가 자동으로 나타납니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T13:12:24.000Z"
    },
    {
      "id": 1316,
      "subject_id": 9,
      "question": "드롭다운 메뉴가 화면 오른쪽 끝으로 정렬되도록 하려면 어떤 CSS 속성을 추가해야 하나요?\n```css\n.dropdown-content {\n    display: none;\n    position: absolute;\n    background-color: #f9f9f9;\n    min-width: 160px;\n    _____: 0;\n}\n```",
      "option_a": "`left`",
      "option_b": "`right`",
      "option_c": "`top`",
      "option_d": "`margin-right`",
      "correct_answer": "B",
      "explanation": "• **`right: 0;`**을 사용하면 드롭다운이 부모 요소의 오른쪽 끝에 정렬됩니다\n\n• 위치 지정 방식의 차이:\n  • `left: 0;`: 부모의 왼쪽 끝에 정렬 (기본)\n  • `right: 0;`: 부모의 오른쪽 끝에 정렬\n\n• 실제 사용 시나리오:\n  • 화면 오른쪽에 있는 사용자 메뉴\n  • 언어 선택 드롭다운\n  • 설정 메뉴 등\n\n• 다른 선택지 분석:\n  • `top`: 세로 위치 조정 (기본값 보통 사용)\n  • `margin-right`: 여백만 조정, 정렬 효과 없음\n\n• `position: absolute;`에서는 `left/right`, `top/bottom` 속성으로 정확한 위치를 지정합니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T13:15:14.000Z"
    },
    {
      "id": 1317,
      "subject_id": 9,
      "question": "완전한 드롭다운 메뉴를 만들기 위해 필요한 핵심 CSS 구성 요소를 모두 포함한 것은?\n```css\n/* 1단계: 컨테이너 */\n.dropdown {\n    position: relative;\n    display: inline-block;\n}\n\n/* 2단계: 드롭다운 내용 */\n.dropdown-content {\n    display: _____;\n    position: _____;\n    background-color: #f9f9f9;\n    min-width: 160px;\n    z-index: 1;\n}\n\n/* 3단계: 호버 효과 */\n.dropdown:_____ .dropdown-content {\n    display: _____;\n}\n```",
      "option_a": "`block`, `relative`, `focus`, `none`",
      "option_b": "`none`, `absolute`, `hover`, `block`",
      "option_c": "`hidden`, `fixed`, `active`, `visible`",
      "option_d": "`inline`, `static`, `hover`, `flex`",
      "correct_answer": "B",
      "explanation": "• 완전한 드롭다운 메뉴의 필수 구성 요소들:\n\n• 1단계 - 컨테이너 설정:\n  • `position: relative;`: 자식 요소의 기준점 제공\n  • `display: inline-block;`: 인라인 배치하면서 크기 조절 가능\n\n• 2단계 - 드롭다운 콘텐츠:\n  • `display: none;`: 평상시 완전히 숨김\n  • `position: absolute;`: 부모 기준 절대 위치 (문서 흐름에서 제거)\n  • `z-index: 1;`: 다른 요소들 위에 표시\n\n• 3단계 - 인터랙션:\n  • `.dropdown:hover .dropdown-content`: 부모에 마우스 올릴 때 자식 선택\n  • `display: block;`: 숨겨진 메뉴를 표시\n\n• 왜 이 조합이 필요한가?\n  • 레이아웃 안정성: `relative` + `absolute`로 다른 요소에 영향 없음\n  • 사용자 경험: 호버만으로 직관적인 조작\n  • 시각적 완성도: `z-index`로 레이어 순서 보장\n\n• 잘못된 선택지들:\n  • 1번: `position: relative`는 드롭다운 내용에 부적합\n  • 3번: `display: hidden`은 존재하지 않는 값\n  • 4번: `position: static`은 위치 지정 불가",
      "difficulty": "hard",
      "created_at": "2025-08-10T13:27:47.000Z"
    },
    {
      "id": 1318,
      "subject_id": 9,
      "question": "CSS로 이미지 갤러리를 만들 때, 여러 개의 갤러리 항목을 가로로 나란히 배치하는 가장 일반적인 방법은?",
      "option_a": "`display: inline;`",
      "option_b": "`float: left;`",
      "option_c": "`position: absolute;`",
      "option_d": "`text-align: center;`",
      "correct_answer": "B",
      "explanation": "• **`float: left;`**는 이미지 갤러리에서 여러 항목을 가로로 배치하는 전통적인 방법입니다\n\n• float의 특징:\n  • 각 갤러리 항목이 왼쪽부터 차례로 배치됩니다\n  • 블록 요소의 특성을 유지하면서 가로 배치가 가능합니다\n  • 너비와 높이를 자유롭게 조절할 수 있습니다\n\n• 다른 방법들의 한계:\n  • `display: inline;`: 너비/높이 조절 불가\n  • `position: absolute;`: 위치를 일일이 지정해야 함\n  • `text-align: center;`: 정렬만 가능, 배치 방법이 아님\n\n• 갤러리처럼 일정한 크기의 항목들을 규칙적으로 배치할 때 매우 효과적입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T13:31:41.000Z"
    },
    {
      "id": 1319,
      "subject_id": 9,
      "question": "다음 코드에서 이미지가 갤러리 컨테이너에 맞게 크기가 조절되도록 하는 빈칸의 값은?\n```css\ndiv.gallery img {\n    width: _____;\n    height: auto;\n}\n```",
      "option_a": "`auto`",
      "option_b": "`180px`",
      "option_c": "`100%`",
      "option_d": "`inherit`",
      "correct_answer": "C",
      "explanation": "• **`width: 100%;`**는 이미지를 부모 컨테이너의 너비에 맞게 자동으로 조절합니다\n\n• 반응형 이미지의 핵심 원리:\n  • `width: 100%`: 컨테이너 너비에 꽉 차게 맞춤\n  • `height: auto`: 가로세로 비율을 유지하면서 높이 자동 조절\n\n• 이 조합의 장점:\n  • 다양한 크기의 이미지가 일관된 크기로 표시됩니다\n  • 원본 이미지의 비율이 왜곡되지 않습니다\n  • 컨테이너 크기가 변해도 자동으로 맞춰집니다\n\n• 다른 값들의 문제:\n  • `auto`: 원본 크기 그대로, 컨테이너를 벗어날 수 있음\n  • `180px`: 고정 크기, 반응형 효과 없음\n  • `inherit`: 부모 요소의 width 값 상속, 부적절",
      "difficulty": "easy",
      "created_at": "2025-08-10T13:33:16.000Z"
    },
    {
      "id": 1320,
      "subject_id": 9,
      "question": "갤러리 항목에 마우스를 올렸을 때 테두리 색상이 변하는 효과를 주는 CSS는?\n```css\ndiv.gallery {\n    border: 1px solid #ccc;\n}\ndiv.gallery_____ {\n    border: 1px solid #777;\n}\n```",
      "option_a": "`:active`",
      "option_b": "`:hover`",
      "option_c": "`:focus`",
      "option_d": "`:visited`",
      "correct_answer": "B",
      "explanation": "• `:hover` 가상 선택자는 사용자가 요소에 마우스를 올렸을 때 스타일을 적용합니다\n\n• 호버 효과의 사용자 경험:\n  • 평상시: 연한 회색 테두리 (`#ccc`)\n  • 마우스 오버 시: 진한 회색 테두리 (`#777`)\n  • 시각적 피드백으로 상호작용 가능함을 알려줌\n\n• 갤러리에서 호버 효과의 중요성:\n  • 사용자가 클릭 가능한 요소임을 직관적으로 알 수 있음\n  • 현재 보고 있는 항목을 명확히 구분\n  • 더 나은 사용자 경험 제공\n\n• 다른 선택자들의 용도:\n  • `:active`: 클릭하는 순간에만 적용\n  • `:focus`: 키보드 탐색이나 포커스 받을 때\n  • `:visited`: 방문한 링크에 적용",
      "difficulty": "medium",
      "created_at": "2025-08-10T13:35:50.000Z"
    },
    {
      "id": 1321,
      "subject_id": 9,
      "question": "갤러리 항목의 설명 텍스트를 중앙 정렬하고 적절한 여백을 주는 CSS는?\n```css\ndiv.desc {\n    padding: _____;\n    text-align: _____;\n}\n```",
      "option_a": "`5px`, `left`",
      "option_b": "`15px`, `center`",
      "option_c": "`0`, `right`",
      "option_d": "`auto`, `justify`",
      "correct_answer": "B",
      "explanation": "• **`padding: 15px;`**는 설명 텍스트 주변에 충분한 여백을 제공합니다\n\n• **`text-align: center;`**는 텍스트를 중앙에 정렬하여 시각적 균형을 맞춥니다\n\n• 갤러리 설명의 디자인 원칙:\n  • 적절한 패딩: 텍스트와 테두리 사이에 숨쉴 공간 제공\n  • 중앙 정렬: 이미지 아래 설명이 균형있게 배치\n  • 가독성 향상: 깔끔하고 정돈된 느낌",
      "difficulty": "medium",
      "created_at": "2025-08-10T13:48:05.000Z"
    },
    {
      "id": 1322,
      "subject_id": 9,
      "question": "완전한 이미지 갤러리 항목을 만들기 위한 CSS 구조에서 빈칸에 들어갈 올바른 값들은?\n```css\ndiv.gallery {\n    margin: 5px;\n    border: 1px solid #ccc;\n    float: _____;\n    width: _____;\n}\ndiv.gallery:hover {\n    border: 1px solid #777;\n}\ndiv.gallery img {\n    width: 100%;\n    height: _____;\n}\ndiv.desc {\n    padding: 15px;\n    text-align: center;\n}\n```",
      "option_a": "`right`, `auto`, `100%`",
      "option_b": "`left`, `180px`, `auto`",
      "option_c": "`none`, `100%`, `fixed`",
      "option_d": "`center`, `max-content`, `inherit`",
      "correct_answer": "B",
      "explanation": "완전한 이미지 갤러리 구성 요소들의 역할:\n\n`float: left;`:\n\n  • 갤러리 항목들을 왼쪽부터 차례로 가로 배치\n  • 여러 행에 걸쳐 자동으로 줄바꿈 가능\n  • 그리드 형태의 갤러리 레이아웃 구현\n\n`width: 180px;`:\n\n  • 각 갤러리 항목의 고정 너비 설정\n  • 일관된 크기로 깔끔한 정렬 효과\n  • 반응형이 필요하면 % 단위도 사용 가능\n\n`height: auto;`:\n\n  • 이미지 비율을 유지하면서 높이 자동 조절\n  • width: 100%와 함께 사용하여 완벽한 반응형 이미지\n  • 다양한 비율의 이미지도 자연스럽게 처리",
      "difficulty": "hard",
      "created_at": "2025-08-10T13:54:37.000Z"
    },
    {
      "id": 1323,
      "subject_id": 9,
      "question": "이미지 스프라이트를 사용하는 주된 이유는 무엇인가요?",
      "option_a": "이미지 화질을 향상시키기 위해",
      "option_b": "서버 요청 횟수를 줄이고 대역폭을 절약하기 위해",
      "option_c": "이미지 파일 크기를 압축하기 위해",
      "option_d": "다양한 브라우저 호환성을 위해",
      "correct_answer": "B",
      "explanation": "• 이미지 스프라이트의 핵심 목적은 웹 성능 최적화입니다\n\n• 성능 개선 효과:\n  • 여러 개의 작은 이미지를 하나로 합쳐서 HTTP 요청 횟수 감소\n  • 서버 부하 감소 및 페이지 로딩 속도 향상\n  • 네트워크 대역폭 절약\n\n• 실제 예시:\n  • 내비게이션 아이콘 3개 → 서버 요청 3번\n  • 스프라이트 이미지 1개 → 서버 요청 1번\n\n• 특히 유용한 경우:\n  • 작은 아이콘들이 많은 웹사이트\n  • 내비게이션 버튼, 소셜 미디어 아이콘 등\n\n• 화질 향상이나 압축은 스프라이트의 목적이 아니며, 브라우저 호환성과도 직접적인 관련이 없습니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T13:57:32.000Z"
    },
    {
      "id": 1324,
      "subject_id": 9,
      "question": "이미지 스프라이트에서 원하는 부분만 표시하기 위해 사용하는 CSS 속성은?\n```css\n#home {\n    width: 46px;\n    height: 44px;\n    _____: url(img_navsprites.gif) 0 0;\n}\n```",
      "option_a": "`background-image`",
      "option_b": "`background`",
      "option_c": "`src`",
      "option_d": "`content`",
      "correct_answer": "B",
      "explanation": "• `background` 속성은 이미지 스프라이트의 핵심 기술입니다\n\n• background 속성의 구성:\n  • `url(img_navsprites.gif)`: 스프라이트 이미지 파일 지정\n  • `0 0`: 배경 위치 (x축 0px, y축 0px)\n\n• 스프라이트 작동 원리:\n  • 큰 이미지를 배경으로 설정\n  • 요소의 크기(width/height)로 보여질 영역 제한\n  • 배경 위치로 원하는 부분을 창문처럼 보여줌\n\n• 다른 선택지 분석:\n  • `background-image`: 이미지만 지정, 위치 설정 불가\n  • `src`: HTML img 태그 속성, CSS가 아님\n  • `content`: 가상 요소에서 사용, 이미지 스프라이트에 부적절\n\n• `background` 단축 속성으로 이미지와 위치를 한 번에 설정하는 것이 일반적입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T13:59:14.000Z"
    },
    {
      "id": 1325,
      "subject_id": 9,
      "question": "스프라이트 이미지에서 두 번째 아이콘을 표시하려면 배경 위치를 어떻게 설정해야 하나요?\n```css\n/* 첫 번째 아이콘 (홈): 너비 46px */\n#home {\n    background: url(img_navsprites.gif) 0 0;\n}\n\n/* 두 번째 아이콘 (이전): 너비 43px */\n#prev {\n    background: url(img_navsprites.gif) _____ 0;\n}\n```",
      "option_a": "`46px`",
      "option_b": "`-46px`",
      "option_c": "`-47px`",
      "option_d": "`47px`",
      "correct_answer": "C",
      "explanation": "• **음수 값(`-47px`)**을 사용하여 배경 이미지를 왼쪽으로 이동시킵니다\n\n• 배경 위치 계산 방법:\n  • 첫 번째 아이콘 너비: 46px\n  • 아이콘 사이 구분선: 1px\n  • 총 이동 거리: 46px + 1px = 47px\n\n• 음수 사용 이유:\n  • 배경 이미지를 왼쪽으로 이동시켜 두 번째 아이콘이 보이게 함\n  • 마치 큰 그림을 왼쪽으로 밀어서 다른 부분을 창으로 보는 것과 같음\n\n• 스프라이트 위치 이동 원리:\n  • `0 0`: 첫 번째 아이콘 (맨 왼쪽)\n  • `-47px 0`: 두 번째 아이콘 (47px만큼 왼쪽으로 이동)\n  • `-91px 0`: 세 번째 아이콘 (91px만큼 왼쪽으로 이동)\n\n• 양수를 사용하면 이미지가 오른쪽으로 이동하여 빈 공간만 보입니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T14:01:09.000Z"
    },
    {
      "id": 1326,
      "subject_id": 9,
      "question": "이미지 스프라이트로 내비게이션 리스트를 만들 때 필요한 위치 지정 방법은?\n```css\n#navlist {\n    position: _____;\n}\n#navlist li {\n    position: _____;\n    top: 0;\n}\n```",
      "option_a": "`static`, `relative`",
      "option_b": "`relative`, `absolute`",
      "option_c": "`absolute`, `fixed`",
      "option_d": "`fixed`, `static`",
      "correct_answer": "B",
      "explanation": "• `position: relative`와 `position: absolute`의 부모-자식 관계가 핵심입니다\n\n• 부모 컨테이너 (`#navlist`):\n  • `position: relative`: 자식 요소들의 기준점 역할\n  • 자신의 위치는 문서 흐름을 따름\n\n• 자식 요소들 (`#navlist li`):\n  • `position: absolute`: 부모 기준으로 절대 위치\n  • `top: 0`: 모든 아이콘을 같은 높이에 배치\n  • 각각 다른 `left` 값으로 가로 위치 조정\n\n• 이 방법의 장점:\n  • 아이콘들을 정확한 위치에 배치 가능\n  • 겹치지 않고 깔끔하게 정렬\n  • 반응형 레이아웃에도 유연하게 대응\n\n• 실제 적용 예:\n  • `#home { left: 0px; }`\n  • `#prev { left: 63px; }`\n  • `#next { left: 129px; }`\n\n• 다른 position 조합으로는 정확한 위치 제어가 어렵습니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T14:03:26.000Z"
    },
    {
      "id": 1327,
      "subject_id": 9,
      "question": "이미지 스프라이트에 호버 효과를 추가할 때, 호버용 이미지의 배경 위치는 어떻게 설정해야 하나요?\n```css\n/* 일반 상태 */\n#home {\n    background: url(img_navsprites.gif) 0 0;\n}\n\n/* 호버 상태 */\n#home a:hover {\n    background: url(img_navsprites_hover.gif) 0 _____;\n}\n```\n여기서 일반 이미지와 호버 이미지가 세로로 배치되어 있고, 각 아이콘의 높이가 45px입니다.",
      "option_a": "`0`",
      "option_b": "`45px`",
      "option_c": "`-45px`",
      "option_d": "`-90px`",
      "correct_answer": "C",
      "explanation": "• 호버 효과를 위해서는 y축 좌표를 음수로 이동시켜야 합니다\n\n• 스프라이트 이미지 구조:\n  • 위쪽: 일반 상태 아이콘들 (0px 위치)\n  • 아래쪽: 호버 상태 아이콘들 (45px 아래 위치)\n\n• 배경 위치 계산:\n  • 일반 상태: `0 0` (맨 위)\n  • 호버 상태: `0 -45px` (45px만큼 위로 이동하여 아래쪽 이미지가 보임)\n\n• 음수를 사용하는 이유:\n  • 배경 이미지를 위로 이동시켜 아래쪽에 있는 호버 이미지가 보이게 함\n  • 마치 큰 그림을 위로 밀어 올려 다른 부분을 보는 것과 같음\n\n• 호버 효과의 장점:\n  • 하나의 이미지 파일로 일반/호버 상태 모두 처리\n  • 마우스 오버 시 이미지 로딩 지연 없음\n  • 더 빠른 사용자 경험 제공",
      "difficulty": "hard",
      "created_at": "2025-08-10T14:05:19.000Z"
    },
    {
      "id": 1328,
      "subject_id": 9,
      "question": "특정 속성을 가진 모든 요소를 선택하는 CSS 선택자는?\n```css\n/* target 속성을 가진 모든 <a> 요소 선택 */\na_____ {\n    background-color: yellow;\n}\n```",
      "option_a": "`(target)`",
      "option_b": "`[target]`",
      "option_c": "`{target}`",
      "option_d": "`<target>`",
      "correct_answer": "B",
      "explanation": "• **대괄호 `[속성명]`**을 사용하여 특정 속성을 가진 요소를 선택합니다\n\n• 속성 선택자의 기본 형태:\n  • `[attribute]`: 해당 속성을 가진 모든 요소\n  • 속성값과 상관없이 속성만 존재하면 선택됨\n\n• 실제 적용 예시:\n  • `a[target]`: target 속성이 있는 모든 링크\n  • `input[required]`: required 속성이 있는 모든 입력 필드\n  • `img[alt]`: alt 속성이 있는 모든 이미지\n\n• 다른 기호들의 용도:\n  • `()`: 함수나 그룹핑에 사용\n  • `{}`: CSS 선언 블록에 사용\n  • `<>`: HTML 태그에 사용\n\n• 대괄호는 HTML 속성을 다루는 CSS의 표준 문법입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T14:08:55.000Z"
    },
    {
      "id": 1329,
      "subject_id": 9,
      "question": "특정 속성값을 가진 요소를 선택하려면 어떤 선택자를 사용해야 하나요?\n```css\n/* target=\"_blank\" 속성을 가진 링크만 선택 */\na[target_____\"_blank\"] {\n    background-color: yellow;\n}\n```",
      "option_a": "`:`",
      "option_b": "`~`",
      "option_c": "`=`",
      "option_d": "`*`",
      "correct_answer": "C",
      "explanation": "• **등호 `=`**를 사용하여 속성값이 정확히 일치하는 요소를 선택합니다\n\n• 정확한 값 매칭:\n  • `[attribute=\"value\"]`: 속성값이 정확히 일치해야 함\n  • 대소문자 구분함\n  • 완전히 동일한 값만 선택\n\n• 실제 사용 예시:\n  • `a[target=\"_blank\"]`: 새 창에서 열리는 링크만\n  • `input[type=\"text\"]`: 텍스트 입력 필드만\n  • `div[class=\"container\"]`: class가 정확히 \"container\"인 div만\n\n• 다른 기호들의 역할:\n  • `~`: 단어 단위 매칭\n  • `*`: 포함 매칭\n  • `:`: 가상 선택자에 사용",
      "difficulty": "easy",
      "created_at": "2025-08-10T14:10:42.000Z"
    },
    {
      "id": 1330,
      "subject_id": 9,
      "question": "속성값이 특정 단어로 시작하는 요소를 선택하는 선택자는?\n```css\n/* class 속성값이 \"top\"으로 시작하는 모든 요소 */\n[class_____\"top\"] {\n    background: yellow;\n}\n```",
      "option_a": "`~=`",
      "option_b": "`|=`",
      "option_c": "`^=`",
      "option_d": "`$=`",
      "correct_answer": "C",
      "explanation": "• **캐럿 기호 `^=`**는 \"~로 시작하는(starts with)\"을 의미합니다\n\n• 시작 문자열 매칭의 특징:\n  • 속성값의 맨 앞 부분이 지정된 값과 일치하면 선택\n  • 전체 단어가 아니어도 됨 (부분 문자열 매칭)\n  • 대소문자 구분함\n\n• 실제 매칭 예시:\n  • `[class^=\"top\"]`가 선택하는 요소들:\n    • `class=\"top\"` ✓\n    • `class=\"topbar\"` ✓\n    • `class=\"top-menu\"` ✓\n    • `class=\"my-top\"` ✗ (시작하지 않음)\n\n• 다른 선택자들과의 차이:\n  • `~=`: 공백으로 구분된 단어 중 하나와 일치\n  • `|=`: 정확한 값이거나 하이픈으로 이어지는 값\n  • `$=`: 끝나는 문자열과 일치\n\n• 클래스명이나 ID 명명 규칙에 따른 그룹 선택에 매우 유용합니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T14:13:01.000Z"
    },
    {
      "id": 1331,
      "subject_id": 9,
      "question": "다음 중 `[title~=\"flower\"]` 선택자에 의해 선택되는 요소는?",
      "option_a": "`<div title=\"flower\">`",
      "option_b": "`<div title=\"summer flower\">`",
      "option_c": "`<div title=\"my-flower\">`",
      "option_d": "1번과 2번 모두",
      "correct_answer": "D",
      "explanation": "• **물결표 `~=`**는 공백으로 구분된 단어 목록에서 특정 단어를 찾는 선택자입니다\n\n• 단어 단위 매칭 규칙:\n  • 속성값을 공백으로 나눈 각 단어 중 하나가 일치하면 선택\n  • 완전한 단어여야 함 (부분 문자열 안 됨)\n  • 하이픈으로 연결된 것은 하나의 단어로 취급\n\n• 각 예시 분석:\n  • `title=\"flower\"`: \"flower\" 단어 하나 → ✓ 선택됨\n  • `title=\"summer flower\"`: \"summer\", \"flower\" 두 단어 → ✓ 선택됨\n  • `title=\"my-flower\"`: \"my-flower\" 하나의 단어 → ✗ 선택 안 됨",
      "difficulty": "medium",
      "created_at": "2025-08-10T14:14:36.000Z"
    },
    {
      "id": 1332,
      "subject_id": 9,
      "question": "폼 요소들을 타입별로 스타일링하기 위한 완전한 CSS 코드는?\n```css\n/* 텍스트 입력 필드 스타일링 */\ninput[type_____\"text\"] {\n    width: 150px;\n    display: block;\n    background-color: yellow;\n}\n\n/* 버튼 스타일링 */\ninput[type_____\"button\"] {\n    width: 120px;\n    display: block;\n}\n```",
      "option_a": "`~=`, `~=`",
      "option_b": "`^=`, `$=`",
      "option_c": "`=`, `=`",
      "option_d": "`*=`, `*=`",
      "correct_answer": "C",
      "explanation": "• **폼 요소 스타일링에서는 정확한 값 매칭 `=`**을 사용해야 합니다\n\n• input type 속성의 특징:\n  • type 속성값은 정확히 하나의 값만 가짐 (\"text\", \"button\", \"email\" 등)\n  • 공백으로 구분된 여러 값을 가지지 않음\n  • 부분 문자열이 아닌 완전한 값 매칭 필요\n\n• 폼 스타일링의 실용적 활용:\n```css\ninput[type=\"text\"]     { /* 텍스트 입력 */ }\ninput[type=\"email\"]    { /* 이메일 입력 */ }\ninput[type=\"password\"] { /* 비밀번호 입력 */ }\ninput[type=\"submit\"]   { /* 제출 버튼 */ }\ninput[type=\"reset\"]    { /* 초기화 버튼 */ }\n```",
      "difficulty": "hard",
      "created_at": "2025-08-10T14:16:18.000Z"
    },
    {
      "id": 1333,
      "subject_id": 9,
      "question": "텍스트 입력 필드의 너비를 설정하는 CSS 속성은?\n```css\ninput[type=text] {\n    _____: 100%;\n}\n```",
      "option_a": "`size`",
      "option_b": "`length`",
      "option_c": "`width`",
      "option_d": "`border`",
      "correct_answer": "C",
      "explanation": "• `width` 속성은 HTML 요소의 너비를 지정하는 표준 CSS 속성입니다\n\n• 폼 필드 너비 설정의 장점:\n  • 일관된 레이아웃 구성\n  • 다양한 화면 크기에 대응 (100% 사용 시)\n  • 사용자 경험 향상\n\n• 값 설정 방법:\n  • `100%`: 부모 요소 너비에 맞춤 (반응형)\n  • `300px`: 고정 너비 (픽셀 단위)\n  • `50%`: 부모 요소 너비의 절반\n\n• 다른 선택지 분석:\n  • `size`: HTML 속성이며 CSS 속성이 아님\n  • `length`: 존재하지 않는 CSS 속성\n  • `border`: 테두리 설정 속성",
      "difficulty": "easy",
      "created_at": "2025-08-10T14:57:53.000Z"
    },
    {
      "id": 1334,
      "subject_id": 9,
      "question": "입력 필드 내부에 여백을 추가하고 외부 간격을 설정하는 CSS 속성들은?\n```css\ninput[type=text] {\n    width: 100%;\n    _____: 12px 20px;\n    _____: 8px 0;\n    box-sizing: border-box;\n}\n```",
      "option_a": "`margin`, `padding`",
      "option_b": "`padding`, `margin`",
      "option_c": "`border`, `outline`",
      "option_d": "`spacing`, `gap`",
      "correct_answer": "B",
      "explanation": "• `padding`은 요소 내부 여백, `margin`은 요소 외부 간격을 설정합니다\n\n• 패딩 설정 (`padding: 12px 20px`):\n  • 상하 12px, 좌우 20px의 내부 여백\n  • 텍스트와 테두리 사이 공간 확보\n  • 입력하기 편한 환경 제공\n\n• 마진 설정 (`margin: 8px 0`):\n  • 상하 8px, 좌우 0px의 외부 간격\n  • 입력 필드들 사이의 간격 확보\n  • 레이아웃의 시각적 분리\n\n• `box-sizing: border-box`의 역할:\n  • 패딩과 테두리를 전체 너비에 포함\n  • 예측 가능한 크기 계산\n  • 레이아웃 깨짐 방지\n\n• Box Model 이해:\n  • Content → Padding → Border → Margin 순서\n  • 각각의 역할과 용도가 다름",
      "difficulty": "easy",
      "created_at": "2025-08-10T15:00:48.000Z"
    },
    {
      "id": 1335,
      "subject_id": 9,
      "question": "입력 필드에 포커스가 될 때 스타일을 변경하려면 어떤 선택자를 사용해야 하나요?\n```css\ninput[type=text]_____ {\n    background-color: lightblue;\n    border: 3px solid #555;\n}\n```",
      "option_a": "`:hover`",
      "option_b": "`:focus`",
      "option_c": "`:active`",
      "option_d": "`:visited`",
      "correct_answer": "B",
      "explanation": "• `:focus` 가상 선택자는 요소가 포커스를 받았을 때 스타일을 적용합니다\n\n• 포커스 상태란:\n  • 사용자가 입력 필드를 클릭했을 때\n  • Tab 키로 해당 필드로 이동했을 때\n  • 키보드 입력을 받을 준비가 된 상태\n\n• 포커스 스타일링의 중요성:\n  • 현재 활성화된 필드를 명확히 표시\n  • 사용자 경험 및 접근성 향상\n  • 키보드 네비게이션 지원\n\n• 다른 선택자들과의 차이:\n • `:hover`: 마우스가 올라갔을 때\n  • `:active`: 마우스를 누르고 있을 때\n  • `:visited`: 방문한 링크 (폼 요소에 부적절)",
      "difficulty": "medium",
      "created_at": "2025-08-10T15:03:29.000Z"
    },
    {
      "id": 1336,
      "subject_id": 9,
      "question": "입력 필드에 아이콘을 추가하고 적절한 여백을 설정하는 CSS는?\n```css\ninput[type=text] {\n    background-image: url('searchicon.png');\n    background-position: 10px 10px;\n    background-repeat: _____;\n    padding-left: _____;\n}\n```",
      "option_a": "`repeat`, `20px`",
      "option_b": "`no-repeat`, `40px`",
      "option_c": "`repeat-x`, `30px`",
      "option_d": "`space`, `50px`",
      "correct_answer": "B",
      "explanation": "• `background-repeat: no-repeat`:\n  • 아이콘 이미지가 반복되지 않도록 설정\n  • 하나의 아이콘만 표시됨\n  • 입력 필드에서 가장 일반적인 설정\n\n• `padding-left: 40px`:\n  • 왼쪽에 충분한 여백 확보\n  • 아이콘과 텍스트가 겹치지 않도록 함\n  • 아이콘 크기 + 여백을 고려한 값",
      "difficulty": "medium",
      "created_at": "2025-08-10T15:05:23.000Z"
    },
    {
      "id": 1337,
      "subject_id": 9,
      "question": "여러 타입의 버튼을 한 번에 스타일링하는 완전한 CSS 코드는?\n```css\ninput[type=_____], input[type=_____], input[type=_____] {\n    background-color: #04AA6D;\n    border: none;\n    color: white;\n    padding: 16px 32px;\n    cursor: pointer;\n}\n```",
      "option_a": "`text`, `email`, `password`",
      "option_b": "`button`, `submit`, `reset`",
      "option_c": "`radio`, `checkbox`, `select`",
      "option_d": "`number`, `date`, `file`",
      "correct_answer": "B",
      "explanation": "• 버튼 타입 입력 요소들을 그룹으로 스타일링하는 실용적인 기법입니다\n\n• 각 버튼 타입의 역할:\n  • `input[type=button]`: 일반적인 버튼 (JavaScript 이벤트용)\n  • `input[type=submit]`: 폼 제출 버튼\n  • `input[type=reset]`: 폼 초기화 버튼\n\n• 공통 스타일링 요소들:\n  • `background-color: #04AA6D`: 녹색 배경 (브랜드 컬러)\n  • `border: none`: 기본 테두리 제거\n  • `color: white`: 흰색 텍스트 (대비 효과)\n  • `padding: 16px 32px`: 클릭하기 좋은 크기\n  • `cursor: pointer`: 마우스 포인터 변경 (클릭 가능 표시)",
      "difficulty": "hard",
      "created_at": "2025-08-10T15:07:16.000Z"
    },
    {
      "id": 1338,
      "subject_id": 9,
      "question": "CSS 카운터를 생성하거나 초기화하는 데 사용하는 속성은?",
      "option_a": "`counter-create`",
      "option_b": "`counter-reset`",
      "option_c": "`counter-init`",
      "option_d": "`counter-start`",
      "correct_answer": "B",
      "explanation": "• `counter-rese`t 속성은 CSS 카운터의 핵심 시작점입니다\n\n• 카운터 생성 및 초기화 역할:\n  • 새로운 카운터를 생성합니다\n  • 기존 카운터를 0으로 재설정합니다\n  • 카운터 사용의 범위를 정의합니다\n\n• 기본 사용법:\n```css\nbody {\n    counter-reset: section;  /* 'section'이라는 카운터 생성 */\n}\n```\n• 카운터 시스템의 3단계:\n  1. 생성: `counter-reset`으로 카운터 생성\n  2. 증가: `counter-increment`로 값 증가\n  3. 표시: `content`와 `counter()`로 값 출력",
      "difficulty": "easy",
      "created_at": "2025-08-10T15:11:08.000Z"
    },
    {
      "id": 1339,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n```css\nh2::before {\n    _____: section;\n    content: \"Section \" counter(section) \": \";\n}\n```",
      "option_a": "`counter-add`",
      "option_b": "`counter-increase`",
      "option_c": "`counter-increment`",
      "option_d": "`counter-plus`",
      "correct_answer": "C",
      "explanation": "• `counter-increment` 속성은 카운터 값을 증가시키는 역할을 합니다\n\n• 카운터 증가의 작동 원리:\n  • 지정된 카운터의 값을 1씩 증가시킵니다\n  • 기본 증가량은 1이지만 다른 값도 설정 가능합니다\n  • 각 요소가 나타날 때마다 자동으로 실행됩니다\n\n• 실제 동작 과정:\n  1. 첫 번째 `<h2>`: section = 1\n  2. 두 번째 `<h2>`: section = 2\n  3. 세 번째 `<h2>`: section = 3\n\n• 증가량 조절 예시:\n```css\ncounter-increment: section 2;  /* 2씩 증가 */\ncounter-increment: section -1; /* 1씩 감소 */\n```\n• `::before` 가상 요소와 함께:\n  • 실제 콘텐츠 앞에 자동으로 번호 삽입\n  • 목차, 섹션 번호, 단계별 안내 등에 활용",
      "difficulty": "easy",
      "created_at": "2025-08-10T15:12:45.000Z"
    },
    {
      "id": 1340,
      "subject_id": 9,
      "question": "카운터 값을 실제로 화면에 표시하기 위해 사용하는 속성과 함수는?\n```css\nh2::before {\n    counter-increment: section;\n    _____: \"Section \" _____(section) \": \";\n}\n```",
      "option_a": "`text`, `display`",
      "option_b": "`content`, `counter`",
      "option_c": "`value`, `number`",
      "option_d": "`output`, `show`",
      "correct_answer": "B",
      "explanation": "• `content` 속성과 `counter()` 함수가 카운터 값 표시의 핵심입니다\n\n• `content` 속성의 역할:\n  • `::before`와 `::after` 가상 요소에서만 사용 가능\n  • 실제 HTML에 없는 콘텐츠를 생성합니다\n  • 텍스트, 카운터 값, 이미지 등을 삽입할 수 있습니다\n\n• `counter()` 함수의 역할:\n  • 지정된 카운터의 현재 값을 반환합니다\n  • 문자열과 함께 조합하여 사용합니다\n  • 다양한 번호 형식 지원 (숫자, 로마자, 알파벳 등)",
      "difficulty": "medium",
      "created_at": "2025-08-10T15:14:19.000Z"
    },
    {
      "id": 1341,
      "subject_id": 9,
      "question": "중첩된 카운터를 구현할 때, 각 상위 섹션에서 하위 카운터를 초기화하려면?\n```css\nbody {\n    counter-reset: section;\n}\nh1 {\n    _____: subsection;\n}\nh1::before {\n    counter-increment: section;\n    content: \"Section \" counter(section) \". \";\n}\nh2::before {\n    counter-increment: subsection;\n    content: counter(section) \".\" counter(subsection) \" \";\n}\n```",
      "option_a": "`counter-clear`",
      "option_b": "`counter-restart`",
      "option_c": "`counter-reset`",
      "option_d": "`counter-zero`",
      "correct_answer": "C",
      "explanation": "• 중첩 카운터에서 `counter-reset`의 중요한 역할을 이해해야 합니다\n\n• 계층적 번호 시스템 구현:\n  • `body`: 전체 섹션 카운터 초기화\n  • `h1`: 각 주 섹션마다 하위 섹션 카운터 초기화\n  • 결과: 1.1, 1.2, 1.3, 2.1, 2.2 형태의 번호\n\n• 중첩 구조의 핵심 원리:\n  • 상위 요소에서 하위 카운터를 `counter-reset`\n  • 하위 카운터는 상위 요소가 나타날 때마다 0으로 재설정\n  • 이를 통해 독립적인 번호 체계 유지\n\n• 실용적 활용:\n  • 문서 목차 자동 생성\n  • 법률 문서의 조항 번호\n  • 기술 문서의 단계별 안내",
      "difficulty": "medium",
      "created_at": "2025-08-10T15:15:58.000Z"
    },
    {
      "id": 1342,
      "subject_id": 9,
      "question": "웹사이트의 상단 헤더를 중앙 정렬하고 적절한 여백을 주는 CSS 속성들은?\n```css\n.header {\n    background-color: #F1F1F1;\n    _____: center;\n    _____: 20px;\n}\n```",
      "option_a": "`align`, `margin`",
      "option_b": "`text-align`, `padding`",
      "option_c": "`position`, `spacing`",
      "option_d": "`justify`, `border`",
      "correct_answer": "B",
      "explanation": "• 헤더 스타일링의 기본 요소들:\n  • `text-align: center`: 헤더 내 텍스트를 중앙 정렬\n  • `padding: 20px`: 헤더 내부에 여백 추가\n\n• `text-align: center`의 역할:\n  • 헤더 안의 로고, 제목, 텍스트를 중앙에 배치\n  • 시각적 균형감 제공\n  • 전문적이고 깔끔한 느낌 연출\n\n• `padding: 20px`의 중요성:\n  • 헤더 내용과 경계선 사이에 숨쉴 공간 제공\n  • 너무 답답하지 않은 레이아웃 구성\n  • 클릭하기 편한 영역 확보",
      "difficulty": "easy",
      "created_at": "2025-08-10T15:20:00.000Z"
    },
    {
      "id": 1343,
      "subject_id": 9,
      "question": "내비게이션 바의 링크들을 가로로 배치하는 CSS 속성은?\n```css\n.topnav a {\n    _____: left;\n    display: block;\n    color: #f2f2f2;\n    padding: 14px 16px;\n}\n```",
      "option_a": "`align`",
      "option_b": "`position`",
      "option_c": "`float`",
      "option_d": "`direction`",
      "correct_answer": "C",
      "explanation": "• **`float: left`**는 내비게이션 링크를 가로로 배치하는 전통적인 방법입니다\n\n• float의 작동 원리:\n  • 각 링크가 왼쪽부터 차례로 배치됩니다\n  • 블록 요소들이 한 줄에 나란히 정렬됩니다\n  • 일반적인 문서 흐름에서 벗어나 떠있게 됩니다\n\n• 내비게이션 바 구성의 핵심:\n```css\n.topnav {\n    overflow: hidden;        /* float 정리 */\n    background-color: #333;  /* 배경색 */\n}\n.topnav a {\n    float: left;            /* 가로 배치 */\n    display: block;         /* 블록 요소화 */\n    padding: 14px 16px;     /* 클릭 영역 확보 */\n}\n```\n• `overflow: hidden`의 필요성:\n  • float된 자식 요소들을 부모가 포함하도록 함\n  • 레이아웃 깨짐 방지\n  • clearfix 기법의 일종\n\n• 현대적 대안:\n  • Flexbox: `display: flex`\n  • CSS Grid: `display: grid`\n  • 하지만 float는 여전히 널리 사용되는 안정적인 방법",
      "difficulty": "easy",
      "created_at": "2025-08-10T15:22:07.000Z"
    },
    {
      "id": 1344,
      "subject_id": 9,
      "question": "3개의 동일한 너비 컬럼을 만들기 위한 CSS 설정은?\n```css\n.column {\n    float: left;\n    width: _____;\n}\n.row:after {\n    content: \"\";\n    display: table;\n    clear: _____;\n}\n```",
      "option_a": "`30%`, `left`",
      "option_b": "`33.33%`, `both`",
      "option_c": "`25%`, `right`",
      "option_d": "`50%`, `none`",
      "correct_answer": "B",
      "explanation": "• 3컬럼 레이아웃의 수학적 계산:\n  • 전체 너비 100% ÷ 3개 컬럼 = 33.33%\n  • 정확한 계산으로 레이아웃 깨짐 방지\n\n• `clear: both`의 중요한 역할:\n  • 왼쪽과 오른쪽 모든 float 요소들을 정리\n  • 다음 요소가 float 영향을 받지 않도록 함\n  • 레이아웃의 깔끔한 마무리\n\n• Clearfix 기법 이해:\n```css\n.row:after {\n    content: \"\";           /* 가상 요소 생성 */\n    display: table;        /* 블록 레벨 요소화 */\n    clear: both;          /* 모든 float 정리 */\n}\n```\n• 다양한 컬럼 레이아웃:\n  • 2컬럼: `width: 50%`\n  • 3컬럼: `width: 33.33%`\n  • 4컬럼: `width: 25%`\n  • 5컬럼: `width: 20%`\n\n• 반응형 고려사항:\n```css\n@media screen and (max-width: 600px) {\n    .column {\n        width: 100%;  /* 모바일에서는 세로 배치 */\n    }\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T15:24:10.000Z"
    },
    {
      "id": 1345,
      "subject_id": 9,
      "question": "불균등한 3컬럼 레이아웃에서 메인 콘텐츠와 사이드바의 적절한 너비 비율은?\n```css\n.column {\n    float: left;\n}\n.column.side {\n    width: _____;\n}\n.column.middle {\n    width: _____;\n}\n```",
      "option_a": "`30%`, `40%`",
      "option_b": "`25%`, `50%`",
      "option_c": "`20%`, `60%`",
      "option_d": "`33%`, `34%`",
      "correct_answer": "B",
      "explanation": "• 불균등 컬럼의 설계 원칙:\n  • 메인 콘텐츠가 가장 넓은 영역 차지\n  • 사이드바는 보조 정보를 위한 적당한 크기\n  • 전체 합계가 100%가 되어야 함\n\n• 25% + 50% + 25% = 100% 구성:\n  • 왼쪽 사이드바: 25% (네비게이션, 메뉴)\n  • 메인 콘텐츠: 50% (주요 내용)\n  • 오른쪽 사이드바: 25% (광고, 관련 링크)",
      "difficulty": "medium",
      "created_at": "2025-08-10T15:25:36.000Z"
    },
    {
      "id": 1346,
      "subject_id": 9,
      "question": "반응형 레이아웃을 위한 미디어 쿼리에서 컬럼을 세로로 스택하는 완전한 CSS 코드는?\n```css\n.column {\n    float: left;\n    width: 33.33%;\n}\n\n@media screen and (max-width: _____) {\n    .column {\n        width: _____;\n    }\n}\n```",
      "option_a": "`768px`, `auto`",
      "option_b": "`600px`, `100%`",
      "option_c": "`1024px`, `50%`",
      "option_d": "`480px`, `inherit`",
      "correct_answer": "B",
      "explanation": "• 반응형 웹 디자인의 핵심 브레이크포인트와 원리:\n\n• `max-width: 600px` 브레이크포인트:\n  • 타블릿과 모바일 기기를 위한 일반적인 기준점\n  • 600px 이하에서는 3컬럼이 읽기 어려워짐\n  • 사용자 경험을 위한 최적화된 값\n\n• `width: 100%`의 효과:\n  • 각 컬럼이 전체 너비를 차지\n  • 3개 컬럼이 세로로 스택되어 배치\n  • 모바일에서 읽기 편한 레이아웃 구성\n\n• 일반적인 브레이크포인트들:\n  • 모바일: 480px 이하\n  • 타블릿: 600px ~ 768px\n  • 데스크톱: 1024px 이상\n\n• 현대적 대안 기술:\n  • CSS Grid: `grid-template-columns: repeat(auto-fit, minmax(300px, 1fr))`\n  • Flexbox: `flex-wrap: wrap`과 `flex-basis` 조합\n  • 하지만 float + 미디어 쿼리는 여전히 안정적이고 호환성이 좋음",
      "difficulty": "hard",
      "created_at": "2025-08-10T15:28:09.000Z"
    },
    {
      "id": 1347,
      "subject_id": 9,
      "question": "웹 화면에서 가장 일반적으로 사용되는 절대 단위는?\n```css\nh1 {\n    font-size: 60_____;\n}\np {\n    font-size: 25_____;\n    line-height: 50_____;\n}\n```",
      "option_a": "`cm`",
      "option_b": "`px`",
      "option_c": "`in`",
      "option_d": "`pt`",
      "correct_answer": "B",
      "explanation": "• 픽셀(`px`)은 웹 디자인에서 가장 널리 사용되는 절대 단위입니다\n\n• 픽셀의 특징:\n  • 화면의 물리적 픽셀과 연관된 단위\n  • 1px = 1/96인치로 정의됨\n  • 정확하고 예측 가능한 크기 제공\n\n• 모바일과 고해상도 화면에서도 브라우저가 자동으로 적절히 조정해줍니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T15:32:04.000Z"
    },
    {
      "id": 1348,
      "subject_id": 9,
      "question": "현재 요소의 폰트 크기를 기준으로 하는 상대 단위는?\n```css\n.container {\n    font-size: 16px;\n}\n.container p {\n    font-size: 1.5_____;  /* 24px가 됨 */\n    margin: 2_____;       /* 32px가 됨 */\n}\n```",
      "option_a": "`rem`",
      "option_b": "`%`",
      "option_c": "`em`",
      "option_d": "`vw`",
      "correct_answer": "C",
      "explanation": "• `em` 단위는 현재 요소의 폰트 크기를 기준으로 계산됩니다\n\n• em 계산 방법:\n  • 부모의 font-size가 16px일 때\n  • 1.5em = 1.5 × 16px = 24px\n  • 2em = 2 × 16px = 32px\n\n• em의 장점:\n  • 폰트 크기에 비례하여 일관된 비율 유지\n  • 접근성 향상 (사용자가 폰트 크기 변경 시 함께 조정)\n  • 모듈화된 컴포넌트 디자인에 유용\n\n• 실제 사용 예시:\n```css\nh1 { font-size: 2em; }      /* 본문의 2배 크기 */\np { margin-bottom: 1em; }   /* 폰트 크기만큼 여백 */\n```\n• 다른 단위들과의 차이:\n  • `rem`: 루트 요소(html) 폰트 크기 기준\n  • `%`: 부모 요소의 해당 속성값 기준\n  • `vw`: 뷰포트 너비 기준",
      "difficulty": "easy",
      "created_at": "2025-08-10T15:33:56.000Z"
    },
    {
      "id": 1349,
      "subject_id": 9,
      "question": "루트 요소의 폰트 크기를 기준으로 하여 중첩된 요소에서도 일관된 크기를 유지하는 단위는?\n```css\nhtml {\n    font-size: 16px;\n}\n.parent {\n    font-size: 1.2em;  /* 19.2px */\n}\n.child {\n    font-size: 1.5_____;  /* 항상 24px가 되어야 함 */\n}\n```",
      "option_a": "`em`",
      "option_b": "`rem`",
      "option_c": "`%`",
      "option_d": "`px`",
      "correct_answer": "B",
      "explanation": "• `rem` (root em) 단위는 항상 루트 요소(html)의 폰트 크기를 기준으로 합니다\n\n• rem과 em의 중요한 차이점:\n  • em: 부모 요소의 폰트 크기에 영향받음 (중첩 시 복합적 계산)\n  • rem: 항상 html 요소의 폰트 크기만 기준 (일관성 유지)\n\n• 중첩 문제 해결:\n```css\n/* em 사용 시 (문제 발생) */\n.parent { font-size: 1.2em; }    /* 19.2px */\n.child { font-size: 1.5em; }     /* 1.5 × 19.2px = 28.8px */\n\n/* rem 사용 시 (일관성 유지) */\n.parent { font-size: 1.2rem; }   /* 19.2px */\n.child { font-size: 1.5rem; }    /* 1.5 × 16px = 24px */\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T15:35:27.000Z"
    },
    {
      "id": 1350,
      "subject_id": 9,
      "question": "브라우저 창 크기에 따라 반응하는 뷰포트 단위로 전체 화면 높이를 설정하려면?\n```css\n.hero-section {\n    width: 100_____;   /* 전체 너비 */\n    height: 100_____;  /* 전체 높이 */\n}\n```",
      "option_a": "`%`, `%`",
      "option_b": "`vw`, `vh`",
      "option_c": "`px`, `px`",
      "option_d": "`em`, `rem`",
      "correct_answer": "B",
      "explanation": "• 뷰포트 단위는 브라우저 창 크기를 기준으로 하는 상대 단위입니다\n\n• 뷰포트 단위의 종류:\n  • `vw` (viewport width): 뷰포트 너비의 1%\n  • `vh` (viewport height): 뷰포트 높이의 1%\n  • `vmin`: 뷰포트의 작은 쪽 차원의 1%\n  • `vmax`: 뷰포트의 큰 쪽 차원의 1%\n\n• % 단위와의 차이:\n  • `%`: 부모 요소의 크기 기준\n  • `vw/vh`: 브라우저 창(뷰포트) 크기 기준",
      "difficulty": "medium",
      "created_at": "2025-08-10T15:37:23.000Z"
    },
    {
      "id": 1351,
      "subject_id": 9,
      "question": "완벽하게 확장 가능한(scalable) 레이아웃을 만들기 위해 권장되는 단위 조합은?\n```css\nhtml {\n    font-size: 16px;\n}\n.card {\n    width: 20_____;        /* 고정 너비 */\n    padding: 1.5_____;     /* 폰트 기준 내부 여백 */\n    margin: 1_____;        /* 루트 폰트 기준 외부 여백 */\n    font-size: 1.125_____;  /* 루트 폰트 기준 크기 */\n}\n```",
      "option_a": "`px`, `px`, `px`, `px`",
      "option_b": "`%`, `em`, `%`, `em`",
      "option_c": "`rem`, `em`, `rem`, `rem`",
      "option_d": "`vw`, `vh`, `vw`, `vh`",
      "correct_answer": "C",
      "explanation": "• 확장 가능한 레이아웃을 위한 최적의 단위 전략:\n\n• `width: 20rem`:\n  • 루트 폰트 크기에 비례한 고정 너비\n  • 사용자가 브라우저 폰트 크기 변경 시 함께 확장\n  • 컴포넌트 독립성 보장\n\n• `padding: 1.5em`:\n  • 현재 요소의 폰트 크기에 비례한 내부 여백\n  • 폰트가 커지면 패딩도 함께 증가하여 비율 유지\n  • 텍스트와 경계선 간의 조화로운 간격\n\n• `margin: 1rem`:\n  • 루트 폰트 기준의 일관된 외부 여백\n  • 전체 페이지에서 통일된 간격 체계\n  • 중첩으로 인한 예상치 못한 여백 증가 방지\n\n• `font-size: 1.125rem`:\n  • 루트 폰트의 1.125배 (18px if root is 16px)\n  • 전역 폰트 스케일링에 반응\n  • 타이포그래피 체계의 일관성",
      "difficulty": "hard",
      "created_at": "2025-08-10T15:39:23.000Z"
    },
    {
      "id": 1352,
      "subject_id": 9,
      "question": "다음 코드에서 텍스트의 최종 색상은 무엇인가요?\n```css\np {\n    color: red;\n}\n.test {\n    color: green;\n}\n```\n```html\n<p class=\"test\">Hello World!</p>\n```",
      "option_a": "빨간색 (red)",
      "option_b": "녹색 (green)",
      "option_c": "검은색 (기본색)",
      "option_d": "두 색이 섞인 색",
      "correct_answer": "B",
      "explanation": "• 클래스 선택자가 요소 선택자보다 높은 특이성을 가집니다\n\n• 특이성 우선순위 (높음 → 낮음):\n  • 인라인 스타일 > ID 선택자 > 클래스 선택자 > 요소 선택자\n\n• 이 예시에서의 특이성 비교:\n  • `.test` (클래스): 특이성 점수 높음\n  • `p` (요소): 특이성 점수 낮음\n\n• 실제 적용 과정:\n  1. 브라우저가 모든 적용 가능한 CSS 규칙을 찾음\n  2. 특이성이 높은 규칙이 우선 적용됨\n  3. 결과: 녹색으로 표시됨",
      "difficulty": "easy",
      "created_at": "2025-08-10T15:43:14.000Z"
    },
    {
      "id": 1353,
      "subject_id": 9,
      "question": "CSS 특이성 계층에서 가장 높은 우선순위를 갖는 것은?\n```html\n<p id=\"demo\" class=\"test\" style=\"color: pink;\">Hello World!</p>\n```\n```css\n#demo { color: blue; }\n.test { color: green; }\np { color: red; }\n```",
      "option_a": "ID 선택자 (`#demo`)",
      "option_b": "클래스 선택자 (`.test`)",
      "option_c": "인라인 스타일 (`style=\"color: pink;\"`)",
      "option_d": "요소 선택자 (`p`)",
      "correct_answer": "C",
      "explanation": "• 인라인 스타일이 모든 CSS 선택자보다 높은 특이성을 가집니다\n\n• 완전한 특이성 계층 구조:\n  1. 인라인 스타일 (`style=\"...\"`) - 최고 우선순위\n  2. ID 선택자 (`#id`) - 두 번째 우선순위\n  3. 클래스 선택자 (`.class`) - 세 번째 우선순위\n  4. 요소 선택자 (`element`) - 최저 우선순위\n\n• 실제 적용 결과:\n  • 텍스트는 분홍색(pink)으로 표시됨\n  • 다른 모든 CSS 규칙은 무시됨",
      "difficulty": "easy",
      "created_at": "2025-08-10T15:45:51.000Z"
    },
    {
      "id": 1354,
      "subject_id": 9,
      "question": "다음 코드에서 `div` 요소의 배경색은 무엇인가요?\n```css\ndiv#myDiv {\n    background-color: green;\n}\n#myDiv {\n    background-color: yellow;\n}\ndiv[id=\"myDiv\"] {\n    background-color: blue;\n}\n```\n```html\n<div id=\"myDiv\">Content</div>\n```",
      "option_a": "녹색 (green)",
      "option_b": "노란색 (yellow)",
      "option_c": "파란색 (blue)",
      "option_d": "기본색",
      "correct_answer": "A",
      "explanation": "• 복합 선택자가 단일 선택자보다 높은 특이성을 가집니다\n\n• 각 선택자의 특이성 분석:\n  • `div#myDiv`: 요소(1) + ID(100) = 101점\n  • `#myDiv`: ID(100) = 100점\n  • `div[id=\"myDiv\"]`: 요소(1) + 속성(10) = 11점\n\n• 특이성 점수 계산 체계:\n  • 인라인 스타일: 1000점\n  • ID 선택자: 100점\n  • 클래스/속성/가상클래스: 10점\n  • 요소/가상요소: 1점\n\n• 결과 분석:\n  • `div#myDiv`가 가장 높은 특이성(101점)을 가짐\n  • 따라서 녹색 배경이 적용됨",
      "difficulty": "medium",
      "created_at": "2025-08-10T15:47:37.000Z"
    },
    {
      "id": 1355,
      "subject_id": 9,
      "question": "같은 특이성을 가진 규칙들이 충돌할 때 적용되는 원칙은?\n```css\nh1 { background-color: yellow; }\nh1 { background-color: red; }\n```\n```html\n<h1>Title</h1>\n```",
      "option_a": "첫 번째 규칙이 적용됨",
      "option_b": "마지막에 작성된 규칙이 적용됨",
      "option_c": "더 긴 선택자가 적용됨",
      "option_d": "브라우저가 임의로 선택함",
      "correct_answer": "B",
      "explanation": "• 동일한 특이성일 때는 \"마지막 규칙이 이긴다(Last Rule Wins)\" 원칙이 적용됩니다\n\n• 캐스케이딩(Cascading) 규칙:\n  1. 특이성이 높은 것이 우선\n  2. 특이성이 같으면 나중에 작성된 것이 우선\n  3. 소스 순서(CSS 파일에서의 위치)가 중요\n\n• 실제 적용 과정:\n  • 두 `h1` 규칙 모두 동일한 특이성(1점)\n  • 브라우저가 CSS를 위에서 아래로 읽음\n  • 나중에 나오는 `red` 규칙이 이전 `yellow` 규칙을 덮어씀\n\n• CSS 파일 로딩 순서도 영향:\n  • 여러 CSS 파일이 있을 때 나중에 로드된 파일이 우선\n  • `<link>` 태그의 순서가 중요",
      "difficulty": "medium",
      "created_at": "2025-08-10T15:49:31.000Z"
    },
    {
      "id": 1356,
      "subject_id": 9,
      "question": "CSS에서 특정 속성에 최고 우선순위를 부여하는 규칙은?\n```css\np {\n    color: red _____;\n}\n```",
      "option_a": "`!priority`",
      "option_b": "`!important`",
      "option_c": "`!override`",
      "option_d": "`!urgent`",
      "correct_answer": "B",
      "explanation": "• `!important`는 CSS에서 가장 강력한 우선순위 규칙입니다\n\n• !important의 기본 특징:\n  • 일반적인 특이성 계산을 무시합니다\n  • 해당 속성에 최고 우선순위를 부여합니다\n  • 다른 모든 스타일 규칙을 덮어씁니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T15:52:48.000Z"
    },
    {
      "id": 1357,
      "subject_id": 9,
      "question": "다음 코드에서 문단의 배경색은 무엇인가요?\n```css\n#myid {\n    background-color: blue;\n}\n.myclass {\n    background-color: gray;\n}\np {\n    background-color: red !important;\n}\n```\n```html\n<p id=\"myid\" class=\"myclass\">Hello World!</p>\n```",
      "option_a": "파란색 (blue) - ID 선택자가 우선",
      "option_b": "회색 (gray) - 클래스 선택자 적용",
      "option_c": "빨간색 (red) - !important 규칙이 우선",
      "option_d": "검은색 - 기본색 적용",
      "correct_answer": "C",
      "explanation": "• !important 규칙은 모든 특이성 계산을 무시하고 최우선 적용됩니다\n\n• 일반적인 특이성 순서:\n  • ID 선택자 (`#myid`) > 클래스 선택자 (`.myclass`) > 요소 선택자 (`p`)\n\n• !important 적용 시:\n  • 특이성과 관계없이 `!important`가 붙은 규칙이 최우선\n  • 이 경우 `p` 요소 선택자의 빨간색이 적용됨\n\n• 실제 적용 과정:\n  1. 브라우저가 모든 적용 가능한 CSS 규칙을 수집\n  2. `!important`가 붙은 규칙을 먼저 확인\n  3. `background-color: red !important`가 다른 모든 규칙을 덮어씀",
      "difficulty": "easy",
      "created_at": "2025-08-10T15:54:52.000Z"
    },
    {
      "id": 1358,
      "subject_id": 9,
      "question": "!important의 적절한 사용 사례가 아닌 것은?",
      "option_a": "CMS에서 편집할 수 없는 CSS를 오버라이드할 때",
      "option_b": "외부 라이브러리의 스타일을 강제로 변경할 때",
      "option_c": "일관된 버튼 스타일을 보장하기 위해",
      "option_d": "일반적인 웹페이지 스타일링의 기본 도구로",
      "correct_answer": "D",
      "explanation": "• !important는 예외적인 상황에서만 사용해야 하는 강력한 도구입니다\n\n• 적절한 사용 사례들:\n\n1. CMS 스타일 오버라이드:\n```css\n/* 편집 불가능한 CMS 스타일을 덮어쓸 때 */\n.cms-content h1 {\n    color: #333 !important;\n}\n```\n2. 외부 라이브러리 커스터마이징:\n```css\n/* Bootstrap이나 jQuery UI 스타일 변경 시 */\n.bootstrap-button {\n    background-color: #custom-color !important;\n}\n```\n3. 일관된 컴포넌트 스타일:\n```css\n/* 특이성 충돌을 방지하여 일관성 보장 */\n.button {\n    background-color: #8c8c8c !important;\n    color: white !important;\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T15:56:39.000Z"
    },
    {
      "id": 1359,
      "subject_id": 9,
      "question": "CSS에서 수학적 계산을 수행하여 속성값으로 사용하는 함수는?\n```css\n#div1 {\n    width: _____(100% - 100px);\n}\n```",
      "option_a": "`calculate`",
      "option_b": "`calc`",
      "option_c": "`compute`",
      "option_d": "`math`",
      "correct_answer": "B",
      "explanation": "• `calc()` 함수는 CSS에서 수학적 계산을 수행하는 표준 함수입니다\n\n• calc() 함수의 기본 특징:\n  • 덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/) 연산자 지원\n  • 서로 다른 단위 간의 계산 가능 (%, px, em 등)\n  • 동적으로 값이 계산됨\n\n• 실제 사용 예시:\n```css\nwidth: calc(100% - 50px);     /* 퍼센트에서 픽셀 빼기 */\nheight: calc(100vh - 80px);   /* 뷰포트에서 헤더 높이 빼기 */\nmargin: calc(1rem + 10px);    /* 서로 다른 단위 더하기 */\n```\n• calc()의 실용적 활용:\n  • 반응형 레이아웃에서 정확한 크기 계산\n  • 고정 요소와 유동 요소의 조합\n  • 복잡한 수학적 관계 표현",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:00:02.000Z"
    },
    {
      "id": 1360,
      "subject_id": 9,
      "question": "`calc()` 함수에서 사용할 수 있는 수학 연산자가 아닌 것은?\n```css\n.example {\n    width: calc(100px + 50px);    /* 덧셈 */\n    height: calc(200px - 30px);   /* 뺄셈 */\n    margin: calc(10px * 2);       /* 곱셈 */\n    padding: calc(100px / 4);     /* 나눗셈 */\n}\n```",
      "option_a": "`+` (덧셈)",
      "option_b": "`%` (나머지)",
      "option_c": "`*` (곱셈)",
      "option_d": "`/` (나눗셈)",
      "correct_answer": "B",
      "explanation": "• `calc()` 함수에서 지원하는 연산자는 4가지입니다\n\n• 지원되는 연산자들:\n  • `+` (덧셈): `calc(100px + 50px)` → 150px\n  • `-` (뺄셈): `calc(100px - 30px)` → 70px\n  • `*` (곱셈): `calc(10px * 3)` → 30px\n  • `/` (나눗셈): `calc(100px / 2)` → 50px\n\n• 지원되지 않는 연산자:\n  • `%` (나머지 연산자): CSS calc()에서 사용 불가\n  • `**` (거듭제곱), `^` (XOR) 등 고급 연산자들",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:02:07.000Z"
    },
    {
      "id": 1361,
      "subject_id": 9,
      "question": "여러 값 중에서 가장 큰 값을 선택하는 CSS 함수는?\n```css\n#div1 {\n    width: _____(50%, 300px);\n    /* 50%와 300px 중 더 큰 값을 사용 */\n}\n```",
      "option_a": "`max`",
      "option_b": "`largest`",
      "option_c": "`bigger`",
      "option_d": "`greatest`",
      "correct_answer": "A",
      "explanation": "• `max()` 함수는 여러 값 중 가장 큰 값을 선택합니다\n\n• max() 함수의 작동 원리:\n  • 쉼표로 구분된 여러 값들을 비교\n  • 그 중 가장 큰 값을 최종 결과로 사용\n  • 서로 다른 단위도 비교 가능\n\n• 실제 동작 예시:\n```css\n/* 화면이 작을 때: 50% < 300px → 300px 사용 */\n/* 화면이 클 때: 50% > 300px → 50% 사용 */\nwidth: max(50%, 300px);\n```\n• 반응형 디자인에서의 활용:\n```css\n/* 최소 너비 보장하면서 반응형 */\nwidth: max(300px, 25%);\n\n/* 폰트 크기의 최소값 설정 */\nfont-size: max(16px, 1rem);\n\n/* 여백의 최소값 보장 */\nmargin: max(20px, 2%);\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T16:03:51.000Z"
    },
    {
      "id": 1362,
      "subject_id": 9,
      "question": "다음 상황에서 `div` 요소의 실제 너비는? (부모 컨테이너 너비가 800px일 때)\n```css\n#container {\n    width: 800px;\n}\n#div1 {\n    width: min(60%, 400px);\n}\n```",
      "option_a": "480px (60%의 결과)",
      "option_b": "400px (400px 고정값)",
      "option_c": "800px (부모와 동일)",
      "option_d": "60px (계산 오류)",
      "correct_answer": "B",
      "explanation": "• `min()` 함수는 여러 값 중 가장 작은 값을 선택합니다\n\n• 계산 과정:\n  • 부모 너비: 800px\n  • 60% 계산: 800px × 0.6 = 480px\n  • 비교할 값들: 480px vs 400px\n  • 더 작은 값: 400px 선택\n\n• min() 함수의 특징:\n```css\n/* 최대값을 제한하면서 반응형 동작 */\nwidth: min(90%, 500px);\n\n/* 화면이 클 때: 90% > 500px → 500px 사용 (최대값 제한) */\n/* 화면이 작을 때: 90% < 500px → 90% 사용 (반응형) */\n```\n• 실용적인 활용 사례:\n```css\n/* 컨테이너 최대 너비 제한 */\n.container {\n    width: min(100%, 1200px);\n    margin: 0 auto;\n}\n\n/* 반응형 이미지 크기 제한 */\nimg {\n    width: min(100%, 600px);\n    height: auto;\n}\n\n/* 폰트 크기 상한선 설정 */\nh1 {\n    font-size: min(4vw, 48px);\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T16:05:19.000Z"
    },
    {
      "id": 1363,
      "subject_id": 9,
      "question": "CSS 성능을 향상시키기 위해 선택자를 작성할 때 권장되는 방법은?\n```css\n/* 방법 A */\nul li a.button:hover {\n    background-color: blue;\n}\n\n/* 방법 B */\n.button:hover {\n    background-color: blue;\n}\n```",
      "option_a": "방법 A - 더 구체적이므로 성능이 좋음",
      "option_b": "방법 B - 단순한 선택자로 성능이 좋음",
      "option_c": "두 방법 모두 동일한 성능",
      "option_d": "선택자 길이는 성능과 무관함",
      "correct_answer": "B",
      "explanation": "• 단순한 선택자가 복잡한 선택자보다 빠르게 처리됩니다\n\n• 브라우저의 선택자 처리 과정:\n  • 오른쪽에서 왼쪽으로 선택자를 읽음\n  • 각 단계마다 DOM을 탐색하여 일치하는 요소 찾기\n  • 더 많은 단계일수록 더 많은 연산 필요\n\n• 성능 비교:\n  • 방법 A (`ul li a.button:hover`): 5단계 검사 필요\n    1. `:hover` 상태 확인\n    2. `.button` 클래스 확인\n    3. `a` 요소인지 확인\n    4. `li` 부모 요소 확인\n    5. `ul` 조상 요소 확인\n\n  • 방법 B (`.button:hover`): 2단계 검사만 필요\n    1. `:hover` 상태 확인\n    2. `.button` 클래스 확인",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:10:00.000Z"
    },
    {
      "id": 1364,
      "subject_id": 9,
      "question": "성능상 피해야 할 CSS 작성 방법은?\n```css\n/* 방법 A */\n.reset {\n    margin: 0;\n    padding: 0;\n}\n\n/* 방법 B */\n_____ {\n    margin: 0;\n    padding: 0;\n}\n```",
      "option_a": "`*` (전역 선택자)",
      "option_b": "`html`",
      "option_c": "`body`",
      "option_d": "`.container`",
      "correct_answer": "A",
      "explanation": "• 전역 선택자(`*`)는 성능에 악영향을 미칩니다\n\n• 전역 선택자의 문제점:\n  • 페이지의 모든 요소에 스타일이 적용됨\n  • 브라우저가 모든 DOM 요소를 검사해야 함\n  • 렌더링 성능 저하 야기",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:12:09.000Z"
    },
    {
      "id": 1365,
      "subject_id": 9,
      "question": "HTML 파일에서 CSS를 로드하는 가장 효율적인 방법은?\n```html\n<!-- 방법 A -->\n<head>\n    <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n\n<!-- 방법 B -->\n<head>\n    <style>\n        @import url('style.css');\n    </style>\n</head>\n\n<!-- 방법 C -->\n<body>\n    <div style=\"color: red;\">Content</div>\n</body>\n```",
      "option_a": "방법 A - `<link>` 태그 사용",
      "option_b": "방법 B - `@import` 사용",
      "option_c": "방법 C - 인라인 스타일 사용",
      "option_d": "모든 방법이 동일한 성능",
      "correct_answer": "A",
      "explanation": "• `<link>` 태그가 가장 효율적인 CSS 로딩 방법입니다\n\n• 각 방법의 성능 분석:\n\n방법 A (`<link>` 태그):\n  • HTML 파싱과 동시에 CSS 파일 다운로드 시작\n  • 병렬 로딩으로 빠른 성능\n  • 브라우저 캐싱 효과적 활용\n  • 렌더링 차단 최소화\n\n방법 B (`@import`):\n  • CSS 파일이 순차적으로 로딩됨\n  • 첫 번째 CSS가 로드된 후 두 번째 CSS 요청\n  • 렌더링 지연 발생\n  • 성능상 권장되지 않음\n\n방법 C (인라인 스타일):\n  • HTML 파일 크기 증가\n  • 캐싱 불가능\n  • 코드 재사용성 떨어짐\n  • 유지보수 어려움\n\n최적의 CSS 로딩 전략:\n```html\n<head>\n    <!-- 중요한 CSS는 head에 배치 -->\n    <link rel=\"stylesheet\" href=\"critical.css\">\n    \n    <!-- 비중요한 CSS는 지연 로딩 -->\n    <link rel=\"stylesheet\" href=\"non-critical.css\" media=\"print\" \n          onload=\"this.media='all'\">\n</head>\n```\n• 성능 최적화 팁:\n  • CSS 파일을 `<head>` 섹션에 배치\n  • 여러 CSS 파일보다 하나의 통합 파일 사용\n  • 미니파이된 CSS 파일 활용\n  • CDN을 통한 CSS 제공",
      "difficulty": "medium",
      "created_at": "2025-08-10T16:15:35.000Z"
    },
    {
      "id": 1366,
      "subject_id": 9,
      "question": "키보드 사용자와 스크린 리더 사용자를 위해 현재 활성화된 요소를 표시하는 CSS 가상 선택자는?\n```css\na_____, \nbutton_____, \ninput_____ {\n    outline: 2px solid #005fcc;\n    outline-offset: 2px;\n}\n```",
      "option_a": "`:hover`",
      "option_b": "`:active`",
      "option_c": "`:focus`",
      "option_d": "`:visited`",
      "correct_answer": "C",
      "explanation": "• `:focus` 가상 선택자는 접근성에 필수적인 선택자입니다\n\n• 접근성 관점에서 `:focus`의 중요성:\n  • 키보드만으로 웹사이트를 탐색하는 사용자를 위함\n  • 스크린 리더 사용자가 현재 위치를 파악할 수 있도록 함\n  • 시각적 피드백을 통한 사용자 경험 향상\n\n• 다른 가상 선택자들과의 차이:\n  • `:hover`: 마우스 오버 시에만 적용 (키보드 사용자에게는 소용없음)\n  • `:active`: 클릭하는 순간에만 적용 (지속적이지 않음)\n  • `:visited`: 방문한 링크에 적용 (현재 상태와 무관)",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:19:29.000Z"
    },
    {
      "id": 1367,
      "subject_id": 9,
      "question": "CSS에서 요소의 모서리를 둥글게 만드는 속성은?\n```css\n#rounded-box {\n    _____: 25px;\n    background: #73AD21;\n    padding: 20px;\n}\n```",
      "option_a": "`corner-radius`",
      "option_b": "`border-radius`",
      "option_c": "`rounded-border`",
      "option_d": "`corner-round`",
      "correct_answer": "B",
      "explanation": "• `border-radius` 속성은 요소의 모서리를 둥글게 만드는 표준 CSS 속성입니다\n\n• border-radius의 기본 특징:\n  • 모든 HTML 요소에 적용 가능\n  • 배경색, 테두리, 배경 이미지 모두에 영향\n  • 픽셀(px), 퍼센트(%), em 등 다양한 단위 사용 가능",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:23:14.000Z"
    },
    {
      "id": 1368,
      "subject_id": 9,
      "question": "모든 모서리에 동일한 둥근 정도를 적용하려면?\n```css\n.circle-button {\n    width: 100px;\n    height: 100px;\n    border-radius: _____;\n    background: #3498db;\n}\n```",
      "option_a": "`50px`",
      "option_b": "`25%`",
      "option_c": "`50%`",
      "option_d": "1번과 3번 모두 정답",
      "correct_answer": "D",
      "explanation": "• 정사각형을 완전한 원으로 만들기 위한 여러 방법이 있습니다\n\n• 각 값의 효과:\n\n`50px` (1번):\n  • 100px × 100px 정사각형에서 반지름 50px\n  • 완전한 원 형태 구현\n  • 절대값 사용으로 정확한 제어\n\n`50%` (3번):\n  • 요소 크기의 50%를 반지름으로 사용\n  • 100px의 50% = 50px와 동일한 효과\n  • 반응형 디자인에 더 유리",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:25:01.000Z"
    },
    {
      "id": 1369,
      "subject_id": 9,
      "question": "타원형 모서리를 만들기 위한 올바른 문법은?\n```css\n.elliptical-corners {\n    border-radius: 50px _____ 15px;\n    background: #73AD21;\n}\n```",
      "option_a": "`×`",
      "option_b": "`/`",
      "option_c": "`:`",
      "option_d": "`-`",
      "correct_answer": "B",
      "explanation": "• 슬래시(`/`)를 사용하여 타원형 모서리를 생성할 수 있습니다\n\n• 타원형 border-radius 문법:\n```css\nborder-radius: 수평반지름 / 수직반지름;\n```\n• 타원형 모서리의 이해:\n  • 슬래시 앞: 수평 방향 반지름\n  • 슬래시 뒤: 수직 방향 반지름\n  • 두 값이 다르면 타원형, 같으면 원형",
      "difficulty": "medium",
      "created_at": "2025-08-10T16:26:20.000Z"
    },
    {
      "id": 1370,
      "subject_id": 9,
      "question": "CSS에서 이미지를 테두리로 사용하기 위한 속성은?\n```css\n#decorative-box {\n    border: 10px solid transparent;\n    _____: url(pattern.png) 30 round;\n}\n```",
      "option_a": "`border-picture`",
      "option_b": "`border-image`",
      "option_c": "`image-border`",
      "option_d": "`border-background`",
      "correct_answer": "B",
      "explanation": "• `border-image` 속성은 이미지를 테두리로 사용하는 CSS 속성입니다\n\n• border-image의 기본 개념:\n  • 일반적인 단색 테두리 대신 이미지 패턴 사용\n  • 복잡하고 장식적인 테두리 효과 구현 가능\n  • 9분할 시스템으로 이미지를 분할하여 적용",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:30:19.000Z"
    },
    {
      "id": 1371,
      "subject_id": 9,
      "question": "border-image가 정상적으로 작동하기 위해 반드시 함께 설정해야 하는 속성은?\n```css\n#image-border-box {\n    _____: 10px solid transparent;\n    border-image: url(decorative.png) 25 stretch;\n}\n```",
      "option_a": "`background`",
      "option_b": "`border`",
      "option_c": "`padding`",
      "option_d": "`margin`",
      "correct_answer": "B",
      "explanation": "• `border-image`는 기존 `border` 속성이 설정되어야만 작동합니다\n\n• border 속성의 필수 이유:\n  • `border-image`는 기존 테두리를 이미지로 대체하는 기능\n  • 테두리의 두께와 스타일이 미리 정의되어야 함\n  • 이미지가 적용될 영역의 크기를 결정\n\n• 올바른 설정 순서:\n```css\n.image-border {\n    /* 1단계: 기본 테두리 설정 (필수) */\n    border: 15px solid transparent;\n    \n    /* 2단계: 이미지 테두리 적용 */\n    border-image: url(pattern.png) 30 round;\n}\n```\n• transparent 사용 이유:\n  • 이미지로 완전히 대체되므로 기본 테두리 색상은 보이지 않음\n  • `transparent`로 설정하여 불필요한 색상 간섭 방지\n  • 이미지 로딩 실패 시에도 투명한 테두리로 레이아웃 유지",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:32:10.000Z"
    },
    {
      "id": 1372,
      "subject_id": 9,
      "question": "border-image에서 이미지의 중간 부분이 반복되도록 하는 키워드는?\n```css\n.repeated-border {\n    border: 15px solid transparent;\n    border-image: url(pattern.png) 30 _____;\n}\n```",
      "option_a": "`repeat`",
      "option_b": "`round`",
      "option_c": "`tile`",
      "option_d": "`loop`",
      "correct_answer": "B",
      "explanation": "• `round` 키워드는 이미지의 중간 부분을 반복하여 테두리를 채웁니다\n\n• border-image의 repeat 옵션들:\n`round` (올바른 답):\n  • 이미지 패턴을 반복하여 테두리 채움\n  • 패턴이 잘리지 않도록 크기를 조정하여 반복\n  • 일정한 패턴이 있는 이미지에 적합\n`stretch`:\n  • 이미지를 늘려서 테두리 전체를 채움\n  • 반복 없이 하나의 이미지를 확대\n  • 그라데이션이나 단순한 패턴에 적합\n\n• 실제 비교 예시:\n```css\n/* 패턴 반복 - 점선이나 무늬가 반복됨 */\n.pattern-repeat {\n    border-image: url(dots.png) 20 round;\n}\n\n/* 이미지 늘림 - 하나의 이미지가 확대됨 */\n.pattern-stretch {\n    border-image: url(gradient.png) 20 stretch;\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T16:34:38.000Z"
    },
    {
      "id": 1373,
      "subject_id": 9,
      "question": "하나의 요소에 여러 개의 배경 이미지를 설정할 때 사용하는 구분자는?\n```css\n.multiple-bg {\n    background-image: url(flower.jpg)_____ url(paper.jpg);\n}\n```",
      "option_a": "`;` (세미콜론)",
      "option_b": "`,` (쉼표)",
      "option_c": "`|` (파이프)",
      "option_d": "`+` (플러스)",
      "correct_answer": "B",
      "explanation": "• 쉼표(`,`)를 사용하여 여러 배경 이미지를 구분합니다\n\n• 다중 배경의 기본 문법:\n```css\nbackground-image: url(첫번째이미지), url(두번째이미지), url(세번째이미지);\n```\n• 레이어 순서의 중요성:\n  • 첫 번째로 작성된 이미지가 가장 위에 표시됨\n  • 나중에 작성된 이미지가 뒤쪽(아래)에 배치됨\n  • 시각적으로는 \"앞에서 뒤로\" 쌓이는 구조",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:41:51.000Z"
    },
    {
      "id": 1374,
      "subject_id": 9,
      "question": "배경 이미지가 요소 전체를 덮도록 하면서 비율을 유지하는 background-size 값은?\n```css\n.full-cover {\n    background: url(hero-image.jpg) center;\n    background-size: _____;\n    background-repeat: no-repeat;\n}\n```",
      "option_a": "`contain`",
      "option_b": "`cover`",
      "option_c": "`100%`",
      "option_d": "`auto`",
      "correct_answer": "B",
      "explanation": "background-size 주요 값들의 차이:\n\n`cover` (정답):\n  • 요소 전체를 완전히 덮음\n  • 이미지 원본 비율 유지\n  • 필요시 이미지 일부가 잘릴 수 있음\n  • 빈 공간 없이 완전 커버\n\n`contain`:\n  • 이미지가 요소 안에 완전히 들어감\n  • 이미지 원본 비율 유지\n  • 빈 공간이 생길 수 있음\n  • 이미지 전체가 보임",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:43:43.000Z"
    },
    {
      "id": 1375,
      "subject_id": 9,
      "question": "다중 배경 이미지에서 각각 다른 크기를 지정하는 올바른 방법은?\n```css\n.multi-background {\n    background-image: url(logo.png), url(pattern.jpg), url(gradient.png);\n    background-size: _____;\n}\n```",
      "option_a": "`50px 130px auto`",
      "option_b": "`50px, 130px, auto`",
      "option_c": "`50px + 130px + auto`",
      "option_d": "`50px | 130px | auto`",
      "correct_answer": "B",
      "explanation": "• 다중 배경에서는 쉼표로 구분하여 각각의 크기를 지정합니다\n\n• 다중 배경 속성의 일관된 구문:\n  • 모든 배경 관련 속성은 쉼표(`,`)로 구분\n  • 각 값은 해당 순서의 배경 이미지에 대응\n  • 값의 개수가 이미지 개수와 일치해야 함",
      "difficulty": "medium",
      "created_at": "2025-08-10T16:45:15.000Z"
    },
    {
      "id": 1376,
      "subject_id": 9,
      "question": "배경 이미지가 시작되는 위치를 content 영역으로 제한하는 속성은?\n```css\n.content-bg {\n    border: 10px solid black;\n    padding: 20px;\n    background: url(pattern.png);\n    background-_____: content-box;\n}\n```",
      "option_a": "`origin`",
      "option_b": "`clip`",
      "option_c": "`position`",
      "option_d": "`area`",
      "correct_answer": "A",
      "explanation": "• `background-origin` 속성은 배경 이미지의 시작 위치를 결정합니다\n\n• background-origin의 3가지 값:\n\n`content-box` (문제에서 사용):\n  • 배경이 content 영역에서만 시작\n  • border와 padding은 제외\n  • 가장 안쪽 영역부터 배경 적용\n\n`padding-box` (기본값):\n  • 배경이 padding 영역부터 시작\n  • border는 제외, padding은 포함\n  • 일반적으로 가장 많이 사용\n\n`border-box`:\n  • 배경이 border 영역부터 시작\n  • border, padding, content 모든 영역 포함\n  • 전체 요소 영역에 배경 적용",
      "difficulty": "medium",
      "created_at": "2025-08-10T16:47:19.000Z"
    },
    {
      "id": 1377,
      "subject_id": 9,
      "question": "투명도를 포함한 RGB 색상을 지정하는 CSS 함수는?\n```css\n.transparent-red {\n    background-color: _____(255, 0, 0, 0.5);\n}\n```",
      "option_a": "`rgb`",
      "option_b": "`rgba`",
      "option_c": "`hsl`",
      "option_d": "`hsla`",
      "correct_answer": "B",
      "explanation": "• `rgba()` 함수는 RGB 색상에 알파(투명도) 채널을 추가한 함수입니다\n\n• rgba 함수의 구조:\n```css\nrgba(red, green, blue, alpha)\n```\n  • red: 빨간색 강도 (0-255)\n  • green: 녹색 강도 (0-255)\n  • blue: 파란색 강도 (0-255)\n  • alpha: 투명도 (0.0-1.0)\n\n• 투명도 값의 의미:\n  • `0.0`: 완전히 투명 (보이지 않음)\n  • `0.5`: 반투명 (50% 투명)\n  • `1.0`: 완전 불투명 (일반 색상)\n\n• 다른 함수들과의 차이:\n  • `rgb()`: 투명도 없는 기본 RGB\n  • `hsl()`: 색조, 채도, 명도 방식\n  • `hsla()`: HSL + 투명도",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:52:04.000Z"
    },
    {
      "id": 1378,
      "subject_id": 9,
      "question": "HSL 색상 모델에서 색조(Hue) 값의 범위는?\n```css\n.green-color {\n    background-color: hsl(_____, 100%, 50%);\n    /* 녹색을 나타내려면 빈칸에 어떤 값? */\n}\n```",
      "option_a": "`120` (0-360도 범위)",
      "option_b": "`100` (0-100% 범위)",
      "option_c": "`0.5` (0.0-1.0 범위)",
      "option_d": "`255` (0-255 범위)",
      "correct_answer": "A",
      "explanation": "• HSL에서 색조(Hue)는 0도부터 360도까지의 원형 스펙트럼입니다\n\n• 주요 색상의 색조 값:\n  • 0° (또는 360°): 빨간색 (Red)\n  • 120°: 녹색 (Green)\n  • 240°: 파란색 (Blue)\n  • 60°: 노란색 (Yellow)\n  • 180°: 청록색 (Cyan)\n  • 300°: 자홍색 (Magenta)\n\nHSL 모델의 완전한 구조:\ncsshsl(hue, saturation, lightness)\n\nHue (색조): 0-360도 (색상환에서의 위치)\nSaturation (채도): 0-100% (색상의 순수함)\nLightness (명도): 0-100% (색상의 밝기)",
      "difficulty": "easy",
      "created_at": "2025-08-10T16:53:12.000Z"
    },
    {
      "id": 1379,
      "subject_id": 9,
      "question": "반투명 효과를 주는 두 가지 방법의 차이점은?\n```css\n/* 방법 A */\n.method-a {\n    background-color: rgb(255, 0, 0);\n    opacity: 0.5;\n}\n\n/* 방법 B */\n.method-b {\n    background-color: rgba(255, 0, 0, 0.5);\n}\n```",
      "option_a": "두 방법 모두 동일한 결과",
      "option_b": "A는 요소 전체가 투명해지고, B는 배경색만 투명해짐",
      "option_c": "A는 배경만 투명해지고, B는 요소 전체가 투명해짐",
      "option_d": "A는 더 성능이 좋고, B는 더 호환성이 좋음",
      "correct_answer": "B",
      "explanation": "• `opacity`와 `rgba`는 투명도 적용 범위가 완전히 다릅니다\n\n• 방법 A (`opacity` 속성):\n  • 전체 요소에 투명도 적용\n  • 배경, 텍스트, 자식 요소 모든 것이 투명해짐\n  • 요소 전체가 하나의 투명 레이어처럼 작동\n\n• 방법 B (`rgba` 함수):\n  • 해당 속성에만 투명도 적용\n  • 배경색만 투명하고 텍스트는 그대로\n  • 다른 요소들은 영향받지 않음\n\n• 실제 비교 예시:\n```css\n.text-content {\n    color: white;\n    padding: 20px;\n}\n\n/* opacity 사용 - 텍스트도 함께 투명해짐 */\n.opacity-method {\n    background-color: red;\n    opacity: 0.5;        /* 텍스트도 50% 투명 */\n}\n\n/* rgba 사용 - 텍스트는 그대로, 배경만 투명 */\n.rgba-method {\n    background-color: rgba(255, 0, 0, 0.5); /* 배경만 50% 투명 */\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T16:55:31.000Z"
    },
    {
      "id": 1380,
      "subject_id": 9,
      "question": "완전히 투명한 검은색 오버레이를 만들다가 점진적으로 불투명하게 변화시키려면?\n```css\n.overlay {\n    background-color: _____(0, 0, 0, _____);\n    /* 처음에는 투명하고 나중에 70% 불투명하게 */\n}\n\n.overlay:hover {\n    background-color: _____(0, 0, 0, _____);\n}\n```",
      "option_a": "`rgba`, `0`, `rgba`, `0.7`",
      "option_b": "`rgb`, `0.7`, `rgb`, `0`",
      "option_c": "`hsl`, `0%`, `hsl`, `70%`",
      "option_d": "`hsla`, `1.0`, `hsla`, `0.3`",
      "correct_answer": "A",
      "explanation": "• 점진적 투명도 변화를 위한 올바른 값 설정을 이해해야 합니다\n\n• 투명도 값의 의미 복습:\n  • `0.0`: 완전 투명 (0%)\n  • `0.7`: 70% 불투명 (30% 투명)\n  • `1.0`: 완전 불투명 (100%)\n\n• 단계별 구현:\n```css\n.overlay {\n    /* 초기 상태: 완전히 투명한 검은색 */\n    background-color: rgba(0, 0, 0, 0);\n    transition: background-color 0.3s ease;\n}\n\n.overlay:hover {\n    /* 호버 시: 70% 불투명한 검은색 */\n    background-color: rgba(0, 0, 0, 0.7);\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T16:58:13.000Z"
    },
    {
      "id": 1381,
      "subject_id": 9,
      "question": "배경을 완전히 투명하게 만들어 뒤의 이미지가 보이도록 하는 키워드는?\n```css\nbody {\n    background-image: url(\"pattern.jpg\");\n}\ndiv {\n    background-color: _____;\n}\n```",
      "option_a": "`clear`",
      "option_b": "`transparent`",
      "option_c": "`invisible`",
      "option_d": "`none`",
      "correct_answer": "B",
      "explanation": "• `transparent` 키워드는 완전히 투명한 색상을 나타냅니다\n\n• transparent의 특징:\n  • 색상을 완전히 투명하게 만듦\n  • 뒤에 있는 배경이나 이미지가 그대로 보임\n  • `rgba(0,0,0,0)`과 동일한 효과",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:01:50.000Z"
    },
    {
      "id": 1382,
      "subject_id": 9,
      "question": "현재 요소의 텍스트 색상과 동일한 색상을 참조하는 키워드는?\n```css\ndiv {\n    color: blue;\n    border: 5px solid _____;\n}\n```",
      "option_a": "`samecolor`",
      "option_b": "`textcolor`",
      "option_c": "`currentcolor`",
      "option_d": "`auto`",
      "correct_answer": "C",
      "explanation": "• `currentcolor` 키워드는 현재 요소의 `color` 속성값을 참조합니다\n\n• currentcolor의 작동 원리:\n  • 요소의 현재 `color` 속성값을 다른 속성에서 재사용\n  • 색상 일관성을 자동으로 유지\n  • 동적으로 색상이 변경되면 함께 변경됨",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:03:05.000Z"
    },
    {
      "id": 1383,
      "subject_id": 9,
      "question": "부모 요소의 속성값을 그대로 상속받도록 하는 키워드는?\n```css\n.parent {\n    border: 3px solid red;\n    padding: 20px;\n}\n.child {\n    border: _____;\n}\n```",
      "option_a": "`inherit`",
      "option_b": "`parent`",
      "option_c": "`copy`",
      "option_d": "`same`",
      "correct_answer": "A",
      "explanation": "• `inherit` 키워드는 부모 요소의 속성값을 강제로 상속받게 합니다\n\n• inherit의 특징:\n  • 모든 CSS 속성에서 사용 가능\n  • 일반적으로 상속되지 않는 속성도 강제 상속\n  • 부모의 계산된 값(computed value)을 상속받음\n\n• 상속의 두 가지 유형:\n\n자연적 상속 (기본 동작):\n```css\n.parent { color: blue; }\n.child { /* color는 자동으로 blue가 됨 */ }\n```\n강제 상속 (inherit 사용):\n```css\n.parent { border: 2px solid red; }\n.child { border: inherit; }  /* border는 보통 상속 안 되지만 강제 상속 */\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:04:54.000Z"
    },
    {
      "id": 1384,
      "subject_id": 9,
      "question": "다음 코드에서 div의 그림자와 테두리 색상은?\n```css\nbody {\n    color: green;\n}\ndiv {\n    color: red;\n    box-shadow: 0px 0px 10px currentcolor;\n    border: 3px solid currentcolor;\n}\n```",
      "option_a": "녹색 (body의 color)",
      "option_b": "빨간색 (div의 color)",
      "option_c": "검은색 (기본값)",
      "option_d": "투명 (transparent)",
      "correct_answer": "B",
      "explanation": "• `currentcolor`는 해당 요소의 직접적인 `color` 속성값을 참조합니다\n\n• currentcolor의 참조 규칙:\n  • 자신의 `color` 속성값을 우선 참조\n  • 자신에게 `color`가 없으면 상속받은 값 사용\n  • 상속 체인을 따라 올라가며 검색\n\n• 이 예시의 단계별 분석:\n  1. `body`의 `color: green` 설정\n  2. `div`의 `color: red` 설정 (body 값 덮어씀)\n  3. `div`의 `currentcolor` = `red` (자신의 color 값)\n  4. 결과: 빨간색 그림자와 빨간색 테두리",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:06:30.000Z"
    },
    {
      "id": 1385,
      "subject_id": 9,
      "question": "다음 코드의 실행 결과로 올바른 설명은?\n```css\n.container {\n    color: blue;\n    border: 2px solid red;\n}\n.item {\n    color: currentcolor;\n    border: inherit;\n    background-color: transparent;\n}\n```\n```html\n<div class=\"container\">\n    <div class=\"item\">Content</div>\n</div>\n```",
      "option_a": "item의 색상은 파란색, 테두리는 빨간색, 배경은 투명",
      "option_b": "item의 색상은 빨간색, 테두리는 파란색, 배경은 흰색",
      "option_c": "item의 색상은 검은색, 테두리는 없음, 배경은 투명",
      "option_d": "모든 속성이 브라우저 기본값으로 표시됨",
      "correct_answer": "A",
      "explanation": "• 세 가지 키워드가 각각 다른 방식으로 작동하는 복합적인 상황입니다\n\n• 각 속성별 상세 분석:\n\n색상 (`color: currentcolor`):\n  • `currentcolor`는 자신의 `color` 속성을 참조하려 함\n  • 하지만 자신이 `currentcolor`로 설정되어 있어 순환 참조\n  • CSS는 이런 경우 상속된 값을 사용: 파란색 (container에서 상속)\n\n테두리 (`border: inherit`):\n  • `inherit`는 부모 요소의 속성값을 그대로 상속받음\n  • container의 `border: 2px solid red`를 상속\n  • 결과: 빨간색 2px 실선 테두리\n\n배경 (`background-color: transparent`):\n  • `transparent`는 완전히 투명한 배경\n  • 결과: 투명 배경 (뒤의 배경이 보임)",
      "difficulty": "hard",
      "created_at": "2025-08-10T17:08:41.000Z"
    },
    {
      "id": 1386,
      "subject_id": 9,
      "question": "선형 그라데이션을 만들기 위한 CSS 함수는?\n```css\n.gradient-box {\n    background-image: _____(red, blue);\n}\n```",
      "option_a": "`gradient`",
      "option_b": "`linear-gradient`",
      "option_c": "`color-gradient`",
      "option_d": "`background-gradient`",
      "correct_answer": "B",
      "explanation": "• `linear-gradient()` 함수는 CSS에서 선형 그라데이션을 생성하는 표준 함수입니다\n\n• 선형 그라데이션의 기본 특징:\n  • 직선 방향으로 색상이 부드럽게 전환\n  • 최소 두 개의 색상 필요 (color stops)\n  • 시작점과 끝점 사이에서 색상이 점진적으로 변화\n\n• 기본 사용법:\n```css\n/* 가장 간단한 형태 - 위에서 아래로 */\nbackground-image: linear-gradient(red, blue);\n\n/* 방향 지정 */\nbackground-image: linear-gradient(to right, red, blue);\n\n/* 각도 지정 */\nbackground-image: linear-gradient(45deg, red, blue);\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:12:42.000Z"
    },
    {
      "id": 1387,
      "subject_id": 9,
      "question": "왼쪽에서 오른쪽으로 향하는 선형 그라데이션을 만들려면?\n```css\n.horizontal-gradient {\n    background-image: linear-gradient(_____, red, blue);\n}\n```",
      "option_a": "`left`",
      "option_b": "`to right`",
      "option_c": "`horizontal`",
      "option_d": "`90deg`",
      "correct_answer": "B",
      "explanation": "• `to right` 키워드는 왼쪽에서 오른쪽 방향으로 그라데이션을 생성합니다\n\n• 방향 지정 키워드들:\n  • `to right`: 왼쪽 → 오른쪽\n  • `to left`: 오른쪽 → 왼쪽\n  • `to bottom`: 위 → 아래 (기본값)\n  • `to top`: 아래 → 위",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:14:00.000Z"
    },
    {
      "id": 1388,
      "subject_id": 9,
      "question": "투명도를 사용한 페이드 아웃 효과를 만들기 위한 올바른 코드는?\n```css\n.fade-effect {\n    background-image: linear-gradient(to right, _____, _____);\n}\n```",
      "option_a": "`rgba(255,0,0,1)`, `rgba(255,0,0,0)`",
      "option_b": "`red`, `transparent`",
      "option_c": "`rgb(255,0,0)`, `rgba(255,0,0,0.5)`",
      "option_d": "1번과 2번 모두 정답",
      "correct_answer": "D",
      "explanation": "• 투명도를 이용한 페이드 효과는 여러 방법으로 구현 가능합니다\n\n• 방법 1: RGBA 함수 사용\n```css\nbackground-image: linear-gradient(to right, rgba(255,0,0,1), rgba(255,0,0,0));\n```\n  • `rgba(255,0,0,1)`: 완전 불투명한 빨간색\n  • `rgba(255,0,0,0)`: 완전 투명한 빨간색\n  • 같은 색상에서 투명도만 변화\n\n• 방법 2: transparent 키워드 사용\n```css\nbackground-image: linear-gradient(to right, red, transparent);\n```\n  • `red`: 불투명한 빨간색\n  • `transparent`: 완전 투명 (`rgba(0,0,0,0)`과 동일)\n  • 더 간단하고 직관적인 문법",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:15:57.000Z"
    },
    {
      "id": 1389,
      "subject_id": 9,
      "question": "각도를 사용하여 그라데이션 방향을 지정할 때, 180도는 어떤 방향을 의미하나요?\n```css\n.angled-gradient {\n    background-image: linear-gradient(180deg, red, blue);\n}\n```",
      "option_a": "위쪽 방향 (to top)",
      "option_b": "오른쪽 방향 (to right)",
      "option_c": "아래쪽 방향 (to bottom)",
      "option_d": "왼쪽 방향 (to left)",
      "correct_answer": "C",
      "explanation": "• CSS 그라데이션에서 각도는 시계방향으로 계산되며, 180deg는 아래쪽을 의미합니다\n\n• 각도와 방향의 완전한 대응표:\n  • 0deg: 위쪽 (12시 방향) = `to top`\n  • 90deg: 오른쪽 (3시 방향) = `to right`\n  • 180deg: 아래쪽 (6시 방향) = `to bottom`\n  • 270deg: 왼쪽 (9시 방향) = `to left`",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:17:13.000Z"
    },
    {
      "id": 1390,
      "subject_id": 9,
      "question": "중심에서 바깥쪽으로 퍼지는 원형/타원형 그라데이션을 만드는 CSS 함수는?\n```css\n.circular-gradient {\n    background-image: _____(red, blue);\n}\n```",
      "option_a": "`circle-gradient`",
      "option_b": "`radial-gradient`",
      "option_c": "`round-gradient`",
      "option_d": "`center-gradient`",
      "correct_answer": "B",
      "explanation": "• `radial-gradient()` 함수는 중심점에서 바깥쪽으로 방사되는 그라데이션을 생성합니다\n\n• 방사형 그라데이션의 기본 특징:\n  • 중심점을 기준으로 모든 방향으로 색상이 퍼져나감\n  • 기본값은 타원형(ellipse) 모양\n  • 중심에서 가장자리로 갈수록 색상이 변화",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:20:41.000Z"
    },
    {
      "id": 1391,
      "subject_id": 9,
      "question": "방사형 그라데이션을 완전한 원형으로 만들려면?\n```css\n.perfect-circle {\n    background-image: radial-gradient(_____, red, blue);\n}\n```",
      "option_a": "`round`",
      "option_b": "`circle`",
      "option_c": "`circular`",
      "option_d": "`ellipse`",
      "correct_answer": "B",
      "explanation": "• `circle` 키워드는 방사형 그라데이션을 완전한 원형으로 만듭니다\n\n• 모양 옵션의 차이점:\n\n`circle` (원형):\n  • 모든 방향으로 동일한 반지름\n  • 가로세로 비율이 1:1로 고정\n  • 정사각형 영역에서 완전한 원 형태\n\n`ellipse` (타원형, 기본값):\n  • 컨테이너의 가로세로 비율에 따라 조정\n  • 직사각형 영역에서 타원 형태\n  • 대부분의 경우 기본값으로 사용",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:24:23.000Z"
    },
    {
      "id": 1392,
      "subject_id": 9,
      "question": "방사형 그라데이션의 중심 위치를 오른쪽 위 모서리로 설정하려면?\n```css\n.positioned-gradient {\n    background-image: radial-gradient(circle _____, red, blue);\n}\n```",
      "option_a": "`at top right`",
      "option_b": "`at right top`",
      "option_c": "`position top right`",
      "option_d": "`center top right`",
      "correct_answer": "A",
      "explanation": "• `at` 키워드 다음에 위치를 지정하여 그라데이션의 중심점을 설정합니다\n\n• 위치 지정 문법:\n```css\nradial-gradient(shape size at position, colors...)\n```\n  • `at` 키워드는 필수\n  • 위치는 키워드 또는 좌표값으로 지정\n\n• 위치 키워드들:\n  • 수직 위치: `top`, `center`, `bottom`\n  • 수평 위치: `left`, `center`, `right`\n  • 조합: `top left`, `top right`, `bottom left`, `bottom right`",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:26:19.000Z"
    },
    {
      "id": 1393,
      "subject_id": 9,
      "question": "방사형 그라데이션의 크기를 제어하는 키워드 중에서 가장 가까운 모서리까지의 거리를 기준으로 하는 것은?\n```css\n.size-controlled {\n    background-image: radial-gradient(circle _____ at center, red, blue);\n}\n```",
      "option_a": "`closest-side`",
      "option_b": "`closest-corner`",
      "option_c": "`farthest-side`",
      "option_d": "`farthest-corner`",
      "correct_answer": "B",
      "explanation": "• `closest-corner`는 중심에서 가장 가까운 모서리까지의 거리를 그라데이션 크기로 설정합니다\n\n• 크기 키워드들의 상세 설명:\n\n`closest-side`:\n  • 중심에서 가장 가까운 **변(side)**까지의 거리\n  • 그라데이션이 상대적으로 작게 나타남\n\n`closest-corner`:\n  • 중심에서 가장 가까운 **모서리(corner)**까지의 거리\n  • `closest-side`보다 큰 크기\n\n`farthest-side`:\n  • 중심에서 가장 먼 변까지의 거리\n  • 중간 크기의 그라데이션\n\n`farthest-corner` (기본값):\n  • 중심에서 가장 먼 모서리까지의 거리\n  • 가장 큰 크기의 그라데이션",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:28:12.000Z"
    },
    {
      "id": 1394,
      "subject_id": 9,
      "question": "중심점을 기준으로 회전하면서 색상이 변화하는 그라데이션을 만드는 CSS 함수는?\n```css\n.rotating-gradient {\n    background-image: _____(red, yellow, blue);\n}\n```",
      "option_a": "`rotation-gradient`",
      "option_b": "`conic-gradient`",
      "option_c": "`circular-gradient`",
      "option_d": "`spin-gradient`",
      "correct_answer": "B",
      "explanation": "• `conic-gradient()` 함수는 중심점 주변으로 회전하는 원뿔형 그라데이션을 생성합니다\n\n• 원뿔형 그라데이션의 특징:\n  • 중심점을 기준으로 360도 회전하면서 색상 변화\n  • 시계방향으로 색상이 순환\n  • 파이 차트나 색상환 제작에 최적\n\n• 기본 동작 원리:\n```css\n/* 기본 형태 - 3개 색상이 균등 분할 */\nconic-gradient(red, yellow, blue);\n/* red: 0-120도, yellow: 120-240도, blue: 240-360도 */\n```\n• 다른 그라데이션과의 차이:\n  • Linear: 직선 방향으로 색상 변화\n  • Radial: 중심에서 바깥으로 원형 확산\n  • Conic: 중심 기준 회전 방향으로 색상 변화",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:32:35.000Z"
    },
    {
      "id": 1395,
      "subject_id": 9,
      "question": "원뿔형 그라데이션을 파이 차트처럼 보이게 만들기 위해 추가해야 하는 CSS 속성은?\n```css\n.pie-chart {\n    background-image: conic-gradient(red, yellow, blue);\n    _____: 50%;\n}\n```",
      "option_a": "`border-radius`",
      "option_b": "`border-circle`",
      "option_c": "`shape`",
      "option_d": "`clip-path`",
      "correct_answer": "A",
      "explanation": "• `border-radius: 50%`는 사각형 요소를 완전한 원형으로 만듭니다\n\n• 파이 차트 생성 과정:\n  1. `conic-gradient()`로 색상 섹션 생성\n  2. `border-radius: 50%`로 원형으로 자르기\n  3. 결과: 완벽한 파이 차트 모양",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:34:00.000Z"
    },
    {
      "id": 1396,
      "subject_id": 9,
      "question": "원뿔형 그라데이션의 시작 각도를 90도로 설정하려면?\n```css\n.rotated-gradient {\n    background-image: conic-gradient(_____ 90deg, red, yellow, blue);\n}\n```",
      "option_a": "`angle`",
      "option_b": "`start`",
      "option_c": "`from`",
      "option_d": "`rotate`",
      "correct_answer": "C",
      "explanation": "• `from` 키워드는 원뿔형 그라데이션의 시작 각도를 지정합니다\n\n• 각도 시스템 이해:\n  • 0deg: 12시 방향 (위쪽) - 기본값\n  • 90deg: 3시 방향 (오른쪽)\n  • 180deg: 6시 방향 (아래쪽)\n  • 270deg: 9시 방향 (왼쪽)",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:35:27.000Z"
    },
    {
      "id": 1397,
      "subject_id": 9,
      "question": "원뿔형 그라데이션의 중심 위치를 오른쪽 아래로 설정하려면?\n```css\n.positioned-conic {\n    background-image: conic-gradient(_____ bottom right, red, yellow, blue);\n}\n```",
      "option_a": "`center`",
      "option_b": "`position`",
      "option_c": "`at`",
      "option_d": "`point`",
      "correct_answer": "C",
      "explanation": "• `at` 키워드는 원뿔형 그라데이션의 중심점 위치를 지정합니다\n\n• 위치 지정 문법:\n```css\nconic-gradient(at position, colors...)\n```\n  • `at` 키워드 다음에 위치 값 지정\n  • 키워드, 퍼센트, 픽셀 등 다양한 단위 사용 가능",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:37:10.000Z"
    },
    {
      "id": 1398,
      "subject_id": 9,
      "question": "CSS에서 텍스트에 그림자 효과를 주기 위해 사용하는 속성은 무엇인가요?",
      "option_a": "box-shadow",
      "option_b": "text-shadow",
      "option_c": "shadow-text",
      "option_d": "font-shadow",
      "correct_answer": "B",
      "explanation": "• `text-shadow` 속성은 텍스트에 그림자 효과를 적용하는 CSS 속성입니다\n• `box-shadow`는 요소(박스)에 그림자를 적용할 때 사용합니다\n• `shadow-text`와 `font-shadow`는 존재하지 않는 속성입니다\n• 텍스트 그림자는 웹 디자인에서 텍스트를 돋보이게 하거나 시각적 효과를 주는 데 자주 사용됩니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:40:00.000Z"
    },
    {
      "id": 1399,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은 무엇인가요?\n```css\nh1 {\n    text-shadow: ___px ___px;\n}\n```\n위 코드는 수평으로 2px, 수직으로 2px 이동한 기본 그림자를 만들려고 합니다.",
      "option_a": "1px 1px",
      "option_b": "2px 2px",
      "option_c": "3px 3px",
      "option_d": "0px 0px",
      "correct_answer": "B",
      "explanation": "• `text-shadow`의 기본 문법에서 첫 번째 값은 수평 이동(horizontal offset)을 나타냅니다\n• 두 번째 값은 수직 이동(vertical offset)을 나타냅니다\n• 양수 값을 사용하면 오른쪽(수평)과 아래쪽(수직)으로 그림자가 이동합니다\n• `2px 2px`는 가장 기본적이고 자주 사용되는 그림자 설정입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:41:08.000Z"
    },
    {
      "id": 1400,
      "subject_id": 9,
      "question": "다음 코드의 실행 결과로 올바른 것은?\n```css\nh1 {\n    text-shadow: 2px 2px 5px red;\n}\n```",
      "option_a": "빨간색 그림자가 오른쪽 2px, 아래쪽 2px에 위치하고, 블러 효과는 없음",
      "option_b": "빨간색 그림자가 오른쪽 2px, 아래쪽 2px에 위치하고, 5px 블러 효과가 적용됨",
      "option_c": "빨간색 그림자가 오른쪽 5px, 아래쪽 5px에 위치하고, 2px 블러 효과가 적용됨",
      "option_d": "검은색 그림자가 오른쪽 2px, 아래쪽 2px에 위치하고, 5px 블러 효과가 적용됨",
      "correct_answer": "B",
      "explanation": "• `text-shadow`의 완전한 문법은 `수평이동 수직이동 블러반경 색상` 순서입니다\n\n• `2px 2px 5px red`에서 각각의 의미:\n  • 첫 번째 `2px`: 수평으로 오른쪽 2px 이동\n  • 두 번째 `2px`: 수직으로 아래쪽 2px 이동\n  • `5px`: 블러 반경 (그림자가 흐려지는 정도)\n  • `red`: 그림자 색상\n\n• 블러 값이 클수록 그림자가 더 부드럽고 흐려집니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:42:55.000Z"
    },
    {
      "id": 1401,
      "subject_id": 9,
      "question": "다음 중 네온 글로우(neon glow) 효과를 만드는 올바른 코드는?",
      "option_a": "`text-shadow: 2px 2px 0 #FF0000;`",
      "option_b": "`text-shadow: 0 0 3px #FF0000;`",
      "option_c": "`text-shadow: -2px -2px 0 #FF0000;`",
      "option_d": "`text-shadow: 1px 1px 1px #FF0000;`",
      "correct_answer": "B",
      "explanation": "• 네온 글로우 효과는 텍스트 주변에 빛이 번지는 효과를 의미합니다\n\n• 이를 위해서는 수평, 수직 이동을 모두 0으로 설정해야 합니다\n\n• `0 0 3px #FF0000`의 의미:\n  • 첫 번째 `0`: 수평 이동 없음\n  • 두 번째 `0`: 수직 이동 없음\n  • `3px`: 블러 반경 (빛이 퍼지는 범위)\n  • `#FF0000`: 빨간색 글로우\n\n• 이동값이 0이면 그림자가 텍스트 중심에서 사방으로 퍼져 글로우 효과가 생성됩니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:44:51.000Z"
    },
    {
      "id": 1402,
      "subject_id": 9,
      "question": "CSS에서 HTML 요소(div, button 등)에 그림자 효과를 주기 위해 사용하는 속성은 무엇인가요?",
      "option_a": "element-shadow",
      "option_b": "div-shadow",
      "option_c": "box-shadow",
      "option_d": "container-shadow",
      "correct_answer": "C",
      "explanation": "• `box-shadow` 속성은 HTML 요소(박스 모델)에 그림자 효과를 적용하는 CSS 속성입니다\n• `text-shadow`는 텍스트에만 사용되지만, `box-shadow`는 모든 HTML 요소에 사용 가능합니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:49:36.000Z"
    },
    {
      "id": 1403,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은 무엇인가요?\n```css\ndiv {\n    box-shadow: ___px ___px;\n}\n```\n위 코드는 수평으로 10px, 수직으로 10px 이동한 기본 그림자를 만들려고 합니다.",
      "option_a": "5px 5px",
      "option_b": "10px 10px",
      "option_c": "15px 15px",
      "option_d": "20px 20px",
      "correct_answer": "B",
      "explanation": "• `box-shadow`의 기본 문법에서 첫 번째 값은 수평 오프셋(horizontal offset)입니다\n\n• 두 번째 값은 수직 오프셋(vertical offset)입니다\n\n• 양수 값은 오른쪽(수평)과 아래쪽(수직)으로 그림자를 이동시킵니다\n\n• 색상을 지정하지 않으면 현재 텍스트 색상이 기본값으로 사용됩니다\n\n• `10px 10px`는 가장 일반적으로 사용되는 기본 그림자 설정입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T17:51:04.000Z"
    },
    {
      "id": 1404,
      "subject_id": 9,
      "question": "다음 코드의 각 값이 나타내는 의미를 올바르게 설명한 것은?\n```css\ndiv {\n    box-shadow: 10px 10px 5px lightblue;\n}\n```",
      "option_a": "수평 10px, 수직 10px, 색상 5px, 블러 lightblue",
      "option_b": "수평 10px, 수직 10px, 블러 5px, 색상 lightblue",
      "option_c": "블러 10px, 색상 10px, 수평 5px, 수직 lightblue",
      "option_d": "색상 10px, 블러 10px, 수평 5px, 수직 lightblue",
      "correct_answer": "B",
      "explanation": "• `box-shadow`의 기본 문법 순서: `수평오프셋 수직오프셋 블러반경 색상`\n\n• 각 값의 의미:\n  • `10px` (첫 번째): 수평으로 오른쪽 10px 이동\n  • `10px` (두 번째): 수직으로 아래쪽 10px 이동\n  • `5px` (세 번째): 블러 반경 (그림자 흐림 정도)\n  • `lightblue`: 그림자 색상\n\n• 블러 값이 클수록 그림자가 더 부드럽고 흐려집니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:52:55.000Z"
    },
    {
      "id": 1405,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 키워드는 무엇인가요?\n```css\ndiv {\n    box-shadow: 10px 10px 5px lightblue _____;\n}\n```\n이 코드는 그림자를 요소 바깥쪽이 아닌 안쪽에 표시하려고 합니다.",
      "option_a": "inner",
      "option_b": "inside",
      "option_c": "inset",
      "option_d": "internal",
      "correct_answer": "C",
      "explanation": "• `inset` 키워드는 그림자를 외부 그림자에서 내부 그림자로 변경합니다\n\n• 기본적으로 `box-shadow`는 외부 그림자(outset)를 만듭니다\n\n• `inset`을 추가하면 그림자가 요소 내부로 들어가 움푹 패인 효과를 만듭니다\n\n• 내부 그림자 효과의 활용:\n  • 버튼의 눌린(pressed) 상태 표현\n  • 입력 필드의 움푹 패인 느낌 연출\n  • 카드의 내부 공간감 표현\n\n• `inset`은 다른 값들의 앞이나 뒤 어디에나 위치할 수 있습니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T17:54:47.000Z"
    },
    {
      "id": 1406,
      "subject_id": 9,
      "question": "텍스트가 요소의 영역을 넘어갔을 때 어떻게 처리할지를 지정하는 CSS 속성은 무엇인가요?",
      "option_a": "text-wrap",
      "option_b": "text-overflow",
      "option_c": "overflow-text",
      "option_d": "text-break",
      "correct_answer": "B",
      "explanation": "• `text-overflow` 속성은 텍스트가 컨테이너 영역을 넘어갔을 때의 처리 방법을 지정합니다\n• 주요 값으로는 `clip`(잘림)과 `ellipsis`(말줄임표 ...)가 있습니다\n• 이 속성이 제대로 작동하려면 `overflow: hidden`과 `white-space: nowrap` 설정이 필요합니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T18:13:49.000Z"
    },
    {
      "id": 1407,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은?\n```css\np {\n  white-space: nowrap;\n  width: 200px;\n  overflow: hidden;\n  text-overflow: _______;\n}\n```\n위 코드는 텍스트가 넘칠 때 말줄임표(...)를 표시하려고 합니다.",
      "option_a": "clip",
      "option_b": "ellipsis",
      "option_c": "hidden",
      "option_d": "wrap",
      "correct_answer": "B",
      "explanation": "• `text-overflow: ellipsis`는 넘치는 텍스트를 말줄임표(...)로 표시합니다\n• `text-overflow: clip`은 넘치는 텍스트를 그냥 잘라버립니다\n• `ellipsis`는 사용자에게 더 많은 내용이 있다는 것을 시각적으로 알려주는 친화적인 방법입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T18:15:35.000Z"
    },
    {
      "id": 1408,
      "subject_id": 9,
      "question": "긴 단어가 컨테이너를 벗어날 때 단어 중간에서라도 줄바꿈이 되도록 하려면 어떤 속성을 사용해야 하나요?",
      "option_a": "word-break: break-all",
      "option_b": "word-wrap: break-word",
      "option_c": "text-wrap: break",
      "option_d": "line-break: anywhere",
      "correct_answer": "B",
      "explanation": "• `word-wrap: break-word`는 긴 단어가 컨테이너를 벗어날 때 단어 중간에서 줄바꿈을 허용합니다\n\n• `word-break: break-all`도 비슷하지만, 더 적극적으로 모든 문자에서 줄바꿈을 허용합니다\n\n• `word-wrap: break-word`가 더 자연스러운 줄바꿈을 제공합니다\n\n• 이 속성은 특히 URL이나 긴 단어가 레이아웃을 깨뜨리는 것을 방지할 때 유용합니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T18:17:05.000Z"
    },
    {
      "id": 1409,
      "subject_id": 9,
      "question": "다음 중 word-break 속성의 값으로 올바른 것은?\n```css\np.test1 {\n  word-break: _______; /* 하이픈에서만 줄바꿈 */\n}\n\np.test2 {\n  word-break: _______; /* 모든 문자에서 줄바꿈 가능 */\n}\n```",
      "option_a": "keep-all, break-all",
      "option_b": "break-word, break-all",
      "option_c": "keep-all, break-word",
      "option_d": "no-break, break-all",
      "correct_answer": "A",
      "explanation": "• `word-break: keep-all`은 단어를 유지하고 하이픈이나 공백에서만 줄바꿈을 허용합니다\n• `word-break: break-all`은 모든 문자 위치에서 줄바꿈을 허용합니다\n• `keep-all`은 한국어, 중국어, 일본어 등 CJK 언어에서 특히 유용합니다\n• `break-all`은 영어에서 단어 중간에서도 강제로 줄바꿈을 만들 때 사용됩니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T18:18:10.000Z"
    },
    {
      "id": 1410,
      "subject_id": 9,
      "question": "다음 코드의 실행 결과를 예상해보세요:\n```css\n.container {\n  width: 100px;\n  border: 1px solid black;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n.container p {\n  text-overflow: ellipsis;\n  margin: 0;\n}\n\n.container:hover {\n  overflow: visible;\n}\n```\n```html\n<div class=\"container\">\n  <p>This is a very long text that will overflow</p>\n</div>\n```",
      "option_a": "평상시에는 텍스트가 잘리고, 호버 시 말줄임표가 나타남",
      "option_b": "평상시에는 말줄임표가 나타나고, 호버 시 전체 텍스트가 보임",
      "option_c": "항상 전체 텍스트가 보임",
      "option_d": "항상 텍스트가 잘림",
      "correct_answer": "B",
      "explanation": "• 평상시 상태에서의 동작:\n  • `width: 100px`로 제한된 영역\n  • `white-space: nowrap`으로 줄바꿈 금지\n  • `overflow: hidden`으로 넘치는 부분 숨김\n  • `text-overflow: ellipsis`로 말줄임표(...) 표시\n\n• 호버 시 동작:\n  • `overflow: visible`로 변경되어 숨겨진 텍스트가 보임\n  • 전체 텍스트가 컨테이너 밖으로 나와서 표시됨\n\n• 이는 말줄임표로 축약된 텍스트의 전체 내용을 보여주는 일반적인 UI 패턴입니다",
      "difficulty": "hard",
      "created_at": "2025-08-10T18:21:22.000Z"
    },
    {
      "id": 1411,
      "subject_id": 9,
      "question": "웹에서 사용자의 컴퓨터에 설치되지 않은 폰트를 사용할 수 있게 해주는 CSS 규칙은 무엇인가요?",
      "option_a": "@font-style",
      "option_b": "@font-face",
      "option_c": "@web-font",
      "option_d": "@custom-font",
      "correct_answer": "B",
      "explanation": "• `@font-face` 규칙은 웹폰트를 정의하는 CSS의 핵심 기능입니다\n• 서버에 업로드된 폰트 파일을 사용자가 자동으로 다운로드하여 사용할 수 있게 해줍니다\n• 웹 디자이너가 시스템 폰트에 의존하지 않고 원하는 폰트를 사용할 수 있게 해주는 중요한 기술입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T18:24:37.000Z"
    },
    {
      "id": 1412,
      "subject_id": 9,
      "question": "다음 중 웹에서 가장 널리 사용되는 웹폰트 포맷은 무엇인가요?",
      "option_a": "TTF (TrueType Font)",
      "option_b": "WOFF (Web Open Font Format)",
      "option_c": "EOT (Embedded OpenType)",
      "option_d": "SVG Fonts",
      "correct_answer": "B",
      "explanation": "• WOFF는 웹페이지에서 사용하기 위해 특별히 개발된 폰트 포맷입니다\n\n• 2009년에 개발되어 현재 W3C 권장사항이 되었습니다\n\n• 주요 장점:\n  • OpenType이나 TrueType을 압축하여 용량이 작음\n  • 네트워크 대역폭이 제한된 환경에서 효율적\n  • 대부분의 현대 브라우저에서 지원",
      "difficulty": "easy",
      "created_at": "2025-08-10T18:25:29.000Z"
    },
    {
      "id": 1413,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성명은?\n```css\n@font-face {\n  _______: myCustomFont;\n  src: url(custom-font.woff);\n}\n\nh1 {\n  _______: myCustomFont;\n}\n```",
      "option_a": "font-name, font-family",
      "option_b": "font-family, font-family",
      "option_c": "font-style, font-name",
      "option_d": "font-family, font-style",
      "correct_answer": "B",
      "explanation": "• @font-face에서: `font-family`로 폰트의 이름을 정의합니다\n\n• 실제 사용에서: 동일한 `font-family` 속성으로 정의한 폰트 이름을 참조합니다\n\n• 사용 과정:\n  1. `@font-face`에서 `font-family: myCustomFont`로 폰트 정의\n  2. HTML 요소에서 `font-family: myCustomFont`로 해당 폰트 적용\n\n• 두 곳 모두 같은 속성명을 사용하는 것이 포인트입니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T18:27:05.000Z"
    },
    {
      "id": 1414,
      "subject_id": 9,
      "question": "CSS에서 요소를 이동, 회전, 크기 조절, 기울이기 등의 변형을 적용할 때 사용하는 속성은 무엇인가요?",
      "option_a": "transform",
      "option_b": "transition",
      "option_c": "animation",
      "option_d": "change",
      "correct_answer": "A",
      "explanation": "• `transform` 속성은 CSS 2D/3D 변형의 핵심 속성입니다\n\n• 주요 기능:\n  • 요소를 이동(translate)\n  • 회전(rotate)\n  • 크기 조절(scale)\n  • 기울이기(skew)\n\n• `transition`은 변화 과정의 애니메이션을, `animation`은 키프레임 애니메이션을 담당합니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T18:31:47.000Z"
    },
    {
      "id": 1415,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 함수는?\n```css\ndiv {\n  transform: _______(50px, 100px);\n}\n```\n위 코드는 요소를 오른쪽으로 50px, 아래쪽으로 100px 이동시키려고 합니다.",
      "option_a": "move",
      "option_b": "translate",
      "option_c": "position",
      "option_d": "shift",
      "correct_answer": "B",
      "explanation": "• `translate()` 함수는 요소를 현재 위치에서 상대적으로 이동시킵니다\n\n• 사용법: `translate(X축 이동거리, Y축 이동거리)`\n\n• 방향:\n  • 양수: 오른쪽(X), 아래쪽(Y)\n  • 음수: 왼쪽(X), 위쪽(Y)\n\n• `translate(50px, 100px)`는 오른쪽으로 50px, 아래로 100px 이동",
      "difficulty": "easy",
      "created_at": "2025-08-10T18:33:29.000Z"
    },
    {
      "id": 1416,
      "subject_id": 9,
      "question": "요소를 시계 반대 방향으로 30도 회전시키려면 어떤 코드를 사용해야 하나요?",
      "option_a": "`transform: rotate(30deg);`",
      "option_b": "`transform: rotate(-30deg);`",
      "option_c": "`transform: rotate(30deg, counter-clockwise);`",
      "option_d": "`transform: rotate-left(30deg);`",
      "correct_answer": "B",
      "explanation": "• `rotate()` 함수의 회전 방향 규칙:\n  • 양수: 시계 방향(clockwise) 회전\n  • 음수: 시계 반대 방향(counter-clockwise) 회전\n\n• 예시:\n  • `rotate(30deg)`: 시계 방향으로 30도\n  • `rotate(-30deg)`: 시계 반대 방향으로 30도\n\n• 각도 단위는 `deg`(도), `rad`(라디안), `turn`(회전) 등을 사용할 수 있습니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T18:35:56.000Z"
    },
    {
      "id": 1417,
      "subject_id": 9,
      "question": "CSS 3D 변형에서 사용되는 주요 속성은 무엇인가요?",
      "option_a": "transform-3d",
      "option_b": "transform",
      "option_c": "rotate-3d",
      "option_d": "dimension",
      "correct_answer": "B",
      "explanation": "• CSS 3D 변형도 2D 변형과 동일하게 `transform` 속성을 사용합니다\n\n• 차이점:\n  • 2D: `rotate()`, `translate()`, `scale()` 등 사용\n  • 3D: `rotateX()`, `rotateY()`, `rotateZ()` 등 축별 함수 추가\n\n• 같은 속성으로 2D와 3D 변형을 모두 처리할 수 있어 학습이 용이합니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T18:40:28.000Z"
    },
    {
      "id": 1418,
      "subject_id": 9,
      "question": "다음 중 CSS 3D 회전 함수가 아닌 것은?",
      "option_a": "rotateX()",
      "option_b": "rotateY()",
      "option_c": "rotateZ()",
      "option_d": "rotateW()",
      "correct_answer": "D",
      "explanation": "• CSS 3D 회전 함수는 3차원 좌표계의 세 축을 기준으로 합니다\n\n• 3D 회전 함수:\n  • `rotateX()`: X축 기준 회전 (좌우를 축으로 위아래 회전)\n  • `rotateY()`: Y축 기준 회전 (상하를 축으로 좌우 회전)\n  • `rotateZ()`: Z축 기준 회전 (화면 수직을 축으로 평면 회전)\n\n• `rotateW()`는 존재하지 않는 함수입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T18:42:07.000Z"
    },
    {
      "id": 1419,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 함수는?\n```css\n.card {\n  transform: _______(180deg);\n}\n```\n위 코드는 카드가 좌우로 뒤집히는 효과(앞면↔뒷면)를 만들려고 합니다.",
      "option_a": "rotateX",
      "option_b": "rotateY",
      "option_c": "rotateZ",
      "option_d": "rotate",
      "correct_answer": "B",
      "explanation": "• 카드 뒤집기 효과 분석:\n  • 좌우 뒤집기: Y축을 중심으로 180도 회전\n  • 상하 뒤집기: X축을 중심으로 180도 회전\n  • 평면 회전: Z축을 중심으로 회전\n\n• 실제 활용 예시:\n```css\n.card {\n  transform: rotateY(180deg); /* 좌우 뒤집기 */\n}\n\n.card-flip {\n  transform: rotateX(180deg); /* 상하 뒤집기 */\n}\n```\n• 카드 게임이나 플립 애니메이션에서 `rotateY(180deg)`가 가장 자연스럽습니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T18:43:24.000Z"
    },
    {
      "id": 1420,
      "subject_id": 9,
      "question": "다음 세 코드의 시각적 효과를 올바르게 설명한 것은?\n```css\n/* A */ .box { transform: rotateX(90deg); }\n/* B */ .box { transform: rotateY(90deg); }  \n/* C */ .box { transform: rotateZ(90deg); }\n```",
      "option_a": "A: 좌우 회전, B: 상하 회전, C: 평면 회전",
      "option_b": "A: 상하 회전, B: 좌우 회전, C: 평면 회전",
      "option_c": "A: 평면 회전, B: 상하 회전, C: 좌우 회전",
      "option_d": "A: 좌우 회전, B: 평면 회전, C: 상하 회전",
      "correct_answer": "B",
      "explanation": "• 각 축의 회전 방향 이해:\n\nA. rotateX(90deg):\n  • X축(좌우 수평선)을 중심으로 회전\n  • 요소가 앞뒤로 기울어짐 (상하 회전)\n  • 위쪽이 뒤로, 아래쪽이 앞으로 오는 효과\n\nB. rotateY(90deg):\n  • Y축(상하 수직선)을 중심으로 회전\n  • 요소가 좌우로 기울어짐 (좌우 회전)\n  • 왼쪽이 뒤로, 오른쪽이 앞으로 오는 효과\n\nC. rotateZ(90deg):\n  • Z축(화면 수직)을 중심으로 회전\n  • 화면 평면에서 시계방향으로 90도 회전\n  • 2D `rotate(90deg)`와 동일한 효과",
      "difficulty": "medium",
      "created_at": "2025-08-10T18:46:03.000Z"
    },
    {
      "id": 1421,
      "subject_id": 9,
      "question": "CSS 트랜지션 효과를 만들기 위해 반드시 지정해야 하는 두 가지는 무엇인가요?",
      "option_a": "속성과 색상",
      "option_b": "속성과 지속시간",
      "option_c": "지속시간과 색상",
      "option_d": "속성과 크기",
      "correct_answer": "B",
      "explanation": "CSS 트랜지션의 필수 요소:\n  • 속성(property): 어떤 CSS 속성에 효과를 줄지 지정\n  • 지속시간(duration): 효과가 얼마나 오래 지속될지 지정\n\n중요한 주의사항:\n  • 지속시간을 지정하지 않으면 기본값이 0이므로 트랜지션 효과가 나타나지 않습니다\n  • 예: `transition: width 2s;` (width 속성을 2초 동안 변화)",
      "difficulty": "easy",
      "created_at": "2025-08-10T18:48:49.000Z"
    },
    {
      "id": 1422,
      "subject_id": 9,
      "question": "여러 속성에 서로 다른 지속시간으로 트랜지션을 적용하려면 어떻게 작성해야 하나요?",
      "option_a": "`transition: width 2s; transition: height 4s;`",
      "option_b": "`transition: width 2s, height 4s;`",
      "option_c": "`transition: width 2s + height 4s;`",
      "option_d": "`transition: (width 2s) (height 4s);`",
      "correct_answer": "B",
      "explanation": "다중 속성 트랜지션 문법: 쉼표(`,`)로 구분하여 나열합니다\n\n올바른 작성법:\n```css\ndiv {\n  transition: width 2s, height 4s, background-color 1s;\n}\n```\n각 선택지 분석:\n  • 1번: 두 번째 transition이 첫 번째를 덮어씀 (height만 적용)\n  • 2번: 올바른 문법 ✓\n  • 3번: 잘못된 연산자 사용\n  • 4번: 잘못된 괄호 문법\n\n실무 팁:\n  • 모든 속성에 같은 시간을 적용하려면: `transition: all 2s;`\n  • 개별 제어가 필요하면 쉼표로 구분",
      "difficulty": "medium",
      "created_at": "2025-08-10T18:52:13.000Z"
    },
    {
      "id": 1423,
      "subject_id": 9,
      "question": "다음 중 `transition-timing-function`의 기본값은 무엇이며, 어떤 특성을 가지나요?",
      "option_a": "linear - 일정한 속도로 진행",
      "option_b": "ease - 천천히 시작, 빠르게 진행, 천천히 끝남",
      "option_c": "ease-in - 천천히 시작",
      "option_d": "ease-out - 천천히 끝남",
      "correct_answer": "B",
      "explanation": "기본값: `ease` (별도 지정하지 않으면 자동 적용)\n\n각 timing-function 특성:\n  • ease: 천천히 → 빠르게 → 천천히 (가장 자연스러운 움직임)\n  • linear: 처음부터 끝까지 일정한 속도\n  • ease-in: 천천히 시작해서 점점 빨라짐\n  • ease-out: 빠르게 시작해서 점점 느려짐\n  • ease-in-out: 천천히 시작하고 천천히 끝남\n\n사용 예시:\n```css\n.smooth { transition: all 1s ease; }        /* 기본값 */\n.constant { transition: all 1s linear; }    /* 일정한 속도 */\n.slow-start { transition: all 1s ease-in; } /* 천천히 시작 */\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T18:55:01.000Z"
    },
    {
      "id": 1424,
      "subject_id": 9,
      "question": "CSS 애니메이션을 만들기 위해 반드시 필요한 두 가지 요소는 무엇인가요?",
      "option_a": "@keyframes와 animation-name",
      "option_b": "animation-duration과 animation-delay",
      "option_c": "@keyframes와 animation-duration",
      "option_d": "animation-name과 animation-timing-function",
      "correct_answer": "A",
      "explanation": "CSS 애니메이션의 필수 요소:\n  • @keyframes: 애니메이션의 단계별 스타일을 정의\n  • animation-name: 요소에 어떤 @keyframes를 적용할지 연결\n\n기본 구조:\n```css\n/* 1단계: 애니메이션 정의 */\n@keyframes myAnimation {\n  from { background-color: red; }\n  to { background-color: blue; }\n}\n\n/* 2단계: 요소에 적용 */\ndiv {\n  animation-name: myAnimation; /* 필수 */\n  animation-duration: 2s;      /* 필수 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T18:57:47.000Z"
    },
    {
      "id": 1425,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 키워드는?\n```css\n@keyframes fadeIn {\n  _______ { opacity: 0; }\n  _______ { opacity: 1; }\n}\n```",
      "option_a": "start, end",
      "option_b": "begin, finish",
      "option_c": "from, to",
      "option_d": "0, 1",
      "correct_answer": "C",
      "explanation": "@keyframes에서 사용하는 키워드:\n  • from: 애니메이션 시작 시점 (0%와 동일)\n  • to: 애니메이션 종료 시점 (100%와 동일)\n\n동일한 표현:\n```css\n/* from/to 사용 */\n@keyframes fadeIn {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n\n/* 퍼센트 사용 */\n@keyframes fadeIn {\n  0% { opacity: 0; }\n  100% { opacity: 1; }\n}\n```\n실무 활용:\n  • 간단한 애니메이션: `from/to` 사용\n  • 복잡한 애니메이션: 퍼센트 사용 (0%, 25%, 50%, 75%, 100%)",
      "difficulty": "easy",
      "created_at": "2025-08-10T18:59:14.000Z"
    },
    {
      "id": 1426,
      "subject_id": 9,
      "question": "애니메이션이 끝난 후 마지막 키프레임의 스타일을 유지하려면 어떤 속성을 사용해야 하나요?",
      "option_a": "`animation-fill-mode: none`",
      "option_b": "`animation-fill-mode: forwards`",
      "option_c": "`animation-fill-mode: backwards`",
      "option_d": "`animation-fill-mode: both`",
      "correct_answer": "B",
      "explanation": "forwards:\n  • 애니메이션 종료 후 마지막 키프레임 스타일 유지\n  • 가장 많이 사용되는 값\n\nbackwards:\n  • 애니메이션 시작 전(delay 동안) 첫 번째 키프레임 스타일 적용\n\nboth:\n  • forwards + backwards 효과를 모두 적용\n\nnone (기본값):\n  • 애니메이션 전후에 키프레임 스타일을 적용하지 않음\n  • 실제 사용 예시:\n```css\n@keyframes slideIn {\n  from { transform: translateX(-100%); }\n  to { transform: translateX(0); }\n}\n\n.element {\n  animation: slideIn 1s ease forwards; /* 슬라이드 후 제자리 유지 */\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:01:11.000Z"
    },
    {
      "id": 1427,
      "subject_id": 9,
      "question": "CSS 툴팁을 만들기 위해 컨테이너 요소에 필요한 position 속성값은 무엇인가요?",
      "option_a": "static",
      "option_b": "relative",
      "option_c": "absolute",
      "option_d": "fixed",
      "correct_answer": "B",
      "explanation": "툴팁 컨테이너의 역할:\n  • 마우스 호버 영역을 제공\n  • 툴팁 텍스트의 기준점 역할\n\nposition: relative가 필요한 이유:\n  • 툴팁 텍스트는 `position: absolute`로 설정\n  • absolute 요소는 가장 가까운 positioned 부모를 기준으로 위치 계산\n  • relative를 설정하지 않으면 body나 다른 부모 요소를 기준으로 배치됨\n\n기본 구조:\n```css\n.tooltip {\n  position: relative;  /* 필수! */\n  display: inline-block;\n}\n\n.tooltip .tooltiptext {\n  position: absolute;  /* 컨테이너 기준으로 배치 */\n  /* 위치 조정 속성들... */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:06:55.000Z"
    },
    {
      "id": 1428,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성값은?\n```css\n.tooltip .tooltiptext {\n  visibility: hidden;\n  /* 기타 스타일... */\n}\n\n.tooltip:hover .tooltiptext {\n  visibility: _______;\n}\n```",
      "option_a": "show",
      "option_b": "block",
      "option_c": "visible",
      "option_d": "display",
      "correct_answer": "C",
      "explanation": "visibility 속성의 두 가지 핵심 값:\n  • `hidden`: 요소를 숨김 (공간은 유지)\n  • `visible`: 요소를 표시\n\n툴팁의 동작 원리:\n```css\n/* 평상시: 툴팁 숨김 */\n.tooltip .tooltiptext {\n  visibility: hidden;\n}\n\n/* 호버시: 툴팁 표시 */\n.tooltip:hover .tooltiptext {\n  visibility: visible;\n}\n```\nvisibility vs display 차이점:\n  • `visibility: hidden`: 공간은 유지하되 보이지 않음\n  • `display: none`: 완전히 제거 (공간도 차지하지 않음)\n  • 툴팁에서는 visibility가 더 적합 (레이아웃 변화 없음)",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:08:15.000Z"
    },
    {
      "id": 1429,
      "subject_id": 9,
      "question": "툴팁을 요소의 위쪽에 중앙 정렬로 배치하려면 어떤 CSS를 사용해야 하나요?",
      "option_a": "`top: 100%; left: 50%; margin-left: -60px;`",
      "option_b": "`bottom: 100%; left: 50%; margin-left: -60px;`",
      "option_c": "`top: -100%; left: 50%; margin-left: -60px;`",
      "option_d": "`bottom: 100%; right: 50%; margin-right: -60px;`",
      "correct_answer": "B",
      "explanation": "bottom: 100%:\n  • 툴팁의 아래쪽을 컨테이너의 위쪽에 맞춤\n  • 결과적으로 툴팁이 컨테이너 위에 표시됨\n\nleft: 50%:\n  • 툴팁의 왼쪽을 컨테이너의 중앙에 맞춤\n\nmargin-left: -60px:\n  • 툴팁 너비의 절반만큼 왼쪽으로 이동 (120px ÷ 2 = 60px)\n  • 완전한 중앙 정렬 완성",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:09:49.000Z"
    },
    {
      "id": 1430,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n```css\nimg {\n  _______: 100%;\n  height: auto;\n}\n```\n위 코드는 이미지가 화면 크기에 따라 반응형으로 조절되도록 하려고 합니다.",
      "option_a": "width",
      "option_b": "max-width",
      "option_c": "min-width",
      "option_d": "size",
      "correct_answer": "B",
      "explanation": "반응형 이미지의 핵심 속성:\n  • `max-width: 100%`: 부모 요소보다 크지 않게 제한\n  • `height: auto`: 비율 유지하면서 높이 자동 조절\n\nwidth vs max-width 차이:\n```css\n/* 문제가 있는 방법 */\nimg { width: 100%; }  /* 항상 부모 크기에 맞춤 (늘어날 수 있음) */\n\n/* 올바른 방법 */\nimg { max-width: 100%; height: auto; }  /* 원본보다 커지지 않음 */\n```\n동작 원리:\n  • 작은 화면: 이미지가 화면에 맞게 축소\n  • 큰 화면: 원본 크기 이상으로 확대되지 않음\n  • 비율 왜곡 없이 자연스럽게 조절",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:13:12.000Z"
    },
    {
      "id": 1431,
      "subject_id": 9,
      "question": "썸네일 이미지에 호버 효과를 주는 CSS 코드에서 빈칸에 들어갈 올바른 속성은?\n```css\nimg {\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  padding: 5px;\n}\n\nimg:hover {\n  _______: 0 0 2px 1px rgba(0, 0, 0, 0.5);\n}\n```",
      "option_a": "border-shadow",
      "option_b": "box-shadow",
      "option_c": "shadow",
      "option_d": "drop-shadow",
      "correct_answer": "B",
      "explanation": "box-shadow 속성의 역할:\n  • 요소 주변에 그림자 효과를 생성\n  • 호버 시 시각적 피드백 제공\n  • 썸네일이 \"떠오르는\" 느낌 연출\n\nbox-shadow 문법:\n```css\nbox-shadow: x축 y축 블러 확산 색상;\nbox-shadow: 0 0 2px 1px rgba(0, 0, 0, 0.5);\n           ↓ ↓  ↓   ↓   ↓\n          x y 블러 확산 색상      \n```\n각 값의 의미:\n  • `0 0`: 그림자 위치 (x, y 오프셋)\n  • `2px`: 블러 정도 (흐림 효과)\n  • `1px`: 확산 거리 (그림자 크기)\n  • `rgba(0, 0, 0, 0.5)`: 반투명 검은색",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:16:06.000Z"
    },
    {
      "id": 1432,
      "subject_id": 9,
      "question": "이미지 투명도를 조절하는 `opacity` 속성의 값 범위와 기본값은 무엇인가요?",
      "option_a": "0-255, 기본값 255",
      "option_b": "0%-100%, 기본값 100%",
      "option_c": "0.0-1.0, 기본값 1.0",
      "option_d": "0-10, 기본값 10",
      "correct_answer": "C",
      "explanation": "opacity 속성 특징:\n  • 값 범위: `0.0` (완전 투명) ~ `1.0` (완전 불투명)\n  • 기본값: `1.0` (불투명)\n  • 소수점 사용 가능\n\n• 실제 사용 예시:\n```css\n/* 완전 투명 */\nimg { opacity: 0; }\n\n/* 반투명 */\nimg { opacity: 0.5; }\n\n/* 살짝 투명 */\nimg { opacity: 0.8; }\n\n/* 완전 불투명 (기본값) */\nimg { opacity: 1.0; }  /* 또는 opacity: 1; */\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:17:24.000Z"
    },
    {
      "id": 1433,
      "subject_id": 9,
      "question": "`margin: auto`를 사용하여 이미지를 가로 중앙 정렬하려고 할 때, 반드시 함께 설정해야 하는 속성은 무엇인가요?",
      "option_a": "`display: inline`",
      "option_b": "`display: block`",
      "option_c": "`position: relative`",
      "option_d": "`float: center`",
      "correct_answer": "B",
      "explanation": "img 요소의 기본 특성:\n  • `<img>`는 기본적으로 인라인 요소(inline element)\n  • 인라인 요소에는 `margin: auto`가 적용되지 않음\n\n해결 방법:\n```css\nimg {\n  display: block;  /* 필수! 블록 요소로 변환 */\n  margin: auto;    /* 가로 중앙 정렬 */\n  width: 50%;      /* 너비 지정 필요 */\n}\n```\n왜 display: block이 필요한가?\n  • 블록 요소만 `margin: auto`로 중앙 정렬 가능\n  • 블록 요소는 전체 너비를 차지하므로 여백을 자동으로 배분\n  • 인라인 요소는 콘텐츠만큼만 공간을 차지",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:22:05.000Z"
    },
    {
      "id": 1434,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n```css\ndiv {\n  display: flex;\n  _______: center;\n}\n\nimg {\n  width: 50%;\n}\n```\n위 코드는 이미지를 가로 중앙에 배치하려고 합니다.",
      "option_a": "align-items",
      "option_b": "justify-content",
      "option_c": "text-align",
      "option_d": "vertical-align",
      "correct_answer": "B",
      "explanation": "Flexbox에서의 정렬 속성:\n  • `justify-content`: 주축(main axis) 방향 정렬 → 가로 정렬\n  • `align-items`: 교차축(cross axis) 방향 정렬 → 세로 정렬",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:23:03.000Z"
    },
    {
      "id": 1435,
      "subject_id": 9,
      "question": "이미지를 가로와 세로 모두 중앙에 배치하려면 다음 중 어떤 CSS 조합이 필요한가요?",
      "option_a": "`justify-content: center; align-items: center;`",
      "option_b": "`text-align: center; vertical-align: middle;`",
      "option_c": "`margin: auto; padding: auto;`",
      "option_d": "`position: center; display: center;`",
      "correct_answer": "A",
      "explanation": "완전한 중앙 정렬을 위한 Flexbox:\n```css\n.container {\n  display: flex;\n  justify-content: center;  /* 가로 중앙 */\n  align-items: center;      /* 세로 중앙 */\n  height: 600px;           /* 높이 지정 필요 */\n}\n\nimg {\n  width: 50%;\n  height: 50%;\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:24:05.000Z"
    },
    {
      "id": 1436,
      "subject_id": 9,
      "question": "다음 두 코드의 차이점을 올바르게 설명한 것은?\n코드 A:\n```css\nimg {\n  display: block;\n  margin: auto;\n  width: 50%;\n}\n```\n코드 B:\n```css\ndiv {\n  display: flex;\n  justify-content: center;\n}\nimg {\n  width: 50%;\n}\n```",
      "option_a": "A는 세로 중앙 정렬도 가능하지만, B는 가로 중앙 정렬만 가능",
      "option_b": "A는 가로 중앙 정렬만 가능하지만, B는 세로 중앙 정렬도 추가할 수 있음",
      "option_c": "A와 B는 완전히 동일한 결과를 보여줌",
      "option_d": "A는 최신 방법이고 B는 구식 방법",
      "correct_answer": "B",
      "explanation": "코드 A의 특징 (`margin: auto` 방식):\n  • 가로 중앙 정렬만 가능\n  • 세로 중앙 정렬은 불가능 (margin auto는 세로 방향에 적용되지 않음)\n  • 단순하고 오래된 방법\n\n코드 B의 특징 (Flexbox 방식):\n  • 가로 중앙 정렬 기본 제공\n  • `align-items: center` 추가로 세로 중앙 정렬도 가능\n  • 더 유연하고 확장 가능",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:25:45.000Z"
    },
    {
      "id": 1437,
      "subject_id": 9,
      "question": "이미지에 흐림 효과를 적용하려면 어떤 CSS 필터 함수를 사용해야 하나요?",
      "option_a": "`filter: fade(5px);`",
      "option_b": "`filter: blur(5px);`",
      "option_c": "`filter: smooth(5px);`",
      "option_d": "`filter: opacity(5px);`",
      "correct_answer": "B",
      "explanation": "blur() 함수의 특징:\n  • 이미지나 요소에 흐림 효과 적용\n  • 픽셀 단위(px)로 흐림 정도 지정\n  • 값이 클수록 더 흐려짐\n\n사용 예시:\n```css\nimg {\n  filter: blur(2px);   /* 약간 흐림 */\n  filter: blur(5px);   /* 보통 흐림 */\n  filter: blur(10px);  /* 많이 흐림 */\n}\n```\n실무 활용:\n  • 배경 이미지에 흐림 효과\n  • 로딩 중인 이미지 placeholder\n  • 포커스 아웃 효과",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:30:30.000Z"
    },
    {
      "id": 1438,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은?\n```css\nimg {\n  filter: brightness(_______);\n}\n```\n위 코드는 이미지를 원본보다 50% 더 밝게 만들려고 합니다.",
      "option_a": "50%",
      "option_b": "150%",
      "option_c": "1.5",
      "option_d": "2번과 3번 모두 정답",
      "correct_answer": "D",
      "explanation": "brightness() 함수의 값 체계:\n  • 100% = 1.0 = 원본 이미지\n  • 50% 더 밝게 = 150% = 1.5",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:31:55.000Z"
    },
    {
      "id": 1439,
      "subject_id": 9,
      "question": "이미지를 흑백으로 만들려면 어떤 필터 함수를 사용해야 하나요?",
      "option_a": "`filter: contrast(0%);`",
      "option_b": "`filter: saturate(0%);`",
      "option_c": "`filter: grayscale(100%);`",
      "option_d": "2번과 3번 모두 정답",
      "correct_answer": "D",
      "explanation": "차이점:\n  • `grayscale()`: 흑백 전용 함수\n  • `saturate(0%)`: 채도 조절의 부수 효과로 흑백\n\ncontrast(0%)와의 차이:\n  • `contrast(0%)`: 대비를 없애서 회색으로 만듦 (흑백과 다름)",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:33:40.000Z"
    },
    {
      "id": 1440,
      "subject_id": 9,
      "question": "이미지를 원형으로 자르기 위해 사용하는 CSS 속성은 무엇인가요?",
      "option_a": "`border-radius`",
      "option_b": "`clip-path`",
      "option_c": "`shape-cut`",
      "option_d": "`image-clip`",
      "correct_answer": "B",
      "explanation": "clip-path vs border-radius:\n  • `clip-path`: 이미지를 실제로 자르는 속성 (영역 밖은 완전히 제거)\n  • `border-radius`: 모서리를 둥글게 만드는 속성 (잘린 부분이 숨겨짐)\n\n기본 사용법:\n```css\n/* clip-path로 원형 자르기 */\nimg {\n  clip-path: circle(50%);\n}\n\n/* border-radius로 원형 만들기 */\nimg {\n  border-radius: 50%;\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:37:04.000Z"
    },
    {
      "id": 1441,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 함수는?\n```css\nimg {\n  clip-path: _______(50%);\n}\n```\n위 코드는 이미지를 완전한 원형으로 자르려고 합니다.",
      "option_a": "round",
      "option_b": "circle",
      "option_c": "circular",
      "option_d": "sphere",
      "correct_answer": "B",
      "explanation": "circle() 함수의 특징:\n  • 원형 클리핑을 위한 전용 함수\n  • 반지름 값을 매개변수로 받음\n  • 50%는 이미지 너비/높이의 절반을 의미\n\n사용 예시:\n```css\n/* 다양한 원형 크기 */\nimg { clip-path: circle(30%); }  /* 작은 원 */\nimg { clip-path: circle(50%); }  /* 전체 원 */\nimg { clip-path: circle(70%); }  /* 큰 원 (이미지 벗어남) */\n```\n위치 지정도 가능:\n```css\nimg { clip-path: circle(50% at center); }  /* 중앙 (기본값) */\nimg { clip-path: circle(50% at right); }   /* 오른쪽 */\nimg { clip-path: circle(50% at left); }    /* 왼쪽 */\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:38:13.000Z"
    },
    {
      "id": 1442,
      "subject_id": 9,
      "question": "타원형 이미지를 만들기 위한 올바른 CSS 코드는?",
      "option_a": "`clip-path: ellipse(50%, 35%);`",
      "option_b": "`clip-path: ellipse(50% 35%);`",
      "option_c": "`clip-path: oval(50% 35%);`",
      "option_d": "`clip-path: ellipse(50% x 35%);`",
      "correct_answer": "B",
      "explanation": "ellipse() 함수의 문법:\n```css\nclip-path: ellipse(x반지름 y반지름);\nclip-path: ellipse(50% 35%);  /* 올바른 문법 */\n```\n매개변수 순서:\n  • 첫 번째 값: 가로(x축) 반지름\n  • 두 번째 값: 세로(y축) 반지름\n  • 공백으로 구분 (쉼표 사용하지 않음)\n\n다양한 타원 예시:\n```css\n/* 가로로 긴 타원 */\nclip-path: ellipse(60% 30%);\n\n/* 세로로 긴 타원 */\nclip-path: ellipse(30% 60%);\n\n/* 위치 지정 */\nclip-path: ellipse(50% 35% at right);\n```\ncircle과의 차이:\n  • `circle(50%)`: 정원 (x = y)\n  • `ellipse(50% 35%)`: 타원 (x ≠ y)",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:39:51.000Z"
    },
    {
      "id": 1443,
      "subject_id": 9,
      "question": "`shape-outside` 속성의 역할은 무엇인가요?",
      "option_a": "이미지의 바깥 테두리 스타일 지정",
      "option_b": "이미지 주변의 텍스트 배치 형태 지정",
      "option_c": "이미지의 그림자 효과 생성",
      "option_d": "이미지 크기 조절",
      "correct_answer": "B",
      "explanation": "shape-outside의 기능:\n  • 플로팅된 요소 주변의 텍스트 흐름을 제어\n  • 이미지 모양에 따라 텍스트가 자연스럽게 감싸도록 함\n\n실제 사용 예시:\n```css\nimg {\n  float: left;\n  clip-path: circle(40%);      /* 이미지를 원형으로 자름 */\n  shape-outside: circle(45%);  /* 텍스트도 원형으로 배치 */\n}\n```\n동작 원리:\n  • `clip-path`: 이미지의 시각적 형태 결정\n  • `shape-outside`: 텍스트가 피해갈 영역 결정\n  • 보통 `shape-outside`가 `clip-path`보다 약간 큼 (여백 효과)\n\n지원하는 함수:\n  • `circle()`, `ellipse()`, `polygon()` 등\n  • `clip-path`와 동일한 함수 사용 가능\n\nfloat와의 관계:\n  • `shape-outside`는 플로팅된 요소에만 적용\n  • `float: left` 또는 `float: right` 필수",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:41:46.000Z"
    },
    {
      "id": 1444,
      "subject_id": 9,
      "question": "`object-fit` 속성의 기본값(default)은 무엇인가요?",
      "option_a": "contain",
      "option_b": "cover",
      "option_c": "fill",
      "option_d": "none",
      "correct_answer": "C",
      "explanation": "object-fit의 기본값은 `fill`입니다\n\n각 값의 기본 특징:\n  • `fill` (기본값): 컨테이너를 완전히 채우되, 필요시 이미지가 늘어나거나 찌그러짐\n  • `contain`: 비율 유지하면서 컨테이너 안에 완전히 들어감\n  • `cover`: 비율 유지하면서 컨테이너를 완전히 채움 (일부 잘릴 수 있음)\n  • `none`: 이미지 크기 변경하지 않음\n\n기본값의 문제점:\n  • 비율(aspect ratio)이 파괴될 수 있음\n  • 이미지가 부자연스럽게 늘어나거나 압축됨\n  • 대부분의 경우 `cover`나 `contain`이 더 적합",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:45:23.000Z"
    },
    {
      "id": 1445,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은?\n```css\nimg {\n  width: 300px;\n  height: 200px;\n  object-fit: _______;\n}\n```\n위 코드는 이미지가 컨테이너를 완전히 채우면서도 원래 비율을 유지하려고 합니다. (일부가 잘려도 괜찮음)",
      "option_a": "fill",
      "option_b": "contain",
      "option_c": "cover",
      "option_d": "none",
      "correct_answer": "C",
      "explanation": "cover의 특징:\n  • 이미지의 원본 비율(aspect ratio) 유지\n  • 컨테이너를 완전히 채움\n  • 비율이 맞지 않으면 이미지의 일부분이 잘릴 수 있음\n\n다른 옵션과의 차이:\n```css\n/* cover: 비율 유지 + 컨테이너 완전히 채움 */\nobject-fit: cover;\n\n/* contain: 비율 유지 + 컨테이너 안에 완전히 들어감 */\nobject-fit: contain;\n\n/* fill: 컨테이너 완전히 채움 + 비율 무시 */\nobject-fit: fill;\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:46:22.000Z"
    },
    {
      "id": 1446,
      "subject_id": 9,
      "question": "`object-fit: contain`과 `object-fit: cover`의 차이점을 올바르게 설명한 것은?",
      "option_a": "contain은 비율을 유지하지 않고, cover는 비율을 유지함",
      "option_b": "contain은 컨테이너를 완전히 채우고, cover는 여백이 생길 수 있음",
      "option_c": "contain은 여백이 생길 수 있고, cover는 이미지가 잘릴 수 있음",
      "option_d": "contain과 cover는 완전히 동일한 결과를 보여줌",
      "correct_answer": "C",
      "explanation": "두 값 모두 이미지 비율을 유지합니다\n\ncontain의 특징:\n  • 이미지가 컨테이너 안에 완전히 들어가도록 조정\n  • 컨테이너보다 이미지가 작아질 수 있음\n  •  여백(빈 공간)이 생길 수 있음\n  • 이미지가 잘리지 않음\n\ncover의 특징:\n  • 이미지가 컨테이너를 완전히 덮도록 조정\n  • 컨테이너보다 이미지가 커질 수 있음\n  • 이미지 일부가 잘릴 수 있음\n  • 여백이 생기지 않음",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:47:35.000Z"
    },
    {
      "id": 1447,
      "subject_id": 9,
      "question": "`object-fit: scale-down`의 동작을 올바르게 설명한 것은?",
      "option_a": "이미지를 항상 확대함",
      "option_b": "이미지를 항상 축소함",
      "option_c": "`none`과 `contain` 중 더 작은 크기를 선택함",
      "option_d": "`fill`과 `cover` 중 더 작은 크기를 선택함",
      "correct_answer": "C",
      "explanation": "scale-down의 동작 원리:\n  • `none`의 결과와 `contain`의 결과를 비교\n  • 두 결과 중 더 작은 크기를 선택\n  • 이미지가 원본보다 커지는 것을 방지\n\n구체적인 동작:\n```css\n/* 원본 이미지가 컨테이너보다 작은 경우 */\nobject-fit: scale-down;  /* = none (원본 크기 유지) */\n\n/* 원본 이미지가 컨테이너보다 큰 경우 */\nobject-fit: scale-down;  /* = contain (축소해서 맞춤) */\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:49:09.000Z"
    },
    {
      "id": 1448,
      "subject_id": 9,
      "question": "`object-position` 속성의 주요 역할은 무엇인가요?",
      "option_a": "이미지의 크기를 조절함",
      "option_b": "이미지가 컨테이너 내에서 어떻게 위치할지 지정함",
      "option_c": "이미지의 투명도를 조절함",
      "option_d": "이미지의 색상을 변경함",
      "correct_answer": "B",
      "explanation": "object-position의 역할:\n  • 이미지나 비디오가 컨테이너 내에서 어느 위치에 표시될지 결정\n  • `object-fit`과 함께 사용되어 이미지의 특정 부분을 보여줄 수 있음\n\n언제 필요한가?\n  • `object-fit: cover`로 이미지가 잘릴 때\n  • 이미지의 중요한 부분을 중앙에 위치시키고 싶을 때\n  • 기본 중앙 정렬이 아닌 다른 위치를 원할 때",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:52:06.000Z"
    },
    {
      "id": 1449,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성명은?\n```css\nimg {\n  width: 300px;\n  height: 200px;\n  object-fit: cover;\n  _______: center top;\n}\n```",
      "option_a": "image-position",
      "option_b": "object-position",
      "option_c": "content-position",
      "option_d": "element-position",
      "correct_answer": "B",
      "explanation": "object-position 문법:\n```css\nobject-position: x축위치 y축위치;\nobject-position: center top;    /* 가로 중앙, 세로 위쪽 */\nobject-position: 50% 0%;        /* 동일한 의미 */\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T19:54:24.000Z"
    },
    {
      "id": 1450,
      "subject_id": 9,
      "question": "`object-position: 0% 0%`과 `object-position: 100% 100%`의 차이점은?",
      "option_a": "0% 0%는 왼쪽 위, 100% 100%는 오른쪽 아래",
      "option_b": "0% 0%는 오른쪽 아래, 100% 100%는 왼쪽 위",
      "option_c": "둘 다 중앙을 의미함",
      "option_d": "둘 다 동일한 결과를 보여줌",
      "correct_answer": "A",
      "explanation": "좌표 시스템 이해:\n  • 0% 0%: 이미지의 왼쪽 위 모서리\n  • 100% 100%: 이미지의 오른쪽 아래 모서리\n  • 50% 50%: 이미지의 정중앙 (기본값)\n\n퍼센트 값의 의미:\n```css\n/* x축 (가로) */\n0% = left,   50% = center,   100% = right\n\n/* y축 (세로) */\n0% = top,    50% = center,   100% = bottom\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:56:31.000Z"
    },
    {
      "id": 1451,
      "subject_id": 9,
      "question": "다음 중 `object-position`이 효과를 발휘하는 상황은?",
      "option_a": "`object-fit: fill`을 사용할 때",
      "option_b": "`object-fit: none`을 사용할 때",
      "option_c": "`object-fit: cover`로 이미지가 잘릴 때",
      "option_d": "이미지 크기를 조절하지 않을 때",
      "correct_answer": "C",
      "explanation": "object-fit: cover (가장 일반적):\n  • 이미지가 컨테이너를 완전히 채우면서 일부가 잘림\n  • `object-position`으로 어느 부분을 보여줄지 조절 가능\n\nobject-fit: none:\n  • 원본 크기 유지로 이미지가 컨테이너보다 클 때\n  • 잘린 부분에서 어느 영역을 보여줄지 조절\n\nobject-fit: fill:\n  • 이미지가 컨테이너에 완전히 맞춰짐\n  • 잘리는 부분이 없어서 위치 조절 의미 없음\n\nobject-fit: contain:\n  • 이미지 전체가 보여짐\n  • 잘리는 부분이 없어서 위치 조절 효과 미미",
      "difficulty": "medium",
      "created_at": "2025-08-10T19:58:21.000Z"
    },
    {
      "id": 1452,
      "subject_id": 9,
      "question": "CSS 마스킹에서 요소의 일부분을 숨기거나 보이게 하는 데 사용되는 주요 속성은 무엇인가요?",
      "option_a": "`mask-layer`",
      "option_b": "`mask-image`",
      "option_c": "`image-mask`",
      "option_d": "`hide-image`",
      "correct_answer": "B",
      "explanation": "mask-image의 역할:\n  • 요소에 적용될 마스크 레이어 이미지를 지정\n  • 마스크를 통해 요소의 특정 부분을 숨기거나 투명하게 만듦\n\n사용 가능한 마스크 타입:\n  • PNG 이미지 (투명/반투명 영역 포함)\n  • SVG 이미지\n  • CSS 그라디언트\n  • SVG `<mask>` 요소\n\n기본 문법:\n```css\n.element {\n  mask-image: url(mask.png);\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T20:02:21.000Z"
    },
    {
      "id": 1453,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n```css\n.logo-mask {\n  -webkit-mask-image: url(logo.png);\n  mask-image: url(logo.png);\n  _______: no-repeat;\n}\n```",
      "option_a": "mask-repeat",
      "option_b": "mask-size",
      "option_c": "mask-position",
      "option_d": "mask-mode",
      "correct_answer": "A",
      "explanation": "mask-repeat 속성:\n  • 마스크 이미지가 반복될지 여부를 결정\n  • `background-repeat`와 유사한 기능\n\n주요 값들:\n```css\nmask-repeat: no-repeat;  /* 반복하지 않음 (한 번만 표시) */\nmask-repeat: repeat;     /* 반복 (기본값) */\nmask-repeat: repeat-x;   /* 가로 방향만 반복 */\nmask-repeat: repeat-y;   /* 세로 방향만 반복 */\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T20:03:31.000Z"
    },
    {
      "id": 1454,
      "subject_id": 9,
      "question": "CSS 그라디언트를 마스크로 사용할 때의 특징은 무엇인가요?",
      "option_a": "그라디언트는 마스크로 사용할 수 없음",
      "option_b": "검은색 부분은 완전 투명, 흰색 부분은 완전 불투명",
      "option_c": "흰색 부분은 완전 투명, 검은색 부분은 완전 불투명",
      "option_d": "색상에 관계없이 모든 부분이 반투명",
      "correct_answer": "B",
      "explanation": "마스크에서의 색상 규칙:\n  • 검은색 (black): 완전 투명 (요소가 숨겨짐)\n  • 흰색 (white): 완전 불투명 (요소가 보임)\n  • 회색/반투명: 부분적으로 투명\n\n그라디언트 마스크 예시:\n```css\n/* 위에서 아래로 페이드 아웃 */\n.fade-out {\n  mask-image: linear-gradient(black, transparent);\n}\n\n/* 원형 페이드 */\n.circle-fade {\n  mask-image: radial-gradient(circle, black 50%, transparent 50%);\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T20:04:43.000Z"
    },
    {
      "id": 1455,
      "subject_id": 9,
      "question": "다음 중 SVG를 마스크로 사용할 때의 장점이 아닌 것은?",
      "option_a": "복잡한 모양의 마스크 생성 가능",
      "option_b": "확대해도 깨지지 않는 벡터 기반",
      "option_c": "파일 크기가 항상 PNG보다 작음",
      "option_d": "프로그래밍적으로 모양 제어 가능",
      "correct_answer": "C",
      "explanation": "SVG 마스크의 실제 장점:\n\n복잡한 모양 생성:\n  • 삼각형, 별, 다각형 등 자유로운 형태\n  • 수학적 정확성\n\n벡터 기반:\n  • 해상도에 무관하게 선명함\n  • 반응형 디자인에 적합\n\n프로그래밍 제어:\n  • JavaScript로 동적 변경 가능\n  • CSS 애니메이션 적용 가능",
      "difficulty": "medium",
      "created_at": "2025-08-10T20:06:46.000Z"
    },
    {
      "id": 1456,
      "subject_id": 9,
      "question": "버튼에 호버 효과를 부드럽게 만들기 위해 함께 사용하는 속성은?\n```css\n.button {\n  background-color: #04AA6D;\n  _______: 0.4s;\n}\n\n.button:hover {\n  background-color: #45a049;\n}\n```",
      "option_a": "animation-duration",
      "option_b": "transition-duration",
      "option_c": "hover-duration",
      "option_d": "delay-duration",
      "correct_answer": "B",
      "explanation": "transition-duration의 역할:\n  • CSS 속성 변화가 일어나는 시간을 지정\n  • 호버 효과를 부드럽게 만들어 사용자 경험 향상\n\n전체 호버 효과 구현:\n```css\n.button {\n  background-color: #04AA6D;\n  transition-duration: 0.4s;     /* 부드러운 전환 */\n  /* 또는 transition: all 0.4s; */\n}\n\n.button:hover {\n  background-color: #45a049;     /* 호버시 색상 변경 */\n  transform: translateY(-2px);   /* 살짝 위로 이동 */\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T20:10:12.000Z"
    },
    {
      "id": 1457,
      "subject_id": 9,
      "question": "기본 페이지네이션에서 링크들을 가로로 나란히 배치하기 위해 사용하는 CSS 속성은?\n```css\n.pagination a {\n  color: black;\n  _______: left;\n  padding: 8px 16px;\n  text-decoration: none;\n}\n```",
      "option_a": "display",
      "option_b": "float",
      "option_c": "position",
      "option_d": "align",
      "correct_answer": "B",
      "explanation": "float: left의 역할:\n  • 요소들을 가로로 나란히 배치\n  • 페이지네이션의 기본 레이아웃 구성에 필수\n\n페이지네이션 기본 구조:\n```css\n.pagination {\n  display: inline-block;  /* 컨테이너 */\n}\n\n.pagination a {\n  float: left;           /* 가로 배치 */\n  padding: 8px 16px;     /* 클릭 영역 확보 */\n  text-decoration: none; /* 밑줄 제거 */\n}\n```\n현대적 대안:\n```css\n.pagination {\n  display: flex;  /* Flexbox 사용 */\n}\n\n.pagination a {\n  /* float 불필요 */\n  padding: 8px 16px;\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T20:13:29.000Z"
    },
    {
      "id": 1458,
      "subject_id": 9,
      "question": "현재 활성화된 페이지를 시각적으로 구분하기 위해 사용하는 CSS 클래스명은?",
      "option_a": "`.current`",
      "option_b": "`.selected`",
      "option_c": "`.active`",
      "option_d": "`.on`",
      "correct_answer": "C",
      "explanation": "active 클래스의 표준 사용:\n  • 현재 선택된 상태를 나타내는 일반적인 클래스명\n  • 웹 개발에서 널리 사용되는 컨벤션\n\n활성 페이지 스타일링:\n```css\n.pagination a.active {\n  background-color: #4CAF50;  /* 강조 배경색 */\n  color: white;              /* 텍스트 색상 */\n}\n\n/* 비활성 페이지 호버 효과 */\n.pagination a:hover:not(.active) {\n  background-color: #ddd;    /* 호버시에만 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T20:15:15.000Z"
    },
    {
      "id": 1459,
      "subject_id": 9,
      "question": "텍스트를 3개의 컬럼으로 나누기 위해 사용하는 CSS 속성과 값은?\n```css\ndiv {\n  _______: 3;\n}\n```",
      "option_a": "column-number",
      "option_b": "column-count",
      "option_c": "columns",
      "option_d": "text-columns",
      "correct_answer": "B",
      "explanation": "column-count의 역할:\n  • 요소의 콘텐츠를 지정된 수의 컬럼으로 자동 분할\n  • 신문이나 잡지 스타일의 레이아웃 구현\n\n자동 분할 특징:\n  • 브라우저가 자동으로 텍스트를 균등하게 배분\n  • 컨테이너 높이에 따라 컬럼 높이 조정\n  • 반응형으로 동작 (화면 크기에 따라 조정)",
      "difficulty": "easy",
      "created_at": "2025-08-10T20:18:59.000Z"
    },
    {
      "id": 1460,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성은?\n```css\ndiv {\n  column-count: 3;\n  _______: 40px;\n}\n```\n위 코드는 컬럼 사이의 간격을 40px로 설정하려고 합니다.",
      "option_a": "column-space",
      "option_b": "column-gap",
      "option_c": "column-margin",
      "option_d": "column-padding",
      "correct_answer": "B",
      "explanation": "column-gap의 기능:\n  • 컬럼과 컬럼 사이의 간격(여백)을 설정\n  • 가독성 향상과 시각적 분리 효과\n\n다양한 단위 사용 가능:\n```css\n.article {\n  column-count: 3;\n  column-gap: 40px;     /* 픽셀 */\n  column-gap: 2em;      /* em 단위 */\n  column-gap: 5%;       /* 퍼센트 */\n  column-gap: normal;   /* 브라우저 기본값 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T20:21:01.000Z"
    },
    {
      "id": 1461,
      "subject_id": 9,
      "question": "제목이 모든 컬럼에 걸쳐 표시되도록 하는 CSS는?\n```css\nh2 {\n  _______: all;\n}\n```",
      "option_a": "column-width",
      "option_b": "column-span",
      "option_c": "column-stretch",
      "option_d": "column-full",
      "correct_answer": "B",
      "explanation": "column-span의 용도:\n  • 특정 요소가 여러 컬럼에 걸쳐 표시되도록 설정\n  • 제목, 이미지, 인용구 등에 주로 사용\n\ncolumn-span 값:\n```css\n/* 모든 컬럼에 걸쳐 표시 */\nh2 {\n  column-span: all;\n}\n\n/* 기본값 (한 컬럼만 차지) */\np {\n  column-span: none;\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T20:22:51.000Z"
    },
    {
      "id": 1462,
      "subject_id": 9,
      "question": "사용자가 요소의 크기를 조절할 수 있게 하는 CSS 속성은 무엇인가요?",
      "option_a": "`resizable`",
      "option_b": "`resize`",
      "option_c": "`resizer`",
      "option_d": "`user-resize`",
      "correct_answer": "B",
      "explanation": "resize 속성의 역할:\n  • 사용자가 마우스로 요소의 크기를 직접 조절할 수 있게 함\n  • 브라우저가 제공하는 네이티브 리사이징 핸들 활성화\n\n기본 문법:\n```css\ndiv {\n  resize: both;      /* 가로, 세로 모두 조절 가능 */\n  overflow: auto;    /* resize 작동을 위해 필수 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T20:26:20.000Z"
    },
    {
      "id": 1463,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 값은?\n```css\ndiv {\n  resize: _______;\n  overflow: auto;\n}\n```\n위 코드는 사용자가 세로 방향으로만 크기를 조절할 수 있게 하려고 합니다.",
      "option_a": "height",
      "option_b": "vertical",
      "option_c": "y-axis",
      "option_d": "up-down",
      "correct_answer": "B",
      "explanation": "resize 속성의 주요 값들:\n\nvertical:\n  • 세로 방향으로만 크기 조절 가능\n  • 높이만 변경, 너비는 고정\n\nhorizontal:\n  • 가로 방향으로만 크기 조절 가능\n  • 너비만 변경, 높이는 고정\n\nboth:\n  • 가로, 세로 모두 조절 가능 (기본값)\n\nnone:\n  • 크기 조절 비활성화",
      "difficulty": "easy",
      "created_at": "2025-08-10T20:27:28.000Z"
    },
    {
      "id": 1464,
      "subject_id": 9,
      "question": "`resize` 속성이 제대로 작동하기 위해 반드시 함께 설정해야 하는 속성은?",
      "option_a": "`position: relative`",
      "option_b": "`display: block`",
      "option_c": "`overflow: auto` (또는 visible이 아닌 값)",
      "option_d": "`width: 100%`",
      "correct_answer": "C",
      "explanation": "resize 작동 조건:\n  • `overflow` 속성이 `visible`이 아닌 값이어야 함\n  • 이는 CSS 명세의 기술적 요구사항\n\n올바른 overflow 값들:\n```css\ndiv {\n  resize: both;\n  overflow: auto;     /* 추천 */\n  overflow: hidden;   /* 작동함 */\n  overflow: scroll;   /* 작동함 */\n  overflow: visible;  /* 작동하지 않음! */\n}\n```",
      "difficulty": "medium",
      "created_at": "2025-08-10T20:28:41.000Z"
    },
    {
      "id": 1465,
      "subject_id": 9,
      "question": "`outline`과 `border`의 차이점으로 올바른 것은?",
      "option_a": "outline은 요소의 크기에 포함되지만, border는 포함되지 않음",
      "option_b": "outline은 요소 외부에 그려지고 크기에 영향을 주지 않음",
      "option_c": "outline과 border는 완전히 동일한 기능을 함",
      "option_d": "outline은 색상을 지정할 수 없지만, border는 가능함",
      "correct_answer": "B",
      "explanation": "outline vs border 주요 차이점:\n\noutline 특징:\n  • 요소의 외부에 그려짐\n  • 요소의 크기(width/height)에 영향을 주지 않음\n  • 다른 요소와 겹칠 수 있음\n  • 레이아웃에 영향 없음\n\nborder 특징:\n  • 요소의 일부로 포함됨\n  • 요소의 크기에 포함됨\n  • 레이아웃에 영향을 줌\n  • 다른 요소를 밀어냄",
      "difficulty": "medium",
      "created_at": "2025-08-10T20:29:58.000Z"
    },
    {
      "id": 1466,
      "subject_id": 9,
      "question": "CSS 변수를 정의할 때 변수 이름 앞에 반드시 붙여야 하는 기호는 무엇인가요?",
      "option_a": "` `",
      "option_b": "`$`",
      "option_c": "`--`",
      "option_d": "`@`",
      "correct_answer": "C",
      "explanation": "• CSS 변수 이름은 반드시 두 개의 대시(--)로 시작해야 합니다\n• 예시: `--blue`, `--main-color`, `--font-size` 등\n• 이는 CSS 표준에서 정한 규칙이며, 변수와 일반 CSS 속성을 구분하기 위함입니다\n• 변수명은 대소문자를 구분하므로 `--Blue`와 `--blue`는 서로 다른 변수입니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T20:38:40.000Z"
    },
    {
      "id": 1467,
      "subject_id": 9,
      "question": "CSS 변수의 값을 사용하기 위해 호출하는 함수는 무엇인가요?",
      "option_a": "get()",
      "option_b": "use()",
      "option_c": "var()",
      "option_d": "value()",
      "correct_answer": "C",
      "explanation": "• CSS 변수의 값을 가져올 때는 `var()` 함수를 사용합니다\n• 기본 문법: `var(--변수명)`\n• 예시: `color: var(--main-color);`\n• `var()` 함수 안에 변수명을 넣으면 해당 변수에 저장된 값이 적용됩니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T20:39:47.000Z"
    },
    {
      "id": 1468,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 CSS 선택자는?\n```css\n_______ {\n    --primary-color: #1e90ff;\n    --secondary-color: #ffffff;\n}\n\nbody {\n    background-color: var(--primary-color);\n}\n```",
      "option_a": "html",
      "option_b": ":root",
      "option_c": "•",
      "option_d": "body",
      "correct_answer": "B",
      "explanation": "• `:root` 선택자는 문서의 최상위 요소(루트 요소)를 선택합니다\n• 전역 변수를 정의할 때 `:root` 선택자를 사용하면 문서 전체에서 해당 변수를 사용할 수 있습니다\n• `:root` 안에 선언된 변수는 모든 하위 요소에서 접근 가능합니다\n• 지역 변수를 만들려면 특정 선택자 안에 변수를 선언하면 됩니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T21:04:25.000Z"
    },
    {
      "id": 1469,
      "subject_id": 9,
      "question": "다음 코드에서 `var()` 함수의 두 번째 매개변수의 역할은 무엇인가요?\n```css\n.button {\n    background-color: var(--button-bg, #cccccc);\n    color: var(--button-text, black);\n}\n```",
      "option_a": "변수의 기본값 설정",
      "option_b": "변수가 없을 때의 대체값(fallback value)",
      "option_c": "변수의 데이터 타입 지정",
      "option_d": "변수의 우선순위 설정",
      "correct_answer": "B",
      "explanation": "• `var()` 함수의 두 번째 매개변수는 fallback value(대체값)입니다\n• 문법: `var(--변수명, 대체값)`\n• 지정한 변수가 정의되지 않았거나 찾을 수 없을 때 대체값이 사용됩니다\n• 위 예시에서 `--button-bg` 변수가 없으면 `#cccccc`가, `--button-text`가 없으면 `black`이 적용됩니다\n• 대체값은 선택사항이므로 생략 가능하지만, 안정성을 위해 제공하는 것이 좋습니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T21:08:32.000Z"
    },
    {
      "id": 1470,
      "subject_id": 9,
      "question": "다음 코드에서 button 요소의 color 값으로 어떤 색이 적용될까요?\n```css\n:root {\n    --blue: #1e90ff;\n}\n\nbutton {\n    --blue: #0000ff;\n    color: var(--blue);\n}\n```",
      "option_a": "`#1e90ff` (하늘색)",
      "option_b": "`#0000ff` (진한 파란색)",
      "option_c": "기본 텍스트 색상",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "• 지역 변수가 전역 변수를 재정의(override)합니다\n• `button` 선택자 안에서 `--blue` 변수를 다시 정의했기 때문에 지역 값이 우선 적용됩니다\n• CSS 변수의 우선순위: 지역 변수 > 전역 변수\n• 이는 CSS의 캐스케이딩(cascading) 원칙과 동일합니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:12:46.000Z"
    },
    {
      "id": 1471,
      "subject_id": 9,
      "question": "CSS Variables를 Media Query 안에서 사용하는 주요 목적은 무엇인가요?",
      "option_a": "변수를 삭제하기 위해",
      "option_b": "다양한 화면 크기에 따라 변수 값을 변경하기 위해",
      "option_c": "변수의 성능을 향상시키기 위해",
      "option_d": "변수를 전역에서 지역으로 변환하기 위해",
      "correct_answer": "B",
      "explanation": "• Media Query는 화면 크기, 디바이스 종류 등에 따라 다른 스타일을 적용하는 CSS 기능입니다\n• CSS Variables를 Media Query와 함께 사용하면 반응형 디자인을 더 효율적으로 구현할 수 있습니다\n• 예시: 모바일에서는 작은 폰트 크기, 데스크톱에서는 큰 폰트 크기 적용\n• 변수 하나만 변경하면 해당 변수를 사용하는 모든 속성이 자동으로 업데이트됩니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:15:21.000Z"
    },
    {
      "id": 1472,
      "subject_id": 9,
      "question": "다음 Media Query 코드에서 빈칸에 들어갈 올바른 문법은?\n```css\n.container {\n    --font-size: 16px;\n    font-size: var(--font-size);\n}\n\n_______ screen and (min-width: 768px) {\n    .container {\n        --font-size: 24px;\n    }\n}\n```",
      "option_a": "@responsive",
      "option_b": "@media",
      "option_c": "@query",
      "option_d": "@breakpoint",
      "correct_answer": "B",
      "explanation": "• Media Query를 작성할 때는 `@media` 키워드를 사용합니다\n• 기본 문법: `@media 미디어타입 and (조건) { 스타일 규칙 }`\n• `screen`은 미디어 타입으로 화면을 의미합니다\n• `(min-width: 768px)`는 화면 너비가 768px 이상일 때를 의미합니다\n• Media Query 안에서 변수를 재정의하면 해당 조건에서만 새로운 값이 적용됩니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:16:16.000Z"
    },
    {
      "id": 1473,
      "subject_id": 9,
      "question": "CSS `@property` 규칙의 주요 목적은 무엇인가요?",
      "option_a": "CSS 애니메이션을 만들기 위해",
      "option_b": "사용자 정의 CSS 속성을 정의하고 타입 검사를 제공하기 위해",
      "option_c": "JavaScript 없이 DOM을 조작하기 위해",
      "option_d": "CSS 파일 크기를 줄이기 위해",
      "correct_answer": "B",
      "explanation": "• `@property` 규칙은 사용자 정의 CSS 속성(CSS Variables)을 더 안전하게 정의하는 방법입니다\n\n• 주요 기능들:\n  • 타입 검사: 속성의 데이터 타입을 명시 (`<color>`, `<number>`, `<length>` 등)\n  • 기본값 설정: `initial-value`로 초기값 지정\n  • 상속 동작 제어: `inherits` 속성으로 부모 요소로부터 값을 상속받을지 결정\n\n• 기존 CSS Variables(`--변수명`)보다 더 엄격하고 안전한 변수 시스템을 제공합니다\n\n• JavaScript 없이도 스타일시트에서 직접 정의할 수 있습니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:20:39.000Z"
    },
    {
      "id": 1474,
      "subject_id": 9,
      "question": "다음 @property 규칙에서 빈칸에 들어갈 올바른 속성명들은?\n```css\n@property --main-color {\n    _______: \"<color>\";\n    _______: true;\n    _______: blue;\n}\n```",
      "option_a": "type, inherit, default",
      "option_b": "syntax, inherits, initial-value",
      "option_c": "datatype, inheritance, value",
      "option_d": "format, extends, fallback",
      "correct_answer": "B",
      "explanation": "• `syntax`: 속성의 데이터 타입을 정의합니다\n  • `\"<color>\"`: 색상 값만 허용\n  • `\"<number>\"`: 숫자 값만 허용\n  • `\"<length>\"`: 길이 값만 허용 등\n\n• `inherits`: 부모 요소로부터 값을 상속받을지 결정합니다\n  • `true`: 상속받음 (부모에서 설정한 값을 자식이 사용)\n  • `false`: 상속받지 않음 (각 요소마다 독립적으로 값 설정)\n\n• `initial-value`: 기본값을 설정합니다\n  • 변수가 설정되지 않았거나 잘못된 값이 할당되었을 때 사용될 값\n  • 타입 검사에 실패한 경우의 fallback 값 역할",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:22:07.000Z"
    },
    {
      "id": 1475,
      "subject_id": 9,
      "question": "다음 코드에서 `.error` 클래스가 적용된 요소의 배경색은 무엇인가요?\n```css\n@property --bg-color {\n    syntax: \"<color>\";\n    inherits: true;\n    initial-value: white;\n}\n\n.container {\n    --bg-color: lightblue;\n    background-color: var(--bg-color);\n}\n\n.error {\n    --bg-color: 123;\n    background-color: var(--bg-color);\n}\n```",
      "option_a": "lightblue",
      "option_b": "white",
      "option_c": "123 (그대로 적용)",
      "option_d": "에러 발생",
      "correct_answer": "B",
      "explanation": "• 타입 검사 실패 시 동작:\n  • `--bg-color`는 `syntax: \"<color>\"`로 정의되어 색상 값만 허용합니다\n  • `.error`에서 `--bg-color: 123`을 설정했지만, 123은 유효한 색상 값이 아닙니다\n  • 타입 검사에 실패하면 `initial-value`에서 정의한 기본값 `white`가 사용됩니다\n\n• @property의 장점:\n  • 잘못된 값이 할당되어도 브라우저가 자동으로 안전한 기본값을 사용\n  • 런타임 에러 대신 graceful fallback 제공\n  • 개발자 실수로 인한 레이아웃 깨짐 방지\n\n• 일반 CSS Variables와의 차이:\n  • 일반 변수: 잘못된 값이라도 그대로 사용하여 스타일이 적용되지 않음\n  • `@property`: 타입 검사 후 안전한 기본값 제공",
      "difficulty": "medium",
      "created_at": "2025-08-10T21:24:20.000Z"
    },
    {
      "id": 1476,
      "subject_id": 9,
      "question": "CSS에서 기본적으로 요소의 실제 너비는 어떻게 계산되나요?",
      "option_a": "width만",
      "option_b": "width + margin",
      "option_c": "width + padding + border",
      "option_d": "width + padding + border + margin",
      "correct_answer": "C",
      "explanation": "• 기본 박스 모델 계산법:\n  • 실제 너비 = `width` + `padding` + `border`\n  • 실제 높이 = `height` + `padding` + `border`\n  • `margin`은 요소 간의 간격이므로 요소 자체의 크기에는 포함되지 않습니다\n\n• 문제가 되는 상황:\n  • `width: 300px`로 설정해도 padding과 border가 추가되어 실제로는 더 큰 크기가 됩니다\n  • 레이아웃을 계획할 때 예상보다 요소가 커져서 디자인이 깨질 수 있습니다\n\n• 예시:\n```css\n.box {\n    width: 200px;\n    padding: 20px;\n    border: 5px solid black;\n    /* 실제 너비: 200px + 40px + 10px = 250px */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:27:58.000Z"
    },
    {
      "id": 1477,
      "subject_id": 9,
      "question": "다음 코드에서 빈칸에 들어갈 올바른 속성값은?\n```css\n.container {\n    width: 300px;\n    padding: 20px;\n    border: 2px solid black;\n    box-sizing: ________;\n}\n```\npadding과 border를 포함하여 전체 너비가 정확히 300px가 되도록 하려면?",
      "option_a": "content-box",
      "option_b": "border-box",
      "option_c": "padding-box",
      "option_d": "margin-box",
      "correct_answer": "B",
      "explanation": "`box-sizing` 속성의 값들:\n  • `content-box` (기본값): padding과 border가 width에 추가됨\n  • `border-box`: padding과 border가 width에 포함됨\n  • `padding-box`, `margin-box`는 표준이 아니거나 지원되지 않는 값입니다\n\n`border-box` 사용 시:\n  • 설정한 `width: 300px`가 padding과 border를 포함한 전체 너비가 됩니다\n  • 내용 영역의 실제 너비 = 300px - 40px(padding) - 4px(border) = 256px\n  • 전체 요소의 너비는 정확히 300px가 됩니다",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:29:31.000Z"
    },
    {
      "id": 1478,
      "subject_id": 9,
      "question": "다음 코드에서 .container 안에 .item 요소 3개가 나란히 배치되도록 하려면 빈칸에 무엇이 들어가야 할까요?\n```css\n.container {\n    width: 600px;\n}\n\n.item {\n    width: ____%;\n    padding: 10px;\n    border: 2px solid black;\n    box-sizing: _____;\n    float: left;\n}\n```",
      "option_a": "33.33, content-box",
      "option_b": "33.33, border-box",
      "option_c": "30, content-box",
      "option_d": "30, border-box",
      "correct_answer": "B",
      "explanation": "문제 상황 분석:\n  • 3개 요소를 나란히 배치하려면 각각 33.33% 너비가 필요합니다\n  • 각 `.item`에는 padding과 border가 있습니다\n\n`content-box`를 사용할 경우:\n  • `width: 33.33%` + padding + border > 33.33%\n  • 실제 너비가 33.33%를 초과하여 3개가 한 줄에 들어가지 못합니다\n  • 마지막 요소가 다음 줄로 밀려납니다\n\n`border-box`를 사용할 경우:\n  • `width: 33.33%`가 padding과 border를 포함한 전체 너비\n  • 정확히 33.33% × 3 = 100%가 되어 3개가 완벽하게 나란히 배치됩니다\n\n실무 팁:\n  • 그리드나 flexbox 레이아웃에서 `border-box`는 필수적입니다\n  • 반응형 디자인에서 예측 가능한 크기 제어가 가능합니다",
      "difficulty": "medium",
      "created_at": "2025-08-10T21:31:13.000Z"
    },
    {
      "id": 1479,
      "subject_id": 9,
      "question": "CSS에서 미디어 쿼리의 주요 목적은 무엇인가요?",
      "option_a": "웹사이트의 로딩 속도를 향상시키기 위해",
      "option_b": "다양한 기기의 특성에 맞는 스타일을 제공하기 위해",
      "option_c": "JavaScript 코드를 최적화하기 위해",
      "option_d": "웹사이트의 보안을 강화하기 위해",
      "correct_answer": "B",
      "explanation": "• 미디어 쿼리의 핵심 목적: 다양한 디바이스의 특성(화면 크기, 해상도, 방향 등)에 따라 적절한 스타일을 제공하는 것입니다.\n• 반응형 웹 디자인: 데스크톱, 태블릿, 스마트폰 등 각 기기에 맞춤형 레이아웃과 스타일을 적용할 수 있습니다.\n• CSS2에서 CSS3로의 발전: CSS2의 미디어 타입 개념을 확장하여 기기의 능력(capability)을 기반으로 스타일을 선택하게 되었습니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:33:35.000Z"
    },
    {
      "id": 1480,
      "subject_id": 9,
      "question": "다음 중 CSS 미디어 타입이 아닌 것은?",
      "option_a": "all",
      "option_b": "print",
      "option_c": "screen",
      "option_d": "mobile",
      "correct_answer": "D",
      "explanation": "• 표준 미디어 타입:\n  • `all`: 모든 미디어 기기에 적용\n  • `print`: 인쇄 미리보기 모드에 사용\n  • `screen`: 컴퓨터 화면, 태블릿, 스마트폰 등에 사용\n\n• mobile은 표준 미디어 타입이 아님: CSS3 미디어 쿼리에서는 기기 유형보다는 기기의 특성(화면 크기, 해상도 등)을 기준으로 분류합니다.\n\n• 실제 사용: 모바일 기기는 `screen` 타입을 사용하고, `min-width`, `max-width` 등의 특성으로 구분합니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:34:48.000Z"
    },
    {
      "id": 1481,
      "subject_id": 9,
      "question": "다음 코드의 빈칸에 들어갈 올바른 구문은?\n```css\n@media _______ and (min-width: 768px) {\n    .container {\n        width: 1200px;\n    }\n}\n```",
      "option_a": "only",
      "option_b": "screen",
      "option_c": "not",
      "option_d": "print",
      "correct_answer": "B",
      "explanation": "• 미디어 타입 지정: `screen`은 컴퓨터 화면, 태블릿, 스마트폰 등의 디스플레이 기기를 대상으로 합니다.\n\n• 논리적 구조:\n  • `@media screen`: 화면 기기에서\n  • `and (min-width: 768px)`: 최소 너비가 768px 이상일 때\n  • 두 조건이 모두 참이면 스타일 적용\n\n• 다른 선택지 분석:\n  • `only`: 구형 브라우저 호환성을 위한 키워드로, 미디어 타입과 함께 사용\n  • `not`: 전체 미디어 쿼리의 결과를 반전\n  • `print`: 인쇄용 스타일에 사용",
      "difficulty": "medium",
      "created_at": "2025-08-10T21:36:37.000Z"
    },
    {
      "id": 1482,
      "subject_id": 9,
      "question": "다음 코드의 동작을 올바르게 설명한 것은?\n```css\n@media screen and (min-width: 480px) {\n    #leftsidebar {\n        width: 200px;\n        float: left;\n    }\n    #main {\n        margin-left: 216px;\n    }\n}\n```",
      "option_a": "화면 너비가 480px 미만일 때만 사이드바가 왼쪽에 배치됩니다",
      "option_b": "화면 너비가 480px 이상일 때 사이드바가 왼쪽에 배치되고 메인 콘텐츠에 여백이 생깁니다",
      "option_c": "모든 화면 크기에서 사이드바가 200px 너비로 고정됩니다",
      "option_d": "인쇄할 때만 이 스타일이 적용됩니다",
      "correct_answer": "B",
      "explanation": "• 조건부 스타일 적용: `min-width: 480px` 조건으로 화면 너비가 480px 이상일 때만 이 스타일이 활성화됩니다.\n\n• 레이아웃 구조:\n  • `#leftsidebar`: 200px 너비로 왼쪽에 float 배치\n  • `#main`: 216px의 왼쪽 마진 (사이드바 200px + 여백 16px)\n\n• 반응형 동작:\n  • 480px 이상: 사이드바가 왼쪽, 메인 콘텐츠가 오른쪽\n  • 480px 미만: 이 스타일이 적용되지 않아 다른 레이아웃 적용",
      "difficulty": "medium",
      "created_at": "2025-08-10T21:38:08.000Z"
    },
    {
      "id": 1483,
      "subject_id": 9,
      "question": "반응형 네비게이션 메뉴에서 모바일 화면(600px 이하)일 때 메뉴 링크들을 세로로 배열하려면 빈칸에 무엇을 입력해야 할까요?\n```css\n.topnav a {\n    float: left;\n    display: block;\n    color: white;\n    padding: 14px 16px;\n}\n\n@media screen and (max-width: 600px) {\n    .topnav a {\n        float: _______;\n        width: 100%;\n    }\n}\n```",
      "option_a": "left",
      "option_b": "right",
      "option_c": "none",
      "option_d": "center",
      "correct_answer": "C",
      "explanation": "• float 속성의 역할:\n  • `float: left`: 요소를 왼쪽으로 띄워서 가로 배열\n  • `float: none`: float를 해제하여 기본 블록 레이아웃으로 복귀\n\n• 반응형 메뉴 패턴:\n  • 데스크톱: `float: left`로 메뉴들이 가로 한 줄에 배치\n  • 모바일: `float: none` + `width: 100%`로 메뉴들이 세로로 쌓임\n\n• width: 100%의 역할: 각 메뉴 링크가 화면 전체 너비를 차지하여 터치하기 쉬운 큰 버튼 형태가 됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:41:41.000Z"
    },
    {
      "id": 1484,
      "subject_id": 9,
      "question": "다음 복합 미디어 쿼리에서 스타일이 적용되는 화면 너비 범위를 올바르게 나타낸 것은?\n```css\n@media screen and (max-width: 900px) and (min-width: 600px), (min-width: 1100px) {\n    div.example {\n        font-size: 50px;\n        background: yellow;\n    }\n}\n```",
      "option_a": "600px 이상 900px 이하",
      "option_b": "1100px 이상",
      "option_c": "600px 이상 900px 이하 또는 1100px 이상",
      "option_d": "600px 이상 1100px 이하",
      "correct_answer": "C",
      "explanation": "• 쉼표(,)의 의미: 미디어 쿼리에서 쉼표는 OR 연산자 역할을 합니다. 즉, 여러 조건 중 하나만 만족하면 스타일이 적용됩니다.\n\n• 조건 분석:\n  • 첫 번째 조건: `(max-width: 900px) and (min-width: 600px)` → 600px ≤ 화면 너비 ≤ 900px\n  • 두 번째 조건: `(min-width: 1100px)` → 화면 너비 ≥ 1100px\n\n• 전체 적용 범위:\n  • 600px ~ 900px 범위 (태블릿)\n  • 또는 1100px 이상 (대형 데스크톱)\n  • 900px ~ 1100px 범위는 제외 (일반 데스크톱)",
      "difficulty": "hard",
      "created_at": "2025-08-10T21:43:44.000Z"
    },
    {
      "id": 1485,
      "subject_id": 9,
      "question": "CSS Flexbox의 주요 목적은 무엇인가요?",
      "option_a": "웹사이트의 로딩 속도를 향상시키기 위해",
      "option_b": "float나 positioning 없이 유연한 반응형 레이아웃을 만들기 위해",
      "option_c": "웹사이트의 보안을 강화하기 위해",
      "option_d": "데이터베이스와 연결하기 위해",
      "correct_answer": "B",
      "explanation": "• Flexbox의 핵심 목적: float나 positioning 같은 복잡한 방법을 사용하지 않고도 유연하고 반응형인 레이아웃을 쉽게 만들 수 있게 해줍니다.\n\n• 기존 방법의 한계:\n  • `float`: 원래 텍스트 회전용으로 설계되어 레이아웃에 사용하면 복잡함\n  • `positioning`: 절대/상대 위치 지정으로 반응형 디자인에 부적합",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:46:26.000Z"
    },
    {
      "id": 1486,
      "subject_id": 9,
      "question": "Flexbox를 사용해야 하는 상황과 CSS Grid를 사용해야 하는 상황을 올바르게 구분한 것은?",
      "option_a": "Flexbox: 2차원 레이아웃, Grid: 1차원 레이아웃",
      "option_b": "Flexbox: 1차원 레이아웃(행 또는 열), Grid: 2차원 레이아웃(행과 열)",
      "option_c": "Flexbox: 테이블 데이터용, Grid: 텍스트용",
      "option_d": "Flexbox: 모바일용, Grid: 데스크톱용",
      "correct_answer": "B",
      "explanation": "Flexbox (1차원 레이아웃):\n  • 행 OR 열 중 하나의 방향으로만 요소 배치\n  • 네비게이션 메뉴, 버튼 그룹, 카드 한 줄 배치 등\n  • 주축(main axis) 하나를 기준으로 요소들을 정렬\n\nCSS Grid (2차원 레이아웃):\n  • 행 AND 열 동시에 요소 배치\n  • 복잡한 페이지 레이아웃, 갤러리, 대시보드 등\n  • 격자 형태로 요소들을 배치\n\n선택 기준:\n  • 한 방향으로만 배치 → Flexbox\n  • 격자 형태로 배치 → Grid\n  • 간단한 정렬 → Flexbox\n  • 복잡한 레이아웃 → Grid\n\n실제 예시:\n  • Flexbox: 헤더의 로고-메뉴-버튼 배치\n  • Grid: 신문 레이아웃 같은 복합적 구조",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:48:09.000Z"
    },
    {
      "id": 1487,
      "subject_id": 9,
      "question": "Flexbox의 구성 요소를 올바르게 설명한 것은?",
      "option_a": "Flex Container: 자식 요소들, Flex Items: 부모 요소",
      "option_b": "Flex Container: 부모 요소, Flex Items: 자식 요소들",
      "option_c": "Flex Container: 형제 요소들, Flex Items: 부모 요소",
      "option_d": "Flex Container와 Flex Items는 같은 요소를 가리킴",
      "correct_answer": "B",
      "explanation": "• Flex Container (플렉스 컨테이너):\n  • 부모 요소: `display: flex`가 적용된 요소\n  • 내부의 자식 요소들을 flexbox 방식으로 배치하는 컨테이너 역할\n  • 플렉스 속성들을 제어하는 주체\n\n• Flex Items (플렉스 아이템):\n  • 자식 요소들: 플렉스 컨테이너 안에 있는 직접적인 자식 요소들\n  • 플렉스 컨테이너의 규칙에 따라 배치되는 요소들\n  • 각각 개별적인 플렉스 속성을 가질 수 있음\n\n• HTML 구조 예시:\n```html\n<div class=\"flex-container\">  <!-- 부모: Flex Container -->\n    <div>1</div>              <!-- 자식: Flex Item -->\n    <div>2</div>              <!-- 자식: Flex Item -->\n    <div>3</div>              <!-- 자식: Flex Item -->\n</div>\n```\n• 관계 특성: 부모-자식 관계가 핵심이며, 손자 요소는 자동으로 flex item이 되지 않습니다.",
      "difficulty": "medium",
      "created_at": "2025-08-10T21:49:57.000Z"
    },
    {
      "id": 1488,
      "subject_id": 9,
      "question": "다음 코드에서 flex items이 세로로 배치되도록 하려면 빈칸에 무엇을 입력해야 할까요?\n```css\n.flex-container {\n    display: flex;\n    flex-direction: _______;\n}\n```",
      "option_a": "row",
      "option_b": "column",
      "option_c": "horizontal",
      "option_d": "vertical",
      "correct_answer": "B",
      "explanation": "• flex-direction 속성의 역할: flex container 내에서 flex items가 배치되는 방향을 결정합니다.\n\n• 주요 속성값들:\n  • `row`: 가로 방향 배치 (기본값)\n  • `column`: 세로 방향 배치\n  • `row-reverse`: 가로 역순 배치\n  • `column-reverse`: 세로 역순 배치",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:54:21.000Z"
    },
    {
      "id": 1489,
      "subject_id": 9,
      "question": "flex container에 여러 줄로 아이템을 배치하고 싶을 때 사용하는 속성과 값의 조합으로 올바른 것은?",
      "option_a": "`flex-direction: wrap`",
      "option_b": "`flex-wrap: wrap`",
      "option_c": "`flex-flow: multi`",
      "option_d": "`justify-content: wrap`",
      "correct_answer": "B",
      "explanation": "• flex-wrap 속성의 역할: flex items가 한 줄에 다 들어가지 않을 때 다음 줄로 넘길지 결정합니다.\n\n• flex-wrap 속성값들:\n  • `nowrap`: 한 줄에 강제로 배치 (기본값)\n  • `wrap`: 필요시 여러 줄로 배치\n  • `wrap-reverse`: 여러 줄 역순 배치",
      "difficulty": "easy",
      "created_at": "2025-08-10T21:55:33.000Z"
    },
    {
      "id": 1490,
      "subject_id": 9,
      "question": "다음 코드에서 flex items를 가로축 중앙에 정렬하려면 빈칸에 무엇을 입력해야 할까요?\n```css\n.flex-container {\n    display: flex;\n    _______: center;\n}\n```",
      "option_a": "align-items",
      "option_b": "justify-content",
      "option_c": "align-content",
      "option_d": "text-align",
      "correct_answer": "B",
      "explanation": "• 정렬 속성들의 구분:\n  • `justify-content`: 주축(main axis) 정렬 - 일반적으로 가로축\n  • `align-items`: 교차축(cross axis) 정렬 - 일반적으로 세로축\n\n• justify-content 주요 값들:\n  • `center`: 중앙 정렬\n  • `flex-start`: 시작점 정렬\n  • `flex-end`: 끝점 정렬\n  • `space-between`: 양끝 정렬\n  • `space-around`: 둘레 간격",
      "difficulty": "medium",
      "created_at": "2025-08-10T21:57:32.000Z"
    },
    {
      "id": 1491,
      "subject_id": 9,
      "question": "다음 HTML에서 flex item이 되는 요소는 무엇인가요?\n```html\n<div class=\"flex-container\">\n    <div>A</div>\n    <div>B\n        <span>내부 요소</span>\n    </div>\n    <div>C</div>\n</div>\n```",
      "option_a": "flex-container만",
      "option_b": "A, B, C만",
      "option_c": "A, B, C, 내부 요소 모두",
      "option_d": "내부 요소만",
      "correct_answer": "B",
      "explanation": "• flex item의 정의: flex container의 직접적인 자식 요소만이 flex item이 됩니다.\n\n• 구조 분석:\n  • `flex-container`: 부모 요소 (flex container)\n  • `A`, `B`, `C`: 직접 자식 요소 → flex item이 됨\n  • `내부 요소 (span)`: 손자 요소 → flex item이 아님\n\n• 중요한 원칙:\n  • flex 속성은 한 단계 아래 자식에게만 적용\n  • 손자 요소에게 flex를 적용하려면 그 부모에도 display: flex 필요\n\n• 실무 예시:\n```html\n<nav class=\"flex-container\">     <!-- flex container -->\n    <div>로고</div>              <!-- flex item -->\n    <ul>                         <!-- flex item -->\n        <li>메뉴1</li>           <!-- 일반 요소 (flex item 아님) -->\n        <li>메뉴2</li>           <!-- 일반 요소 (flex item 아님) -->\n    </ul>\n    <div>로그인</div>            <!-- flex item -->\n</nav>\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:00:53.000Z"
    },
    {
      "id": 1492,
      "subject_id": 9,
      "question": "다음 코드에서 \"3번 아이템\"이 첫 번째로 나타나게 하려면 빈칸에 무엇을 입력해야 할까요?\n```css\n.item-3 {\n    order: _______;\n}\n```\n```html\n<div class=\"flex-container\">\n    <div>1번 아이템</div>\n    <div>2번 아이템</div>\n    <div class=\"item-3\">3번 아이템</div>\n</div>\n```",
      "option_a": "1",
      "option_b": "0",
      "option_c": "-1",
      "option_d": "first",
      "correct_answer": "C",
      "explanation": "• order 속성의 작동 원리:\n  • 숫자가 작을수록 앞에 배치됩니다\n  • 기본값은 0입니다\n  • 음수 사용 가능합니다\n\n• 각 선택지 분석:\n  • `order: 1` → 1번(0), 2번(0), 3번(1) → 순서: 1, 2, 3 (변화 없음)\n  • `order: 0` → 모두 0 → 순서: 1, 2, 3 (HTML 순서대로)\n  • `order: -1` → 1번(0), 2번(0), 3번(-1) → 순서: 3, 1, 2 ✓\n  • `first` → 유효하지 않은 값\n\n• order 우선순위 규칙:\n  1. order 값이 작은 순서대로\n  2. 같은 order 값이면 HTML 작성 순서대로",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:02:24.000Z"
    },
    {
      "id": 1493,
      "subject_id": 9,
      "question": "다음 중 flex 단축 속성을 올바르게 사용한 것은?\n```css\n.item {\n    /* flex: flex-grow flex-shrink flex-basis */\n    flex: _______;\n}\n```",
      "option_a": "`1 1 200px`",
      "option_b": "`grow shrink basis`",
      "option_c": "`200px 1 1`",
      "option_d": "`1 200px 1`",
      "correct_answer": "A",
      "explanation": "• flex 단축 속성의 순서: `flex-grow` → `flex-shrink` → `flex-basis` 순으로 작성합니다.\n\n• 각 값의 의미:\n  • 첫 번째 값 (1): `flex-grow` - 늘어나는 비율\n  • 두 번째 값 (1): `flex-shrink` - 줄어드는 비율\n  • 세 번째 값 (200px): `flex-basis` - 기본 크기",
      "difficulty": "medium",
      "created_at": "2025-08-10T22:05:04.000Z"
    },
    {
      "id": 1494,
      "subject_id": 9,
      "question": "반응형 웹 디자인에서 Flexbox와 Media Queries를 함께 사용하는 주요 목적은 무엇인가요?",
      "option_a": "웹사이트의 로딩 속도를 빠르게 하기 위해",
      "option_b": "다양한 화면 크기에 맞는 레이아웃을 제공하기 위해",
      "option_c": "웹사이트의 보안을 강화하기 위해",
      "option_d": "검색 엔진 최적화를 위해",
      "correct_answer": "B",
      "explanation": "• 반응형 디자인의 핵심 목표: 데스크톱, 태블릿, 모바일 등 다양한 기기에서 최적의 사용자 경험을 제공하는 것입니다.\n\n• Flexbox + Media Queries 조합의 장점:\n  • Flexbox: 유연한 레이아웃 구조 제공\n  • Media Queries: 화면 크기별 조건부 스타일 적용\n  • 결합 효과: 화면 크기에 따라 레이아웃을 자동으로 변경",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:08:33.000Z"
    },
    {
      "id": 1495,
      "subject_id": 9,
      "question": "데스크톱에서는 가로 배치, 모바일에서는 세로 배치로 변경하려면 빈칸에 무엇을 입력해야 할까요?\n```css\n.flex-container {\n    display: flex;\n    flex-direction: row;\n}\n\n@media (max-width: 800px) {\n    .flex-container {\n        flex-direction: _______;\n    }\n}\n```",
      "option_a": "row",
      "option_b": "column",
      "option_c": "vertical",
      "option_d": "horizontal",
      "correct_answer": "B",
      "explanation": "• flex-direction의 역할: flex items의 배치 방향을 결정합니다.\n  • `row`: 가로 배치 (왼쪽에서 오른쪽)\n  • `column`: 세로 배치 (위에서 아래)\n\n• 반응형 패턴 분석:\n  • 기본 스타일: `flex-direction: row` (데스크톱용 가로 배치)\n  • 모바일 조건: `max-width: 800px` (800px 이하일 때)\n  • 모바일 스타일: `flex-direction: column` (세로 배치)\n\n• 브레이크포인트 800px: 태블릿과 모바일을 구분하는 일반적인 기준점입니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:10:14.000Z"
    },
    {
      "id": 1496,
      "subject_id": 9,
      "question": "다음 코드에서 2컬럼 레이아웃을 1컬럼으로 변경하는 방법으로 올바른 것은?\n```css\n.flex-container {\n    display: flex;\n    flex-wrap: wrap;\n}\n\n.flex-item-left, .flex-item-right {\n    flex: 50%;\n}\n\n@media (max-width: 800px) {\n    .flex-item-left, .flex-item-right {\n        flex: _______;\n    }\n}\n```",
      "option_a": "25%",
      "option_b": "50%",
      "option_c": "100%",
      "option_d": "auto",
      "correct_answer": "C",
      "explanation": "• flex 속성과 레이아웃 계산:\n  • `flex: 50%`: 각 아이템이 50% 너비 → 2개가 한 줄에 배치 (2컬럼)\n  • `flex: 100%`: 각 아이템이 100% 너비 → 1개가 한 줄에 배치 (1컬럼)\n\n• flex-wrap: wrap의 역할:\n  • 한 줄에 들어가지 않는 아이템들을 다음 줄로 넘깁니다\n  • 100% + 100% = 200% → 두 번째 아이템이 다음 줄로 이동\n\n• 레이아웃 변화:\n  • 데스크톱: 가로 2컬럼\n  • 모바일: 세로 1컬럼",
      "difficulty": "medium",
      "created_at": "2025-08-10T22:12:01.000Z"
    },
    {
      "id": 1497,
      "subject_id": 9,
      "question": "다음 HTML에서 grid item이 되는 요소는 무엇인가요?\n```html\n<div class=\"grid-container\">\n    <div>Header</div>\n    <div>Sidebar\n        <ul>\n            <li>메뉴1</li>\n            <li>메뉴2</li>\n        </ul>\n    </div>\n    <div>Main Content</div>\n    <div>Footer</div>\n</div>\n```",
      "option_a": "grid-container만",
      "option_b": "Header, Sidebar, Main Content, Footer만",
      "option_c": "Header, Sidebar, Main Content, Footer, 메뉴1, 메뉴2 모두",
      "option_d": "메뉴1, 메뉴2만",
      "correct_answer": "B",
      "explanation": "• Grid Item의 정의: grid container의 직접적인 자식 요소만이 grid item이 됩니다.\n\n• 구조 분석:\n  • `grid-container`: 부모 요소 (Grid Container)\n  • `Header`, `Sidebar`, `Main Content`, `Footer`: 직접 자식 → Grid Item\n  • `ul`, `li` 요소들: 손자 요소 → Grid Item 아님\n\n• Grid vs Flexbox 공통점: 둘 다 직접 자식 요소에게만 레이아웃 속성이 적용됩니다.",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:15:50.000Z"
    },
    {
      "id": 1498,
      "subject_id": 9,
      "question": "div 요소를 grid container로 만들기 위해 빈칸에 들어가야 할 속성값은?\n```css\n.container {\n    display: _______;\n}\n```",
      "option_a": "grid",
      "option_b": "flex",
      "option_c": "block-grid",
      "option_d": "table-grid",
      "correct_answer": "A",
      "explanation": "• Grid Container 생성 방법: `display: grid` 또는 `display: inline-grid`를 사용합니다.\n\n• display 속성값 비교:\n  • `display: grid`: 블록 레벨 grid container (세로로 쌓임)\n  • `display: inline-grid`: 인라인 레벨 grid container (가로로 나란히)\n  • `display: flex`: Flexbox container (Grid 아님)\n\n• grid vs inline-grid 선택:\n  • 대부분의 경우: `display: grid` 사용\n  • 특별한 경우: grid container 자체를 인라인으로 배치해야 할 때만 `inline-grid` 사용",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:17:19.000Z"
    },
    {
      "id": 1499,
      "subject_id": 9,
      "question": "다음 Grid 속성들 중에서 grid container에 적용하는 속성이 아닌 것은?",
      "option_a": "`grid-template-columns`",
      "option_b": "`grid-template-rows`",
      "option_c": "`grid-area`",
      "option_d": "`column-gap`",
      "correct_answer": "C",
      "explanation": "• Grid Container 속성들 (전체 그리드 구조 정의):\n  • `grid-template-columns`: 컬럼의 크기와 개수 설정\n  • `grid-template-rows`: 행의 크기와 개수 설정\n  • `column-gap`, `row-gap`: 그리드 간격 설정\n  • `justify-content`, `align-content`: 전체 그리드 정렬\n\n• Grid Item 속성들 (개별 아이템 위치/크기 조정):\n  • `grid-area`: 특정 그리드 영역에 아이템 배치 ⭐\n  • `grid-column`, `grid-row`: 아이템의 시작/끝 위치 지정\n  • `justify-self`, `align-self`: 개별 아이템 정렬",
      "difficulty": "medium",
      "created_at": "2025-08-10T22:19:06.000Z"
    },
    {
      "id": 1500,
      "subject_id": 9,
      "question": "그리드의 컬럼들 사이에만 50px 간격을 주려면 빈칸에 무엇을 입력해야 할까요?\n```css\n.grid-container {\n    display: grid;\n    _______: 50px;\n}\n```",
      "option_a": "gap",
      "option_b": "column-gap",
      "option_c": "row-gap",
      "option_d": "grid-gap",
      "correct_answer": "B",
      "explanation": "• 간격 속성들의 차이:\n  • `column-gap`: 컬럼 사이의 간격만 조정\n  • `row-gap`: 행 사이의 간격만 조정\n  • `gap`: 컬럼과 행 모든 간격 조정 (단축 속성)\n\n• 문제 조건 분석: \"컬럼들 사이에만\" → `column-gap` 사용\n\n• 각 속성의 효과:\n```css\ncolumn-gap: 50px;  /* 세로 간격만 50px */\nrow-gap: 30px;     /* 가로 간격만 30px */  \ngap: 20px;         /* 모든 간격 20px */\ngap: 20px 40px;    /* 행 20px, 컬럼 40px */\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:22:49.000Z"
    },
    {
      "id": 1501,
      "subject_id": 9,
      "question": "그리드에서 특정 아이템이 첫 번째 컬럼부터 세 번째 컬럼까지 차지하게 하려면 빈칸에 무엇을 입력해야 할까요?\n```css\n.item1 {\n    grid-column-start: 1;\n    grid-column-end: _______;\n}\n```",
      "option_a": "2",
      "option_b": "3",
      "option_c": "4",
      "option_d": "span 3",
      "correct_answer": "C",
      "explanation": "• Grid Line의 이해:\n  • 3개 컬럼이 있으면 4개의 라인이 존재합니다\n  • Line 1 | Column 1 | Line 2 | Column 2 | Line 3 | Column 3 | Line 4\n\n• grid-column-start/end 작동 원리:\n  • `grid-column-start`: 1: 1번 라인에서 시작\n  • `grid-column-end`: 4: 4번 라인에서 끝\n  • 결과: 1번~3번 컬럼까지 차지 (1, 2, 3번 컬럼)",
      "difficulty": "medium",
      "created_at": "2025-08-10T22:24:21.000Z"
    },
    {
      "id": 1502,
      "subject_id": 9,
      "question": "3개의 동일한 너비 컬럼을 만들려면 빈칸에 무엇을 입력해야 할까요?\n```css\n.grid-container {\n    display: grid;\n    grid-template-columns: _______;\n}\n```",
      "option_a": "1fr 1fr 1fr",
      "option_b": "auto auto auto",
      "option_c": "33% 33% 33%",
      "option_d": "위의 모든 답이 정답",
      "correct_answer": "D",
      "explanation": "동일한 너비 컬럼을 만드는 다양한 방법:\n\n• 1fr 1fr 1fr:\n  • `fr` (fraction) 단위 사용\n  • 사용 가능한 공간을 1:1:1 비율로 분배\n  • 가장 권장되는 방법\n\n• auto auto auto:\n  • 각 컬럼이 콘텐츠에 맞춰 자동 크기 조정\n  • 콘텐츠가 동일하면 같은 크기가 됨\n\n• 33% 33% 33%:\n  • 백분율로 명시적 크기 지정\n  • 컨테이너 너비의 33%씩 차지\n\n• 실무에서 권장하는 방법: `1fr 1fr 1fr`\n  • 반응형 디자인에 최적화\n  • 남은 공간을 효율적으로 활용\n  • 간격(gap)이 있어도 자동으로 계산\n\n• 단축 문법: `repeat(3, 1fr)`으로 더 간단히 작성 가능",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:28:15.000Z"
    },
    {
      "id": 1503,
      "subject_id": 9,
      "question": "`fr` 단위에 대한 설명으로 올바른 것은?",
      "option_a": "`fr`은 \"fixed ratio\"의 줄임말이다",
      "option_b": "`fr`은 \"fraction\"의 줄임말로, 사용 가능한 공간을 비율로 나눈다",
      "option_c": "`fr`은 \"flex ratio\"의 줄임말이다",
      "option_d": "`fr`은 픽셀과 같은 절대 단위이다",
      "correct_answer": "B",
      "explanation": "• fr 단위의 정의: \"fraction(분수)\"의 줄임말로, 사용 가능한 공간을 비율로 분배하는 상대 단위입니다.\n\n• fr 단위의 작동 원리:\n  • 그리드 컨테이너의 남은 공간을 계산\n  • 각 fr 값의 비율에 따라 공간 분배\n  • 예: `1fr 2fr 1fr` → 1:2:1 비율로 분배",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:29:22.000Z"
    },
    {
      "id": 1504,
      "subject_id": 9,
      "question": "그리드가 컨테이너보다 작을 때 전체 그리드를 가로 중앙에 정렬하려면 빈칸에 무엇을 입력해야 할까요?\n```css\n.grid-container {\n    display: grid;\n    width: 800px;\n    grid-template-columns: 100px 100px 100px;\n    _______: center;\n}\n```",
      "option_a": "align-content",
      "option_b": "justify-content",
      "option_c": "align-items",
      "option_d": "justify-items",
      "correct_answer": "B",
      "explanation": "• `justify-content`: 전체 그리드의 가로(주축) 정렬\n• `align-content`: 전체 그리드의 세로(교차축) 정렬\n• `justify-items`: 개별 아이템의 가로 정렬\n• `align-items`: 개별 아이템의 세로 정렬",
      "difficulty": "medium",
      "created_at": "2025-08-10T22:31:04.000Z"
    },
    {
      "id": 1505,
      "subject_id": 9,
      "question": "그리드 아이템을 1번 컬럼에서 시작해서 2개 컬럼만큼 확장하려면 빈칸에 무엇을 입력해야 할까요?\n```css\n.item1 {\n    grid-column: 1 / _______;\n}\n```",
      "option_a": "2",
      "option_b": "3",
      "option_c": "span 2",
      "option_d": "span 3",
      "correct_answer": "C",
      "explanation": "• span 키워드의 의미: \"확장하다\"라는 뜻으로, 지정된 개수만큼 그리드 셀을 차지합니다.\n\n• grid-column 문법:\n  • `grid-column: start / end` (라인 번호로 지정)\n  • `grid-column: start / span count` (시작점과 확장 개수로 지정)\n\n• 각 선택지 분석:\n  • `1 / 2`: 1번 라인에서 2번 라인까지 → 1개 컬럼 차지\n  • `1 / 3`: 1번 라인에서 3번 라인까지 → 2개 컬럼 차지\n  • `1 / span 2`: 1번 라인에서 시작해서 2개 컬럼 확장 ✓\n  • `1 / span 3`: 1번 라인에서 시작해서 3개 컬럼 확장",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:35:00.000Z"
    },
    {
      "id": 1506,
      "subject_id": 9,
      "question": "다음 중 `grid-column`의 단축 속성이 아닌 것은?",
      "option_a": "`grid-column-start`",
      "option_b": "`grid-column-end`",
      "option_c": "`grid-column-gap`",
      "option_d": "1번과 2번이 모두 단축 속성임",
      "correct_answer": "C",
      "explanation": "• grid-column 단축 속성의 구성:\n  • `grid-column-start`: 시작 위치 지정\n  • `grid-column-end`: 끝 위치 지정\n  • `grid-column`: 위 두 속성의 단축형\n\n• 단축 속성 사용 예시:\n```css\n/* 개별 속성 */\ngrid-column-start: 2;\ngrid-column-end: 4;\n\n/* 단축 속성 */\ngrid-column: 2 / 4;  /* 같은 효과 */\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:36:36.000Z"
    },
    {
      "id": 1507,
      "subject_id": 9,
      "question": "grid-area 속성의 값 순서를 올바르게 나타낸 것은?\n```css\n.item {\n    grid-area: _______;\n}\n```",
      "option_a": "`column-start / row-start / column-end / row-end`",
      "option_b": "`row-start / column-start / row-end / column-end`",
      "option_c": "`row-start / row-end / column-start / column-end`",
      "option_d": "`start / end / start / end`",
      "correct_answer": "B",
      "explanation": "• grid-area 4값 문법: `grid-area: row-start / column-start / row-end / column-end`\n\n• 순서 기억법: \"위 왼쪽 아래 오른쪽\" 순서\n  • row-start (위쪽 시작)\n  • column-start (왼쪽 시작)\n  • row-end (아래쪽 끝)\n  • column-end (오른쪽 끝)",
      "difficulty": "medium",
      "created_at": "2025-08-10T22:38:07.000Z"
    },
    {
      "id": 1508,
      "subject_id": 9,
      "question": "CSS `@supports` 규칙의 주요 목적은 무엇인가요?",
      "option_a": "CSS 파일의 크기를 줄이기 위해",
      "option_b": "브라우저가 특정 CSS 기능을 지원하는지 확인하고 대체 스타일을 제공하기 위해",
      "option_c": "CSS 코드의 실행 속도를 향상시키기 위해",
      "option_d": "CSS 코드를 압축하기 위해",
      "correct_answer": "B",
      "explanation": "@supports 사용 전후 비교:\n```css\n/* @supports 없이 (위험함) */\n.container { display: grid; }  /* 구형 브라우저에서 깨짐 */\n\n/* @supports 사용 (안전함) */\n.container { display: block; }  /* 기본 스타일 */\n@supports (display: grid) {\n    .container { display: grid; }  /* 지원 시에만 적용 */\n}\n```",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:42:29.000Z"
    },
    {
      "id": 1509,
      "subject_id": 9,
      "question": "다음 코드에서 브라우저가 Flexbox를 지원할 때만 적용되는 스타일을 작성하려면 빈칸에 무엇을 입력해야 할까요?\n```css\n_______ (display: flex) {\n    .container {\n        display: flex;\n        justify-content: center;\n    }\n}\n```",
      "option_a": "@media",
      "option_b": "@supports",
      "option_c": "@import",
      "option_d": "@keyframes",
      "correct_answer": "B",
      "explanation": "@supports 문법: `@supports (property: value) { CSS rules }`\n  • 특정 CSS 속성과 값의 지원 여부를 확인\n  • 지원하는 경우에만 내부 CSS 규칙 적용",
      "difficulty": "easy",
      "created_at": "2025-08-10T22:43:33.000Z"
    },
    {
      "id": 1510,
      "subject_id": 9,
      "question": "Grid를 지원하지 않는 브라우저에서만 경고 메시지를 표시하려면 빈칸에 무엇을 입력해야 할까요?\n```css\n@supports _______ (display: grid) {\n    .warning {\n        display: block;\n        background: red;\n        color: white;\n        padding: 10px;\n    }\n}\n```",
      "option_a": "and",
      "option_b": "or",
      "option_c": "not",
      "option_d": "only",
      "correct_answer": "C",
      "explanation": "• @supports에서 not 키워드: 조건을 반전시켜 기능을 지원하지 않을 때만 스타일을 적용합니다.\n\n• 조건 반전의 동작:\n  • `@supports (display: grid)`: Grid 지원할 때 적용\n  • `@supports not (display: grid)`: Grid 지원하지 않을 때 적용",
      "difficulty": "medium",
      "created_at": "2025-08-10T22:45:20.000Z"
    },
    {
      "id": 1511,
      "subject_id": 9,
      "question": "웹페이지의 Grid-View란 무엇인가요?",
      "option_a": "웹페이지를 세로로만 나누어 배치하는 방법",
      "option_b": "웹페이지를 행(rows)과 열(columns)로 나누어 배치하는 방법",
      "option_c": "웹페이지의 색상을 격자 무늬로 표시하는 방법",
      "option_d": "웹페이지의 텍스트를 표 형태로 배치하는 방법",
      "correct_answer": "B",
      "explanation": "Grid-View는 웹페이지를 행과 열로 나누어 구성하는 레이아웃 방법입니다.\n\n• 격자 구조: 페이지를 행(rows)과 열(columns)로 나누어 체계적으로 구성\n• 요소 배치 용이성: 웹 요소들을 정확한 위치에 쉽게 배치할 수 있음\n• 반응형 지원: 일반적으로 6개 또는 12개의 열을 사용하며, 브라우저 크기에 따라 유연하게 조정됨",
      "difficulty": "easy",
      "created_at": "2025-08-11T12:00:45.000Z"
    },
    {
      "id": 1512,
      "subject_id": 9,
      "question": "CSS Grid를 사용하기 전에 모든 HTML 요소에 반드시 설정해야 하는 속성은?\n```css\n* {\n    margin: 0;\n    ______: border-box;\n}\n```",
      "option_a": "padding-sizing",
      "option_b": "border-sizing",
      "option_c": "box-sizing",
      "option_d": "element-sizing",
      "correct_answer": "C",
      "explanation": "`box-sizing: border-box` 속성은 Grid 레이아웃에서 필수적입니다.\n\n• 박스 모델 통일: 모든 요소의 크기 계산 방식을 일관되게 만듦\n• 패딩과 테두리 포함: 요소의 너비와 높이에 패딩과 테두리가 포함되어 계산됨\n• 레이아웃 예측 가능: 요소 크기가 예상대로 동작하여 레이아웃이 깨지지 않음\n• 전역 설정: `*` 선택자로 모든 요소에 적용",
      "difficulty": "easy",
      "created_at": "2025-08-11T12:01:52.000Z"
    },
    {
      "id": 1513,
      "subject_id": 9,
      "question": "다음 CSS Grid 코드에서 빈칸에 들어갈 올바른 속성은?\n```css\n.grid-container {\n    display: grid;\n    ______: \n        'header header header header header header'\n        'menu main main main main right'\n        'footer footer footer footer footer footer';\n}\n```",
      "option_a": "grid-template-columns",
      "option_b": "grid-template-areas",
      "option_c": "grid-template-rows",
      "option_d": "grid-area-template",
      "correct_answer": "B",
      "explanation": "`grid-template-areas`는 Grid 영역을 시각적으로 정의하는 속성입니다.\n\n• 영역 명명: 각 그리드 셀에 이름을 부여하여 직관적으로 레이아웃 구성\n• 시각적 표현: 코드만 봐도 실제 레이아웃 구조를 쉽게 파악 가능\n• 영역 할당:\n  • `header`: 전체 상단 6개 열을 차지\n  • `menu`: 왼쪽 1개 열, `main`: 중앙 4개 열, `right`: 오른쪽 1개 열\n  • `footer`: 전체 하단 6개 열을 차지",
      "difficulty": "medium",
      "created_at": "2025-08-11T12:03:05.000Z"
    },
    {
      "id": 1514,
      "subject_id": 9,
      "question": "Grid 아이템에 특정 영역을 할당하는 CSS 속성과 올바른 사용법은?\n```css\n.item1 {\n    ______: header;\n    background-color: purple;\n}\n```",
      "option_a": "grid-template: header",
      "option_b": "grid-position: header",
      "option_c": "grid-area: header",
      "option_d": "grid-section: header",
      "correct_answer": "C",
      "explanation": "`grid-area` 속성은 개별 그리드 아이템이 차지할 영역을 지정합니다.\n\n• 영역 연결: `grid-template-areas`에서 정의한 영역 이름과 연결\n• 아이템별 설정: 각 그리드 아이템(`.item1`, `.item2` 등)에 개별적으로 적용\n• 자동 배치: 지정된 영역에 자동으로 아이템이 배치됨\n• 예시 구조:\n```css\n.item1 { grid-area: header; }   /* 헤더 영역 */\n.item2 { grid-area: menu; }     /* 메뉴 영역 */\n.item3 { grid-area: main; }     /* 메인 콘텐츠 영역 */\n```",
      "difficulty": "medium",
      "created_at": "2025-08-11T12:04:13.000Z"
    },
    {
      "id": 1515,
      "subject_id": 9,
      "question": "다음 Grid 레이아웃에서 .item2(메뉴)의 스타일링에 대한 설명으로 올바른 것은?\n```css\n.item2 ul {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n}\n.item2 li {\n    padding: 8px;\n    margin-bottom: 7px;\n    background-color: #33b5e5;\n    color: #ffffff;\n}\n.item2 li:hover {\n    background-color: #0099cc;\n}\n```",
      "option_a": "리스트 항목들이 세로로 배치되고, 마우스 오버 시 더 밝은 파란색으로 변함",
      "option_b": "리스트 항목들이 가로로 배치되고, 마우스 오버 시 더 어두운 파란색으로 변함",
      "option_c": "리스트 항목들이 세로로 배치되고, 마우스 오버 시 더 어두운 파란색으로 변함",
      "option_d": "리스트 항목들이 격자 형태로 배치되고, 마우스 오버 시 색상이 변하지 않음",
      "correct_answer": "C",
      "explanation": "메뉴 영역의 스타일링은 네비게이션 메뉴의 일반적인 패턴을 따릅니다.\n\n• 리스트 초기화:\n  • `list-style-type: none`: 불릿 포인트 제거\n  • `margin: 0; padding: 0`: 기본 여백 제거\n\n• 세로 배치:\n  • 별도의 `display: flex`나 `float` 설정이 없으므로 기본 블록 요소로 세로 배치\n  • `margin-bottom: 7px`로 항목 간 간격 생성\n\n• 색상 변화:\n  • 기본 색상: `#33b5e5` (밝은 파란색)\n  • 호버 색상: `#0099cc` (더 어두운 파란색)\n  • 마우스 오버 시 시각적 피드백 제공\n\n• 패딩과 여백: `padding: 8px`로 클릭 영역 확보 및 가독성 향상",
      "difficulty": "hard",
      "created_at": "2025-08-11T12:06:32.000Z"
    },
    {
      "id": 1516,
      "subject_id": 9,
      "question": "Media Query는 무엇을 위한 CSS 기술인가요?",
      "option_a": "웹페이지의 색상을 변경하기 위한 기술",
      "option_b": "특정 조건이 참일 때만 CSS 속성을 적용하기 위한 기술",
      "option_c": "HTML 구조를 변경하기 위한 기술",
      "option_d": "웹페이지의 속도를 향상시키기 위한 기술",
      "correct_answer": "B",
      "explanation": "Media Query는 조건부 CSS 적용을 위한 강력한 기술입니다.\n\n• 조건부 적용: 특정 조건(화면 크기, 방향 등)이 만족될 때만 CSS 스타일 적용\n• CSS3 도입: CSS3에서 소개된 반응형 웹 디자인의 핵심 기술\n• @media 규칙 사용: `@media` 규칙을 통해 조건을 설정하고 해당 블록 내 CSS만 실행\n• 반응형 디자인: 다양한 디바이스에서 최적화된 화면을 제공하는 핵심 도구",
      "difficulty": "easy",
      "created_at": "2025-08-11T12:13:53.000Z"
    },
    {
      "id": 1517,
      "subject_id": 9,
      "question": "Breakpoint의 개념과 목적에 대한 설명으로 가장 적절한 것은?",
      "option_a": "웹페이지가 로딩되는 시점을 의미함",
      "option_b": "CSS 코드에서 오류가 발생하는 지점을 의미함",
      "option_c": "디자인이 다르게 동작하도록 설정하는 특정 화면 크기 지점",
      "option_d": "웹페이지의 속도가 느려지는 지점을 의미함",
      "correct_answer": "C",
      "explanation": "Breakpoint는 반응형 디자인의 핵심 개념입니다.\n\n• 화면 크기 기준점: 특정 화면 크기에서 레이아웃이 변경되는 지점\n• 디자인 전환점: 데스크톱 → 태블릿 → 모바일로 레이아웃이 바뀌는 경계\n• 사용자 경험 최적화: 각 디바이스에서 가장 적합한 레이아웃 제공\n• 일반적인 Breakpoint:\n  • 600px: 모바일과 태블릿 경계\n  • 768px: 태블릿과 데스크톱 경계\n  • 992px, 1200px: 대형 화면 구분",
      "difficulty": "medium",
      "created_at": "2025-08-11T12:36:45.000Z"
    },
    {
      "id": 1518,
      "subject_id": 9,
      "question": "반응형 이미지를 만들기 위해 다음 코드의 빈칸에 들어갈 올바른 속성은?\n```css\nimg {\n    width: 100%;\n    ______: auto;\n}\n```",
      "option_a": "width",
      "option_b": "height",
      "option_c": "max-width",
      "option_d": "min-height",
      "correct_answer": "B",
      "explanation": "반응형 이미지의 가장 기본적인 설정 방법입니다.\n\n• width: 100%: 이미지가 부모 컨테이너의 전체 너비를 차지하도록 설정\n• height: auto: 이미지의 높이를 자동으로 조정하여 원본 비율 유지\n• 비율 유지: 너비가 변해도 이미지가 찌그러지지 않고 원본 비율을 그대로 유지\n• 반응형 동작: 화면 크기가 변할 때마다 이미지 크기가 자동으로 조정됨",
      "difficulty": "easy",
      "created_at": "2025-08-11T12:40:52.000Z"
    },
    {
      "id": 1519,
      "subject_id": 9,
      "question": "`width: 100%`와 `max-width: 100%`의 차이점으로 올바른 것은?",
      "option_a": "둘 다 동일하게 작동함",
      "option_b": "`width`는 이미지를 원본보다 크게 확대할 수 있지만, `max-width`는 원본 크기를 넘지 않음",
      "option_c": "`max-width`는 이미지를 원본보다 크게 확대할 수 있지만, `width`는 원본 크기를 넘지 않음",
      "option_d": "`width`는 반응형이고 `max-width`는 고정 크기임",
      "correct_answer": "B",
      "explanation": "두 속성의 핵심적인 차이점을 이해하는 것이 중요합니다.\n\n• width: 100%의 특징:\n  • 부모 컨테이너 크기에 맞춰 강제로 확대/축소\n  • 원본보다 큰 화면에서는 이미지가 흐릿해질 수 있음\n  • 무조건 100% 크기로 맞춤\n\n• max-width: 100%의 장점:\n  • 원본 크기보다 큰 화면에서는 원본 크기 유지\n  • 작은 화면에서만 축소되어 이미지 품질 보호\n  • 더 나은 사용자 경험 제공\n\n• 실무 권장사항: 대부분의 경우 `max-width: 100%` 사용을 권장",
      "difficulty": "easy",
      "created_at": "2025-08-11T12:42:06.000Z"
    },
    {
      "id": 1520,
      "subject_id": 9,
      "question": "배경 이미지의 background-size 속성에 대한 설명으로 올바른 것은?\n```css\ndiv {\n    background-image: url('image.jpg');\n    background-size: ______;\n}\n```",
      "option_a": "`contain`: 이미지를 늘려서 전체 영역을 채우되, 일부가 잘릴 수 있음",
      "option_b": "`cover`: 이미지 비율을 유지하며 컨테이너에 맞추되, 빈 공간이 생길 수 있음",
      "option_c": "`100% 100%`: 이미지를 늘려서 전체 영역을 채우되, 비율이 변형될 수 있음",
      "option_d": "위의 모든 설명이 틀림",
      "correct_answer": "C",
      "explanation": "각 `background-size` 값의 동작 방식을 정확히 구분해야 합니다.\n\n• contain:\n  • 이미지 전체가 보이도록 컨테이너에 맞춤\n  • 비율 유지하며 빈 공간이 생길 수 있음\n  • 이미지가 잘리지 않음\n\n• cover:\n  • 컨테이너 전체를 이미지로 채움\n  • 비율 유지하되 일부가 잘릴 수 있음\n  • 빈 공간 없이 가득 참\n\n• 100% 100%:\n  • 가로, 세로 모두 컨테이너에 맞춤\n  • 원본 비율이 변형될 수 있음\n  • 이미지가 늘어나거나 찌그러질 수 있음",
      "difficulty": "medium",
      "created_at": "2025-08-11T12:43:34.000Z"
    },
    {
      "id": 1521,
      "subject_id": 9,
      "question": "Media Query를 사용하여 디바이스별로 다른 배경 이미지를 설정하는 코드에서 빈칸에 들어갈 올바른 값은?\n```css\n/* 작은 디바이스용 */\nbody {\n    background-image: url('small.jpg');\n}\n\n/* 400px 이상 디바이스용 */\n@media only screen and (______: 400px) {\n    body {\n        background-image: url('large.jpg');\n    }\n}\n```",
      "option_a": "max-width",
      "option_b": "min-width",
      "option_c": "max-device-width",
      "option_d": "device-width",
      "correct_answer": "B",
      "explanation": "Media Query에서 화면 크기 조건을 올바르게 설정하는 방법입니다.\n\n• min-width: 400px:\n  • 화면 너비가 400px 이상일 때 적용\n  • 큰 화면에서 고해상도 이미지 사용\n  • 브라우저 창 크기 기준\n\n• 논리적 구조:\n  • 기본: 작은 이미지 (모바일 우선)\n  • 조건: 400px 이상에서 큰 이미지로 교체\n  • 성능 최적화: 작은 디바이스에서 불필요한 대용량 이미지 로딩 방지",
      "difficulty": "medium",
      "created_at": "2025-08-11T12:44:41.000Z"
    },
    {
      "id": 1522,
      "subject_id": 9,
      "question": "HTML `<picture>` 요소의 올바른 사용법과 장점에 대한 설명으로 맞는 것은?\n```html\n<picture>\n    <source srcset=\"mobile.jpg\" media=\"(max-width: 400px)\">\n    <source srcset=\"desktop.jpg\">\n    <img src=\"desktop.jpg\" alt=\"Description\">\n</picture>\n```",
      "option_a": "`<img>` 태그는 필수가 아니며, 최신 브라우저에서만 작동함",
      "option_b": "`srcset`은 선택사항이고, `media` 속성이 반드시 필요함",
      "option_c": "첫 번째 조건에 맞는 이미지가 선택되며, `<img>`는 폴백용으로 필수임",
      "option_d": "CSS Media Query보다 성능상 불리함",
      "correct_answer": "C",
      "explanation": "`<picture>` 요소는 반응형 이미지의 가장 강력한 해결책입니다.\n\n• 작동 원리:\n  • 위에서부터 조건을 확인하여 첫 번째 맞는 이미지 선택\n  • 400px 이하: `mobile.jpg` 사용\n  • 그 외: `desktop.jpg` 사용\n\n• 필수 요소들:\n  • `srcset`: 이미지 소스 지정 (필수)\n  • `media`: 조건 설정 (선택, 없으면 기본 선택)\n  • `<img>`: 구형 브라우저 호환성을 위한 폴백 (필수)\n\n• CSS 대비 장점:\n  • 브라우저가 최적 이미지를 미리 선택하여 성능 향상\n  • 불필요한 이미지 다운로드 방지\n  • 더 세밀한 제어 가능\n\n• 접근성: `alt` 속성으로 스크린 리더 지원",
      "difficulty": "hard",
      "created_at": "2025-08-11T12:46:44.000Z"
    },
    {
      "id": 1523,
      "subject_id": 9,
      "question": "반응형 비디오 플레이어를 만들기 위한 가장 기본적인 CSS 설정은?\n```css\nvideo {\n    width: 100%;\n    ______: auto;\n}\n```",
      "option_a": "width",
      "option_b": "height",
      "option_c": "max-height",
      "option_d": "min-width",
      "correct_answer": "B",
      "explanation": "반응형 비디오의 기본 설정은 이미지와 동일한 원리를 따릅니다.\n\n• width: 100%: 비디오가 부모 컨테이너의 전체 너비를 차지\n• height: auto: 비디오의 높이를 자동 조정하여 원본 비율 유지\n• 비율 유지: 비디오가 찌그러지지 않고 원본 종횡비(aspect ratio) 보존\n• 반응형 동작: 화면 크기 변화에 따라 비디오 크기 자동 조정",
      "difficulty": "easy",
      "created_at": "2025-08-11T12:49:24.000Z"
    },
    {
      "id": 1524,
      "subject_id": 9,
      "question": "`width: 100%`를 사용할 때 발생할 수 있는 문제점은?",
      "option_a": "비디오가 재생되지 않음",
      "option_b": "비디오가 원본 크기보다 확대되어 화질이 떨어질 수 있음",
      "option_c": "비디오가 세로로만 재생됨",
      "option_d": "비디오 컨트롤이 사라짐",
      "correct_answer": "B",
      "explanation": "`width: 100%`의 한계점을 이해하는 것이 중요합니다.\n\n• 강제 확대 문제:\n  • 원본보다 큰 화면에서 비디오가 강제로 확대됨\n  • 픽셀이 늘어나면서 화질 저하 발생\n  • 특히 저해상도 비디오에서 문제가 심각함\n\n• 사용자 경험 저하:\n  • 흐릿한 비디오로 인한 시청 경험 악화\n  • 불필요한 대역폭 사용\n\n• 해결책: `max-width: 100%` 사용으로 원본 크기 이상 확대 방지",
      "difficulty": "easy",
      "created_at": "2025-08-11T12:50:16.000Z"
    },
    {
      "id": 1525,
      "subject_id": 9,
      "question": "`max-width: 100%`와 `width: 100%`의 차이점으로 올바른 것은?\n```css\n/* 방법 A */\nvideo {\n    width: 100%;\n    height: auto;\n}\n\n/* 방법 B */\nvideo {\n    max-width: 100%;\n    height: auto;\n}\n```",
      "option_a": "방법 A는 항상 부모 요소의 100% 크기를 차지하고, 방법 B는 원본 크기를 넘지 않음",
      "option_b": "방법 B는 항상 부모 요소의 100% 크기를 차지하고, 방법 A는 원본 크기를 넘지 않음",
      "option_c": "둘 다 동일하게 작동함",
      "option_d": "방법 A는 모바일에서만 작동하고, 방법 B는 데스크톱에서만 작동함",
      "correct_answer": "A",
      "explanation": "두 속성의 핵심적인 차이점을 명확히 구분해야 합니다.\n\n• width: 100% (방법 A):\n  • 부모 컨테이너 크기에 무조건 맞춤\n  • 원본보다 큰 화면에서도 강제로 확대\n  • 화질 저하 가능성 있음\n\n• max-width: 100% (방법 B):\n  • 부모 컨테이너보다 작으면 원본 크기 유지\n  • 부모 컨테이너보다 크면 100%로 축소\n  • 화질 보호 및 최적 사용자 경험\n\n• 실무 권장: 대부분의 경우 `max-width: 100%` 사용 권장",
      "difficulty": "medium",
      "created_at": "2025-08-11T12:51:32.000Z"
    },
    {
      "id": 1526,
      "subject_id": 9,
      "question": "반응형 비디오에서 종횡비(aspect ratio)를 유지하는 가장 중요한 속성은?\n```css\nvideo {\n    width: 100%;\n    ______: auto;\n    display: block;\n}\n```",
      "option_a": "max-height",
      "option_b": "min-height",
      "option_c": "height",
      "option_d": "line-height",
      "correct_answer": "C",
      "explanation": "종횡비 유지는 반응형 미디어의 핵심 개념입니다.\n\n• height: auto의 역할:\n  • 너비 변화에 따라 높이를 자동으로 계산\n  • 원본 비디오의 종횡비(16:9, 4:3 등) 유지\n  • 비디오가 늘어나거나 찌그러지는 것을 방지\n\n• 종횡비 중요성:\n  • 비디오 콘텐츠의 원본 의도 보존\n  • 자연스러운 시청 경험 제공\n  • 레이아웃 깨짐 방지\n\n• 추가 고려사항:\n  • `display: block`: 인라인 요소의 여백 문제 해결\n  • `object-fit`: 컨테이너와 비디오 비율이 다를 때 조정 방법",
      "difficulty": "medium",
      "created_at": "2025-08-11T12:52:40.000Z"
    },
    {
      "id": 1527,
      "subject_id": 9,
      "question": "웹페이지에 반응형 비디오를 추가할 때 고려해야 할 사항들로 올바른 것은?\n```css\nvideo {\n    width: 100%;\n    height: auto;\n    /* 추가 속성들 */\n}\n```",
      "option_a": "비디오는 항상 자동재생되어야 하고, 컨트롤을 숨겨야 함",
      "option_b": "모든 디바이스에서 동일한 해상도의 비디오를 사용해야 함",
      "option_c": "비디오 파일 크기와 로딩 성능, 그리고 다양한 형식 지원을 고려해야 함",
      "option_d": "비디오는 페이지 로딩 시 즉시 전체 화면으로 재생되어야 함",
      "correct_answer": "C",
      "explanation": "반응형 비디오 구현 시 성능과 호환성을 종합적으로 고려해야 합니다.\n\n• 파일 크기 최적화:\n  • 모바일에서는 작은 해상도 비디오 사용\n  • `<source>` 태그로 여러 해상도 제공\n  • 압축률과 화질의 균형점 찾기\n\n• 다양한 형식 지원:\n```html\n<video controls>\n  <source src=\"video.mp4\" type=\"video/mp4\">\n  <source src=\"video.webm\" type=\"video/webm\">\n  <source src=\"video.ogg\" type=\"video/ogg\">\n</video>\n```\n• 성능 고려사항:\n  • `preload` 속성으로 로딩 방식 제어\n  • `poster` 속성으로 썸네일 이미지 설정\n  • 자동재생 지양 (데이터 사용량, 배터리 절약)",
      "difficulty": "hard",
      "created_at": "2025-08-11T12:54:28.000Z"
    },
    {
      "id": 1528,
      "subject_id": 9,
      "question": "반응형 웹 디자인을 위한 CSS 프레임워크 사용의 주요 장점은?",
      "option_a": "웹사이트 로딩 속도가 빨라짐",
      "option_b": "미리 만들어진 반응형 스타일로 개발 시간 단축",
      "option_c": "웹사이트의 보안이 강화됨",
      "option_d": "데이터베이스 연결이 쉬워짐",
      "correct_answer": "B",
      "explanation": "CSS 프레임워크는 반응형 웹 개발을 효율적으로 만들어주는 도구입니다.\n\n• 개발 시간 단축: 미리 작성된 반응형 CSS 클래스들을 활용\n• 일관된 디자인: 검증된 스타일 시스템으로 안정적인 레이아웃 구현\n• 크로스 브라우저 호환성: 다양한 브라우저에서 동일하게 작동\n• 학습 곡선 완화: 복잡한 CSS 코드를 직접 작성할 필요 없음",
      "difficulty": "easy",
      "created_at": "2025-08-11T12:56:48.000Z"
    }
  ],
  "exportDate": "2025-08-12T19:30:47.924Z"
}